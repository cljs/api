{:release {:cljs-version "1.7.228",
           :cljs-tag "r1.7.228",
           :cljs-date "2016-01-08",
           :clj-version "1.7.0",
           :clj-tag "clojure-1.7.0",
           :treader-version "1.0.0-alpha1",
           :treader-tag "tools.reader-1.0.0-alpha1",
           :gclosure-lib "0.0-20151016-61277aea"},
 :clj-not-cljs #{"clojure.core/the-ns"
                 "clojure.core/create-struct"
                 "clojure.data/diff-similar"
                 "clojure.core/*in*"
                 "clojure.main/demunge"
                 "clojure.core.protocols/kv-reduce"
                 "clojure.core/release-pending-sends"
                 "clojure.lang/AReference"
                 "clojure.reflect/flag-descriptors"
                 "clojure.core/shutdown-agents"
                 "clojure.core/restart-agent"
                 "clojure.java.io/input-stream"
                 "clojure.lang/AMapEntry"
                 "clojure.lang/IHashEq"
                 "clojure.stacktrace/print-cause-trace"
                 "clojure.java.io/file"
                 "clojure.lang/FnLoaderThunk"
                 "clojure.test/*load-tests*"
                 "clojure.core/->Vec"
                 "clojure.test/deftest-"
                 "clojure.inspector/inspect-tree"
                 "clojure.core/remove-ns"
                 "clojure.repl/thread-stopper"
                 "clojure.core/+'"
                 "clojure.core/rationalize"
                 "clojure.main/repl"
                 "clojure.repl/dir-fn"
                 "clojure.lang/LazilyPersistentVector"
                 "clojure.core/proxy-super"
                 "clojure.core/refer"
                 "clojure.lang/Numbers"
                 "clojure.stacktrace/print-trace-element"
                 "clojure.lang/ILookupThunk"
                 "clojure.core.protocols/CollReduce"
                 "clojure.core/future-call"
                 "clojure.core.protocols/InternalReduce"
                 "clojure.core/loaded-libs"
                 "clojure.core/commute"
                 "clojure.core/agent-errors"
                 "clojure.main/repl-caught"
                 "clojure.core/printf"
                 "clojure.core/ArrayChunk"
                 "clojure.core/load-string"
                 "clojure.lang/LispReader"
                 "clojure.core/pmap"
                 "clojure.lang/ARef"
                 "clojure.test/file-position"
                 "clojure.lang/Repl"
                 "clojure.core.protocols/IKVReduce"
                 "clojure.lang/RestFn"
                 "clojure.lang/Compiler"
                 "clojure.lang/IProxy"
                 "clojure.core/send"
                 "clojure.core/ref-history-count"
                 "clojure.core/iterator-seq"
                 "clojure.lang/WarnBoxedMath"
                 "clojure.lang/PersistentStructMap"
                 "clojure.reflect/map->Field"
                 "clojure.core/find-var"
                 "clojure.core/defstruct"
                 "clojure.core/-'"
                 "clojure.lang/Util"
                 "clojure.core/agent-error"
                 "clojure.core/->Eduction"
                 "clojure.lang/Obj"
                 "clojure.core/ns-refers"
                 "clojure.lang/Binding"
                 "clojure.core/num"
                 "clojure.lang/IPersistentMap"
                 "clojure.lang/IRef"
                 "clojure.reflect/do-reflect"
                 "clojure.core/future-cancelled?"
                 "clojure.java.io/make-writer"
                 "clojure.stacktrace/print-stack-trace"
                 "clojure.core/init-proxy"
                 "clojure.walk/postwalk-demo"
                 "clojure.core/read-line"
                 "clojure.core/alter-var-root"
                 "clojure.core/bases"
                 "clojure.repl/source-fn"
                 "clojure.core/class"
                 "clojure.core/Eduction"
                 "clojure.reflect/ClassResolver"
                 "clojure.reflect/type-reflect"
                 "clojure.core/default-data-readers"
                 "clojure.core/byte-array"
                 "clojure.lang/LineNumberingPushbackReader"
                 "clojure.java.shell/with-sh-dir"
                 "clojure.lang/EnumerationSeq"
                 "clojure.core/*err*"
                 "clojure.core/await"
                 "clojure.core/supers"
                 "clojure.reflect/Field"
                 "clojure.core/vector-of"
                 "clojure.core/Throwable->map"
                 "clojure.core/accessor"
                 "clojure.inspector/inspect-table"
                 "clojure.core/class?"
                 "clojure.core/ns-map"
                 "clojure.instant/parse-timestamp"
                 "clojure.java.io/make-output-stream"
                 "clojure.lang/BigInt"
                 "clojure.lang/APersistentVector"
                 "clojure.core/aset-boolean"
                 "clojure.reflect/typename"
                 "clojure.walk/prewalk-demo"
                 "clojure.reflect/reflect"
                 "clojure.core/with-bindings"
                 "clojure.core/sync"
                 "clojure.lang/IReference"
                 "clojure.java.javadoc/javadoc"
                 "clojure.reflect/->AsmReflector"
                 "clojure.core/ref-set"
                 "clojure.reflect/->Method"
                 "clojure.core/->ArrayChunk"
                 "clojure.test.tap/with-tap-output"
                 "clojure.java.io/copy"
                 "clojure.core/*data-readers*"
                 "clojure.core/use"
                 "clojure.lang/Intrinsics"
                 "clojure.test.junit/with-junit-output"
                 "clojure.lang/Compile"
                 "clojure.core/future?"
                 "clojure.core/proxy-mappings"
                 "clojure.lang/Reflector"
                 "clojure.core/*read-eval*"
                 "clojure.template/do-template"
                 "clojure.core/spit"
                 "clojure.core/Vec"
                 "clojure.core/monitor-enter"
                 "clojure.core/alter"
                 "clojure.lang/ILookupSite"
                 "clojure.java.io/resource"
                 "clojure.repl/root-cause"
                 "clojure.core/inc'"
                 "clojure.java.io/make-parents"
                 "clojure.lang/Agent"
                 "clojure.reflect/->Constructor"
                 "clojure.core/ref-min-history"
                 "clojure.core/get-proxy-class"
                 "clojure.main/repl-requires"
                 "clojure.core/aset-double"
                 "clojure.test/set-test"
                 "clojure.core/ref"
                 "clojure.core/future-cancel"
                 "clojure.lang/ReaderConditional"
                 "clojure.core/with-local-vars"
                 "clojure.core/agent"
                 "clojure.core/bean"
                 "clojure.core/aset-float"
                 "clojure.core/*file*"
                 "clojure.core/clojure-version"
                 "clojure.core/with-in-str"
                 "clojure.xml/parse"
                 "clojure.lang/ATransientSet"
                 "clojure.core/reader-conditional"
                 "clojure.core/with-bindings*"
                 "clojure.test/assert-predicate"
                 "clojure.instant/read-instant-timestamp"
                 "clojure.lang/ArityException"
                 "clojure.reflect/->Field"
                 "clojure.core/*default-data-reader-fn*"
                 "clojure.core/update-proxy"
                 "clojure.lang/APersistentMap"
                 "clojure.java.io/make-input-stream"
                 "clojure.core/promise"
                 "clojure.instant/validated"
                 "clojure.core/*compile-files*"
                 "clojure.core/float?"
                 "clojure.lang/Repeat"
                 "clojure.core/eval"
                 "clojure.core/*compile-path*"
                 "clojure.core/gen-class"
                 "clojure.lang/TransformerIterator"
                 "clojure.test.tap/print-tap-diagnostic"
                 "clojure.core/find-keyword"
                 "clojure.core/bound-fn*"
                 "clojure.reflect/Constructor"
                 "clojure.test/*stack-trace-depth*"
                 "clojure.reflect/resolve-class"
                 "clojure.edn/read"
                 "clojure.java.io/as-file"
                 "clojure.core/ns-aliases"
                 "clojure.main/stack-element-str"
                 "clojure.core/extend"
                 "clojure.core/char-name-string"
                 "clojure.reflect/JavaReflector"
                 "clojure.inspector/inspect"
                 "clojure.core/send-via"
                 "clojure.core/set-agent-send-executor!"
                 "clojure.lang/IObj"
                 "clojure.lang/APersistentSet"
                 "clojure.core/aset-int"
                 "clojure.edn/read-string"
                 "clojure.stacktrace/print-throwable"
                 "clojure.reflect/map->Method"
                 "clojure.main/repl-prompt"
                 "clojure.lang/IBlockingDeref"
                 "clojure.test/with-test"
                 "clojure.core/struct-map"
                 "clojure.lang/ATransientMap"
                 "clojure.template/apply-template"
                 "clojure.core/set-agent-send-off-executor!"
                 "clojure.core/cast"
                 "clojure.lang/XMLHandler"
                 "clojure.core/load"
                 "clojure.java.shell/with-sh-env"
                 "clojure.main/repl-read"
                 "clojure.core/io!"
                 "clojure.lang/TransactionalHashMap"
                 "clojure.core/ensure"
                 "clojure.string/re-quote-replacement"
                 "clojure.lang/AFunction"
                 "clojure.core/re-groups"
                 "clojure.core/pvalues"
                 "clojure.lang/IKeywordLookup"
                 "clojure.core/deliver"
                 "clojure.main/load-script"
                 "clojure.core/numerator"
                 "clojure.core/VecNode"
                 "clojure.core/VecSeq"
                 "clojure.lang/RecordIterator"
                 "clojure.core/var-get"
                 "clojure.core/clear-agent-errors"
                 "clojure.core/var-set"
                 "clojure.core/slurp"
                 "clojure.core/bound-fn"
                 "clojure.core/push-thread-bindings"
                 "clojure.core/*unchecked-math*"
                 "clojure.core/aset-short"
                 "clojure.java.io/make-reader"
                 "clojure.core/ns-resolve"
                 "clojure.core/locking"
                 "clojure.lang/IType"
                 "clojure.core.protocols/coll-reduce"
                 "clojure.core/char-array"
                 "clojure.lang/Murmur3"
                 "clojure.stacktrace/root-cause"
                 "clojure.core/ratio?"
                 "clojure.core/rational?"
                 "clojure.java.io/as-url"
                 "clojure.core/future"
                 "clojure.lang/IteratorSeq"
                 "clojure.core/aset-byte"
                 "clojure.core/send-off"
                 "clojure.lang/AFn"
                 "clojure.java.io/IOFactory"
                 "clojure.lang/Iterate"
                 "clojure.reflect/Method"
                 "clojure.core/float-array"
                 "clojure.core/thread-bound?"
                 "clojure.lang/MapEntry"
                 "clojure.core/with-precision"
                 "clojure.core/proxy"
                 "clojure.core/reader-conditional?"
                 "clojure.lang/IMapIterable"
                 "clojure.core/aset-char"
                 "clojure.java.io/output-stream"
                 "clojure.test/inc-report-counter"
                 "clojure.java.io/delete-file"
                 "clojure.core/compile"
                 "clojure.repl/stack-element-str"
                 "clojure.core/->VecSeq"
                 "clojure.lang/IPersistentCollection"
                 "clojure.core/resolve"
                 "clojure.core/->VecNode"
                 "clojure.core/xml-seq"
                 "clojure.test/with-test-out"
                 "clojure.core/file-seq"
                 "clojure.core/short-array"
                 "clojure.core/future-done?"
                 "clojure.core.reducers/->Cat"
                 "clojure.core/get-thread-bindings"
                 "clojure.stacktrace/e"
                 "clojure.lang/MapEquivalence"
                 "clojure.lang/DynamicClassLoader"
                 "clojure.core/struct"
                 "clojure.repl/set-break-handler!"
                 "clojure.core/&"
                 "clojure.instant/read-instant-date"
                 "clojure.java.javadoc/add-remote-javadoc"
                 "clojure.reflect/map->Constructor"
                 "clojure.test.tap/print-tap-pass"
                 "clojure.main/root-cause"
                 "clojure.core/extenders"
                 "clojure.core/construct-proxy"
                 "clojure.core/intern"
                 "clojure.core/error-mode"
                 "clojure.lang/MethodImplCache"
                 "clojure.core/all-ns"
                 "clojure.walk/macroexpand-all"
                 "clojure.lang/EdnReader"
                 "clojure.core/char-escape-string"
                 "clojure.lang/RT"
                 "clojure.repl/demunge"
                 "clojure.core/line-seq"
                 "clojure.lang/Ref"
                 "clojure.core/enumeration-seq"
                 "clojure.core/bigdec"
                 "clojure.java.javadoc/add-local-javadoc"
                 "clojure.lang/ProxyHandler"
                 "clojure.core/decimal?"
                 "clojure.core/definterface"
                 "clojure.core/pcalls"
                 "clojure.lang/KeywordLookupSite"
                 "clojure.lang/StringSeq"
                 "clojure.core/ns-unalias"
                 "clojure.core/error-handler"
                 "clojure.core/biginteger"
                 "clojure.core/ref-max-history"
                 "clojure.reflect/TypeReference"
                 "clojure.lang/ArraySeq"
                 "clojure.test/function?"
                 "clojure.lang/Cycle"
                 "clojure.core/definline"
                 "clojure.core/namespace-munge"
                 "clojure.lang/IReduceInit"
                 "clojure.core/pop-thread-bindings"
                 "clojure.main/main"
                 "clojure.core/ns-imports"
                 "clojure.core/aset-long"
                 "clojure.lang/IExceptionInfo"
                 "clojure.core/dosync"
                 "clojure.lang/LongRange"
                 "clojure.core/*'"
                 "clojure.core/seque"
                 "clojure.lang/LockingTransaction"
                 "clojure.lang/SeqEnumeration"
                 "clojure.main/skip-whitespace"
                 "clojure.main/with-bindings"
                 "clojure.core/load-reader"
                 "clojure.core/await-for"
                 "clojure.test.tap/print-tap-plan"
                 "clojure.core/*command-line-args*"
                 "clojure.java.browse/browse-url"
                 "clojure.core/monitor-exit"
                 "clojure.core/re-matcher"
                 "clojure.java.io/as-relative-path"
                 "clojure.test/assert-any"
                 "clojure.core/gen-interface"
                 "clojure.core/with-redefs-fn"
                 "clojure.core/extends?"
                 "clojure.java.io/Coercions"
                 "clojure.core/set-error-mode!"
                 "clojure.core/format"
                 "clojure.core/*agent*"
                 "clojure.core/alias"
                 "clojure.core/ns-publics"
                 "clojure.core/bound?"
                 "clojure.instant/read-instant-calendar"
                 "clojure.java.io/writer"
                 "clojure.core/with-open"
                 "clojure.core/set-error-handler!"
                 "clojure.java.shell/sh"
                 "clojure.reflect/->JavaReflector"
                 "clojure.lang/Settable"
                 "clojure.lang/Script"
                 "clojure.core/*compiler-options*"
                 "clojure.core/denominator"
                 "clojure.main/skip-if-eol"
                 "clojure.core/dec'"
                 "clojure.data/equality-partition"
                 "clojure.core/refer-clojure"
                 "clojure.main/with-read-known"
                 "clojure.lang/Ratio"
                 "clojure.java.io/reader"
                 "clojure.reflect/Reflector"
                 "clojure.main/repl-exception"
                 "clojure.test.tap/print-tap-fail"
                 "clojure.core/bigint"
                 "clojure.core/resultset-seq"
                 "clojure.test/get-possibly-unbound-var"
                 "clojure.core.protocols/internal-reduce"
                 "clojure.reflect/AsmReflector"
                 "clojure.core/boolean-array"
                 "clojure.core/add-classpath"
                 "clojure.core/*warn-on-reflection*"},
 :symbols {"cljs.core/keys" {:description "Returns a sequence of the keys in `hash-map`.",
                             :ns "cljs.core",
                             :name "keys",
                             :signature ["[hash-map]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/vals"],
                             :full-name-encode "cljs.core/keys",
                             :source {:code "(defn keys\n  [hash-map]\n  (when-let [mseq (seq hash-map)]\n    (KeySeq. mseq nil)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [7845 7849]},
                             :full-name "cljs.core/keys",
                             :clj-symbol "clojure.core/keys",
                             :docstring "Returns a sequence of the map's keys."},
           "cljs.core/unchecked-negate" {:ns "cljs.core",
                                         :name "unchecked-negate",
                                         :signature ["[x]"],
                                         :history [["+" "0.0-1798"]],
                                         :type "function/macro",
                                         :full-name-encode "cljs.core/unchecked-negate",
                                         :source {:code "(defn unchecked-negate [x]\n  (cljs.core/unchecked-negate x))",
                                                  :title "Function code",
                                                  :repo "clojurescript",
                                                  :tag "r1.7.228",
                                                  :filename "src/main/cljs/cljs/core.cljs",
                                                  :lines [2427 2428]},
                                         :extra-sources [{:code "(core/defmacro ^::ana/numeric unchecked-negate\n  ([x] `(- ~x)))",
                                                          :title "Macro code",
                                                          :repo "clojurescript",
                                                          :tag "r1.7.228",
                                                          :filename "src/main/clojure/cljs/core.cljc",
                                                          :lines [1001
                                                                  1002]}],
                                         :full-name "cljs.core/unchecked-negate",
                                         :clj-symbol "clojure.core/unchecked-negate"},
           "cljs.core/reset!" {:description "Sets the value of atom `a` to `new-value` without regard for the current value.\n\nReturns `new-value`.",
                               :ns "cljs.core",
                               :name "reset!",
                               :signature ["[a new-value]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/swap!"
                                         "cljs.core/compare-and-set!"
                                         "cljs.core/atom"],
                               :full-name-encode "cljs.core/resetBANG",
                               :source {:code "(defn reset!\n  [a new-value]\n  (if (instance? Atom a)\n    (let [validate (.-validator a)]\n      (when-not (nil? validate)\n        (assert (validate new-value) \"Validator rejected reference state\"))\n      (let [old-value (.-state a)]\n        (set! (.-state a) new-value)\n        (when-not (nil? (.-watches a))\n          (-notify-watches a old-value new-value))\n        new-value))\n    (-reset! a new-value)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [3999 4012]},
                               :full-name "cljs.core/reset!",
                               :clj-symbol "clojure.core/reset!",
                               :docstring "Sets the value of atom to newval without regard for the\ncurrent value. Returns newval."},
           "cljs.core/ITransientCollection" {:ns "cljs.core",
                                             :name "ITransientCollection",
                                             :history [["+"
                                                        "0.0-1211"]],
                                             :type "protocol",
                                             :full-name-encode "cljs.core/ITransientCollection",
                                             :source {:code "(defprotocol ITransientCollection\n  \"Protocol for adding basic functionality to transient collections.\"\n  (^clj -conj! [tcoll val]\n    \"Adds value val to tcoll and returns tcoll.\")\n  (^clj -persistent! [tcoll]\n    \"Creates a persistent data structure from tcoll and returns it.\"))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.7.228",
                                                      :filename "src/main/cljs/cljs/core.cljs",
                                                      :lines [672 677]},
                                             :methods [{:name "-conj!",
                                                        :signature ["[tcoll val]"],
                                                        :docstring "Adds value val to tcoll and returns tcoll."}
                                                       {:name "-persistent!",
                                                        :signature ["[tcoll]"],
                                                        :docstring "Creates a persistent data structure from tcoll and returns it."}],
                                             :full-name "cljs.core/ITransientCollection",
                                             :clj-symbol "clojure.lang/ITransientCollection",
                                             :docstring "Protocol for adding basic functionality to transient collections."},
           "cljs.core/transient" {:ns "cljs.core",
                                  :name "transient",
                                  :signature ["[coll]"],
                                  :history [["+" "0.0-1211"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/transient",
                                  :source {:code "(defn transient\n  [coll]\n  (-as-transient coll))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [3375 3378]},
                                  :full-name "cljs.core/transient",
                                  :clj-symbol "clojure.core/transient",
                                  :docstring "Returns a new, transient version of the collection, in constant time."},
           "cljs.core/Fn" {:ns "cljs.core",
                           :name "Fn",
                           :history [["+" "0.0-1552"]],
                           :type "protocol",
                           :full-name-encode "cljs.core/Fn",
                           :source {:code "(defprotocol Fn\n  \"Marker protocol\")",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r1.7.228",
                                    :filename "src/main/cljs/cljs/core.cljs",
                                    :lines [424 425]},
                           :full-name "cljs.core/Fn",
                           :clj-symbol "clojure.lang/Fn",
                           :docstring "Marker protocol"},
           "clojure.data/EqualityPartition" {:ns "clojure.data",
                                             :name "EqualityPartition",
                                             :history [["+"
                                                        "0.0-1503"]],
                                             :type "protocol",
                                             :full-name-encode "clojure.data/EqualityPartition",
                                             :source {:code "(defprotocol EqualityPartition\n  \"Implementation detail. Subject to change.\"\n  (equality-partition [x] \"Implementation detail. Subject to change.\"))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.7.228",
                                                      :filename "src/main/cljs/clojure/data.cljs",
                                                      :lines [75 77]},
                                             :methods [{:name "equality-partition",
                                                        :signature ["[x]"],
                                                        :docstring "Implementation detail. Subject to change."}],
                                             :full-name "clojure.data/EqualityPartition",
                                             :clj-symbol "clojure.data/EqualityPartition",
                                             :docstring "Implementation detail. Subject to change."},
           "cljs.core/ex-message" {:ns "cljs.core",
                                   :name "ex-message",
                                   :signature ["[ex]"],
                                   :history [["+" "0.0-1576"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/ex-message",
                                   :source {:code "(defn ex-message\n  [ex]\n  (when (instance? js/Error ex)\n    (.-message ex)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [9935 9940]},
                                   :full-name "cljs.core/ex-message",
                                   :docstring "Returns the message attached to the given Error / ExceptionInfo object.\nFor non-Errors returns nil."},
           "cljs.core/js-reserved" {:ns "cljs.core",
                                    :name "js-reserved",
                                    :type "var",
                                    :source {:code "(def\n  ^{:jsdoc [\"@type {null|Object}\"]}\n  js-reserved nil)",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [10032 10034]},
                                    :full-name "cljs.core/js-reserved",
                                    :full-name-encode "cljs.core/js-reserved",
                                    :history [["+" "1.7.10"]]},
           "cljs.repl.nashorn/repl-filename" {:ns "cljs.repl.nashorn",
                                              :name "repl-filename",
                                              :type "var",
                                              :source {:code "(def repl-filename \"<cljs repl>\")",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.7.228",
                                                       :filename "src/main/clojure/cljs/repl/nashorn.clj",
                                                       :lines [107]},
                                              :full-name "cljs.repl.nashorn/repl-filename",
                                              :full-name-encode "cljs.repl.nashorn/repl-filename",
                                              :history [["+"
                                                         "0.0-2814"]]},
           "cljs.pprint/write-out" {:ns "cljs.pprint",
                                    :name "write-out",
                                    :signature ["[object]"],
                                    :history [["+" "0.0-3255"]],
                                    :type "function",
                                    :full-name-encode "cljs.pprint/write-out",
                                    :source {:code "(defn write-out\n  [object]\n  (let [length-reached (and *current-length*\n                            *print-length*\n                            (>= *current-length* *print-length*))]\n    (if-not *print-pretty*\n      (pr object)\n      (if length-reached\n        (-write *out* \"...\") ;;TODO could this (incorrectly) print ... on the next line?\n        (do\n          (if *current-length* (set! *current-length* (inc *current-length*)))\n          (*print-pprint-dispatch* object))))\n    length-reached))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/pprint.cljs",
                                             :lines [724 746]},
                                    :full-name "cljs.pprint/write-out",
                                    :clj-symbol "clojure.pprint/write-out",
                                    :docstring "Write an object to *out* subject to the current bindings of the printer control\nvariables. Use the kw-args argument to override individual variables for this call (and\nany recursive calls).\n\n*out* must be a PrettyWriter if pretty printing is enabled. This is the responsibility\nof the caller.\n\nThis method is primarily intended for use by pretty print dispatch functions that\nalready know that the pretty printer will have set up their environment appropriately.\nNormal library clients should use the standard \"write\" interface. "},
           "cljs.test/test-vars-block" {:ns "cljs.test",
                                        :name "test-vars-block",
                                        :signature ["[vars]"],
                                        :history [["+" "0.0-2814"]],
                                        :type "function",
                                        :full-name-encode "cljs.test/test-vars-block",
                                        :source {:code "(defn test-vars-block\n  [vars]\n  (map\n   (fn [[ns vars]]\n     (fn []\n       (block\n        (let [env (get-current-env)\n              once-fixtures (get-in env [:once-fixtures ns])\n              each-fixtures (get-in env [:each-fixtures ns])]\n          (case (execution-strategy once-fixtures each-fixtures)\n            :async\n            (->> vars\n                 (filter (comp :test meta))\n                 (mapcat (comp (partial wrap-map-fixtures each-fixtures)\n                               test-var-block))\n                 (wrap-map-fixtures once-fixtures))\n            :sync\n            (let [each-fixture-fn (join-fixtures each-fixtures)]\n              [(fn []\n                 ((join-fixtures once-fixtures)\n                  (fn []\n                    (doseq [v vars]\n                      (when-let [t (:test (meta v))]\n                        ;; (alter-meta! v update :test disable-async)\n                        (each-fixture-fn\n                         (fn []\n                           ;; (test-var v)\n                           (run-block\n                            (test-var-block* v (disable-async t))))))))))]))))))\n   (group-by (comp :ns meta) vars)))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/cljs/cljs/test.cljs",
                                                 :lines [543 574]},
                                        :full-name "cljs.test/test-vars-block",
                                        :docstring "Like test-vars, but returns a block for further composition and\nlater execution."},
           "clojure.set/select" {:description "Returns a set of the elements for which `pred` is true.",
                                 :ns "clojure.set",
                                 :name "select",
                                 :signature ["[pred xset]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :related ["cljs.core/filter"],
                                 :full-name-encode "clojure.set/select",
                                 :source {:code "(defn select\n  [pred xset]\n    (reduce (fn [s k] (if (pred k) s (disj s k)))\n            xset xset))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/clojure/set.cljs",
                                          :lines [61 65]},
                                 :full-name "clojure.set/select",
                                 :clj-symbol "clojure.set/select",
                                 :docstring "Returns a set of the elements for which pred is true"},
           "cljs.core/hash-unordered-coll" {:return-type number,
                                            :ns "cljs.core",
                                            :name "hash-unordered-coll",
                                            :signature ["[coll]"],
                                            :history [["+" "0.0-2261"]],
                                            :type "function",
                                            :full-name-encode "cljs.core/hash-unordered-coll",
                                            :source {:code "(defn ^number hash-unordered-coll\n  [coll]\n  (loop [n 0 hash-code 0 coll (seq coll)]\n    (if-not (nil? coll)\n      (recur (inc n) (bit-or (+ hash-code (hash (first coll))) 0) (next coll))\n      (mix-collection-hash hash-code n))))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.7.228",
                                                     :filename "src/main/cljs/cljs/core.cljs",
                                                     :lines [1207
                                                             1217]},
                                            :full-name "cljs.core/hash-unordered-coll",
                                            :clj-symbol "clojure.core/hash-unordered-coll",
                                            :docstring "Returns the hash code, consistent with =, for an external unordered\ncollection implementing Iterable. For maps, the iterator should\nreturn map entries whose hash is computed as\n  (hash-ordered-coll [k v]).\nSee http://clojure.org/data_structures#hash for full algorithms."},
           "cljs.core/delay" {:ns "cljs.core",
                              :name "delay",
                              :signature ["[& body]"],
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :full-name-encode "cljs.core/delay",
                              :source {:code "(core/defmacro delay\n  [& body]\n  `(new cljs.core/Delay (fn [] ~@body) nil))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/clojure/cljs/core.cljc",
                                       :lines [1985 1991]},
                              :full-name "cljs.core/delay",
                              :clj-symbol "clojure.core/delay",
                              :docstring "Takes a body of expressions and yields a Delay object that will\ninvoke the body only the first time it is forced (with force or deref/@), and\nwill cache the result and return it on all subsequent force\ncalls."},
           "cljs.core/float" {:return-type number,
                              :ns "cljs.core",
                              :name "float",
                              :signature ["[x]"],
                              :history [["+" "0.0-1798"]],
                              :type "function/macro",
                              :full-name-encode "cljs.core/float",
                              :source {:code "(defn ^number float [x] x)",
                                       :title "Function code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [2367]},
                              :extra-sources [{:code "(core/defmacro float [x] x)",
                                               :title "Macro code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/clojure/cljs/core.cljc",
                                               :lines [965]}],
                              :full-name "cljs.core/float",
                              :clj-symbol "clojure.core/float"},
           "cljs.core/bit-not" {:description "Bitwise complement.  Same as `~x` in JavaScript.",
                                :ns "cljs.core",
                                :name "bit-not",
                                :signature ["[x]"],
                                :history [["+" "0.0-927"]],
                                :type "function/macro",
                                :full-name-encode "cljs.core/bit-not",
                                :source {:code "(defn bit-not\n  [x] (cljs.core/bit-not x))",
                                         :title "Function code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [2542 2544]},
                                :extra-sources [{:code "(core/defmacro ^::ana/numeric bit-not [x]\n  (core/list 'js* \"(~ ~{})\" x))",
                                                 :title "Macro code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/clojure/cljs/core.cljc",
                                                 :lines [1092 1093]}],
                                :examples [{:id "d4c5e3",
                                            :content "Bits can be entered using radix notation:\n\n```clj\n(bit-not 2r1100)\n;;=> -13\n```\n\nSame numbers in decimal:\n\n```clj\n(bit-not 12)\n;;=> -13\n```"}],
                                :full-name "cljs.core/bit-not",
                                :clj-symbol "clojure.core/bit-not",
                                :docstring "Bitwise complement"},
           "cljs.core/partition" {:description "Returns a lazy sequence of lists of `n` items each, at offsets `step` apart.\n\nIf `step` is not supplied, defaults to `n`, i.e. the partitions do not overlap.\n\nIf a `pad` collection is supplied, its elements will be used as necessary to\ncomplete the last partition up to `n` items.\n\nReturns a partition with less than `n` items if there are not enough padding\nelements.",
                                  :ns "cljs.core",
                                  :name "partition",
                                  :signature ["[n coll]"
                                              "[n step coll]"
                                              "[n step pad coll]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/partition-all"
                                            "cljs.core/split-at"
                                            "cljs.core/partition-by"],
                                  :full-name-encode "cljs.core/partition",
                                  :source {:code "(defn partition\n  ([n coll]\n     (partition n n coll))\n  ([n step coll]\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (let [p (take n s)]\n           (when (== n (count p))\n             (cons p (partition n step (drop step s))))))))\n  ([n step pad coll]\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (let [p (take n s)]\n           (if (== n (count p))\n             (cons p (partition n step pad (drop step s)))\n             (list (take n (concat p pad)))))))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [4525 4545]},
                                  :full-name "cljs.core/partition",
                                  :clj-symbol "clojure.core/partition",
                                  :docstring "Returns a lazy sequence of lists of n items each, at offsets step\napart. If step is not supplied, defaults to n, i.e. the partitions\ndo not overlap. If a pad collection is supplied, use its elements as\nnecessary to complete last partition up to n items. In case there are\nnot enough padding elements, return a partition with less than n items."},
           "cljs.core/IEncodeJS" {:ns "cljs.core",
                                  :name "IEncodeJS",
                                  :type "protocol",
                                  :full-name-encode "cljs.core/IEncodeJS",
                                  :source {:code "(defprotocol IEncodeJS\n  (-clj->js [x] \"Recursively transforms clj values to JavaScript\")\n  (-key->js [x] \"Transforms map keys to valid JavaScript keys. Arbitrary keys are\n  encoded to their string representation via (pr-str x)\"))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [9299 9302]},
                                  :methods [{:name "-clj->js",
                                             :signature ["[x]"],
                                             :docstring "Recursively transforms clj values to JavaScript"}
                                            {:name "-key->js",
                                             :signature ["[x]"],
                                             :docstring "Transforms map keys to valid JavaScript keys. Arbitrary keys are\n  encoded to their string representation via (pr-str x)"}],
                                  :full-name "cljs.core/IEncodeJS",
                                  :history [["+" "0.0-1552"]]},
           "cljs.core/parents" {:ns "cljs.core",
                                :name "parents",
                                :signature ["[tag]" "[h tag]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/parents",
                                :source {:code "(defn parents\n  ([tag] (parents @(get-global-hierarchy) tag))\n  ([h tag] (not-empty (get (:parents h) tag))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [9467 9473]},
                                :full-name "cljs.core/parents",
                                :clj-symbol "clojure.core/parents",
                                :docstring "Returns the immediate parents of tag, either via a JavaScript type\ninheritance relationship or a relationship established via derive. h\nmust be a hierarchy obtained from make-hierarchy, if not supplied\ndefaults to the global hierarchy"},
           "cljs.core/aclone" {:description "Creates a clone of the given JavaScript array `arr`.  The result is a new\nJavaScript array, which is a shallow copy, not a deep copy.",
                               :ns "cljs.core",
                               :name "aclone",
                               :signature ["[arr]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/array"
                                         "cljs.core/make-array"],
                               :full-name-encode "cljs.core/aclone",
                               :source {:code "(defn aclone\n  [arr]\n  (let [len (alength arr)\n        new-arr (make-array len)]\n    (dotimes [i len]\n      (aset new-arr i (aget arr i)))\n    new-arr))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [364 371]},
                               :examples [{:id "422c4e",
                                           :content "```clj\n(def a #js [1 2 3])\n(def b (aclone a))\n(aset b 0 4)\n\na\n;;=> #js [1 2 3]\n\nb\n;;=> #js [4 2 3]\n```"}],
                               :full-name "cljs.core/aclone",
                               :clj-symbol "clojure.core/aclone",
                               :docstring "Returns a javascript array, cloned from the passed in array"},
           "cljs.core/reset-meta!" {:ns "cljs.core",
                                    :name "reset-meta!",
                                    :signature ["[iref m]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/reset-metaBANG",
                                    :source {:code "(defn reset-meta!\n  [iref m]\n  (set! (.-meta iref) m))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [9136 9139]},
                                    :full-name "cljs.core/reset-meta!",
                                    :clj-symbol "clojure.core/reset-meta!",
                                    :docstring "Atomically resets the metadata for an atom"},
           "cljs.core/IReset" {:ns "cljs.core",
                               :name "IReset",
                               :history [["+" "0.0-2173"]],
                               :type "protocol",
                               :full-name-encode "cljs.core/IReset",
                               :source {:code "(defprotocol IReset\n  \"Protocol for adding resetting functionality.\"\n  (-reset! [o new-value]\n    \"Sets the value of o to new-value.\"))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [735 738]},
                               :methods [{:name "-reset!",
                                          :signature ["[o new-value]"],
                                          :docstring "Sets the value of o to new-value."}],
                               :full-name "cljs.core/IReset",
                               :docstring "Protocol for adding resetting functionality."},
           "special/defrecord*" {:ns "special",
                                 :name "defrecord*",
                                 :type "special form",
                                 :source {:code "(defmethod parse 'defrecord*\n  [_ env form _ _]\n  (parse-type :defrecord* env form) )",
                                          :title "Parser code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/clojure/cljs/analyzer.cljc",
                                          :lines [2018 2020]},
                                 :full-name "special/defrecord*",
                                 :full-name-encode "special/defrecordSTAR",
                                 :history [["+" "0.0-927"]]},
           "cljs.core/Box" {:ns "cljs.core",
                            :name "Box",
                            :signature ["[val]"],
                            :history [["+" "0.0-1424"]],
                            :type "type",
                            :full-name-encode "cljs.core/Box",
                            :source {:code "(deftype Box [^:mutable val])",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.7.228",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [6111]},
                            :full-name "cljs.core/Box",
                            :clj-symbol "clojure.lang/Box"},
           "cljs.pprint/cl-format" {:ns "cljs.pprint",
                                    :name "cl-format",
                                    :signature ["[writer format-in & args]"],
                                    :history [["+" "0.0-3255"]],
                                    :type "function",
                                    :full-name-encode "cljs.pprint/cl-format",
                                    :source {:code "(defn cl-format\n  [writer format-in & args]\n  (let [compiled-format (if (string? format-in) (compile-format format-in) format-in)\n        navigator (init-navigator args)]\n    (execute-format writer compiled-format navigator)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/pprint.cljs",
                                             :lines [893 928]},
                                    :full-name "cljs.pprint/cl-format",
                                    :clj-symbol "clojure.pprint/cl-format",
                                    :docstring "An implementation of a Common Lisp compatible format function. cl-format formats its\narguments to an output stream or string based on the format control string given. It\nsupports sophisticated formatting of structured data.\n\nWriter satisfies IWriter, true to output via *print-fn* or nil to output\nto a string, format-in is the format control string and the remaining arguments\nare the data to be formatted.\n\nThe format control string is a string to be output with embedded 'format directives'\ndescribing how to format the various arguments passed in.\n\nIf writer is nil, cl-format returns the formatted result string. Otherwise, cl-format\nreturns nil.\n\nFor example:\n (let [results [46 38 22]]\n        (cl-format true \"There ~[are~;is~:;are~]~:* ~d result~:p: ~{~d~^, ~}~%\"\n                   (count results) results))\n\nPrints via *print-fn*:\n There are 3 results: 46, 38, 22\n\nDetailed documentation on format control strings is available in the \"Common Lisp the\nLanguage, 2nd edition\", Chapter 22 (available online at:\nhttp://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html#SECTION002633000000000000000)\nand in the Common Lisp HyperSpec at\nhttp://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm"},
           "cljs.core/tagged-literal?" {:return-type boolean,
                                        :ns "cljs.core",
                                        :name "tagged-literal?",
                                        :signature ["[value]"],
                                        :history [["+" "0.0-3255"]],
                                        :type "function",
                                        :full-name-encode "cljs.core/tagged-literalQMARK",
                                        :source {:code "(defn ^boolean tagged-literal?\n  [value]\n  (instance? TaggedLiteral value))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/cljs/cljs/core.cljs",
                                                 :lines [10002 10005]},
                                        :full-name "cljs.core/tagged-literal?",
                                        :clj-symbol "clojure.core/tagged-literal?",
                                        :docstring "Return true if the value is the data representation of a tagged literal"},
           "cljs.reader/dispatch-macros" {:ns "cljs.reader",
                                          :name "dispatch-macros",
                                          :type "function",
                                          :signature ["[s]"],
                                          :source {:code "(defn dispatch-macros [s]\n  (cond\n   (identical? s \"{\") read-set\n   (identical? s \"<\") (throwing-reader \"Unreadable form\")\n   (identical? s \"\\\"\") read-regex\n   (identical? s\"!\") read-comment\n   (identical? s \"_\") read-discard\n   :else nil))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/cljs/cljs/reader.cljs",
                                                   :lines [430 437]},
                                          :full-name "cljs.reader/dispatch-macros",
                                          :full-name-encode "cljs.reader/dispatch-macros",
                                          :history [["+" "0.0-927"]]},
           "cljs.core/demunge" {:ns "cljs.core",
                                :name "demunge",
                                :type "function",
                                :signature ["[name]"],
                                :source {:code "(defn demunge [name]\n  ((if (symbol? name) symbol str)\n    (let [name' (str name)]\n      (if (identical? name' \"_DOT__DOT_\")\n        \"..\"\n        (demunge-str (str name))))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [10098 10103]},
                                :full-name "cljs.core/demunge",
                                :full-name-encode "cljs.core/demunge",
                                :history [["+" "1.7.10"]]},
           "cljs.pprint/get-pretty-writer" {:ns "cljs.pprint",
                                            :name "get-pretty-writer",
                                            :signature ["[writer]"],
                                            :history [["+" "0.0-3255"]],
                                            :type "function",
                                            :full-name-encode "cljs.pprint/get-pretty-writer",
                                            :source {:code "(defn get-pretty-writer\n  [writer]\n  (if (pretty-writer? writer)\n    writer\n    (pretty-writer writer *print-right-margin* *print-miser-width*)))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.7.228",
                                                     :filename "src/main/cljs/cljs/pprint.cljs",
                                                     :lines [2052
                                                             2087]},
                                            :full-name "cljs.pprint/get-pretty-writer",
                                            :clj-symbol "clojure.pprint/get-pretty-writer",
                                            :docstring "Returns the IWriter passed in wrapped in a pretty writer proxy, unless it's\nalready a pretty writer. Generally, it is unnecessary to call this function, since pprint,\nwrite, and cl-format all call it if they need to. However if you want the state to be\npreserved across calls, you will want to wrap them with this.\n\nFor example, when you want to generate column-aware output with multiple calls to cl-format,\ndo it like in this example:\n\n    (defn print-table [aseq column-width]\n      (binding [*out* (get-pretty-writer *out*)]\n        (doseq [row aseq]\n          (doseq [col row]\n            (cl-format true \"~4D~7,vT\" col column-width))\n          (prn))))\n\nNow when you run:\n\n    user> (print-table (map #(vector % (* % %) (* % % %)) (range 1 11)) 8)\n\nIt prints a table of squares and cubes for the numbers from 1 to 10:\n\n       1      1       1\n       2      4       8\n       3      9      27\n       4     16      64\n       5     25     125\n       6     36     216\n       7     49     343\n       8     64     512\n       9     81     729\n      10    100    1000"},
           "cljs.repl.rhino/current-repl-env" {:ns "cljs.repl.rhino",
                                               :name "current-repl-env",
                                               :type "var",
                                               :source {:code "(def current-repl-env (atom nil))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r2511",
                                                        :filename "src/clj/cljs/repl/rhino.clj",
                                                        :lines [18]},
                                               :full-name "cljs.repl.rhino/current-repl-env",
                                               :full-name-encode "cljs.repl.rhino/current-repl-env",
                                               :history [["+"
                                                          "0.0-927"]
                                                         ["-"
                                                          "0.0-2629"]],
                                               :removed {:in "0.0-2629",
                                                         :last-seen "0.0-2511"}},
           "cljs.core/int-rotate-left" {:return-type number,
                                        :ns "cljs.core",
                                        :name "int-rotate-left",
                                        :signature ["[x n]"],
                                        :history [["+" "0.0-2261"]],
                                        :type "function",
                                        :full-name-encode "cljs.core/int-rotate-left",
                                        :source {:code "(defn ^number int-rotate-left [x n]\n  (bit-or\n    (bit-shift-left x n)\n    (unsigned-bit-shift-right x (- n))))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/cljs/cljs/core.cljs",
                                                 :lines [776 779]},
                                        :full-name "cljs.core/int-rotate-left"},
           "cljs.core/ICollection" {:ns "cljs.core",
                                    :name "ICollection",
                                    :history [["+" "0.0-927"]],
                                    :type "protocol",
                                    :full-name-encode "cljs.core/ICollection",
                                    :source {:code "(defprotocol ICollection\n  \"Protocol for adding to a collection.\"\n  (^clj -conj [coll o]\n    \"Returns a new collection of coll with o added to it. The new item\n     should be added to the most efficient place, e.g.\n     (conj [1 2 3 4] 5) => [1 2 3 4 5]\n     (conj '(2 3 4 5) 1) => '(1 2 3 4 5)\"))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [471 477]},
                                    :methods [{:name "-conj",
                                               :signature ["[coll o]"],
                                               :docstring "Returns a new collection of coll with o added to it. The new item\n     should be added to the most efficient place, e.g.\n     (conj [1 2 3 4] 5) => [1 2 3 4 5]\n     (conj '(2 3 4 5) 1) => '(1 2 3 4 5)"}],
                                    :full-name "cljs.core/ICollection",
                                    :docstring "Protocol for adding to a collection."},
           "cljs.build.api/cljs-dependents-for-macro-namespaces" {:ns "cljs.build.api",
                                                                  :name "cljs-dependents-for-macro-namespaces",
                                                                  :signature ["[namespaces]"
                                                                              "[state namespaces]"],
                                                                  :history [["+"
                                                                             "0.0-2496"]],
                                                                  :type "function",
                                                                  :full-name-encode "cljs.build.api/cljs-dependents-for-macro-namespaces",
                                                                  :source {:code "(defn cljs-dependents-for-macro-namespaces\n  ([namespaces]\n   (cljs-dependents-for-macro-namespaces\n     (if-not (nil? env/*compiler*)\n       env/*compiler*\n       (env/default-compiler-env))\n     namespaces))\n  ([state namespaces]\n   (map :name\n     (let [namespaces-set (set namespaces)]\n       (filter (fn [x] (not-empty\n                         (intersection namespaces-set (-> x :require-macros vals set))))\n         (vals (:cljs.analyzer/namespaces @state)))))))",
                                                                           :title "Source code",
                                                                           :repo "clojurescript",
                                                                           :tag "r1.7.228",
                                                                           :filename "src/main/clojure/cljs/build/api.clj",
                                                                           :lines [49
                                                                                   71]},
                                                                  :full-name "cljs.build.api/cljs-dependents-for-macro-namespaces",
                                                                  :docstring "Takes a list of Clojure (.clj) namespaces that define macros and\nreturns a list ClojureScript (.cljs) namespaces that depend on those macro\nnamespaces.\n\nFor example where example.macros is defined in the clojure file\n\"example/macros.clj\" and both 'example.core and 'example.util are\nClojureScript namespaces that require and use the macros from\n'example.macros :\n(cljs-dependents-for-macro-namespaces 'example.macros) ->\n('example.core 'example.util)"},
           "cljs.core/every?" {:description "Returns true if `(pred x)` is logical true for every `x` in `coll`, else false.",
                               :return-type boolean,
                               :ns "cljs.core",
                               :name "every?",
                               :signature ["[pred coll]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/some"
                                         "cljs.core/not-any?"],
                               :full-name-encode "cljs.core/everyQMARK",
                               :source {:code "(defn ^boolean every?\n  [pred coll]\n  (cond\n   (nil? (seq coll)) true\n   (pred (first coll)) (recur pred (next coll))\n   :else false))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [3754 3761]},
                               :full-name "cljs.core/every?",
                               :clj-symbol "clojure.core/every?",
                               :docstring "Returns true if (pred x) is logical true for every x in coll, else\nfalse."},
           "clojure.zip/node" {:ns "clojure.zip",
                               :name "node",
                               :signature ["[loc]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip/node",
                               :source {:code "(defn node\n  [loc] (loc 0))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/clojure/zip.cljs",
                                        :lines [60 62]},
                               :full-name "clojure.zip/node",
                               :clj-symbol "clojure.zip/node",
                               :docstring "Returns the node at loc"},
           "cljs.core/RecordIter" {:ns "cljs.core",
                                   :name "RecordIter",
                                   :type "type",
                                   :signature ["[i record base-count fields ext-map-iter]"],
                                   :source {:code "(deftype RecordIter [^:mutable i record base-count fields ext-map-iter]\n  Object\n  (hasNext [_]\n    (or (< i base-count) (.hasNext ext-map-iter)))\n  (next [_]\n    (if (< i base-count)\n      (let [k (nth fields i)]\n        (set! i (inc i))\n        [k (-lookup record k)])\n      (.next ext-map-iter)))\n  (remove [_] (js/Error. \"Unsupported operation\")))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [5660 5670]},
                                   :full-name "cljs.core/RecordIter",
                                   :full-name-encode "cljs.core/RecordIter",
                                   :history [["+" "1.7.28"]]},
           "clojure.string/index-of" {:ns "clojure.string",
                                      :name "index-of",
                                      :signature ["[s value]"
                                                  "[s value from-index]"],
                                      :history [["+" "1.7.145"]],
                                      :type "function",
                                      :full-name-encode "clojure.string/index-of",
                                      :source {:code "(defn index-of\n  ([s value]\n   (let [result (.indexOf s value)]\n     (if (neg? result)\n       nil\n       result)))\n  ([s value from-index]\n   (let [result (.indexOf s value from-index)]\n     (if (neg? result)\n       nil\n       result))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/cljs/clojure/string.cljs",
                                               :lines [217 229]},
                                      :full-name "clojure.string/index-of",
                                      :docstring "Return index of value (string or char) in s, optionally searching\nforward from from-index or nil if not found."},
           "cljs.core/IEmptyableCollection" {:ns "cljs.core",
                                             :name "IEmptyableCollection",
                                             :history [["+" "0.0-927"]],
                                             :type "protocol",
                                             :full-name-encode "cljs.core/IEmptyableCollection",
                                             :source {:code "(defprotocol IEmptyableCollection\n  \"Protocol for creating an empty collection.\"\n  (-empty [coll]\n    \"Returns an empty collection of the same category as coll. Used\n     by cljs.core/empty.\"))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.7.228",
                                                      :filename "src/main/cljs/cljs/core.cljs",
                                                      :lines [465 469]},
                                             :methods [{:name "-empty",
                                                        :signature ["[coll]"],
                                                        :docstring "Returns an empty collection of the same category as coll. Used\n     by cljs.core/empty."}],
                                             :full-name "cljs.core/IEmptyableCollection",
                                             :docstring "Protocol for creating an empty collection."},
           "clojure.zip/right" {:ns "clojure.zip",
                                :name "right",
                                :signature ["[loc]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "clojure.zip/right",
                                :source {:code "(defn right\n  [loc]\n    (let [[node {l :l  [r & rnext :as rs] :r :as path}] loc]\n      (when (and path rs)\n        (with-meta [r (assoc path :l (conj l node) :r rnext)] (meta loc)))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/clojure/zip.cljs",
                                         :lines [135 140]},
                                :full-name "clojure.zip/right",
                                :clj-symbol "clojure.zip/right",
                                :docstring "Returns the loc of the right sibling of the node at this loc, or nil"},
           "cljs.core/int-array" {:ns "cljs.core",
                                  :name "int-array",
                                  :signature ["[size-or-seq]"
                                              "[size init-val-or-seq]"],
                                  :history [["+" "0.0-1798"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/int-array",
                                  :source {:code "(defn int-array\n  ([size-or-seq]\n     (if (number? size-or-seq)\n       (int-array size-or-seq nil)\n       (into-array size-or-seq)))\n  ([size init-val-or-seq]\n     (let [a (make-array size)]\n       (if (seq? init-val-or-seq)\n         (let [s (seq init-val-or-seq)]\n           (loop [i 0 s s]\n             (if (and s (< i size))\n               (do\n                 (aset a i (first s))\n                 (recur (inc i) (next s)))\n               a)))\n         (do\n           (dotimes [i size]\n             (aset a i init-val-or-seq))\n           a)))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [3233 3253]},
                                  :full-name "cljs.core/int-array",
                                  :clj-symbol "clojure.core/int-array",
                                  :docstring "Creates an array of ints. Does not coerce array, provided for compatibility\nwith Clojure."},
           "cljs.core/LazyTransformer.createMulti" {:ns "cljs.core",
                                                    :name "LazyTransformer.createMulti",
                                                    :signature ["[xform colls]"],
                                                    :history [["+"
                                                               "0.0-2301"]],
                                                    :parent-type "LazyTransformer",
                                                    :type "function",
                                                    :full-name-encode "cljs.core/LazyTransformerDOTcreateMulti",
                                                    :source {:code "(set! (.-createMulti LazyTransformer)\n  (fn [xform colls]\n    (let [iters (array)]\n      (doseq [coll colls]\n        (.push iters (iter coll)))\n      (LazyTransformer.\n        (multi-stepper xform iters (make-array (alength iters)))\n        nil nil nil))))",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r1.7.228",
                                                             :filename "src/main/cljs/cljs/core.cljs",
                                                             :lines [3727
                                                                     3734]},
                                                    :full-name "cljs.core/LazyTransformer.createMulti"},
           "cljs.core/==" {:description "This is an equality check for numbers of different types that was carried over from Clojure,\nto allow compatibility when converting code to ClojureScript.\n\nSince there is only a single number type in JavaScript, 64-bit floating point, there is no\nreason to use the `==` operator in ClojureScript.\n\nBehavior on non-number arguments is undefined.",
                           :return-type boolean,
                           :ns "cljs.core",
                           :name "==",
                           :signature ["[x]" "[x y]" "[x y & more]"],
                           :history [["+" "0.0-927"]],
                           :type "function/macro",
                           :related ["cljs.core/="
                                     "cljs.core/identical?"],
                           :full-name-encode "cljs.core/EQEQ",
                           :source {:code "(defn ^boolean ==\n  ([x] true)\n  ([x y] (-equiv x y))\n  ([x y & more]\n   (if (== x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (== y (first more)))\n     false)))",
                                    :title "Function code",
                                    :repo "clojurescript",
                                    :tag "r1.7.228",
                                    :filename "src/main/cljs/cljs/core.cljs",
                                    :lines [2579 2590]},
                           :extra-sources [{:code "(core/defmacro ^::ana/numeric ==\n  ([x] true)\n  ([x y] (bool-expr (core/list 'js* \"(~{} === ~{})\" x y)))\n  ([x y & more] `(and (== ~x ~y) (== ~y ~@more))))",
                                            :title "Macro code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/clojure/cljs/core.cljc",
                                            :lines [1057 1060]}],
                           :examples [{:id "5ac342",
                                       :content "```clj\n(== 1 1)\n;;=> true\n\n(== 1 2)\n;;=> false\n```"}],
                           :full-name "cljs.core/==",
                           :clj-symbol "clojure.core/==",
                           :docstring "Returns non-nil if nums all have the equivalent\nvalue, otherwise false. Behavior on non nums is\nundefined."},
           "cljs.build.api/build" {:ns "cljs.build.api",
                                   :name "build",
                                   :signature ["[source opts]"
                                               "[source opts compiler-env]"],
                                   :history [["+" "0.0-3208"]],
                                   :type "function",
                                   :full-name-encode "cljs.build.api/build",
                                   :source {:code "(defn build\n  ([source opts]\n   (build source opts\n     (if-not (nil? env/*compiler*)\n       env/*compiler*\n       (env/default-compiler-env opts))))\n  ([source opts compiler-env]\n   (binding [ana/*cljs-warning-handlers* (:warning-handlers opts ana/*cljs-warning-handlers*)]\n     (closure/build source opts compiler-env))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/clojure/cljs/build/api.clj",
                                            :lines [198 207]},
                                   :full-name "cljs.build.api/build",
                                   :docstring "Given a source which can be compiled, produce runnable JavaScript."},
           "cljs.core/dissoc!" {:ns "cljs.core",
                                :name "dissoc!",
                                :signature ["[tcoll key]"
                                            "[tcoll key & ks]"],
                                :history [["+" "0.0-1211"]],
                                :type "function",
                                :full-name-encode "cljs.core/dissocBANG",
                                :source {:code "(defn dissoc!\n  ([tcoll key]\n    (-dissoc! tcoll key))\n  ([tcoll key & ks]\n    (let [ntcoll (-dissoc! tcoll key)]\n      (if ks\n        (recur ntcoll (first ks) (next ks))\n        ntcoll))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [3412 3420]},
                                :full-name "cljs.core/dissoc!",
                                :clj-symbol "clojure.core/dissoc!",
                                :docstring "Returns a transient map that doesn't contain a mapping for key(s)."},
           "cljs.repl/self-require?" {:ns "cljs.repl",
                                      :name "self-require?",
                                      :type "function",
                                      :signature ["[specs]"],
                                      :source {:code "(defn self-require? [specs]\n  (some\n    (fn [quoted-spec-or-kw]\n      (and (not (keyword? quoted-spec-or-kw))\n           (let [spec (second quoted-spec-or-kw)\n                 ns (if (sequential? spec)\n                      (first spec)\n                      spec)]\n             (= ns ana/*cljs-ns*))))\n    specs))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/clojure/cljs/repl.cljc",
                                               :lines [611 620]},
                                      :full-name "cljs.repl/self-require?",
                                      :full-name-encode "cljs.repl/self-requireQMARK",
                                      :history [["+" "0.0-2911"]]},
           "special/." {:description "For interop, the `.` special form allows access to member properties of the\ngiven JavaScript object `o`.\n\nIf the second operand is a symbol preceded with a hyphen as in `-p`, the\nexpression will result in the value of the property named `p`.\n\nIf the second operand is a symbol that is not preceded with a hyphen as in `m`,\nthe expression will evaluate to a call of the method named `m`.  Any additional\noperands will be passed as arguments to the method.\n\nThe __preferred, idiomatic__ way to access members of a JavaScript object is to\nuse the following sugar:\n\n<table class=\"code-tbl-9bef6\">\n  <thead>\n    <tr>\n      <th>Sugar</th>\n      <th>Expands To</th></tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><pre>(.-p o)</pre></td>\n      <td><pre>(. o -p)</pre></td>\n    </tr>\n    <tr>\n      <td><pre>(.m o)</pre></td>\n      <td><pre>(. o m)</pre></td>\n    </tr>\n    <tr>\n      <td><pre>(.m o 1 2)</pre></td>\n      <td><pre>(. o m 1 2)</pre></td>\n    </tr>\n  </tbody>\n</table>",
                        :ns "special",
                        :name ".",
                        :signature ["[o -p]"
                                    "[o m]"
                                    "[o m 1 2]"
                                    "[o (m 1 2)]"],
                        :history [["+" "0.0-927"]],
                        :type "special form",
                        :related ["cljs.core/.." "cljs.core/aget"],
                        :full-name-encode "special/DOT",
                        :source {:code "(defmethod parse '.\n  [_ env [_ target & [field & member+] :as form] _ _]\n  (disallowing-recur (analyze-dot env target field member+ form)))",
                                 :title "Parser code",
                                 :repo "clojurescript",
                                 :tag "r1.7.228",
                                 :filename "src/main/clojure/cljs/analyzer.cljc",
                                 :lines [2115 2117]},
                        :usage ["(.-foo obj)" "(.foo obj)"],
                        :examples [{:id "22ccbb",
                                    :content "We can access the JavaScript properties of a string:\n\n```js\n// JavaScript\nvar m = \"Hello World\";\nm.length;\n//=> 11\n```\n\n```clj\n;; ClojureScript\n(def m \"Hello World\")\n(.-length m)\n;;=> 11\n```\n\nWe can also call member functions on the string:\n\n```js\n// JavaScript\nm.toUpperCase();\n//=> \"HELLO WORLD\"\n\nm.replace(\"H\", \"\");\n//=> \"ello World\";\n```\n\n```clj\n;; ClojureScript\n(.toUpperCase m)\n;;=> \"HELLO WORLD\"\n\n(.replace m \"H\" \"\")\n;;=> \"ello World\"\n```"}
                                   {:id "7c5e58",
                                    :content "Create a JavaScript object `o`:\n\n```clj\n(def o #js {:foo \"bar\"})\n```\n\nYou can get the value at property `\"foo\"` with any of the following:\n\n```clj\n(. o -foo)\n;;=> \"bar\"\n\n(.-foo o)\n;;=> \"bar\"\n\n(aget o \"foo\")\n;;=> \"bar\"\n```"}],
                        :full-name "special/.",
                        :clj-symbol "clojure.core/.",
                        :docstring "The instance member form works for methods and fields.\nThey all expand into calls to the dot operator at macroexpansion time."},
           "cljs.build.api/ns->source" {:ns "cljs.build.api",
                                        :name "ns->source",
                                        :signature ["[ns]"],
                                        :history [["+" "0.0-3291"]],
                                        :type "function",
                                        :full-name-encode "cljs.build.api/ns-GTsource",
                                        :source {:code "(defn ns->source\n  [ns]\n  (util/ns->source ns))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/clojure/cljs/build/api.clj",
                                                 :lines [125 128]},
                                        :full-name "cljs.build.api/ns->source",
                                        :docstring "Given a namespace as a symbol return the corresponding resource if it exists."},
           "clojure.reflect/meta" {:ns "clojure.reflect",
                                   :name "meta",
                                   :signature ["[sym cb]"],
                                   :history [["+" "0.0-1503"]],
                                   :type "function",
                                   :full-name-encode "clojure.reflect/meta",
                                   :source {:code "(defn meta\n  [sym cb]\n  (query-reflection (str \"var=\" (js/encodeURIComponent (str sym)))\n                    #(cb (evaluate-javascript %))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/clojure/reflect.cljs",
                                            :lines [25 31]},
                                   :full-name "clojure.reflect/meta",
                                   :docstring "Queries the reflection api with a fully qualified symbol, then calls\ncallback fn cb with the evaluated cljs map containing that symbol's\nmeta information."},
           "cljs.reader/read-literal" {:ns "cljs.reader",
                                       :name "read-literal",
                                       :type "function",
                                       :signature ["[rdr ch]"],
                                       :source {:code "(defn read-literal\n  [rdr ch]\n  (let [token (read-token rdr ch)\n        chars (subs token 1)]\n    (cond (identical? (.-length chars) 1) chars\n          (identical? chars \"tab\")       \"\\t\"\n          (identical? chars \"return\")    \"\\r\"\n          (identical? chars \"newline\")   \"\\n\"\n          (identical? chars \"space\")     \" \"\n          (identical? chars \"backspace\") \"\\b\"\n          (identical? chars \"formfeed\")  \"\\f\"\n          (identical? (.charAt chars 0) \"u\") (make-unicode-char (subs chars 1))\n          (identical? (.charAt chars 0) \"o\") (not-implemented rdr token)\n          :else (reader-error rdr \"Unknown character literal: \" token))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/cljs/reader.cljs",
                                                :lines [337 350]},
                                       :full-name "cljs.reader/read-literal",
                                       :full-name-encode "cljs.reader/read-literal",
                                       :history [["+" "1.7.107"]]},
           "clojure.browser.net/*timeout*" {:ns "clojure.browser.net",
                                            :name "*timeout*",
                                            :type "var",
                                            :source {:code "(def *timeout* 10000)",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.7.228",
                                                     :filename "src/main/cljs/clojure/browser/net.cljs",
                                                     :lines [19]},
                                            :full-name "clojure.browser.net/*timeout*",
                                            :full-name-encode "clojure.browser.net/STARtimeoutSTAR",
                                            :history [["+" "0.0-927"]]},
           "cljs.js/*loaded*" {:ns "cljs.js",
                               :name "*loaded*",
                               :type "var",
                               :source {:code "(def *loaded* (atom #{}))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/js.cljs",
                                        :lines [159]},
                               :full-name "cljs.js/*loaded*",
                               :full-name-encode "cljs.js/STARloadedSTAR",
                               :history [["+" "1.7.10"]]},
           "cljs.core/remove-method" {:ns "cljs.core",
                                      :name "remove-method",
                                      :signature ["[multifn dispatch-val]"],
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "cljs.core/remove-method",
                                      :source {:code "(defn remove-method\n [multifn dispatch-val]\n (-remove-method multifn dispatch-val))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [9805 9808]},
                                      :full-name "cljs.core/remove-method",
                                      :clj-symbol "clojure.core/remove-method",
                                      :docstring "Removes the method of multimethod associated with dispatch-value."},
           "cljs.core/array-chunk" {:ns "cljs.core",
                                    :name "array-chunk",
                                    :type "function",
                                    :signature ["[arr]"
                                                "[arr off]"
                                                "[arr off end]"],
                                    :source {:code "(defn array-chunk\n  ([arr]\n     (ArrayChunk. arr 0 (alength arr)))\n  ([arr off]\n     (ArrayChunk. arr off (alength arr)))\n  ([arr off end]\n     (ArrayChunk. arr off end)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [3116 3122]},
                                    :full-name "cljs.core/array-chunk",
                                    :full-name-encode "cljs.core/array-chunk",
                                    :history [["+" "0.0-1424"]]},
           "clojure.core.reducers/drop" {:ns "clojure.core.reducers",
                                         :name "drop",
                                         :signature ["[n]" "[n coll]"],
                                         :history [["+" "0.0-1236"]],
                                         :type "function",
                                         :full-name-encode "clojure.core.reducers/drop",
                                         :source {:code "(defcurried drop\n  \"Elides the first n values from the reduction of coll.\"\n  {}\n  [n coll]\n  (reducer coll\n   (fn [f1]\n     (let [cnt (atom n)]\n       (rfn [f1 k]\n         ([ret k v]\n            (swap! cnt dec)\n            (if (neg? @cnt)\n              (f1 ret k v)\n              ret)))))))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.7.228",
                                                  :filename "src/main/cljs/clojure/core/reducers.cljs",
                                                  :lines [178 190]},
                                         :full-name "clojure.core.reducers/drop",
                                         :clj-symbol "clojure.core.reducers/drop",
                                         :docstring "Elides the first n values from the reduction of coll."},
           "syntax/symbol" {:description "A symbol represents a name.  When evaluated, its result will be the value that the symbol\nis bound to.\n\nSome naming rules:\n\n- must not begin with a number\n- can contain special characters `. * + ! - _ ? $ % & = < > : #`, as long as:\n  - if starting with `-`, `+`, or `.`, next character cannot be numeric (would be interpreted as number)\n  - cannot start with `:` and `#`\n- symbols starting or ending with a decimal are reserved for interop purposes (see [doc:syntax/dot])\n\nSymbols can use a single `/` for an optional namespace. See [doc:syntax/namespace]:\n\n- `foo/bar` => value of `bar` in the `foo` namespace\n\nTo access symbols in the global JavaScript context, use the [doc:syntax/js-namespace]:\n\n- `js/document` => global `document` JavaScript object\n\nDots can also be included in symbols for direct JS property access, see [doc:syntax/dot]:\n\n- `js/console.log` => the `console.log` JavaScript function",
                            :ns "syntax",
                            :name "symbol",
                            :history [["+" "0.0-927"]],
                            :type "syntax",
                            :related ["cljs.core/symbol"
                                      "cljs.core/symbol?"],
                            :full-name-encode "syntax/symbol",
                            :extra-sources [{:code "(defn- read-symbol\n  [rdr initch]\n  (let [[line column] (starting-line-col-info rdr)]\n    (when-let [token (read-token rdr initch)]\n      (case token\n\n        ;; special symbols\n        \"nil\" nil\n        \"true\" true\n        \"false\" false\n        \"/\" '/\n        \"NaN\" Double/NaN\n        \"-Infinity\" Double/NEGATIVE_INFINITY\n        (\"Infinity\" \"+Infinity\") Double/POSITIVE_INFINITY\n\n        (or (when-let [p (parse-symbol token)]\n              (with-meta (symbol (p 0) (p 1))\n                (when line\n                  (merge\n                   (when-let [file (get-file-name rdr)]\n                     {:file file})\n                   (let [[end-line end-column] (ending-line-col-info rdr)]\n                     {:line line\n                      :column column\n                      :end-line end-line\n                      :end-column end-column})))))\n            (reader-error rdr \"Invalid token: \" token))))))",
                                             :title "Reader code",
                                             :repo "tools.reader",
                                             :tag "tools.reader-1.0.0-alpha1",
                                             :filename "src/main/clojure/clojure/tools/reader.clj",
                                             :lines [303 329]}],
                            :usage ["foo" "foo/bar"],
                            :examples [{:id "cd60a5",
                                        :content "The following has two symbols, `def` and `a`:\n\n```clj\n(def a 1)\n```\n\nThe evaluation of the symbols is controlled by the evaluation of the list `(def\na 1)`.  `def` evaluates to a special form, which suppresses the evaluation of\n`a` since it is just being used as a name for the bound value `1`.\n\nWhen a symbol is by itself, it will evaluated to 1:\n\n```clj\na\n;;=> 1\n```\n\nTo signify an unevaluated symbol, precede it with a quote:\n\n```clj\n'a\n;;=> a\n```"}],
                            :edn-doc "https://github.com/edn-format/edn#symbols",
                            :full-name "syntax/symbol",
                            :display "symbol literal",
                            :clj-doc "http://clojure.org/reader#toc1"},
           "clojure.browser.net/IWebSocket" {:ns "clojure.browser.net",
                                             :name "IWebSocket",
                                             :type "protocol",
                                             :full-name-encode "clojure.browser.net/IWebSocket",
                                             :source {:code "(defprotocol IWebSocket\n  (open? [this]))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.7.228",
                                                      :filename "src/main/cljs/clojure/browser/net.cljs",
                                                      :lines [143 144]},
                                             :methods [{:name "open?",
                                                        :signature ["[this]"],
                                                        :docstring nil}],
                                             :full-name "clojure.browser.net/IWebSocket",
                                             :history [["+"
                                                        "0.0-2911"]]},
           "cljs.core/PersistentArrayMap.fromArrays" {:ns "cljs.core",
                                                      :name "PersistentArrayMap.fromArrays",
                                                      :signature ["[ks vs]"],
                                                      :history [["+"
                                                                 "0.0-1211"]
                                                                ["-"
                                                                 "0.0-1798"]],
                                                      :parent-type "PersistentArrayMap",
                                                      :type "function",
                                                      :full-name-encode "cljs.core/PersistentArrayMapDOTfromArrays",
                                                      :source {:code "(set! cljs.core.PersistentArrayMap/fromArrays\n      (fn [ks vs]\n        (let [len (count ks)]\n          (loop [i   0\n                 out (transient cljs.core.PersistentArrayMap/EMPTY)]\n            (if (< i len)\n              (recur (inc i) (assoc! out (aget ks i) (aget vs i)))\n              (persistent! out))))))",
                                                               :title "Source code",
                                                               :repo "clojurescript",
                                                               :tag "r1586",
                                                               :filename "src/cljs/cljs/core.cljs",
                                                               :lines [3976
                                                                       3983]},
                                                      :full-name "cljs.core/PersistentArrayMap.fromArrays",
                                                      :removed {:in "0.0-1798",
                                                                :last-seen "0.0-1586"}},
           "cljs.core/frequencies" {:description "Returns a map from distinct items in `coll` to the number of times they appear.\n\n`(frequencies [:a :a :b])` => `{:a 2, :b 1}`",
                                    :ns "cljs.core",
                                    :name "frequencies",
                                    :signature ["[coll]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :related ["cljs.core/group-by"
                                              "cljs.core/distinct"],
                                    :full-name-encode "cljs.core/frequencies",
                                    :source {:code "(defn frequencies\n  [coll]\n  (persistent!\n   (reduce (fn [counts x]\n             (assoc! counts x (inc (get counts x 0))))\n           (transient {}) coll)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [8605 8612]},
                                    :full-name "cljs.core/frequencies",
                                    :clj-symbol "clojure.core/frequencies",
                                    :docstring "Returns a map from distinct items in coll to the number of times\nthey appear."},
           "cljs.core/pop" {:description "For a list, returns a new list without the first item.\n\nFor a vector, returns a new vector without the last item.",
                            :ns "cljs.core",
                            :name "pop",
                            :signature ["[coll]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/peek"
                                      "cljs.core/rest"
                                      "cljs.core/conj"],
                            :full-name-encode "cljs.core/pop",
                            :source {:code "(defn pop\n  [coll]\n  (when-not (nil? coll)\n    (-pop coll)))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.7.228",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [1861 1867]},
                            :examples [{:id "6bd9f7",
                                        :content "With vectors:\n\n```clj\n(pop [1 2 3])\n;;=> [1 2]\n\n(pop [1 2])\n;;=> [1]\n\n(pop [1])\n;;=> []\n\n(pop [])\n;; Error: Can't pop empty vector\n```"}
                                       {:id "81221f",
                                        :content "With lists:\n\n```clj\n(pop '(1 2 3))\n;;=> (2 3)\n\n(pop '(1 2))\n;;=> (2)\n\n(pop '(1))\n;;=> ()\n\n(pop '())\n;; Error: Can't pop empty list\n```"}],
                            :full-name "cljs.core/pop",
                            :clj-symbol "clojure.core/pop",
                            :docstring "For a list or queue, returns a new list/queue without the first\nitem, for a vector, returns a new vector without the last item.\nNote - not the same as next/butlast."},
           "cljs.repl/with-read-known" {:ns "cljs.repl",
                                        :name "with-read-known",
                                        :signature ["[& body]"],
                                        :history [["+" "0.0-2719"]
                                                  ["-" "0.0-2911"]],
                                        :type "macro",
                                        :full-name-encode "cljs.repl/with-read-known",
                                        :source {:code "(defmacro with-read-known\n  [& body]\n  `(binding [*read-eval* (if (= :unknown *read-eval*) true *read-eval*)]\n     ~@body))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2850",
                                                 :filename "src/clj/cljs/repl.clj",
                                                 :lines [84 89]},
                                        :full-name "cljs.repl/with-read-known",
                                        :docstring "Evaluates body with *read-eval* set to a \"known\" value,\ni.e. substituting true for :unknown if necessary.",
                                        :removed {:in "0.0-2911",
                                                  :last-seen "0.0-2850"}},
           "cljs.core/flatmap" {:ns "cljs.core",
                                :name "flatmap",
                                :signature ["[f]" "[f coll]"],
                                :history [["+" "0.0-2301"]
                                          ["-" "0.0-2341"]],
                                :type "function",
                                :full-name-encode "cljs.core/flatmap",
                                :source {:code "(defn flatmap\n  ([f]\n   (fn [f1]\n     (fn\n       ([] (f1))\n       ([result] (f1 result))\n       ([result input]\n          (reduce (preserving-reduced f1) result (f input))))))\n  ([f coll] (sequence (flatmap f) coll)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2322",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [8139 8150]},
                                :full-name "cljs.core/flatmap",
                                :docstring "maps f over coll and concatenates the results.  Thus function f\nshould return a collection.  Returns a transducer when no collection\nis provided.",
                                :removed {:in "0.0-2341",
                                          :last-seen "0.0-2322"}},
           "cljs.core/not-every?" {:description "Returns false if `(pred x)` is logical true for every `x` in `coll`, else true.",
                                   :return-type boolean,
                                   :ns "cljs.core",
                                   :name "not-every?",
                                   :signature ["[pred coll]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/every?"
                                             "cljs.core/not-any?"
                                             "cljs.core/some"],
                                   :full-name-encode "cljs.core/not-everyQMARK",
                                   :source {:code "(defn ^boolean not-every?\n  [pred coll] (not (every? pred coll)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [3763 3766]},
                                   :full-name "cljs.core/not-every?",
                                   :clj-symbol "clojure.core/not-every?",
                                   :docstring "Returns false if (pred x) is logical true for every x in\ncoll, else true."},
           "cljs.core/js-invoke" {:description "Invoke JavaScript object `obj` method via string `s`. Needed when the string is\nnot a valid unquoted property name.",
                                  :ns "cljs.core",
                                  :name "js-invoke",
                                  :signature ["[obj s & args]"],
                                  :history [["+" "0.0-2411"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/js-invoke",
                                  :source {:code "(defn js-invoke\n  [obj s & args]\n  (.apply (aget obj s) obj (into-array args)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [416 420]},
                                  :examples [{:id "373cce",
                                              :content "If we have a JavaScript object with an unusual property name:\n\n```js\n// JavaScript\nvar obj = {\n  \"my sum\": function(a,b) { return a+b; }\n};\n```\n\nWe can invoke it from ClojureScript:\n\n```clj\n(js-invoke js/obj \"my sum\" 1 2)\n;=> 3\n```"}],
                                  :full-name "cljs.core/js-invoke",
                                  :docstring "Invoke JavaScript object method via string. Needed when the\nstring is not a valid unquoted property name."},
           "cljs.core/some-fn" {:description "Takes a set of predicate functions and returns a function `f` that returns the\nfirst logical true value returned by one of its composing predicates against any\nof its arguments, else it returns logical false.\n\nNote that `f` is short-circuiting in that it will stop execution on the first\nargument that triggers a logical true result against the original predicates.",
                                :ns "cljs.core",
                                :name "some-fn",
                                :signature ["[p]"
                                            "[p1 p2]"
                                            "[p1 p2 p3]"
                                            "[p1 p2 p3 & ps]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/every-pred"
                                          "cljs.core/some"
                                          "cljs.core/or"],
                                :full-name-encode "cljs.core/some-fn",
                                :source {:code "(defn some-fn\n  ([p]\n     (fn sp1\n       ([] nil)\n       ([x] (p x))\n       ([x y] (or (p x) (p y)))\n       ([x y z] (or (p x) (p y) (p z)))\n       ([x y z & args] (or (sp1 x y z)\n                           (some p args)))))\n  ([p1 p2]\n     (fn sp2\n       ([] nil)\n       ([x] (or (p1 x) (p2 x)))\n       ([x y] (or (p1 x) (p1 y) (p2 x) (p2 y)))\n       ([x y z] (or (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z)))\n       ([x y z & args] (or (sp2 x y z)\n                           (some #(or (p1 %) (p2 %)) args)))))\n  ([p1 p2 p3]\n     (fn sp3\n       ([] nil)\n       ([x] (or (p1 x) (p2 x) (p3 x)))\n       ([x y] (or (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y)))\n       ([x y z] (or (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y) (p1 z) (p2 z) (p3 z)))\n       ([x y z & args] (or (sp3 x y z)\n                           (some #(or (p1 %) (p2 %) (p3 %)) args)))))\n  ([p1 p2 p3 & ps]\n     (let [ps (list* p1 p2 p3 ps)]\n       (fn spn\n         ([] nil)\n         ([x] (some #(% x) ps))\n         ([x y] (some #(or (% x) (% y)) ps))\n         ([x y z] (some #(or (% x) (% y) (% z)) ps))\n         ([x y z & args] (or (spn x y z)\n                             (some #(some % args) ps)))))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [4157 4194]},
                                :full-name "cljs.core/some-fn",
                                :clj-symbol "clojure.core/some-fn",
                                :docstring "Takes a set of predicates and returns a function f that returns the first logical true value\nreturned by one of its composing predicates against any of its arguments, else it returns\nlogical false. Note that f is short-circuiting in that it will stop execution on the first\nargument that triggers a logical true result against the original predicates."},
           "syntax/vector" {:description "Creates a vector.  A vector is the most commonly used form for creating literal\nsequences, and supports random-access and inserting at the end via [doc:cljs.core/conj]:\n\n```clj\n(def a [1 2 3 4 5])\n```\n\nVectors also serve an important language role as the convention for signaling a\n_binding form_, that is, when local names are created and bound to values.\nExamples:\n\n- `[a b]` as function arg bindings in [`(fn [a b] ...)`][doc:cljs.core/fn]\n- `[a 1 b 2]` as let bindings in [`(let [a 1 b 2] ...)`][doc:cljs.core/let]\n\nThis helps differentiate binding forms from the parentheses of [callable forms][doc:syntax/list].\n\nSee [doc:cljs.core/PersistentVector] for data structure details.",
                            :ns "syntax",
                            :name "vector",
                            :history [["+" "0.0-927"]],
                            :type "syntax",
                            :related ["cljs.core/vector"
                                      "cljs.core/vec"],
                            :full-name-encode "syntax/vector",
                            :extra-sources ({:code "(defn- read-vector\n  [rdr _ opts pending-forms]\n  (let [[start-line start-column] (starting-line-col-info rdr)\n        the-vector (read-delimited \\] rdr opts pending-forms)\n        [end-line end-column] (ending-line-col-info rdr)]\n    (with-meta the-vector\n      (when start-line\n        (merge\n         (when-let [file (get-file-name rdr)]\n           {:file file})\n         {:line start-line\n          :column start-column\n          :end-line end-line\n          :end-column end-column})))))",
                                             :title "Reader code",
                                             :repo "tools.reader",
                                             :tag "tools.reader-1.0.0-alpha1",
                                             :filename "src/main/clojure/clojure/tools/reader.clj",
                                             :lines [222 236]}
                                            {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                             :title "Reader table",
                                             :repo "tools.reader",
                                             :tag "tools.reader-1.0.0-alpha1",
                                             :filename "src/main/clojure/clojure/tools/reader.clj",
                                             :lines [743 762]}),
                            :usage ["[...]"],
                            :examples [{:id "18e143",
                                        :content "```clj\n[1 2 3]\n;;=> [1 2 3]\n```"}],
                            :edn-doc "https://github.com/edn-format/edn#vectors",
                            :full-name "syntax/vector",
                            :display "[] vector",
                            :clj-doc "http://clojure.org/reader#toc1"},
           "clojure.browser.event/remove-all" {:ns "clojure.browser.event",
                                               :name "remove-all",
                                               :type "function",
                                               :signature ["[opt_obj opt_type opt_capt]"],
                                               :source {:code "(defn remove-all [opt_obj opt_type opt_capt])",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.7.228",
                                                        :filename "src/main/cljs/clojure/browser/event.cljs",
                                                        :lines [100]},
                                               :full-name "clojure.browser.event/remove-all",
                                               :full-name-encode "clojure.browser.event/remove-all",
                                               :history [["+"
                                                          "0.0-927"]]},
           "cljs.core/doto" {:ns "cljs.core",
                             :name "doto",
                             :signature ["[x & forms]"],
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :full-name-encode "cljs.core/doto",
                             :source {:code "(defmacro doto\n  [x & forms]\n    (let [gx (gensym)]\n      `(let [~gx ~x]\n         ~@(map (fn [f]\n                  (if (seq? f)\n                    `(~(first f) ~gx ~@(next f))\n                    `(~f ~gx)))\n                forms)\n         ~gx)))",
                                      :title "Source code",
                                      :repo "clojure",
                                      :tag "clojure-1.7.0",
                                      :filename "src/clj/clojure/core.clj",
                                      :lines [3700 3715]},
                             :full-name "cljs.core/doto",
                             :clj-symbol "clojure.core/doto",
                             :docstring "Evaluates x then calls all of the methods and functions with the\nvalue of x supplied at the front of the given arguments.  The forms\nare evaluated in order.  Returns x.\n\n(doto (new java.util.HashMap) (.put \"a\" 1) (.put \"b\" 2))"},
           "cljs.core/take-while" {:description "Returns a lazy sequence of successive items from `coll` while `(pred item)`\nreturns true. `pred` must be free of side-effects.\n\nReturns a transducer when no collection is provided.",
                                   :ns "cljs.core",
                                   :name "take-while",
                                   :signature ["[pred]" "[pred coll]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/drop-while"
                                             "cljs.core/split-with"],
                                   :full-name-encode "cljs.core/take-while",
                                   :source {:code "(defn take-while\n  ([pred]\n     (fn [rf]\n       (fn\n         ([] (rf))\n         ([result] (rf result))\n         ([result input]\n            (if (pred input)\n              (rf result input)\n              (reduced result))))))\n  ([pred coll]\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (when (pred (first s))\n           (cons (first s) (take-while pred (rest s))))))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [8374 8391]},
                                   :full-name "cljs.core/take-while",
                                   :clj-symbol "clojure.core/take-while",
                                   :docstring "Returns a lazy sequence of successive items from coll while\n(pred item) returns true. pred must be free of side-effects.\nReturns a transducer when no collection is provided."},
           "cljs.repl/evaluate-form" {:ns "cljs.repl",
                                      :name "evaluate-form",
                                      :signature ["[repl-env env filename form]"
                                                  "[repl-env env filename form wrap]"
                                                  "[repl-env env filename form wrap opts]"],
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "cljs.repl/evaluate-form",
                                      :source {:code "(defn evaluate-form\n  ([repl-env env filename form]\n    (evaluate-form repl-env env filename form identity))\n  ([repl-env env filename form wrap]\n    (evaluate-form repl-env env filename form wrap *repl-opts*))\n  ([repl-env env filename form wrap opts]\n   (binding [ana/*cljs-file* filename]\n     (let [ast (ana/analyze env form nil opts)\n           js (comp/emit-str ast)\n           def-emits-var (:def-emits-var opts)\n           wrap-js\n           ;; TODO: check opts as well - David\n           (if (:source-map repl-env)\n             (binding [comp/*source-map-data*\n                       (atom {:source-map (sorted-map)\n                              :gen-col 0\n                              :gen-line 0})]\n               (let [js (comp/emit-str\n                          (ana/no-warn\n                            (ana/analyze (assoc env :repl-env repl-env :def-emits-var def-emits-var)\n                              (wrap form) nil opts)))\n                     t (System/currentTimeMillis)]\n                 (str js\n                   \"\\n//# sourceURL=repl-\" t \".js\"\n                   \"\\n//# sourceMappingURL=data:application/json;base64,\"\n                   (DatatypeConverter/printBase64Binary\n                     (.getBytes\n                       (sm/encode\n                         {(str \"repl-\" t \".cljs\")\n                          (:source-map @comp/*source-map-data*)}\n                         {:lines (+ (:gen-line @comp/*source-map-data*) 3)\n                          :file (str \"repl-\" t \".js\")\n                          :sources-content\n                          [(or (:source (meta form))\n                             ;; handle strings / primitives without metadata\n                             (with-out-str (pr form)))]})\n                       \"UTF-8\")))))\n             (comp/emit-str\n               (ana/no-warn\n                 (ana/analyze (assoc env :repl-env repl-env :def-emits-var def-emits-var)\n                   (wrap form) nil opts))))]\n       (when (= (:op ast) :ns)\n         (load-dependencies repl-env\n           (into (vals (:requires ast))\n             (distinct (vals (:uses ast))))\n           opts))\n       (when *cljs-verbose*\n         (err-out (println js)))\n       (let [ret (-evaluate repl-env filename (:line (meta form)) wrap-js)]\n         (case (:status ret)\n           :error (throw\n                    (ex-info (:value ret)\n                      {:type :js-eval-error\n                       :error ret\n                       :repl-env repl-env\n                       :form form}))\n           :exception (throw\n                        (ex-info (:value ret)\n                          {:type :js-eval-exception\n                           :error ret\n                           :repl-env repl-env\n                           :form form\n                           :js js}))\n           :success (:value ret)))))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/clojure/cljs/repl.cljc",
                                               :lines [431 497]},
                                      :full-name "cljs.repl/evaluate-form",
                                      :docstring "Evaluate a ClojureScript form in the JavaScript environment. Returns a\nstring which is the ClojureScript return value. This string may or may\nnot be readable by the Clojure reader."},
           "cljs.reader/escape-char-map" {:ns "cljs.reader",
                                          :name "escape-char-map",
                                          :type "function",
                                          :signature ["[c]"],
                                          :source {:code "(defn escape-char-map [c]\n  (cond\n   (identical? c \\t) \"\\t\"\n   (identical? c \\r) \"\\r\"\n   (identical? c \\n) \"\\n\"\n   (identical? c \\\\) \\\\\n   (identical? c \\\") \\\"\n   (identical? c \\b) \"\\b\"\n   (identical? c \\f) \"\\f\"\n   :else nil))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/cljs/cljs/reader.cljs",
                                                   :lines [152 161]},
                                          :full-name "cljs.reader/escape-char-map",
                                          :full-name-encode "cljs.reader/escape-char-map",
                                          :history [["+" "0.0-927"]]},
           "clojure.browser.event/all-listeners" {:ns "clojure.browser.event",
                                                  :name "all-listeners",
                                                  :type "function",
                                                  :signature ["[obj type capture]"],
                                                  :source {:code "(defn all-listeners [obj type capture])",
                                                           :title "Source code",
                                                           :repo "clojurescript",
                                                           :tag "r1.7.228",
                                                           :filename "src/main/cljs/clojure/browser/event.cljs",
                                                           :lines [92]},
                                                  :full-name "clojure.browser.event/all-listeners",
                                                  :full-name-encode "clojure.browser.event/all-listeners",
                                                  :history [["+"
                                                             "0.0-927"]]},
           "cljs.core/ITransientSet" {:ns "cljs.core",
                                      :name "ITransientSet",
                                      :history [["+" "0.0-1211"]],
                                      :type "protocol",
                                      :full-name-encode "cljs.core/ITransientSet",
                                      :source {:code "(defprotocol ITransientSet\n  \"Protocol for adding set functionality to a transient collection.\"\n  (^clj -disjoin! [tcoll v]\n    \"Returns tcoll without v.\"))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [697 700]},
                                      :methods [{:name "-disjoin!",
                                                 :signature ["[tcoll v]"],
                                                 :docstring "Returns tcoll without v."}],
                                      :full-name "cljs.core/ITransientSet",
                                      :clj-symbol "clojure.lang/ITransientSet",
                                      :docstring "Protocol for adding set functionality to a transient collection."},
           "cljs.core/vals" {:description "Returns a sequence of the values in `hash-map`.",
                             :ns "cljs.core",
                             :name "vals",
                             :signature ["[hash-map]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/keys"],
                             :full-name-encode "cljs.core/vals",
                             :source {:code "(defn vals\n  [hash-map]\n  (when-let [mseq (seq hash-map)]\n    (ValSeq. mseq nil)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [7913 7917]},
                             :full-name "cljs.core/vals",
                             :clj-symbol "clojure.core/vals",
                             :docstring "Returns a sequence of the map's values."},
           "cljs.core/IDeref" {:ns "cljs.core",
                               :name "IDeref",
                               :history [["+" "0.0-927"]],
                               :type "protocol",
                               :full-name-encode "cljs.core/IDeref",
                               :source {:code "(defprotocol IDeref\n  \"Protocol for adding dereference functionality to a reference.\"\n  (-deref [o]\n    \"Returns the value of the reference o.\"))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [557 560]},
                               :methods [{:name "-deref",
                                          :signature ["[o]"],
                                          :docstring "Returns the value of the reference o."}],
                               :full-name "cljs.core/IDeref",
                               :clj-symbol "clojure.lang/IDeref",
                               :docstring "Protocol for adding dereference functionality to a reference."},
           "cljs.build.api/parse-js-ns" {:ns "cljs.build.api",
                                         :name "parse-js-ns",
                                         :signature ["[f]"],
                                         :history [["+" "0.0-2629"]],
                                         :type "function",
                                         :full-name-encode "cljs.build.api/parse-js-ns",
                                         :source {:code "(defn parse-js-ns\n  [f]\n  (closure/parse-js-ns f))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.7.228",
                                                  :filename "src/main/clojure/cljs/build/api.clj",
                                                  :lines [73 78]},
                                         :full-name "cljs.build.api/parse-js-ns",
                                         :docstring "Given a Google Closure style JavaScript file or resource return the namespace\ninformation for the given file. Only returns the value extracted from the\nfirst provide statement."},
           "cljs.js/require" {:ns "cljs.js",
                              :name "require",
                              :type "function",
                              :signature ["[name cb]"
                                          "[name opts cb]"
                                          "[bound-vars name opts cb]"
                                          "[bound-vars name reload opts cb]"],
                              :source {:code "(defn require\n  ([name cb]\n    (require name nil cb))\n  ([name opts cb]\n    (require nil name opts cb))\n  ([bound-vars name opts cb]\n   (require bound-vars name nil opts cb))\n  ([bound-vars name reload opts cb]\n   (let [bound-vars (merge\n                      {:*compiler*     (env/default-compiler-env)\n                       :*data-readers* tags/*cljs-data-readers*\n                       :*load-macros*  (or (:load-macros opts) true)\n                       :*analyze-deps* (or (:analyze-deps opts) true)\n                       :*load-fn*      (or (:load opts) *load-fn*)\n                       :*eval-fn*      (or (:eval opts) *eval-fn*)}\n                      bound-vars)\n         aname (cond-> name (:macros-ns opts) ana/macro-ns-name)]\n     (when (= :reload reload)\n       (swap! *loaded* disj aname))\n     (when (= :reload-all reload)\n       (reset! *loaded* #{}))\n     (when (:verbose opts)\n       (debug-prn (str \"Loading \" name (when (:macros-ns opts) \" macros\") \" namespace\")))\n     (if-not (contains? @*loaded* aname)\n       (let [env (:*env* bound-vars)]\n         (try\n           ((:*load-fn* bound-vars)\n             {:name name\n              :macros (:macros-ns opts)\n              :path (ns->relpath name)}\n             (fn [resource]\n               (assert (or (map? resource) (nil? resource))\n                 \"*load-fn* may only return a map or nil\")\n               (if resource\n                 (let [{:keys [lang source cache source-map]} resource]\n                   (condp = lang\n                     :clj (eval-str* bound-vars source name opts\n                            (fn [res]\n                              (if (:error res)\n                                (cb res)\n                                (do\n                                  (swap! *loaded* conj aname)\n                                  (cb {:value true})))))\n                     :js (process-macros-deps bound-vars cache opts\n                           (fn [res]\n                             (if (:error res)\n                               (cb res)\n                               (process-libs-deps bound-vars cache opts\n                                 (fn [res]\n                                   (if (:error res)\n                                     (cb res)\n                                     (let [res (try\n                                                 ((:*eval-fn* bound-vars) resource)\n                                                 (when cache\n                                                   (load-analysis-cache!\n                                                     (:*compiler* bound-vars) aname cache))\n                                                 (when source-map\n                                                   (load-source-map!\n                                                     (:*compiler* bound-vars) aname source-map))\n                                                 (catch :default cause\n                                                   (wrap-error\n                                                     (ana/error env\n                                                       (str \"Could not require \" name) cause))))]\n                                       (if (:error res)\n                                         (cb res)\n                                         (do\n                                           (swap! *loaded* conj name)\n                                           (cb {:value true}))))))))))\n                     (cb (wrap-error\n                           (ana/error env\n                             (str \"Invalid :lang specified \" lang \", only :clj or :js allowed\"))))))\n                 (cb (wrap-error\n                       (ana/error env\n                         (ana/error-message (if (:macros-ns opts)\n                                              :undeclared-macros-ns\n                                              :undeclared-ns)\n                           {:ns-sym name :js-provide (cljs.core/name name)})))))))\n           (catch :default cause\n             (cb (wrap-error\n                   (ana/error env\n                     (str \"Could not require \" name) cause))))))\n       (cb {:value true})))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/js.cljs",
                                       :lines [204 285]},
                              :full-name "cljs.js/require",
                              :full-name-encode "cljs.js/require",
                              :history [["+" "1.7.10"]]},
           "cljs.core/string-hash-cache" {:ns "cljs.core",
                                          :name "string-hash-cache",
                                          :type "var",
                                          :source {:code "(def string-hash-cache (js-obj))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/cljs/cljs/core.cljs",
                                                   :lines [841]},
                                          :full-name "cljs.core/string-hash-cache",
                                          :full-name-encode "cljs.core/string-hash-cache",
                                          :history [["+" "0.0-1424"]]},
           "cljs.core/array-map" {:description "Returns a new array map (a map implemented with arrays) with the supplied mappings.\n\n`keyvals` must be an even number of forms.",
                                  :ns "cljs.core",
                                  :name "array-map",
                                  :signature ["[& keyvals]"],
                                  :history [["+" "0.0-1211"]],
                                  :type "function/macro",
                                  :related ["cljs.core/assoc"
                                            "cljs.core/hash-map"
                                            "cljs.core/sorted-map"],
                                  :full-name-encode "cljs.core/array-map",
                                  :source {:code "(defn array-map\n  [& keyvals]\n  (let [arr (if (and (instance? IndexedSeq keyvals) (zero? (.-i keyvals)))\n              (.-arr keyvals)\n              (into-array keyvals))]\n    (.fromArray cljs.core/PersistentArrayMap arr true false)))",
                                           :title "Function code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [7747 7754]},
                                  :extra-sources [{:code "(core/defmacro array-map\n  ([] '(.-EMPTY cljs.core/PersistentArrayMap))\n  ([& kvs]\n   (core/let [keys (map first (partition 2 kvs))]\n     (if (core/and (every? #(= (:op %) :constant)\n                     (map #(cljs.analyzer/analyze &env %) keys))\n           (= (count (into #{} keys)) (count keys)))\n       `(cljs.core/PersistentArrayMap. nil ~(clojure.core// (count kvs) 2) (array ~@kvs) nil)\n       `(.fromArray cljs.core/PersistentArrayMap (array ~@kvs) true false)))))",
                                                   :title "Macro code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/clojure/cljs/core.cljc",
                                                   :lines [2353 2361]}],
                                  :examples [{:id "198026",
                                              :content "```clj\n(array-map :a 10)\n;;=> {:a 10}\n\n(array-map :a 10 :b 20)\n;;=> {:a 10 :b 20}\n```"}],
                                  :full-name "cljs.core/array-map",
                                  :clj-symbol "clojure.core/array-map",
                                  :docstring "keyval => key val\nReturns a new array map with supplied mappings."},
           "cljs.test/report" {:ns "cljs.test",
                               :name "report",
                               :history [["+" "0.0-2496"]],
                               :type "multimethod",
                               :full-name-encode "cljs.test/report",
                               :source {:code "(defmulti\n  ^{:doc \"Generic reporting function, may be overridden to plug in\n   different report formats (e.g., TAP, JUnit).  Assertions such as\n   'is' call 'report' to indicate results.  The argument given to\n   'report' will be a map with a :type key.\"\n     :dynamic true}\n  report (fn [m] [(:reporter (get-current-env)) (:type m)]))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/test.cljs",
                                        :lines [312 318]},
                               :extra-sources ({:code "(defmethod report :default [m])",
                                                :title "Dispatch method",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/cljs/test.cljs",
                                                :lines [320]}
                                               {:code "(defmethod report [::default :pass] [m]\n  (inc-report-counter! :pass))",
                                                :title "Dispatch method",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/cljs/test.cljs",
                                                :lines [322 323]}
                                               {:code "(defmethod report [::default :fail] [m]\n  (inc-report-counter! :fail)\n  (println \"\\nFAIL in\" (testing-vars-str m))\n  (when (seq (:testing-contexts (get-current-env)))\n    (println (testing-contexts-str)))\n  (when-let [message (:message m)] (println message))\n  (print-comparison m))",
                                                :title "Dispatch method",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/cljs/test.cljs",
                                                :lines [330 336]}
                                               {:code "(defmethod report [::default :error] [m]\n  (inc-report-counter! :error)\n  (println \"\\nERROR in\" (testing-vars-str m))\n  (when (seq (:testing-contexts (get-current-env)))\n    (println (testing-contexts-str)))\n  (when-let [message (:message m)] (println message))\n  (print-comparison m))",
                                                :title "Dispatch method",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/cljs/test.cljs",
                                                :lines [338 344]}
                                               {:code "(defmethod report [::default :summary] [m]\n  (println \"\\nRan\" (:test m) \"tests containing\"\n    (+ (:pass m) (:fail m) (:error m)) \"assertions.\")\n  (println (:fail m) \"failures,\" (:error m) \"errors.\"))",
                                                :title "Dispatch method",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/cljs/test.cljs",
                                                :lines [346 349]}
                                               {:code "(defmethod report [::default :begin-test-ns] [m]\n  (println \"\\nTesting\" (name (:ns m))))",
                                                :title "Dispatch method",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/cljs/test.cljs",
                                                :lines [351 352]}
                                               {:code "(defmethod report [::default :end-test-ns] [m])",
                                                :title "Dispatch method",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/cljs/test.cljs",
                                                :lines [355]}
                                               {:code "(defmethod report [::default :begin-test-var] [m]\n  #_(println \":begin-test-var\" (testing-vars-str m)))",
                                                :title "Dispatch method",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/cljs/test.cljs",
                                                :lines [356 357]}
                                               {:code "(defmethod report [::default :end-test-var] [m])",
                                                :title "Dispatch method",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/cljs/test.cljs",
                                                :lines [358]}
                                               {:code "(defmethod report [::default :end-run-tests] [m])",
                                                :title "Dispatch method",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/cljs/test.cljs",
                                                :lines [359]}
                                               {:code "(defmethod report [::default :end-test-all-vars] [m])",
                                                :title "Dispatch method",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/cljs/test.cljs",
                                                :lines [360]}
                                               {:code "(defmethod report [::default :end-test-vars] [m])",
                                                :title "Dispatch method",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/cljs/test.cljs",
                                                :lines [361]}),
                               :full-name "cljs.test/report",
                               :clj-symbol "clojure.test/report",
                               :docstring "Generic reporting function, may be overridden to plug in\n   different report formats (e.g., TAP, JUnit).  Assertions such as\n   'is' call 'report' to indicate results.  The argument given to\n   'report' will be a map with a :type key."},
           "clojure.browser.dom/log-obj" {:ns "clojure.browser.dom",
                                          :name "log-obj",
                                          :type "function",
                                          :signature ["[obj]"],
                                          :source {:code "(defn log-obj [obj]\n  (.log js/console obj))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/cljs/clojure/browser/dom.cljs",
                                                   :lines [23 24]},
                                          :full-name "clojure.browser.dom/log-obj",
                                          :full-name-encode "clojure.browser.dom/log-obj",
                                          :history [["+" "0.0-927"]]},
           "cljs.nodejs/enable-util-print!" {:ns "cljs.nodejs",
                                             :name "enable-util-print!",
                                             :type "function",
                                             :signature ["[]"],
                                             :source {:code "(defn enable-util-print! []\n  (set! *print-newline* false)\n  (set! *print-fn*\n    (fn [& args]\n      (.apply (.-log js/console) js/console (into-array args))))\n  (set! *print-err-fn*\n    (fn [& args]\n      (.apply (.-error js/console) js/console (into-array args))))\n  nil)",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.7.228",
                                                      :filename "src/main/cljs/cljs/nodejs.cljs",
                                                      :lines [18 26]},
                                             :full-name "cljs.nodejs/enable-util-print!",
                                             :full-name-encode "cljs.nodejs/enable-util-printBANG",
                                             :history [["+"
                                                        "0.0-2156"]]},
           "cljs.repl.browser/repl-env*" {:ns "cljs.repl.browser",
                                          :name "repl-env*",
                                          :type "function",
                                          :signature ["[{:keys [output-dir], :as opts}]"],
                                          :source {:code "(defn repl-env*\n  [{:keys [output-dir] :as opts}]\n  (merge (BrowserEnv.)\n    {:host \"localhost\"\n     :port 9000\n     :working-dir (->> [\".repl\" (util/clojurescript-version)]\n                       (remove empty?) (string/join \"-\"))\n     :serve-static true\n     :static-dir (cond-> [\".\" \"out/\"] output-dir (conj output-dir))\n     :preloaded-libs []\n     :optimizations :simple\n     :src \"src/\"\n     :browser-state (atom {:return-value-fn nil\n                          :client-js nil})\n     :ordering (agent {:expecting nil :fns {}})\n     :es (Executors/newFixedThreadPool 16)\n     :server-state\n     (atom\n       {:socket nil\n        :connection nil\n        :promised-conn nil})}\n    opts))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/clojure/cljs/repl/browser.clj",
                                                   :lines [286 307]},
                                          :full-name "cljs.repl.browser/repl-env*",
                                          :full-name-encode "cljs.repl.browser/repl-envSTAR",
                                          :history [["+" "0.0-3030"]]},
           "cljs.repl/source" {:description "Prints the source code for the given symbol `name`, if it can find it.  This\nrequires that the symbol resolve to a Var defined in a namespace for which the\n.cljs is in the classpath.",
                               :ns "cljs.repl",
                               :name "source",
                               :signature ["[name]"],
                               :history [["+" "0.0-2985"]],
                               :type "macro",
                               :related ["cljs.repl/doc"],
                               :full-name-encode "cljs.repl/source",
                               :source {:code "(defmacro source\n  [n]\n  `(println ~(or (source-fn &env n) (str \"Source not found\"))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/clojure/cljs/repl.cljc",
                                        :lines [1242 1249]},
                               :examples [{:id "94c94c",
                                           :content "```clj\n(source comment)\n;; Prints:\n;; (defmacro comment\n;;   \"Ignores body, yields nil\"\n;;   {:added \"1.0\"}\n;;   [& body])\n;;\n;;=> nil\n```"}],
                               :full-name "cljs.repl/source",
                               :clj-symbol "clojure.repl/source",
                               :docstring "Prints the source code for the given symbol, if it can find it.\nThis requires that the symbol resolve to a Var defined in a\nnamespace for which the .cljs is in the classpath.\n\nExample: (source filter)"},
           "cljs.core/for" {:description "List comprehension.\n\nTakes a vector of one or more binding-form/collection-expr pairs, each followed\nby zero or more modifiers, and yields a lazy sequence of evaluations of expr.\n\nCollections are iterated in a nested fashion, rightmost fastest, and nested\ncoll-exprs can refer to bindings created in prior binding-forms. Supported\nmodifiers are: `:let [binding-form expr ...]`, `:while test`, `:when test`.",
                            :ns "cljs.core",
                            :name "for",
                            :signature ["[seq-exprs body-expr]"],
                            :history [["+" "0.0-927"]],
                            :type "macro",
                            :related ["cljs.core/doseq"
                                      "cljs.core/doall"
                                      "special/recur"],
                            :full-name-encode "cljs.core/for",
                            :source {:code "(core/defmacro for\n  [seq-exprs body-expr]\n  (assert-args for\n    (vector? seq-exprs) \"a vector for its binding\"\n    (even? (count seq-exprs)) \"an even number of forms in binding vector\")\n  (core/let [to-groups (core/fn [seq-exprs]\n                         (reduce (core/fn [groups [k v]]\n                                   (if (core/keyword? k)\n                                     (conj (pop groups) (conj (peek groups) [k v]))\n                                     (conj groups [k v])))\n                           [] (partition 2 seq-exprs)))\n             err (core/fn [& msg] (throw (ex-info (apply core/str msg) {})))\n             emit-bind (core/fn emit-bind [[[bind expr & mod-pairs]\n                                       & [[_ next-expr] :as next-groups]]]\n                         (core/let [giter (gensym \"iter__\")\n                                    gxs (gensym \"s__\")\n                                    do-mod (core/fn do-mod [[[k v :as pair] & etc]]\n                                             (core/cond\n                                               (= k :let) `(let ~v ~(do-mod etc))\n                                               (= k :while) `(when ~v ~(do-mod etc))\n                                               (= k :when) `(if ~v\n                                                              ~(do-mod etc)\n                                                              (recur (rest ~gxs)))\n                                               (core/keyword? k) (err \"Invalid 'for' keyword \" k)\n                                               next-groups\n                                               `(let [iterys# ~(emit-bind next-groups)\n                                                      fs# (seq (iterys# ~next-expr))]\n                                                  (if fs#\n                                                    (concat fs# (~giter (rest ~gxs)))\n                                                    (recur (rest ~gxs))))\n                                               :else `(cons ~body-expr\n                                                        (~giter (rest ~gxs)))))]\n                           (if next-groups\n                             #_ \"not the inner-most loop\"\n                             `(fn ~giter [~gxs]\n                                (lazy-seq\n                                  (loop [~gxs ~gxs]\n                                    (when-first [~bind ~gxs]\n                                      ~(do-mod mod-pairs)))))\n                             #_\"inner-most loop\"\n                             (core/let [gi (gensym \"i__\")\n                                        gb (gensym \"b__\")\n                                        do-cmod (core/fn do-cmod [[[k v :as pair] & etc]]\n                                                  (core/cond\n                                                    (= k :let) `(let ~v ~(do-cmod etc))\n                                                    (= k :while) `(when ~v ~(do-cmod etc))\n                                                    (= k :when) `(if ~v\n                                                                   ~(do-cmod etc)\n                                                                   (recur\n                                                                     (unchecked-inc ~gi)))\n                                                    (core/keyword? k)\n                                                    (err \"Invalid 'for' keyword \" k)\n                                                    :else\n                                                    `(do (chunk-append ~gb ~body-expr)\n                                                         (recur (unchecked-inc ~gi)))))]\n                               `(fn ~giter [~gxs]\n                                  (lazy-seq\n                                    (loop [~gxs ~gxs]\n                                      (when-let [~gxs (seq ~gxs)]\n                                        (if (chunked-seq? ~gxs)\n                                          (let [c# ^not-native (chunk-first ~gxs)\n                                                size# (count c#)\n                                                ~gb (chunk-buffer size#)]\n                                            (if (coercive-boolean\n                                                  (loop [~gi 0]\n                                                    (if (< ~gi size#)\n                                                      (let [~bind (-nth c# ~gi)]\n                                                        ~(do-cmod mod-pairs))\n                                                      true)))\n                                              (chunk-cons\n                                                (chunk ~gb)\n                                                (~giter (chunk-rest ~gxs)))\n                                              (chunk-cons (chunk ~gb) nil)))\n                                          (let [~bind (first ~gxs)]\n                                            ~(do-mod mod-pairs)))))))))))]\n    `(let [iter# ~(emit-bind (to-groups seq-exprs))]\n       (iter# ~(second seq-exprs)))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.7.228",
                                     :filename "src/main/clojure/cljs/core.cljc",
                                     :lines [2177 2262]},
                            :full-name "cljs.core/for",
                            :clj-symbol "clojure.core/for",
                            :docstring "List comprehension. Takes a vector of one or more\n binding-form/collection-expr pairs, each followed by zero or more\n modifiers, and yields a lazy sequence of evaluations of expr.\n Collections are iterated in a nested fashion, rightmost fastest,\n and nested coll-exprs can refer to bindings created in prior\n binding-forms.  Supported modifiers are: :let [binding-form expr ...],\n :while test, :when test.\n\n(take 100 (for [x (range 100000000) y (range 1000000) :while (< y x)]  [x y]))"},
           "syntax/inst-literal" {:description "An instant in time, using a [RFC-3339] formatted string. Creates a JavaScript [Date] object.\n\nThe format is `#inst \"yyyy-mm-ddThh:mm:ss\"`, where:\n\n- `yyyy-mm-dd` = date\n- `hh:mm:ss` = time (optional)\n\nAppend `Z` to denote UTC, or `-hh:mm` to denote exact UTC offset.\n\n[Date]:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date\n[RFC-3339]:http://www.ietf.org/rfc/rfc3339.txt",
                                  :ns "syntax",
                                  :name "inst-literal",
                                  :history [["+" "0.0-1211"]],
                                  :type "tagged literal",
                                  :related ["cljs.core/time"
                                            "syntax/tagged-literal"],
                                  :full-name-encode "syntax/inst-literal",
                                  :extra-sources ({:code "   (defn read-inst\n     [form]\n     (when-not (string? form)\n       (throw (RuntimeException. \"Instance literal expects a string for its timestamp.\")))\n     (try\n       (inst/read-instant-date form)\n       (catch Throwable e\n         (throw (RuntimeException. (.getMessage e)))))))",
                                                   :title "Reader code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/clojure/cljs/tagged_literals.cljc",
                                                   :lines [36 43]}
                                                  {:code "(def ^:dynamic *cljs-data-readers*\n  {'queue read-queue\n   'uuid  read-uuid\n   'inst  read-inst\n   'js    read-js})",
                                                   :title "Reader table",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/clojure/cljs/tagged_literals.cljc",
                                                   :lines [79 83]}),
                                  :usage ["#inst \"yyyy-mm-dd\""
                                          "#inst \"yyyy-mm-ddThh:mm:ss\""
                                          "#inst \"yyyy-mm-ddThh:mm:ssZ\""
                                          "#inst \"yyyy-mm-ddThh:mm:ss-hh:mm\""],
                                  :examples [{:id "47d8ee",
                                              :content "```clj\n#inst \"1985-04-12\"\n;;=> #inst \"1985-04-12T00:00:00.000-00:00\"\n\n#inst \"1985-04-12T23:20:50.52Z\"\n;;=> #inst \"1985-04-12T23:20:50.520-00:00\"\n```\n\nDates can be tested for order, as native JavaScript Dates can:\n\n```clj\n(def a #inst \"2005-01-20\")\n(def b #inst \"2005-01-21\")\n\n(< a b)\n;;=> true\n```\n\nDates can be tested for equality, unlike JavaScript Dates.  (ClojureScript\nextends `js/Date` type with `IEquiv` protocol to allow this.)\n\n```clj\n(def a #inst \"2012-06-13\")\n(def b #inst \"2012-06-13\")\n\n(= a b)\n;;=> true\n```"}],
                                  :edn-doc "https://github.com/edn-format/edn#inst-rfc-3339-format",
                                  :full-name "syntax/inst-literal",
                                  :display "#inst literal",
                                  :clj-doc "https://github.com/clojure/clojure/blob/clojure-1.6.0/src/clj/clojure/core.clj#L6947"},
           "cljs.js/debug-prn" {:ns "cljs.js",
                                :name "debug-prn",
                                :signature ["[& args]"],
                                :history [["+" "1.7.10"]
                                          ["-" "1.7.48"]],
                                :type "function",
                                :full-name-encode "cljs.js/debug-prn",
                                :source {:code "(defn debug-prn\n  [& args]\n  (binding [*print-fn* *print-err-fn*]\n    (apply println args)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.28",
                                         :filename "src/main/cljs/cljs/js.cljs",
                                         :lines [25 28]},
                                :full-name "cljs.js/debug-prn",
                                :removed {:in "1.7.48",
                                          :last-seen "1.7.28"}},
           "cljs.core/unchecked-multiply-int" {:return-type number,
                                               :ns "cljs.core",
                                               :name "unchecked-multiply-int",
                                               :signature ["[]"
                                                           "[x]"
                                                           "[x y]"
                                                           "[x y & more]"],
                                               :history [["+"
                                                          "0.0-1798"]],
                                               :type "function/macro",
                                               :full-name-encode "cljs.core/unchecked-multiply-int",
                                               :source {:code "(defn ^number unchecked-multiply-int\n  ([] 1)\n  ([x] x)\n  ([x y] (cljs.core/unchecked-multiply-int x y))\n  ([x y & more] (reduce unchecked-multiply-int (cljs.core/unchecked-multiply-int x y) more)))",
                                                        :title "Function code",
                                                        :repo "clojurescript",
                                                        :tag "r1.7.228",
                                                        :filename "src/main/cljs/cljs/core.cljs",
                                                        :lines [2420
                                                                2425]},
                                               :extra-sources [{:code "(core/defmacro ^::ana/numeric unchecked-multiply-int\n  ([& xs] `(* ~@xs)))",
                                                                :title "Macro code",
                                                                :repo "clojurescript",
                                                                :tag "r1.7.228",
                                                                :filename "src/main/clojure/cljs/core.cljc",
                                                                :lines [998
                                                                        999]}],
                                               :full-name "cljs.core/unchecked-multiply-int",
                                               :clj-symbol "clojure.core/unchecked-multiply-int",
                                               :docstring "Returns the product of nums. (*) returns 1."},
           "cljs.core/cond->" {:description "Takes an expression and a set of test/form pairs. Threads `expr` (via `->`)\nthrough each form for which the corresponding test expression is true.\n\nNote that, unlike `cond` branching, `cond->` threading does not short circuit\nafter the first true test expression.",
                               :ns "cljs.core",
                               :name "cond->",
                               :signature ["[expr & clauses]"],
                               :history [["+" "0.0-1798"]],
                               :type "macro",
                               :related ["cljs.core/->"
                                         "cljs.core/->>"
                                         "cljs.core/cond->>"
                                         "cljs.core/cond"],
                               :full-name-encode "cljs.core/cond-GT",
                               :source {:code "(defmacro cond->\n  [expr & clauses]\n  (assert (even? (count clauses)))\n  (let [g (gensym)\n        pstep (fn [[test step]] `(if ~test (-> ~g ~step) ~g))]\n    `(let [~g ~expr\n           ~@(interleave (repeat g) (map pstep (partition 2 clauses)))]\n       ~g)))",
                                        :title "Source code",
                                        :repo "clojure",
                                        :tag "clojure-1.7.0",
                                        :filename "src/clj/clojure/core.clj",
                                        :lines [7233 7245]},
                               :examples [{:id "f08338",
                                           :content "```clj\n(def a 12)\n(cond-> a\n  (> a 10) (str \" is greater than 10\")\n  (< a 20) (str \" and less than 20\"))\n;;=> \"12 is greater than 10 and less than 20\"\n```"}],
                               :full-name "cljs.core/cond->",
                               :clj-symbol "clojure.core/cond->",
                               :docstring "Takes an expression and a set of test/form pairs. Threads expr (via ->)\nthrough each form for which the corresponding test\nexpression is true. Note that, unlike cond branching, cond-> threading does\nnot short circuit after the first true test expression."},
           "cljs.repl/load-stream" {:ns "cljs.repl",
                                    :name "load-stream",
                                    :type "function",
                                    :signature ["[repl-env filename res]"],
                                    :source {:code "(defn load-stream [repl-env filename res]\n  (let [env (ana/empty-env)]\n    (with-open [rdr (io/reader res)]\n      (doseq [form (ana/forms-seq* rdr filename)]\n        (let [env (assoc env :ns (ana/get-namespace ana/*cljs-ns*))]\n          (evaluate-form repl-env env filename form))))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/clojure/cljs/repl.cljc",
                                             :lines [499 504]},
                                    :full-name "cljs.repl/load-stream",
                                    :full-name-encode "cljs.repl/load-stream",
                                    :history [["+" "0.0-927"]]},
           "cljs.core/instance?" {:description "Returns true if `o` is an instance of type `t`, false otherwise.",
                                  :return-type boolean,
                                  :ns "cljs.core",
                                  :name "instance?",
                                  :signature ["[t o]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function/macro",
                                  :related ["cljs.core/type"],
                                  :full-name-encode "cljs.core/instanceQMARK",
                                  :source {:code "(defn ^boolean instance?\n  [c x]\n  (cljs.core/instance? c x))",
                                           :title "Function code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [904 908]},
                                  :extra-sources [{:code "(core/defmacro instance? [c x]\n  ;; Google Closure warns about some references to RegExp, so\n  ;; (instance? RegExp ...) needs to be inlined, but the expansion\n  ;; should preserve the order of argument evaluation.\n  (bool-expr (if (clojure.core/symbol? c)\n               (core/list 'js* \"(~{} instanceof ~{})\" x c)\n               `(let [c# ~c x# ~x]\n                  (~'js* \"(~{} instanceof ~{})\" x# c#)))))",
                                                   :title "Macro code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/clojure/cljs/core.cljc",
                                                   :lines [924 931]}],
                                  :full-name "cljs.core/instance?",
                                  :clj-symbol "clojure.core/instance?",
                                  :docstring "Evaluates x and tests if it is an instance of the type\nc. Returns true or false"},
           "cljs.core/ValSeq" {:ns "cljs.core",
                               :name "ValSeq",
                               :signature ["[mseq _meta]"],
                               :history [["+" "0.0-1820"]],
                               :type "type",
                               :full-name-encode "cljs.core/ValSeq",
                               :source {:code "(deftype ValSeq [^not-native mseq _meta]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  IMeta\n  (-meta [coll] _meta)\n\n  IWithMeta\n  (-with-meta [coll new-meta] (ValSeq. mseq new-meta))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ICollection\n  (-conj [coll o]\n    (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY List) _meta))\n\n  IHash\n  (-hash [coll] (hash-ordered-coll coll))\n\n  ISeq\n  (-first [coll]\n    (let [^not-native me (-first mseq)]\n      (-val me)))\n\n  (-rest [coll]\n    (let [nseq (if (satisfies? INext mseq)\n                 (-next mseq)\n                 (next mseq))]\n      (if-not (nil? nseq)\n        (ValSeq. nseq _meta)\n        ())))\n\n  INext\n  (-next [coll]\n    (let [nseq (if (satisfies? INext mseq)\n                 (-next mseq)\n                 (next mseq))]\n      (when-not (nil? nseq)\n        (ValSeq. nseq _meta))))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [7856 7909]},
                               :full-name "cljs.core/ValSeq",
                               :clj-symbol "clojure.lang/ValSeq"},
           "clojure.browser.repl/print-queue" {:ns "clojure.browser.repl",
                                               :name "print-queue",
                                               :type "var",
                                               :source {:code "(def print-queue (array))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.7.228",
                                                        :filename "src/main/cljs/clojure/browser/repl.cljs",
                                                        :lines [31]},
                                               :full-name "clojure.browser.repl/print-queue",
                                               :full-name-encode "clojure.browser.repl/print-queue",
                                               :history [["+"
                                                          "1.7.48"]]},
           "clojure.string/last-index-of" {:ns "clojure.string",
                                           :name "last-index-of",
                                           :signature ["[s value]"
                                                       "[s value from-index]"],
                                           :history [["+" "1.7.145"]],
                                           :type "function",
                                           :full-name-encode "clojure.string/last-index-of",
                                           :source {:code "(defn last-index-of\n  ([s value]\n   (let [result (.lastIndexOf s value)]\n     (if (neg? result)\n       nil\n       result)))\n  ([s value from-index]\n   (let [result (.lastIndexOf s value from-index)]\n     (if (neg? result)\n       nil\n       result))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.7.228",
                                                    :filename "src/main/cljs/clojure/string.cljs",
                                                    :lines [231 243]},
                                           :full-name "clojure.string/last-index-of",
                                           :docstring "Return last index of value (string or char) in s, optionally\nsearching backward from from-index or nil if not found."},
           "cljs.core/rseq" {:description "Returns a sequence of the items in `coll` in reverse order in constant time.\n\nReturns nil if `coll` is empty.\n\n`coll` must be a vector or a sorted-map.",
                             :return-type seq,
                             :ns "cljs.core",
                             :name "rseq",
                             :signature ["[coll]"],
                             :history [["+" "0.0-1211"]],
                             :type "function",
                             :related ["cljs.core/reverse"],
                             :full-name-encode "cljs.core/rseq",
                             :source {:code "(defn ^seq rseq\n  [rev]\n  (-rseq rev))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [2828 2832]},
                             :full-name "cljs.core/rseq",
                             :clj-symbol "clojure.core/rseq",
                             :docstring "Returns, in constant time, a seq of the items in rev (which\ncan be a vector or sorted-map), in reverse order. If rev is empty returns nil"},
           "cljs.core/PersistentVector.EMPTY_NODE" {:moved "cljs.core/PersistentVector.EMPTY-NODE",
                                                    :ns "cljs.core",
                                                    :name "PersistentVector.EMPTY_NODE",
                                                    :history [["+"
                                                               "0.0-1006"]
                                                              ["-"
                                                               "0.0-2301"]],
                                                    :parent-type "PersistentVector",
                                                    :type "var",
                                                    :full-name-encode "cljs.core/PersistentVectorDOTEMPTY_NODE",
                                                    :source {:code "(set! cljs.core.PersistentVector.EMPTY_NODE (VectorNode. nil (make-array 32)))",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r2280",
                                                             :filename "src/cljs/cljs/core.cljs",
                                                             :lines [3667]},
                                                    :full-name "cljs.core/PersistentVector.EMPTY_NODE",
                                                    :removed {:in "0.0-2301",
                                                              :last-seen "0.0-2280"}},
           "cljs.repl/repl-prompt" {:ns "cljs.repl",
                                    :name "repl-prompt",
                                    :type "function",
                                    :signature ["[]"],
                                    :source {:code "(defn repl-prompt []\n  (print (str ana/*cljs-ns* \"=> \")))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/clojure/cljs/repl.cljc",
                                             :lines [733 734]},
                                    :full-name "cljs.repl/repl-prompt",
                                    :full-name-encode "cljs.repl/repl-prompt",
                                    :history [["+" "0.0-2911"]]},
           "cljs.reader/read-comment" {:ns "cljs.reader",
                                       :name "read-comment",
                                       :type "var",
                                       :source {:code "(def read-comment skip-line)",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/cljs/reader.cljs",
                                                :lines [268]},
                                       :full-name "cljs.reader/read-comment",
                                       :full-name-encode "cljs.reader/read-comment",
                                       :history [["+" "0.0-927"]]},
           "cljs.repl.rhino/eval-result" {:ns "cljs.repl.rhino",
                                          :name "eval-result",
                                          :type "multimethod",
                                          :source {:code "(defmulti eval-result class)",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/clojure/cljs/repl/rhino.clj",
                                                   :lines [61]},
                                          :full-name "cljs.repl.rhino/eval-result",
                                          :full-name-encode "cljs.repl.rhino/eval-result",
                                          :extra-sources ({:code "(defmethod eval-result :default [r]\n  (.toString r))",
                                                           :title "Dispatch method",
                                                           :repo "clojurescript",
                                                           :tag "r1.7.228",
                                                           :filename "src/main/clojure/cljs/repl/rhino.clj",
                                                           :lines [63
                                                                   64]}
                                                          {:code "(defmethod eval-result nil [_] \"\")",
                                                           :title "Dispatch method",
                                                           :repo "clojurescript",
                                                           :tag "r1.7.228",
                                                           :filename "src/main/clojure/cljs/repl/rhino.clj",
                                                           :lines [66]}
                                                          {:code "(defmethod eval-result Undefined [_] \"\")",
                                                           :title "Dispatch method",
                                                           :repo "clojurescript",
                                                           :tag "r1.7.228",
                                                           :filename "src/main/clojure/cljs/repl/rhino.clj",
                                                           :lines [68]}),
                                          :history [["+" "0.0-927"]]},
           "cljs.repl.node/socket" {:ns "cljs.repl.node",
                                    :name "socket",
                                    :type "function",
                                    :signature ["[host port]"],
                                    :source {:code "(defn socket [host port]\n  (let [socket (Socket. host port)\n        in     (io/reader socket)\n        out    (io/writer socket)]\n    {:socket socket :in in :out out}))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/clojure/cljs/repl/node.clj",
                                             :lines [24 28]},
                                    :full-name "cljs.repl.node/socket",
                                    :full-name-encode "cljs.repl.node/socket",
                                    :history [["+" "0.0-2629"]]},
           "cljs.core/ITransientMap" {:ns "cljs.core",
                                      :name "ITransientMap",
                                      :history [["+" "0.0-1211"]],
                                      :type "protocol",
                                      :full-name-encode "cljs.core/ITransientMap",
                                      :source {:code "(defprotocol ITransientMap\n  \"Protocol for adding mapping functionality to transient collections.\"\n  (^clj -dissoc! [tcoll key]\n    \"Returns a new transient collection of tcoll without the mapping for key.\"))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [685 688]},
                                      :methods [{:name "-dissoc!",
                                                 :signature ["[tcoll key]"],
                                                 :docstring "Returns a new transient collection of tcoll without the mapping for key."}],
                                      :full-name "cljs.core/ITransientMap",
                                      :clj-symbol "clojure.lang/ITransientMap",
                                      :docstring "Protocol for adding mapping functionality to transient collections."},
           "cljs.core/*loaded-libs*" {:ns "cljs.core",
                                      :name "*loaded-libs*",
                                      :type "dynamic var",
                                      :source {:code "(defonce\n  ^{:dynamic true\n    :jsdoc [\"@type {*}\"]}\n  *loaded-libs* nil)",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [130 133]},
                                      :full-name "cljs.core/*loaded-libs*",
                                      :full-name-encode "cljs.core/STARloaded-libsSTAR",
                                      :history [["+" "0.0-2655"]]},
           "syntax/whitespace" {:description "The amount of whitespace between syntax forms does not affect syntax\ncorrectness.  Elements are free to be aligned as desired.\n\nIndentation is conventionally two spaces, no tab characters.\n[More indentation conventions here](https://github.com/bbatsov/clojure-style-guide#source-code-layout--organization)\n\nWhitespace around collection delimiters is not required:\n\n```clj\n(a(b(c)))\n```\n\n```clj\n#js[1 2 3]\n#inst\"2015-10-12\"\n```\n\nA [comma][doc:syntax/comma] is considered whitespace:\n\n```clj\n[1, 2, 3]\n{:foo 1, :bar 2}\n```",
                                :ns "syntax",
                                :name "whitespace",
                                :history [["+" "0.0-927"]],
                                :type "special character",
                                :related ["syntax/comma"],
                                :full-name-encode "syntax/whitespace",
                                :edn-doc "https://github.com/edn-format/edn#general-considerations",
                                :full-name "syntax/whitespace",
                                :display "whitespace",
                                :clj-doc "https://github.com/edn-format/edn#general-considerations"},
           "cljs.reader/read-number" {:ns "cljs.reader",
                                      :name "read-number",
                                      :type "function",
                                      :signature ["[reader initch]"],
                                      :source {:code "(defn read-number\n  [reader initch]\n  (loop [buffer (gstring/StringBuffer. initch)\n         ch (read-char reader)]\n    (if (or (nil? ch) (whitespace? ch) (macros ch))\n      (do\n        (unread reader ch)\n        (let [s (.toString buffer)]\n          (or (match-number s)\n              (reader-error reader \"Invalid number format [\" s \"]\"))))\n      (recur (do (.append buffer ch) buffer) (read-char reader)))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/cljs/cljs/reader.cljs",
                                               :lines [281 291]},
                                      :full-name "cljs.reader/read-number",
                                      :full-name-encode "cljs.reader/read-number",
                                      :history [["+" "0.0-927"]]},
           "cljs.core/ILookup" {:ns "cljs.core",
                                :name "ILookup",
                                :history [["+" "0.0-927"]],
                                :type "protocol",
                                :full-name-encode "cljs.core/ILookup",
                                :source {:code "(defprotocol ILookup\n  \"Protocol for looking up a value in a data structure.\"\n  (-lookup [o k] [o k not-found]\n    \"Use k to look up a value in o. If not-found is supplied and k is not\n     a valid value that can be used for look up, not-found is returned.\"))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [509 513]},
                                :methods [{:name "-lookup",
                                           :signature ["[o k]"
                                                       "[o k not-found]"],
                                           :docstring "Use k to look up a value in o. If not-found is supplied and k is not\n     a valid value that can be used for look up, not-found is returned."}],
                                :full-name "cljs.core/ILookup",
                                :clj-symbol "clojure.lang/ILookup",
                                :docstring "Protocol for looking up a value in a data structure."},
           "cljs.core/when" {:description "Evaluates `test`. If logical true, evaluates `body` in an implicit `do`.\n\n`when` is often used instead of `if` for conditions that do not have an \"else\".",
                             :ns "cljs.core",
                             :name "when",
                             :signature ["[test & body]"],
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :related ["cljs.core/when-not"
                                       "cljs.core/when-let"
                                       "special/if"],
                             :full-name-encode "cljs.core/when",
                             :source {:code "(defmacro when\n  [test & body]\n  (list 'if test (cons 'do body)))",
                                      :title "Source code",
                                      :repo "clojure",
                                      :tag "clojure-1.7.0",
                                      :filename "src/clj/clojure/core.clj",
                                      :lines [477 481]},
                             :full-name "cljs.core/when",
                             :clj-symbol "clojure.core/when",
                             :docstring "Evaluates test. If logical true, evaluates body in an implicit do."},
           "cljs.core/ArrayNodeSeq" {:ns "cljs.core",
                                     :name "ArrayNodeSeq",
                                     :type "type",
                                     :signature ["[meta nodes i s __hash]"],
                                     :source {:code "(deftype ArrayNodeSeq [meta nodes i s ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IWithMeta\n  (-with-meta [coll meta] (ArrayNodeSeq. meta nodes i s __hash))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY List) meta))\n\n  ISequential\n  ISeq\n  (-first [coll] (first s))\n  (-rest  [coll] (create-array-node-seq nil nodes i (next s)))\n\n  ISeqable\n  (-seq [this] this)\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/cljs/cljs/core.cljs",
                                              :lines [6740 6775]},
                                     :full-name "cljs.core/ArrayNodeSeq",
                                     :full-name-encode "cljs.core/ArrayNodeSeq",
                                     :history [["+" "0.0-1211"]]},
           "cljs.core/list?" {:description "Returns true if `x` is a list, false otherwise.",
                              :return-type boolean,
                              :ns "cljs.core",
                              :name "list?",
                              :signature ["[x]"],
                              :history [["+" "0.0-1211"]],
                              :type "function",
                              :related ["cljs.core/seq?"
                                        "cljs.core/sequential?"
                                        "cljs.core/coll?"],
                              :full-name-encode "cljs.core/listQMARK",
                              :source {:code "(defn ^boolean list?\n  [x]\n  (satisfies? IList x))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [2756 2759]},
                              :full-name "cljs.core/list?",
                              :clj-symbol "clojure.core/list?",
                              :docstring "Returns true if x implements IList"},
           "cljs.core/val" {:description "Returns the value in the map entry.",
                            :ns "cljs.core",
                            :name "val",
                            :signature ["[map-entry]"],
                            :history [["+" "0.0-1211"]],
                            :type "function",
                            :related ["cljs.core/vals"],
                            :full-name-encode "cljs.core/val",
                            :source {:code "(defn val\n  [map-entry]\n  (-val map-entry))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.7.228",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [7919 7922]},
                            :full-name "cljs.core/val",
                            :clj-symbol "clojure.core/val",
                            :docstring "Returns the value in the map entry."},
           "clojure.browser.dom/set-value" {:ns "clojure.browser.dom",
                                            :name "set-value",
                                            :signature ["[e v]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "clojure.browser.dom/set-value",
                                            :source {:code "(defn set-value\n  [e v]\n  (set-properties e {\"value\" v}))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.7.228",
                                                     :filename "src/main/cljs/clojure/browser/dom.cljs",
                                                     :lines [142 145]},
                                            :full-name "clojure.browser.dom/set-value",
                                            :docstring "Set the value property for an element."},
           "cljs.repl.browser/read-get" {:moved "cljs.repl.server/read-get",
                                         :ns "cljs.repl.browser",
                                         :name "read-get",
                                         :signature ["[line rdr]"],
                                         :history [["+" "0.0-927"]
                                                   ["-" "0.0-1503"]],
                                         :type "function",
                                         :full-name-encode "cljs.repl.browser/read-get",
                                         :source {:code "(defn read-get [line rdr]\n  (let [[_ path _] (str/split line #\" \")\n        headers (parse-headers (read-headers rdr))]\n    {:method :get\n     :path path\n     :headers headers}))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1450",
                                                  :filename "src/clj/cljs/repl/browser.clj",
                                                  :lines [154 159]},
                                         :full-name "cljs.repl.browser/read-get",
                                         :removed {:in "0.0-1503",
                                                   :last-seen "0.0-1450"}},
           "cljs.core/BitmapIndexedNode" {:ns "cljs.core",
                                          :name "BitmapIndexedNode",
                                          :signature ["[edit bitmap arr]"],
                                          :history [["+" "0.0-1211"]],
                                          :type "type",
                                          :full-name-encode "cljs.core/BitmapIndexedNode",
                                          :source {:code "(deftype BitmapIndexedNode [edit ^:mutable bitmap ^:mutable arr]\n  Object\n  (inode-assoc [inode shift hash key val added-leaf?]\n    (let [bit (bitpos hash shift)\n          idx (bitmap-indexed-node-index bitmap bit)]\n      (if (zero? (bit-and bitmap bit))\n        (let [n (bit-count bitmap)]\n          (if (>= n 16)\n            (let [nodes (make-array 32)\n                  jdx   (mask hash shift)]\n              (aset nodes jdx (.inode-assoc (.-EMPTY BitmapIndexedNode) (+ shift 5) hash key val added-leaf?))\n              (loop [i 0 j 0]\n                (if (< i 32)\n                  (if (zero? (bit-and (bit-shift-right-zero-fill bitmap i) 1))\n                    (recur (inc i) j)\n                    (do (aset nodes i\n                              (if-not (nil? (aget arr j))\n                                (.inode-assoc (.-EMPTY BitmapIndexedNode)\n                                              (+ shift 5) (cljs.core/hash (aget arr j)) (aget arr j) (aget arr (inc j)) added-leaf?)\n                                (aget arr (inc j))))\n                        (recur (inc i) (+ j 2))))))\n              (ArrayNode. nil (inc n) nodes))\n            (let [new-arr (make-array (* 2 (inc n)))]\n              (array-copy arr 0 new-arr 0 (* 2 idx))\n              (aset new-arr (* 2 idx) key)\n              (aset new-arr (inc (* 2 idx)) val)\n              (array-copy arr (* 2 idx) new-arr (* 2 (inc idx)) (* 2 (- n idx)))\n              (set! (.-val added-leaf?) true)\n              (BitmapIndexedNode. nil (bit-or bitmap bit) new-arr))))\n        (let [key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil)\n                (let [n (.inode-assoc val-or-node (+ shift 5) hash key val added-leaf?)]\n                  (if (identical? n val-or-node)\n                    inode\n                    (BitmapIndexedNode. nil bitmap (clone-and-set arr (inc (* 2 idx)) n))))\n\n                (key-test key key-or-nil)\n                (if (identical? val val-or-node)\n                  inode\n                  (BitmapIndexedNode. nil bitmap (clone-and-set arr (inc (* 2 idx)) val)))\n\n                :else\n                (do (set! (.-val added-leaf?) true)\n                    (BitmapIndexedNode. nil bitmap\n                                        (clone-and-set arr (* 2 idx) nil (inc (* 2 idx))\n                                                       (create-node (+ shift 5) key-or-nil val-or-node hash key val)))))))))\n\n  (inode-without [inode shift hash key]\n    (let [bit (bitpos hash shift)]\n      (if (zero? (bit-and bitmap bit))\n        inode\n        (let [idx         (bitmap-indexed-node-index bitmap bit)\n              key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil)\n                (let [n (.inode-without val-or-node (+ shift 5) hash key)]\n                  (cond (identical? n val-or-node) inode\n                        (not (nil? n)) (BitmapIndexedNode. nil bitmap (clone-and-set arr (inc (* 2 idx)) n))\n                        (== bitmap bit) nil\n                        :else (BitmapIndexedNode. nil (bit-xor bitmap bit) (remove-pair arr idx))))\n                (key-test key key-or-nil)\n                (BitmapIndexedNode. nil (bit-xor bitmap bit) (remove-pair arr idx))\n                :else inode)))))\n\n  (inode-lookup [inode shift hash key not-found]\n    (let [bit (bitpos hash shift)]\n      (if (zero? (bit-and bitmap bit))\n        not-found\n        (let [idx         (bitmap-indexed-node-index bitmap bit)\n              key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil)  (.inode-lookup val-or-node (+ shift 5) hash key not-found)\n                (key-test key key-or-nil) val-or-node\n                :else not-found)))))\n\n  (inode-find [inode shift hash key not-found]\n    (let [bit (bitpos hash shift)]\n      (if (zero? (bit-and bitmap bit))\n        not-found\n        (let [idx         (bitmap-indexed-node-index bitmap bit)\n              key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil) (.inode-find val-or-node (+ shift 5) hash key not-found)\n                (key-test key key-or-nil)          [key-or-nil val-or-node]\n                :else not-found)))))\n\n  (inode-seq [inode]\n    (create-inode-seq arr))\n\n  (ensure-editable [inode e]\n    (if (identical? e edit)\n      inode\n      (let [n       (bit-count bitmap)\n            new-arr (make-array (if (neg? n) 4 (* 2 (inc n))))]\n        (array-copy arr 0 new-arr 0 (* 2 n))\n        (BitmapIndexedNode. e bitmap new-arr))))\n\n  (edit-and-remove-pair [inode e bit i]\n    (if (== bitmap bit)\n      nil\n      (let [editable (.ensure-editable inode e)\n            earr     (.-arr editable)\n            len      (alength earr)]\n        (set! (.-bitmap editable) (bit-xor bit (.-bitmap editable)))\n        (array-copy earr (* 2 (inc i))\n                    earr (* 2 i)\n                    (- len (* 2 (inc i))))\n        (aset earr (- len 2) nil)\n        (aset earr (dec len) nil)\n        editable)))\n\n  (inode-assoc! [inode edit shift hash key val added-leaf?]\n    (let [bit (bitpos hash shift)\n          idx (bitmap-indexed-node-index bitmap bit)]\n      (if (zero? (bit-and bitmap bit))\n        (let [n (bit-count bitmap)]\n          (cond\n            (< (* 2 n) (alength arr))\n            (let [editable (.ensure-editable inode edit)\n                  earr     (.-arr editable)]\n              (set! (.-val added-leaf?) true)\n              (array-copy-downward earr (* 2 idx)\n                                   earr (* 2 (inc idx))\n                                   (* 2 (- n idx)))\n              (aset earr (* 2 idx) key)\n              (aset earr (inc (* 2 idx)) val)\n              (set! (.-bitmap editable) (bit-or (.-bitmap editable) bit))\n              editable)\n\n            (>= n 16)\n            (let [nodes (make-array 32)\n                  jdx   (mask hash shift)]\n              (aset nodes jdx (.inode-assoc! (.-EMPTY BitmapIndexedNode) edit (+ shift 5) hash key val added-leaf?))\n              (loop [i 0 j 0]\n                (if (< i 32)\n                  (if (zero? (bit-and (bit-shift-right-zero-fill bitmap i) 1))\n                    (recur (inc i) j)\n                    (do (aset nodes i\n                              (if-not (nil? (aget arr j))\n                                (.inode-assoc! (.-EMPTY BitmapIndexedNode)\n                                               edit (+ shift 5) (cljs.core/hash (aget arr j)) (aget arr j) (aget arr (inc j)) added-leaf?)\n                                (aget arr (inc j))))\n                        (recur (inc i) (+ j 2))))))\n              (ArrayNode. edit (inc n) nodes))\n\n            :else\n            (let [new-arr (make-array (* 2 (+ n 4)))]\n              (array-copy arr 0 new-arr 0 (* 2 idx))\n              (aset new-arr (* 2 idx) key)\n              (aset new-arr (inc (* 2 idx)) val)\n              (array-copy arr (* 2 idx) new-arr (* 2 (inc idx)) (* 2 (- n idx)))\n              (set! (.-val added-leaf?) true)\n              (let [editable (.ensure-editable inode edit)]\n                (set! (.-arr editable) new-arr)\n                (set! (.-bitmap editable) (bit-or (.-bitmap editable) bit))\n                editable))))\n        (let [key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil)\n                (let [n (.inode-assoc! val-or-node edit (+ shift 5) hash key val added-leaf?)]\n                  (if (identical? n val-or-node)\n                    inode\n                    (edit-and-set inode edit (inc (* 2 idx)) n)))\n\n                (key-test key key-or-nil)\n                (if (identical? val val-or-node)\n                  inode\n                  (edit-and-set inode edit (inc (* 2 idx)) val))\n\n                :else\n                (do (set! (.-val added-leaf?) true)\n                    (edit-and-set inode edit (* 2 idx) nil (inc (* 2 idx))\n                                  (create-node edit (+ shift 5) key-or-nil val-or-node hash key val))))))))\n\n  (inode-without! [inode edit shift hash key removed-leaf?]\n    (let [bit (bitpos hash shift)]\n      (if (zero? (bit-and bitmap bit))\n        inode\n        (let [idx         (bitmap-indexed-node-index bitmap bit)\n              key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil)\n                (let [n (.inode-without! val-or-node edit (+ shift 5) hash key removed-leaf?)]\n                  (cond (identical? n val-or-node) inode\n                        (not (nil? n)) (edit-and-set inode edit (inc (* 2 idx)) n)\n                        (== bitmap bit) nil\n                        :else (.edit-and-remove-pair inode edit bit idx)))\n                (key-test key key-or-nil)\n                (do (aset removed-leaf? 0 true)\n                    (.edit-and-remove-pair inode edit bit idx))\n                :else inode)))))\n\n  (kv-reduce [inode f init]\n    (inode-kv-reduce arr f init))\n\n  IIterable\n  (-iterator [coll]\n    (NodeIterator. arr 0 nil nil)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/cljs/cljs/core.cljs",
                                                   :lines [6212 6410]},
                                          :full-name "cljs.core/BitmapIndexedNode",
                                          :clj-symbol "clojure.lang/BitmapIndexedNode"},
           "cljs.repl.node/close-socket" {:ns "cljs.repl.node",
                                          :name "close-socket",
                                          :type "function",
                                          :signature ["[s]"],
                                          :source {:code "(defn close-socket [s]\n  (.close (:in s))\n  (.close (:out s))\n  (.close (:socket s)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/clojure/cljs/repl/node.clj",
                                                   :lines [30 33]},
                                          :full-name "cljs.repl.node/close-socket",
                                          :full-name-encode "cljs.repl.node/close-socket",
                                          :history [["+" "0.0-2629"]]},
           "cljs.reader/read-past" {:ns "cljs.reader",
                                    :name "read-past",
                                    :signature ["[pred rdr]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.reader/read-past",
                                    :source {:code "(defn read-past\n  [pred rdr]\n  (loop [ch (read-char rdr)]\n    (if (pred ch)\n      (recur (read-char rdr))\n      ch)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/reader.cljs",
                                             :lines [216 223]},
                                    :full-name "cljs.reader/read-past",
                                    :docstring "Read until first character that doesn't match pred, returning\nchar."},
           "cljs.repl.browser/load-javascript" {:ns "cljs.repl.browser",
                                                :name "load-javascript",
                                                :signature ["[repl-env provides url]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.repl.browser/load-javascript",
                                                :source {:code "(defn load-javascript\n  [repl-env provides url]\n  (browser-eval (slurp url)))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1.7.228",
                                                         :filename "src/main/clojure/cljs/repl/browser.clj",
                                                         :lines [202
                                                                 209]},
                                                :full-name "cljs.repl.browser/load-javascript",
                                                :docstring "Accepts a REPL environment, a list of namespaces, and a URL for a\nJavaScript file which contains the implementation for the list of\nnamespaces. Will load the JavaScript file into the REPL environment\nif any of the namespaces have not already been loaded from the\nClojureScript REPL."},
           "cljs.core/to-array" {:ns "cljs.core",
                                 :name "to-array",
                                 :signature ["[s]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/to-array",
                                 :source {:code "(defn to-array\n  [s]\n  (let [ary (array)]\n    (loop [s s]\n      (if (seq s)\n        (do (. ary push (first s))\n            (recur (next s)))\n        ary))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [3212 3220]},
                                 :full-name "cljs.core/to-array",
                                 :clj-symbol "clojure.core/to-array",
                                 :docstring "Naive impl of to-array as a start."},
           "cljs.core/interpose" {:description "Returns a lazy seq of the elements of `coll` separated by `sep`.",
                                  :ns "cljs.core",
                                  :name "interpose",
                                  :signature ["[sep coll]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/interleave"
                                            "clojure.string/join"],
                                  :full-name-encode "cljs.core/interpose",
                                  :source {:code "(defn interpose\n  ([sep]\n    (fn [rf]\n      (let [started (volatile! false)]\n        (fn\n          ([] (rf))\n          ([result] (rf result))\n          ([result input]\n            (if @started\n              (let [sepr (rf result sep)]\n                (if (reduced? sepr)\n                  sepr\n                  (rf sepr input)))\n              (do\n                (vreset! started true)\n                (rf result input))))))))\n  ([sep coll] (drop 1 (interleave (repeat sep) coll))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [4380 4398]},
                                  :full-name "cljs.core/interpose",
                                  :clj-symbol "clojure.core/interpose",
                                  :docstring "Returns a lazy seq of the elements of coll separated by sep.\nReturns a stateful transducer when no collection is provided."},
           "cljs.core/IMapEntry" {:ns "cljs.core",
                                  :name "IMapEntry",
                                  :history [["+" "0.0-1211"]],
                                  :type "protocol",
                                  :full-name-encode "cljs.core/IMapEntry",
                                  :source {:code "(defprotocol IMapEntry\n  \"Protocol for examining a map entry.\"\n  (-key [coll]\n    \"Returns the key of the map entry.\")\n  (-val [coll]\n    \"Returns the value of the map entry.\"))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [530 535]},
                                  :methods [{:name "-key",
                                             :signature ["[coll]"],
                                             :docstring "Returns the key of the map entry."}
                                            {:name "-val",
                                             :signature ["[coll]"],
                                             :docstring "Returns the value of the map entry."}],
                                  :full-name "cljs.core/IMapEntry",
                                  :clj-symbol "clojure.lang/IMapEntry",
                                  :docstring "Protocol for examining a map entry."},
           "clojure.browser.net/ICrossPageChannel" {:ns "clojure.browser.net",
                                                    :name "ICrossPageChannel",
                                                    :type "protocol",
                                                    :full-name-encode "clojure.browser.net/ICrossPageChannel",
                                                    :source {:code "(defprotocol ICrossPageChannel\n  (register-service [this service-name fn] [this service-name fn encode-json?]))",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r1.7.228",
                                                             :filename "src/main/cljs/clojure/browser/net.cljs",
                                                             :lines [86
                                                                     87]},
                                                    :methods [{:name "register-service",
                                                               :signature ["[this service-name fn]"
                                                                           "[this service-name fn encode-json?]"],
                                                               :docstring nil}],
                                                    :full-name "clojure.browser.net/ICrossPageChannel",
                                                    :history [["+"
                                                               "0.0-927"]]},
           "special/finally" {:description "`finally` should be the last form inside of a `try` expression. It is optional.\n\n`finally` clauses are always evaluated for their side effects whether there was\nan error or not, but they are never the return value of a `try` expression.",
                              :ns "special",
                              :name "finally",
                              :signature ["[expr*]"],
                              :history [["+" "0.0-927"]],
                              :type "special form",
                              :related ["special/try"
                                        "special/catch"
                                        "special/throw"],
                              :full-name-encode "special/finally",
                              :source {:code "(defmethod parse 'try\n  [op env [_ & body :as form] name _]\n  (let [catchenv (update-in env [:context] #(if (= :expr %) :return %))\n        catch? (every-pred seq? #(= (first %) 'catch))\n        default? (every-pred catch? #(= (second %) :default))\n        finally? (every-pred seq? #(= (first %) 'finally))\n\n        {:keys [body cblocks dblock fblock]}\n        (loop [parser {:state :start :forms body\n                       :body [] :cblocks [] :dblock nil :fblock nil}]\n          (if (seq? (:forms parser))\n            (let [[form & forms*] (:forms parser)\n                  parser* (assoc parser :forms forms*)]\n              (case (:state parser)\n                :start (cond\n                         (catch? form) (recur (assoc parser :state :catches))\n                         (finally? form) (recur (assoc parser :state :finally))\n                         :else (recur (update-in parser* [:body] conj form)))\n                :catches (cond\n                           (default? form) (recur (assoc parser* :dblock form :state :finally))\n                           (catch? form) (recur (update-in parser* [:cblocks] conj form))\n                           (finally? form) (recur (assoc parser :state :finally))\n                           :else (throw (error env \"Invalid try form\")))\n                :finally (recur (assoc parser* :fblock form :state :done))\n                :done (throw (error env \"Unexpected form after finally\"))))\n            parser))\n\n        finally (when (seq fblock)\n                  (analyze (assoc env :context :statement) `(do ~@(rest fblock))))\n        e (when (or (seq cblocks) dblock) (gensym \"e\"))\n        default (if-let [[_ _ name & cb] dblock]\n                  `(cljs.core/let [~name ~e] ~@cb)\n                  `(throw ~e))\n        cblock (if (seq cblocks)\n                 `(cljs.core/cond\n                   ~@(mapcat\n                      (fn [[_ type name & cb]]\n                        (when name (assert (not (namespace name)) \"Can't qualify symbol in catch\"))\n                        `[(cljs.core/instance? ~type ~e)\n                          (cljs.core/let [~name ~e] ~@cb)])\n                      cblocks)\n                   :else ~default)\n                 default)\n        locals (:locals catchenv)\n        locals (if e\n                 (assoc locals e\n                        {:name e\n                         :line (get-line e env)\n                         :column (get-col e env)})\n                 locals)\n        catch (when cblock\n                (analyze (assoc catchenv :locals locals) cblock))\n        try (analyze (if (or e finally) catchenv env) `(do ~@body))]\n\n    {:env env :op :try :form form\n     :try try\n     :finally finally\n     :name e\n     :catch catch\n     :children [try catch finally]}))",
                                       :title "Parser code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/clojure/cljs/analyzer.cljc",
                                       :lines [1008 1067]},
                              :full-name "special/finally",
                              :clj-symbol "clojure.core/finally",
                              :docstring "catch-clause => (catch classname name expr*)\nfinally-clause => (finally expr*)\nCatches and handles JavaScript exceptions."},
           "cljs.core/Cons" {:ns "cljs.core",
                             :name "Cons",
                             :signature ["[meta first rest __hash]"],
                             :history [["+" "0.0-927"]],
                             :type "type",
                             :full-name-encode "cljs.core/Cons",
                             :source {:code "(deftype Cons [meta first rest ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  IList\n\n  ICloneable\n  (-clone [_] (Cons. meta first rest __hash))\n\n  IWithMeta\n  (-with-meta [coll meta] (Cons. meta first rest __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ASeq\n  ISeq\n  (-first [coll] first)\n  (-rest [coll] (if (nil? rest) () rest))\n\n  INext\n  (-next [coll]\n    (if (nil? rest) nil (seq rest)))\n\n  ICollection\n  (-conj [coll o] (Cons. nil o coll nil))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY List) meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  ISeqable\n  (-seq [coll] coll)\n  \n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [2858 2903]},
                             :full-name "cljs.core/Cons",
                             :clj-symbol "clojure.lang/Cons"},
           "cljs.core/re-find" {:description "Returns the first regex match, if any, of `s` to `re`, using `re.exec(s)`.\n\nReturns a vector, containing first the matching substring, then any capturing\ngroups if the regular expression contains capturing groups.",
                                :ns "cljs.core",
                                :name "re-find",
                                :signature ["[re s]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/re-find",
                                :source {:code "(defn re-find\n  [re s]\n  (if (string? s)\n    (let [matches (.exec re s)]\n      (when-not (nil? matches)\n        (if (== (count matches) 1)\n          (first matches)\n          (vec matches))))\n    (throw (js/TypeError. \"re-find must match against a string.\"))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [8710 8722]},
                                :full-name "cljs.core/re-find",
                                :clj-symbol "clojure.core/re-find",
                                :docstring "Returns the first regex match, if any, of s to re, using\nre.exec(s). Returns a vector, containing first the matching\nsubstring, then any capturing groups if the regular expression contains\ncapturing groups."},
           "cljs.core/IMeta" {:ns "cljs.core",
                              :name "IMeta",
                              :history [["+" "0.0-927"]],
                              :type "protocol",
                              :full-name-encode "cljs.core/IMeta",
                              :source {:code "(defprotocol IMeta\n  \"Protocol for accessing the metadata of an object.\"\n  (^clj-or-nil -meta [o]\n    \"Returns the metadata of object o.\"))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [565 568]},
                              :methods [{:name "-meta",
                                         :signature ["[o]"],
                                         :docstring "Returns the metadata of object o."}],
                              :full-name "cljs.core/IMeta",
                              :clj-symbol "clojure.lang/IMeta",
                              :docstring "Protocol for accessing the metadata of an object."},
           "cljs.core/js-str" {:description "Convert `s` to string using JavaScript's coercion behavior.\n\nEquivalent to `''+s` in JavaScript.",
                               :ns "cljs.core",
                               :name "js-str",
                               :signature ["[s]"],
                               :history [["+" "0.0-2341"]],
                               :type "macro",
                               :related ["cljs.core/str"],
                               :full-name-encode "cljs.core/js-str",
                               :source {:code "(core/defmacro js-str [s]\n  (core/list 'js* \"''+~{}\" s))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/clojure/cljs/core.cljc",
                                        :lines [2597 2598]},
                               :examples [{:id "e92009",
                                           :content "```clj\n(js-str 23)\n;;=> \"23\"\n\n(js-str #js {:foo 1})\n;;=> \"[Object object]\"\n```"}],
                               :full-name "cljs.core/js-str"},
           "cljs.repl/repl*" {:ns "cljs.repl",
                              :name "repl*",
                              :type "function",
                              :signature ["[repl-env {:keys [init need-prompt quit-prompt prompt flush read eval print caught reader print-no-newline source-map-inline wrap repl-requires compiler-env bind-err], :or {caught repl-caught, quit-prompt repl-quit-prompt, eval eval-cljs, print-no-newline print, flush flush, read repl-read, bind-err true, print println, source-map-inline true, prompt repl-prompt, repl-requires (quote [[cljs.repl :refer-macros [source doc find-doc apropos dir pst]] [cljs.pprint :refer [pprint] :refer-macros [pp]]]), reader (fn* [] (readers/source-logging-push-back-reader (PushbackReader. (io/reader *in*)) 1 \"NO_SOURCE_FILE\")), need-prompt (fn* [] (if (readers/indexing-reader? *in*) (== (readers/get-column-number *in*) 1) (identity true)))}, :as opts}]"],
                              :source {:code "(defn repl*\n  [repl-env {:keys [init need-prompt quit-prompt prompt flush read eval print caught reader\n                    print-no-newline source-map-inline wrap repl-requires\n                    compiler-env bind-err]\n             :or {need-prompt #(if (readers/indexing-reader? *in*)\n                                (== (readers/get-column-number *in*) 1)\n                                (identity true))\n                  quit-prompt repl-quit-prompt\n                  prompt repl-prompt\n                  flush flush\n                  read repl-read\n                  eval eval-cljs\n                  print println\n                  caught repl-caught\n                  reader #(readers/source-logging-push-back-reader\n                           (PushbackReader. (io/reader *in*))\n                           1 \"NO_SOURCE_FILE\")\n                  print-no-newline print\n                  source-map-inline true\n                  repl-requires '[[cljs.repl :refer-macros [source doc find-doc apropos dir pst]]\n                                  [cljs.pprint :refer [pprint] :refer-macros [pp]]]\n                  bind-err true}\n             :as opts}]\n  (let [repl-opts (-repl-options repl-env)\n        repl-requires (into repl-requires (:repl-requires repl-opts))\n        {:keys [analyze-path repl-verbose warn-on-undeclared special-fns static-fns] :as opts\n         :or   {warn-on-undeclared true}}\n        (merge\n          {:cache-analysis true :source-map true :def-emits-var true}\n          (cljsc/add-implicit-options\n            (merge-with (fn [a b] (if (nil? b) a b))\n              repl-opts\n              opts\n              {:prompt prompt\n               :need-prompt need-prompt\n               :flush flush\n               :read read\n               :print print\n               :caught caught\n               :reader reader\n               :print-no-newline print-no-newline\n               :source-map-inline source-map-inline})))\n        done? (atom false)]\n    (env/with-compiler-env (or compiler-env (env/default-compiler-env opts))\n     (when (:source-map opts)\n       (.start (Thread. (bound-fn [] (read-source-map \"cljs/core.aot.js\")))))\n     (binding [*err* (if bind-err\n                       (cond-> *out*\n                         (not (instance? PrintWriter *out*)) (PrintWriter.))\n                       *err*)\n               ana/*cljs-ns* ana/*cljs-ns*\n               *cljs-verbose* repl-verbose\n               ana/*cljs-warnings*\n               (let [warnings (opts :warnings true)]\n                 (merge\n                   ana/*cljs-warnings*\n                   (if (or (true? warnings)\n                         (false? warnings))\n                     (zipmap (keys ana/*cljs-warnings*) (repeat warnings))\n                     warnings)\n                   (zipmap\n                     [:unprovided :undeclared-var\n                      :undeclared-ns :undeclared-ns-form]\n                     (repeat (if (false? warnings)\n                               false\n                               warn-on-undeclared)))))\n               ana/*cljs-static-fns* static-fns\n               *repl-opts* opts]\n       (let [env {:context :expr :locals {}}\n             special-fns (merge default-special-fns special-fns)\n             is-special-fn? (set (keys special-fns))\n             request-prompt (Object.)\n             request-exit (Object.)\n             opts (comp/with-core-cljs opts\n                    (fn []\n                      (try\n                        (if-let [merge-opts (:merge-opts (-setup repl-env opts))]\n                          (merge opts merge-opts)\n                          opts)\n                        (catch Throwable e\n                          (caught e repl-env opts)\n                          opts))))\n             opts (if (or (:libs opts) (:foreign-libs opts))\n                    (let [opts (cljsc/process-js-modules opts)]\n                      (swap! env/*compiler* assoc :js-dependency-index (deps/js-dependency-index opts))\n                      opts)\n                    opts)\n             init (or init\n                      #(evaluate-form repl-env env \"<cljs repl>\"\n                         (with-meta\n                           `(~'ns ~'cljs.user\n                              (:require ~@repl-requires))\n                           {:line 1 :column 1})\n                         identity opts))\n             read-eval-print\n             (fn []\n               (let [input (binding [*ns* (create-ns ana/*cljs-ns*)\n                                     reader/resolve-symbol ana/resolve-symbol\n                                     reader/*data-readers* tags/*cljs-data-readers*\n                                     reader/*alias-map*\n                                     (apply merge\n                                       ((juxt :requires :require-macros)\n                                         (ana/get-namespace ana/*cljs-ns*)))]\n                             (read request-prompt request-exit))]\n                 (or ({request-exit request-exit\n                       :cljs/quit request-exit\n                       request-prompt request-prompt} input)\n                   (if (and (seq? input) (is-special-fn? (first input)))\n                     (do\n                       ((get special-fns (first input)) repl-env env input opts)\n                       (print nil))\n                     (let [value (eval repl-env env input opts)]\n                       (print value))))))]\n         (comp/with-core-cljs opts\n           (fn []\n             (binding [*repl-opts* opts]\n               (try\n                 (when analyze-path\n                   (if (vector? analyze-path)\n                     (run! #(analyze-source % opts) analyze-path)\n                     (analyze-source analyze-path opts)))\n                 (init)\n                 (catch Throwable e\n                   (caught e repl-env opts)))\n               (when-let [src (:watch opts)]\n                 (.start\n                   (Thread.\n                     ((ns-resolve 'clojure.core 'binding-conveyor-fn)\n                       (fn []\n                         (let [log-file (io/file (util/output-directory opts) \"watch.log\")]\n                           (err-out (println \"Watch compilation log available at:\" (str log-file)))\n                           (try\n                             (let [log-out (FileWriter. log-file)]\n                               (binding [*err* log-out\n                                         *out* log-out]\n                                 (cljsc/watch src (dissoc opts :watch)\n                                   env/*compiler* done?)))\n                             (catch Throwable e\n                               (caught e repl-env opts)))))))))\n               ;; let any setup async messages flush\n               (Thread/sleep 50)\n               (binding [*in* (if (true? (:source-map-inline opts))\n                                *in*\n                                (reader))]\n                 (quit-prompt)\n                 (prompt)\n                 (flush)\n                 (loop []\n                   (when-not\n                     (try\n                       (identical? (read-eval-print) request-exit)\n                       (catch Throwable e\n                         (caught e repl-env opts)\n                         nil))\n                     (when (need-prompt)\n                       (prompt)\n                       (flush))\n                     (recur))))))))\n       (reset! done? true)\n       (-tear-down repl-env)))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/clojure/cljs/repl.cljc",
                                       :lines [752 911]},
                              :full-name "cljs.repl/repl*",
                              :full-name-encode "cljs.repl/replSTAR",
                              :history [["+" "0.0-2629"]]},
           "cljs.test/are" {:ns "cljs.test",
                            :name "are",
                            :signature ["[argv expr & args]"],
                            :history [["+" "0.0-2629"]],
                            :type "macro",
                            :full-name-encode "cljs.test/are",
                            :source {:code "(defmacro are\n  [argv expr & args]\n  (if (or\n        ;; (are [] true) is meaningless but ok\n        (and (empty? argv) (empty? args))\n        ;; Catch wrong number of args\n        (and (pos? (count argv))\n          (pos? (count args))\n          (zero? (mod (count args) (count argv)))))\n    `(clojure.template/do-template ~argv (is ~expr) ~@args)\n    (throw (IllegalArgumentException. \"The number of args doesn't match are's argv.\"))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.7.228",
                                     :filename "src/main/cljs/cljs/test.clj",
                                     :lines [167 189]},
                            :full-name "cljs.test/are",
                            :clj-symbol "clojure.test/are",
                            :docstring "Checks multiple assertions with a template expression.\nSee clojure.template/do-template for an explanation of\ntemplates.\n\nExample: (are [x y] (= x y)  \n              2 (+ 1 1)\n              4 (* 2 2))\nExpands to: \n         (do (is (= 2 (+ 1 1)))\n             (is (= 4 (* 2 2))))\n\nNote: This breaks some reporting features, such as line numbers."},
           "cljs.core/RangeIterator" {:ns "cljs.core",
                                      :name "RangeIterator",
                                      :type "type",
                                      :signature ["[i end step]"],
                                      :source {:code "(deftype RangeIterator [^:mutable i end step]\n  Object\n  (hasNext [_]\n    (if (pos? step)\n      (< i end)\n      (> i end)))\n  (next [_]\n    (let [ret i]\n      (set! i (+ i step))\n      ret)))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [8429 8438]},
                                      :full-name "cljs.core/RangeIterator",
                                      :full-name-encode "cljs.core/RangeIterator",
                                      :history [["+" "0.0-2371"]]},
           "cljs.core/iterator" {:ns "cljs.core",
                                 :name "iterator",
                                 :signature ["[coll]"],
                                 :history [["+" "0.0-2268"]
                                           ["-" "0.0-2371"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/iterator",
                                 :source {:code "(defn iterator [coll]\n  (Iterator. (seq coll)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2356",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [4870 4871]},
                                 :full-name "cljs.core/iterator",
                                 :removed {:in "0.0-2371",
                                           :last-seen "0.0-2356"}},
           "cljs.core/assoc-in" {:description "Associates a value in a nested associative structure, where `ks` is a sequence\nof keys and `v` is the new value. Returns a new nested structure.\n\nIf any levels do not exist, hash-maps will be created.",
                                 :ns "cljs.core",
                                 :name "assoc-in",
                                 :signature ["[m [k & ks] v]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :related ["cljs.core/assoc"
                                           "cljs.core/update-in"
                                           "cljs.core/get-in"],
                                 :full-name-encode "cljs.core/assoc-in",
                                 :source {:code "(defn assoc-in\n  [m [k & ks] v]\n  (if ks\n    (assoc m k (assoc-in (get m k) ks v))\n    (assoc m k v)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [4568 4575]},
                                 :examples [{:id "e76f20",
                                             :content "```clj\n(def users [{:name \"James\" :age 26}\n            {:name \"John\" :age 43}])\n```\n\nUpdate the age of the second (index 1) user:\n\n```clj\n(assoc-in users [1 :age] 44)\n;;=> [{:name \"James\", :age 26}\n;;    {:name \"John\", :age 44}]\n```\n\nInsert the password of the second (index 1) user:\n\n```clj\n(assoc-in users [1 :password] \"nhoJ\")\n;;=> [{:name \"James\", :age 26}\n;;    {:password \"nhoJ\", :name \"John\", :age 43}]\n```"}],
                                 :full-name "cljs.core/assoc-in",
                                 :clj-symbol "clojure.core/assoc-in",
                                 :docstring "Associates a value in a nested associative structure, where ks is a\nsequence of keys and v is the new value and returns a new nested structure.\nIf any levels do not exist, hash-maps will be created."},
           "special/letfn*" {:ns "special",
                             :name "letfn*",
                             :type "special form",
                             :source {:code "(defmethod parse 'letfn*\n  [op env [_ bindings & exprs :as form] name _]\n  (when-not (and (vector? bindings) (even? (count bindings)))\n    (throw (error env \"bindings must be vector of even number of elements\")))\n  (let [n->fexpr (into {} (map (juxt first second) (partition 2 bindings)))\n        names    (keys n->fexpr)\n        context  (:context env)\n        ;; first pass to collect information for recursive references\n        [meth-env bes]\n        (reduce (fn [[{:keys [locals] :as env} bes] n]\n                  (let [ret-tag (-> n meta :tag)\n                        fexpr (no-warn (analyze env (n->fexpr n)))\n                        be (cond->\n                             {:name n\n                              :fn-var true\n                              :line (get-line n env)\n                              :column (get-col n env)\n                              :local true\n                              :shadow (locals n)\n                              :variadic (:variadic fexpr)\n                              :max-fixed-arity (:max-fixed-arity fexpr)\n                              :method-params (map :params (:methods fexpr))}\n                             ret-tag (assoc :ret-tag ret-tag))]\n                    [(assoc-in env [:locals n] be)\n                     (conj bes be)]))\n                [env []] names)\n        meth-env (assoc meth-env :context :expr)\n        ;; the real pass\n        [meth-env bes]\n        (reduce (fn [[meth-env bes] {:keys [name shadow] :as be}]\n                  (let [env (assoc-in meth-env [:locals name] shadow)\n                        fexpr (analyze env (n->fexpr name))\n                        be' (assoc be\n                              :init fexpr\n                              :variadic (:variadic fexpr)\n                              :max-fixed-arity (:max-fixed-arity fexpr)\n                              :method-params (map :params (:methods fexpr)))]\n                    [(assoc-in env [:locals name] be')\n                     (conj bes be')]))\n          [meth-env []] bes)\n        expr (analyze (assoc meth-env :context (if (= :expr context) :return context)) `(do ~@exprs))]\n    {:env env :op :letfn :bindings bes :expr expr :form form\n     :children (conj (vec (map :init bes)) expr)}))",
                                      :title "Parser code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/clojure/cljs/analyzer.cljc",
                                      :lines [1355 1397]},
                             :full-name "special/letfn*",
                             :full-name-encode "special/letfnSTAR",
                             :history [["+" "0.0-1236"]]},
           "clojure.string/join" {:description "Returns a string of all elements in `coll`, as returned by `(seq coll)`,\nseparated by an optional separator.",
                                  :ns "clojure.string",
                                  :name "join",
                                  :signature ["[coll]"
                                              "[separator coll]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.string/join",
                                  :source {:code "(defn join\n  ([coll]\n   (loop [sb (StringBuffer.) coll (seq coll)]\n     (if-not (nil? coll)\n       (recur (. sb (append (str (first coll)))) (next coll))\n       (.toString sb))))\n  ([separator coll]\n   (loop [sb (StringBuffer.) coll (seq coll)]\n     (if-not (nil? coll)\n       (do\n         (. sb (append (str (first coll))))\n         (let [coll (next coll)]\n           (when-not (nil? coll)\n             (. sb (append separator)))\n           (recur sb coll)))\n       (.toString sb)))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/clojure/string.cljs",
                                           :lines [66 83]},
                                  :full-name "clojure.string/join",
                                  :clj-symbol "clojure.string/join",
                                  :docstring "Returns a string of all elements in coll, as returned by (seq coll),\nseparated by an optional separator."},
           "cljs.core/*unchecked-if*" {:ns "cljs.core",
                                       :name "*unchecked-if*",
                                       :type "var",
                                       :source {:code "(def *unchecked-if* false)",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/cljs/core.cljs",
                                                :lines [18]},
                                       :full-name "cljs.core/*unchecked-if*",
                                       :full-name-encode "cljs.core/STARunchecked-ifSTAR",
                                       :history [["+" "0.0-1211"]]},
           "cljs.build.api/output-unoptimized" {:ns "cljs.build.api",
                                                :name "output-unoptimized",
                                                :signature ["[opts & sources]"],
                                                :history [["+"
                                                           "0.0-3291"]],
                                                :type "function",
                                                :full-name-encode "cljs.build.api/output-unoptimized",
                                                :source {:code "(defn output-unoptimized\n  [opts & sources]\n  (apply closure/output-unoptimized opts sources))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1.7.228",
                                                         :filename "src/main/clojure/cljs/build/api.clj",
                                                         :lines [188
                                                                 196]},
                                                :full-name "cljs.build.api/output-unoptimized",
                                                :docstring "Ensure that all JavaScript source files are on disk (not in jars),\nwrite the goog deps file including only the libraries that are being\nused and write the deps file for the current project.\n\nThe deps file for the current project will include third-party\nlibraries."},
           "cljs.core/some?" {:description "Returns true if `x` is not nil, false otherwise.",
                              :return-type boolean,
                              :ns "cljs.core",
                              :name "some?",
                              :signature ["[x]"],
                              :history [["+" "0.0-2261"]],
                              :type "function",
                              :related ["cljs.core/true?"
                                        "cljs.core/nil?"],
                              :full-name-encode "cljs.core/someQMARK",
                              :source {:code "(defn ^boolean some?\n  [x] (not (nil? x)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [211 213]},
                              :full-name "cljs.core/some?",
                              :clj-symbol "clojure.core/some?",
                              :docstring "Returns true if x is not nil, false otherwise."},
           "cljs.core/seqable?" {:return-type boolean,
                                 :ns "cljs.core",
                                 :name "seqable?",
                                 :signature ["[s]"],
                                 :history [["+" "0.0-1211"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/seqableQMARK",
                                 :source {:code "(defn ^boolean seqable?\n  [s]\n  (satisfies? ISeqable s))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [2002 2005]},
                                 :full-name "cljs.core/seqable?",
                                 :docstring "Return true if s satisfies ISeqable"},
           "clojure.browser.repl/flush-print-queue!" {:ns "clojure.browser.repl",
                                                      :name "flush-print-queue!",
                                                      :type "function",
                                                      :signature ["[conn]"],
                                                      :source {:code "(defn flush-print-queue! [conn]\n  (doseq [str print-queue]\n    (net/transmit conn :print str))\n  (garray/clear print-queue))",
                                                               :title "Source code",
                                                               :repo "clojurescript",
                                                               :tag "r1.7.228",
                                                               :filename "src/main/cljs/clojure/browser/repl.cljs",
                                                               :lines [33
                                                                       36]},
                                                      :full-name "clojure.browser.repl/flush-print-queue!",
                                                      :full-name-encode "clojure.browser.repl/flush-print-queueBANG",
                                                      :history [["+"
                                                                 "1.7.48"]]},
           "clojure.zip/rights" {:ns "clojure.zip",
                                 :name "rights",
                                 :signature ["[loc]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "clojure.zip/rights",
                                 :source {:code "(defn rights\n  [loc]\n    (:r (loc 1)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/clojure/zip.cljs",
                                          :lines [92 95]},
                                 :full-name "clojure.zip/rights",
                                 :clj-symbol "clojure.zip/rights",
                                 :docstring "Returns a seq of the right siblings of this loc"},
           "cljs.core/split-at" {:description "Returns a vector of `[(take n coll) (drop n coll)]`.",
                                 :ns "cljs.core",
                                 :name "split-at",
                                 :signature ["[n coll]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :related ["cljs.core/split-with"
                                           "clojure.string/split"],
                                 :full-name-encode "cljs.core/split-at",
                                 :source {:code "(defn split-at\n  [n coll]\n  [(take n coll) (drop n coll)])",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [4340 4343]},
                                 :full-name "cljs.core/split-at",
                                 :clj-symbol "clojure.core/split-at",
                                 :docstring "Returns a vector of [(take n coll) (drop n coll)]"},
           "clojure.zip/append-child" {:ns "clojure.zip",
                                       :name "append-child",
                                       :signature ["[loc item]"],
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "clojure.zip/append-child",
                                       :source {:code "(defn append-child\n  [loc item]\n    (replace loc (make-node loc (node loc) (concat (children loc) [item]))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/clojure/zip.cljs",
                                                :lines [200 204]},
                                       :full-name "clojure.zip/append-child",
                                       :clj-symbol "clojure.zip/append-child",
                                       :docstring "Inserts the item as the rightmost child of the node at this loc,\nwithout moving"},
           "cljs.core/binding" {:description "binding => var-symbol init-expr\n\nCreates new bindings for the (already-existing) vars, with the\nsupplied initial values, executes the exprs in an implicit `do`, then\nre-establishes the bindings that existed before.\n\nThe new bindings are made in parallel (unlike `let`); all init-exprs are\nevaluated before the vars are bound to their new values.",
                                :ns "cljs.core",
                                :name "binding",
                                :signature ["[bindings & body]"],
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :related ["cljs.core/let"],
                                :full-name-encode "cljs.core/binding",
                                :source {:code "(core/defmacro binding\n  [bindings & body]\n  (core/let [names (take-nth 2 bindings)]\n    (cljs.analyzer/confirm-bindings &env names)\n    `(with-redefs ~bindings ~@body)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/clojure/cljs/core.cljc",
                                         :lines [2015 2026]},
                                :examples [{:id "7dd17f",
                                            :content "```clj\n(def ^:dynamic *foo* 1)\n\n(defn do-something []\n  (println *foo*))\n\n(binding [*foo* 2]\n  (do-something))\n;;=> prints 2\n\n*foo*\n;;=> 1\n```"}],
                                :full-name "cljs.core/binding",
                                :clj-symbol "clojure.core/binding",
                                :docstring "binding => var-symbol init-expr\n\nCreates new bindings for the (already-existing) vars, with the\nsupplied initial values, executes the exprs in an implicit do, then\nre-establishes the bindings that existed before.  The new bindings\nare made in parallel (unlike let); all init-exprs are evaluated\nbefore the vars are bound to their new values."},
           "cljs.test/get-current-env" {:ns "cljs.test",
                                        :name "get-current-env",
                                        :type "function",
                                        :signature ["[]"],
                                        :source {:code "(defn get-current-env []\n  (or *current-env* (empty-env)))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/cljs/cljs/test.cljs",
                                                 :lines [271 272]},
                                        :full-name "cljs.test/get-current-env",
                                        :full-name-encode "cljs.test/get-current-env",
                                        :history [["+" "0.0-2496"]]},
           "cljs.core/Set" {:ns "cljs.core",
                            :name "Set",
                            :signature ["[meta hash-map]"],
                            :history [["+" "0.0-927"]
                                      ["-" "0.0-1211"]],
                            :type "type",
                            :full-name-encode "cljs.core/Set",
                            :source {:code "(deftype Set [meta hash-map]\n  IWithMeta\n  (-with-meta [coll meta] (Set. meta hash-map))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll o]\n    (Set. meta (assoc hash-map o nil)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.Set/EMPTY meta))\n\n  IEquiv\n  (-equiv [coll other]\n    (and\n     (set? other)\n     (= (count coll) (count other))\n     (every? #(contains? coll %)\n             other)))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll] (keys hash-map))\n\n  ICounted\n  (-count [coll] (count (seq coll)))\n\n  ILookup\n  (-lookup [coll v]\n    (-lookup coll v nil))\n  (-lookup [coll v not-found]\n    (if (-contains-key? hash-map v)\n      v\n      not-found))\n\n  ISet\n  (-disjoin [coll v]\n    (Set. meta (dissoc hash-map v)))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1011",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [2659 2706]},
                            :full-name "cljs.core/Set",
                            :removed {:in "0.0-1211",
                                      :last-seen "0.0-1011"}},
           "cljs.core/sorted-map" {:description "Returns a new sorted map with supplied mappings.\n\n`keyvals` must be an even number of forms.",
                                   :ns "cljs.core",
                                   :name "sorted-map",
                                   :signature ["[& keyvals]"],
                                   :history [["+" "0.0-1211"]],
                                   :type "function",
                                   :related ["cljs.core/sorted-map-by"
                                             "cljs.core/subseq"
                                             "cljs.core/rsubseq"
                                             "cljs.core/sorted-set"
                                             "cljs.core/array-map"
                                             "cljs.core/hash-map"],
                                   :full-name-encode "cljs.core/sorted-map",
                                   :source {:code "(defn sorted-map\n  ([& keyvals]\n     (loop [in (seq keyvals) out (.-EMPTY PersistentTreeMap)]\n       (if in\n         (recur (nnext in) (assoc out (first in) (second in)))\n         out))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [7769 7776]},
                                   :full-name "cljs.core/sorted-map",
                                   :clj-symbol "clojure.core/sorted-map",
                                   :docstring "keyval => key val\nReturns a new sorted map with supplied mappings."},
           "cljs.reader/macro-terminating?" {:return-type boolean,
                                             :ns "cljs.reader",
                                             :name "macro-terminating?",
                                             :signature ["[ch]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.reader/macro-terminatingQMARK",
                                             :source {:code "(defn ^boolean macro-terminating? [ch]\n  (and (not (identical? ch \"#\"))\n       (not (identical? ch \\'))\n       (not (identical? ch \":\"))\n       (macros ch)))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.7.228",
                                                      :filename "src/main/cljs/cljs/reader.cljs",
                                                      :lines [73 77]},
                                             :full-name "cljs.reader/macro-terminating?"},
           "cljs.pprint/write" {:ns "cljs.pprint",
                                :name "write",
                                :signature ["[object & kw-args]"],
                                :history [["+" "0.0-3255"]],
                                :type "function",
                                :full-name-encode "cljs.pprint/write",
                                :source {:code "(defn write\n  [object & kw-args]\n  (let [options (merge {:stream true} (apply hash-map kw-args))]\n    ;;TODO rewrite this as a macro\n    (binding [cljs.pprint/*print-base* (:base options cljs.pprint/*print-base*)\n              ;;:case             *print-case*,\n              cljs.pprint/*print-circle* (:circle options cljs.pprint/*print-circle*)\n              ;;:escape           *print-escape*\n              ;;:gensym           *print-gensym*\n              cljs.core/*print-length* (:length options cljs.core/*print-length*)\n              cljs.core/*print-level* (:level options cljs.core/*print-level*)\n              cljs.pprint/*print-lines* (:lines options cljs.pprint/*print-lines*)\n              cljs.pprint/*print-miser-width* (:miser-width options cljs.pprint/*print-miser-width*)\n              cljs.pprint/*print-pprint-dispatch* (:dispatch options cljs.pprint/*print-pprint-dispatch*)\n              cljs.pprint/*print-pretty* (:pretty options cljs.pprint/*print-pretty*)\n              cljs.pprint/*print-radix* (:radix options cljs.pprint/*print-radix*)\n              cljs.core/*print-readably* (:readably options cljs.core/*print-readably*)\n              cljs.pprint/*print-right-margin* (:right-margin options cljs.pprint/*print-right-margin*)\n              cljs.pprint/*print-suppress-namespaces* (:suppress-namespaces options cljs.pprint/*print-suppress-namespaces*)]\n      ;;TODO enable printing base\n      #_[bindings (if (or (not (= *print-base* 10)) *print-radix*)\n                  {#'pr pr-with-base}\n                  {})]\n      (binding []\n        (let [sb (StringBuffer.)\n              optval (if (contains? options :stream)\n                       (:stream options)\n                       true)\n              base-writer (if (or (true? optval) (nil? optval))\n                            (StringBufferWriter. sb)\n                            optval)]\n          (if *print-pretty*\n            (with-pretty-writer base-writer\n                                (write-out object))\n            (binding [*out* base-writer]\n              (pr object)))\n          (if (true? optval)\n            (*print-fn* (str sb)))\n          (if (nil? optval)\n            (str sb)))))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/pprint.cljs",
                                         :lines [748 809]},
                                :full-name "cljs.pprint/write",
                                :clj-symbol "clojure.pprint/write",
                                :docstring "Write an object subject to the current bindings of the printer control variables.\nUse the kw-args argument to override individual variables for this call (and any\nrecursive calls). Returns the string result if :stream is nil or nil otherwise.\n\nThe following keyword arguments can be passed with values:\n  Keyword              Meaning                              Default value\n  :stream              Writer for output or nil             true (indicates *out*)\n  :base                Base to use for writing rationals    Current value of *print-base*\n  :circle*             If true, mark circular structures    Current value of *print-circle*\n  :length              Maximum elements to show in sublists Current value of *print-length*\n  :level               Maximum depth                        Current value of *print-level*\n  :lines*              Maximum lines of output              Current value of *print-lines*\n  :miser-width         Width to enter miser mode            Current value of *print-miser-width*\n  :dispatch            The pretty print dispatch function   Current value of *print-pprint-dispatch*\n  :pretty              If true, do pretty printing          Current value of *print-pretty*\n  :radix               If true, prepend a radix specifier   Current value of *print-radix*\n  :readably*           If true, print readably              Current value of *print-readably*\n  :right-margin        The column for the right margin      Current value of *print-right-margin*\n  :suppress-namespaces If true, no namespaces in symbols    Current value of *print-suppress-namespaces*\n\n  * = not yet supported\n"},
           "cljs.test/join-fixtures" {:ns "cljs.test",
                                      :name "join-fixtures",
                                      :signature ["[fixtures]"],
                                      :history [["+" "0.0-2496"]],
                                      :type "function",
                                      :full-name-encode "cljs.test/join-fixtures",
                                      :source {:code "(defn join-fixtures\n  [fixtures]\n  (reduce compose-fixtures default-fixture fixtures))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/cljs/cljs/test.cljs",
                                               :lines [504 510]},
                                      :full-name "cljs.test/join-fixtures",
                                      :clj-symbol "clojure.test/join-fixtures",
                                      :docstring "Composes a collection of fixtures, in order.  Always returns a valid\nfixture function, even if the collection is empty.\n\nNOTE: Incompatible with map fixtures."},
           "cljs.core/prefers" {:ns "cljs.core",
                                :name "prefers",
                                :signature ["[multifn]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/prefers",
                                :source {:code "(defn prefers\n  [multifn] (-prefers multifn))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [9825 9827]},
                                :full-name "cljs.core/prefers",
                                :clj-symbol "clojure.core/prefers",
                                :docstring "Given a multimethod, returns a map of preferred value -> set of other values"},
           "cljs.core/vary-meta" {:description "Returns an object of the same type and value as `obj`, with\n`(apply f (meta obj) args)` as its metadata.",
                                  :ns "cljs.core",
                                  :name "vary-meta",
                                  :signature ["[obj f & args]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/alter-meta!"
                                            "cljs.core/with-meta"],
                                  :full-name-encode "cljs.core/vary-meta",
                                  :source {:code "(defn vary-meta\n  ([obj f]\n   (with-meta obj (f (meta obj))))\n  ([obj f a]\n   (with-meta obj (f (meta obj) a)))\n  ([obj f a b]\n   (with-meta obj (f (meta obj) a b)))\n  ([obj f a b c]\n   (with-meta obj (f (meta obj) a b c)))\n  ([obj f a b c d]\n   (with-meta obj (f (meta obj) a b c d)))\n  ([obj f a b c d & args]\n   (with-meta obj (apply f (meta obj) a b c d args))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [3494 3508]},
                                  :examples [{:id "8cca62",
                                              :content "```clj\n(def a ^:foo [1 2 3])\n(def b (vary-meta a assoc :bar true))\n\n(= a b)\n;;=> true\n\n(meta a)\n;;=> {:foo true}\n\n(meta b)\n;;=> {:foo true, :bar true}\n```"}],
                                  :full-name "cljs.core/vary-meta",
                                  :clj-symbol "clojure.core/vary-meta",
                                  :docstring "Returns an object of the same type and value as obj, with\n(apply f (meta obj) args) as its metadata."},
           "cljs.core/unchecked-add" {:return-type number,
                                      :ns "cljs.core",
                                      :name "unchecked-add",
                                      :signature ["[]"
                                                  "[x]"
                                                  "[x y]"
                                                  "[x y & more]"],
                                      :history [["+" "0.0-1798"]],
                                      :type "function/macro",
                                      :full-name-encode "cljs.core/unchecked-add",
                                      :source {:code "(defn ^number unchecked-add\n  ([] 0)\n  ([x] x)\n  ([x y] (cljs.core/unchecked-add x y))\n  ([x y & more] (reduce unchecked-add (cljs.core/unchecked-add x y) more)))",
                                               :title "Function code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [2376 2381]},
                                      :extra-sources [{:code "(core/defmacro ^::ana/numeric unchecked-add\n  ([& xs] `(+ ~@xs)))",
                                                       :title "Macro code",
                                                       :repo "clojurescript",
                                                       :tag "r1.7.228",
                                                       :filename "src/main/clojure/cljs/core.cljc",
                                                       :lines [974
                                                               975]}],
                                      :full-name "cljs.core/unchecked-add",
                                      :clj-symbol "clojure.core/unchecked-add",
                                      :docstring "Returns the sum of nums. (+) returns 0."},
           "cljs.core/when-let" {:description "When `test` is logical true, evaluates `body` with the value of `test` bound to\n`x`.",
                                 :ns "cljs.core",
                                 :name "when-let",
                                 :signature ["[[x test] & body]"],
                                 :history [["+" "0.0-927"]],
                                 :type "macro",
                                 :related ["cljs.core/if-let"
                                           "cljs.core/when"
                                           "cljs.core/when-not"
                                           "special/if"
                                           "cljs.core/when-first"],
                                 :full-name-encode "cljs.core/when-let",
                                 :source {:code "(defmacro when-let\n  [bindings & body]\n  (assert-args\n     (vector? bindings) \"a vector for its binding\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n   (let [form (bindings 0) tst (bindings 1)]\n    `(let [temp# ~tst]\n       (when temp#\n         (let [~form temp#]\n           ~@body)))))",
                                          :title "Source code",
                                          :repo "clojure",
                                          :tag "clojure-1.7.0",
                                          :filename "src/clj/clojure/core.clj",
                                          :lines [1747 1760]},
                                 :full-name "cljs.core/when-let",
                                 :clj-symbol "clojure.core/when-let",
                                 :docstring "bindings => binding-form test\n\nWhen test is true, evaluates body with binding-form bound to the value of test"},
           "clojure.core.reducers/folder" {:ns "clojure.core.reducers",
                                           :name "folder",
                                           :signature ["[coll xf]"],
                                           :history [["+" "0.0-1236"]],
                                           :type "function",
                                           :full-name-encode "clojure.core.reducers/folder",
                                           :source {:code "(defn folder\n  ([coll xf]\n     (reify\n       cljs.core/IReduce\n       (-reduce [_ f1]\n         (-reduce coll (xf f1) (f1)))\n       (-reduce [_ f1 init]\n         (-reduce coll (xf f1) init))\n\n       CollFold\n       (coll-fold [_ n combinef reducef]\n         (coll-fold coll n combinef (xf reducef))))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.7.228",
                                                    :filename "src/main/cljs/clojure/core/reducers.cljs",
                                                    :lines [79 94]},
                                           :full-name "clojure.core.reducers/folder",
                                           :clj-symbol "clojure.core.reducers/folder",
                                           :docstring "Given a foldable collection, and a transformation function xf,\nreturns a foldable collection, where any supplied reducing\nfn will be transformed by xf. xf is a function of reducing fn to\nreducing fn."},
           "cljs.core/ASeq" {:ns "cljs.core",
                             :name "ASeq",
                             :history [["+" "0.0-1211"]],
                             :type "protocol",
                             :full-name-encode "cljs.core/ASeq",
                             :source {:code "(defprotocol ASeq\n  \"Marker protocol indicating an array sequence.\")",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [488 489]},
                             :full-name "cljs.core/ASeq",
                             :clj-symbol "clojure.lang/ASeq",
                             :docstring "Marker protocol indicating an array sequence."},
           "cljs.core/drop" {:description "Returns a lazy sequence of all but the first `n` items in `coll`.\n\nReturns a stateful transducer when no collection is provided.",
                             :ns "cljs.core",
                             :name "drop",
                             :signature ["[n]" "[n coll]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/take"
                                       "cljs.core/drop-last"
                                       "cljs.core/drop-while"
                                       "cljs.core/nthnext"
                                       "cljs.core/nthrest"],
                             :full-name-encode "cljs.core/drop",
                             :source {:code "(defn drop\n  ([n]\n   {:pre [(number? n)]}\n     (fn [rf]\n       (let [na (volatile! n)]\n         (fn\n           ([] (rf))\n           ([result] (rf result))\n           ([result input]\n              (let [n @na]\n                (vswap! na dec)\n                (if (pos? n)\n                  result\n                  (rf result input))))))))\n  ([n coll]\n   {:pre [(number? n)]}\n     (let [step (fn [n coll]\n                  (let [s (seq coll)]\n                    (if (and (pos? n) s)\n                      (recur (dec n) (rest s))\n                      s)))]\n       (lazy-seq (step n coll)))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [4270 4293]},
                             :full-name "cljs.core/drop",
                             :clj-symbol "clojure.core/drop",
                             :docstring "Returns a lazy sequence of all but the first n items in coll.\nReturns a stateful transducer when no collection is provided."},
           "cljs.core/ArrayList" {:ns "cljs.core",
                                  :name "ArrayList",
                                  :type "type",
                                  :signature ["[arr]"],
                                  :source {:code "(deftype ArrayList [^:mutable arr]\n  Object\n  (add [_ x] (.push arr x))\n  (size [_] (alength arr))\n  (clear [_] (set! arr (array)))\n  (isEmpty [_] (zero? (alength arr)))\n  (toArray [_] arr))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [8332 8338]},
                                  :full-name "cljs.core/ArrayList",
                                  :full-name-encode "cljs.core/ArrayList",
                                  :history [["+" "0.0-2301"]]},
           "cljs.core/stepper" {:ns "cljs.core",
                                :name "stepper",
                                :type "function",
                                :signature ["[xform iter]"],
                                :source {:code "(defn stepper [xform iter]\n  (letfn [(stepfn\n            ([result]\n               (let [lt (if (reduced? result)\n                          @result\n                          result)]\n                 (set! (.-stepper lt) nil)\n                 result))\n            ([result input]\n               (let [lt result]\n                 (set! (.-first lt) input)\n                 (set! (.-rest lt) (lazy-transformer (.-stepper lt)))\n                 (set! (.-stepper lt) nil)\n                 (.-rest lt))))]\n   (Stepper. (xform stepfn) iter)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [3603 3617]},
                                :full-name "cljs.core/stepper",
                                :full-name-encode "cljs.core/stepper",
                                :history [["+" "0.0-2301"]]},
           "cljs.pprint/char-code" {:ns "cljs.pprint",
                                    :name "char-code",
                                    :signature ["[c]"],
                                    :history [["+" "0.0-3255"]],
                                    :type "function",
                                    :full-name-encode "cljs.pprint/char-code",
                                    :source {:code "(defn char-code\n  [c]\n  (cond\n    (number? c) c\n    (and (string? c) (== (.-length c) 1)) (.charCodeAt c 0)\n    :else (throw (js/Error. \"Argument to char must be a character or number\"))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/pprint.cljs",
                                             :lines [62 68]},
                                    :full-name "cljs.pprint/char-code",
                                    :docstring "Convert char to int"},
           "cljs.core/IAtom" {:ns "cljs.core",
                              :name "IAtom",
                              :history [["+" "0.0-2173"]],
                              :type "protocol",
                              :full-name-encode "cljs.core/IAtom",
                              :source {:code "(defprotocol IAtom\n  \"Marker protocol indicating an atom.\")",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [732 733]},
                              :full-name "cljs.core/IAtom",
                              :clj-symbol "clojure.lang/IAtom",
                              :docstring "Marker protocol indicating an atom."},
           "cljs.core/reduceable?" {:return-type boolean,
                                    :ns "cljs.core",
                                    :name "reduceable?",
                                    :signature ["[x]"],
                                    :history [["+" "0.0-1211"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/reduceableQMARK",
                                    :source {:code "(defn ^boolean reduceable?\n  [x] (satisfies? IReduce x))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [1915 1917]},
                                    :full-name "cljs.core/reduceable?",
                                    :docstring "Returns true if coll satisfies IReduce"},
           "cljs.core/while" {:description "Repeatedly executes `body` while `test` expression is true. Presumes some\nside-effect will cause `test` to become false or nil.\n\nReturns nil.",
                              :ns "cljs.core",
                              :name "while",
                              :signature ["[test & body]"],
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :related ["cljs.core/loop"],
                              :full-name-encode "cljs.core/while",
                              :source {:code "(defmacro while\n  [test & body]\n  `(loop []\n     (when ~test\n       ~@body\n       (recur))))",
                                       :title "Source code",
                                       :repo "clojure",
                                       :tag "clojure-1.7.0",
                                       :filename "src/clj/clojure/core.clj",
                                       :lines [6060 6068]},
                              :full-name "cljs.core/while",
                              :clj-symbol "clojure.core/while",
                              :docstring "Repeatedly executes body while test expression is true. Presumes\nsome side-effect will cause test to become false/nil. Returns nil"},
           "cljs.core/dispatch-fn" {:ns "cljs.core",
                                    :name "dispatch-fn",
                                    :signature ["[multifn]"],
                                    :history [["+" "0.0-3165"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/dispatch-fn",
                                    :source {:code "(defn dispatch-fn\n  [multifn] (-dispatch-fn multifn))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [9833 9835]},
                                    :full-name "cljs.core/dispatch-fn",
                                    :docstring "Given a multimethod, return it's dispatch-fn."},
           "cljs.core/*out*" {:ns "cljs.core",
                              :name "*out*",
                              :type "dynamic var",
                              :source {:code "(def\n  ^{:dynamic true\n    :jsdoc [\"@type {*}\"]}\n  *out* nil)",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [34 37]},
                              :full-name "cljs.core/*out*",
                              :full-name-encode "cljs.core/STARoutSTAR",
                              :clj-symbol "clojure.core/*out*",
                              :history [["+" "1.7.10"]]},
           "cljs.core/import-macros" {:ns "cljs.core",
                                      :name "import-macros",
                                      :type "macro",
                                      :signature ["[ns [& vars]]"],
                                      :source {:code "   (core/defmacro import-macros [ns [& vars]]\n     (core/let [ns (find-ns ns)\n                vars (map #(ns-resolve ns %) vars)\n                syms (map\n                       (core/fn [^clojure.lang.Var v]\n                         (core/-> v .sym\n                           (with-meta\n                             (merge\n                               {:macro true}\n                               (update-in (select-keys (meta v) [:arglists :doc :file :line])\n                                 [:arglists] (core/fn [arglists] `(quote ~arglists)))))))\n                       vars)\n                defs (map\n                       (core/fn [sym var]\n                         (core/let [{:keys [arglists doc file line]} (meta sym)]\n                           `(do\n                              (def ~sym (deref ~var))\n                              ;for AOT compilation\n                              (alter-meta! (var ~sym) assoc\n                                :macro true\n                                :arglists ~arglists\n                                :doc ~doc\n                                :file ~file\n                                :line ~line))))\n                       syms vars)]\n       `(do ~@defs\n            :imported))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/clojure/cljs/core.cljc",
                                               :lines [58 84]},
                                      :full-name "cljs.core/import-macros",
                                      :full-name-encode "cljs.core/import-macros",
                                      :history [["+" "0.0-927"]]},
           "cljs.repl.browser/add-in-order" {:ns "cljs.repl.browser",
                                             :name "add-in-order",
                                             :type "function",
                                             :signature ["[{:keys [expecting fns]} order f]"],
                                             :source {:code "(defn add-in-order [{:keys [expecting fns]} order f]\n  {:expecting (or expecting order)\n   :fns (assoc fns order f)})",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.7.228",
                                                      :filename "src/main/clojure/cljs/repl/browser.clj",
                                                      :lines [152 154]},
                                             :full-name "cljs.repl.browser/add-in-order",
                                             :full-name-encode "cljs.repl.browser/add-in-order",
                                             :history [["+" "0.0-927"]]},
           "cljs.repl.nashorn/-main" {:ns "cljs.repl.nashorn",
                                      :name "-main",
                                      :type "function",
                                      :signature ["[]"],
                                      :source {:code "(defn -main []\n      (repl/repl (repl-env)))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/clojure/cljs/repl/nashorn.clj",
                                               :lines [182 183]},
                                      :full-name "cljs.repl.nashorn/-main",
                                      :full-name-encode "cljs.repl.nashorn/-main",
                                      :history [["+" "0.0-3165"]]},
           "cljs.core/string-print" {:ns "cljs.core",
                                     :name "string-print",
                                     :type "function",
                                     :signature ["[x]"],
                                     :source {:code "(defn string-print [x]\n  (*print-fn* x)\n  nil)",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/cljs/cljs/core.cljs",
                                              :lines [8771 8773]},
                                     :full-name "cljs.core/string-print",
                                     :full-name-encode "cljs.core/string-print",
                                     :history [["+" "0.0-927"]]},
           "cljs.core/ES6IteratorSeq" {:ns "cljs.core",
                                       :name "ES6IteratorSeq",
                                       :type "type",
                                       :signature ["[value iter _rest]"],
                                       :source {:code "(deftype ES6IteratorSeq [value iter ^:mutable _rest]\n  ISeqable\n  (-seq [this] this)\n  ISeq\n  (-first [_] value)\n  (-rest [_]\n    (when (nil? _rest)\n      (set! _rest (es6-iterator-seq iter)))\n    _rest))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/cljs/core.cljs",
                                                :lines [1161 1169]},
                                       :full-name "cljs.core/ES6IteratorSeq",
                                       :full-name-encode "cljs.core/ES6IteratorSeq",
                                       :history [["+" "0.0-2411"]]},
           "cljs.js/sm-data" {:ns "cljs.js",
                              :name "sm-data",
                              :signature ["[]"],
                              :history [["+" "1.7.10"] ["-" "1.7.28"]],
                              :type "function",
                              :full-name-encode "cljs.js/sm-data",
                              :source {:code "(defn sm-data []\n  (atom\n    {:source-map (sorted-map)\n     :gen-col    0\n     :gen-line   0}))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.10",
                                       :filename "src/main/cljs/cljs/js.cljs",
                                       :lines [122 126]},
                              :full-name "cljs.js/sm-data",
                              :removed {:in "1.7.28",
                                        :last-seen "1.7.10"}},
           "cljs.repl/err-out" {:ns "cljs.repl",
                                :name "err-out",
                                :type "macro",
                                :signature ["[& body]"],
                                :source {:code "(defmacro err-out [& body]\n  `(binding [*out* *err*]\n     ~@body))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/clojure/cljs/repl.cljc",
                                         :lines [38 40]},
                                :full-name "cljs.repl/err-out",
                                :full-name-encode "cljs.repl/err-out",
                                :history [["+" "0.0-3148"]]},
           "cljs.core/-" {:description "If no `y`s are supplied, returns the negation of `x`, else subtracts the `y`s\nfrom `x` and returns the result.",
                          :return-type number,
                          :ns "cljs.core",
                          :name "-",
                          :signature ["[x]" "[x y]" "[x y & more]"],
                          :history [["+" "0.0-927"]],
                          :type "function/macro",
                          :related ["cljs.core/+"],
                          :full-name-encode "cljs.core/-",
                          :source {:code "(defn ^number -\n  ([x] (cljs.core/- x))\n  ([x y] (cljs.core/- x y))\n  ([x y & more] (reduce - (cljs.core/- x y) more)))",
                                   :title "Function code",
                                   :repo "clojurescript",
                                   :tag "r1.7.228",
                                   :filename "src/main/cljs/cljs/core.cljs",
                                   :lines [2267 2272]},
                          :extra-sources [{:code "(core/defmacro ^::ana/numeric -\n  ([x] (core/list 'js* \"(- ~{})\" x))\n  ([x y] (core/list 'js* \"(~{} - ~{})\" x y))\n  ([x y & more] `(- (- ~x ~y) ~@more)))",
                                           :title "Macro code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/clojure/cljs/core.cljc",
                                           :lines [1016 1019]}],
                          :examples [{:id "0a974e",
                                      :content "```clj\n(- 1)\n;;=> -1\n\n(- 6 3)\n;;=> 3\n\n(- 10 3 2)\n;;=> 5\n```"}],
                          :full-name "cljs.core/-",
                          :clj-symbol "clojure.core/-",
                          :docstring "If no ys are supplied, returns the negation of x, else subtracts\nthe ys from x and returns the result."},
           "cljs.core/vector-seq" {:ns "cljs.core",
                                   :name "vector-seq",
                                   :signature ["[v offset]"],
                                   :history [["+" "0.0-1211"]
                                             ["-" "0.0-1424"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/vector-seq",
                                   :source {:code "(defn vector-seq [v offset]\n  (let [c (-count v)]\n    (when (pos? c)\n      (reify\n        IPrintable\n        (-pr-seq [vseq opts] (pr-sequential pr-seq \"(\" \" \" \")\" opts vseq))\n        ISequential\n        IEquiv\n        (-equiv [vseq other] (equiv-sequential vseq other))\n        ASeq\n        ISeq\n        (-first [_] (-nth v offset))\n        (-rest [_]\n          (let [offset (inc offset)]\n            (if (< offset c)\n              (vector-seq v offset)\n              ())))\n        ISeqable\n        (-seq [vseq] vseq)))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1236",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [2522 2540]},
                                   :full-name "cljs.core/vector-seq",
                                   :removed {:in "0.0-1424",
                                             :last-seen "0.0-1236"}},
           "cljs.core/IIterable" {:ns "cljs.core",
                                  :name "IIterable",
                                  :history [["+" "0.0-2356"]],
                                  :type "protocol",
                                  :full-name-encode "cljs.core/IIterable",
                                  :source {:code "(defprotocol IIterable\n  \"Protocol for iterating over a collection.\"\n  (-iterator [coll]\n    \"Returns an iterator for coll.\"))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [751 754]},
                                  :methods [{:name "-iterator",
                                             :signature ["[coll]"],
                                             :docstring "Returns an iterator for coll."}],
                                  :full-name "cljs.core/IIterable",
                                  :docstring "Protocol for iterating over a collection."},
           "cljs.test/testing-contexts-str" {:ns "cljs.test",
                                             :name "testing-contexts-str",
                                             :signature ["[]"],
                                             :history [["+"
                                                        "0.0-2496"]],
                                             :type "function",
                                             :full-name-encode "cljs.test/testing-contexts-str",
                                             :source {:code "(defn testing-contexts-str\n  []\n  (apply str (interpose \" \" (reverse (:testing-contexts (get-current-env))))))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.7.228",
                                                      :filename "src/main/cljs/cljs/test.cljs",
                                                      :lines [299 303]},
                                             :full-name "cljs.test/testing-contexts-str",
                                             :clj-symbol "clojure.test/testing-contexts-str",
                                             :docstring "Returns a string representation of the current test context. Joins\nstrings in *testing-contexts* with spaces."},
           "clojure.zip/vector-zip" {:ns "clojure.zip",
                                     :name "vector-zip",
                                     :signature ["[root]"],
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "clojure.zip/vector-zip",
                                     :source {:code "(defn vector-zip\n  [root]\n    (zipper vector?\n            seq\n            (fn [node children] (with-meta (vec children) (meta node)))\n            root))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/cljs/clojure/zip.cljs",
                                              :lines [42 48]},
                                     :full-name "clojure.zip/vector-zip",
                                     :clj-symbol "clojure.zip/vector-zip",
                                     :docstring "Returns a zipper for nested vectors, given a root vector"},
           "cljs.reader/read-2-chars" {:ns "cljs.reader",
                                       :name "read-2-chars",
                                       :type "function",
                                       :signature ["[reader]"],
                                       :source {:code "(defn read-2-chars [reader]\n  (.toString\n    (StringBuffer.\n      (read-char reader)\n      (read-char reader))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/cljs/reader.cljs",
                                                :lines [167 171]},
                                       :full-name "cljs.reader/read-2-chars",
                                       :full-name-encode "cljs.reader/read-2-chars",
                                       :history [["+" "0.0-1424"]]},
           "cljs.core/chunk" {:ns "cljs.core",
                              :name "chunk",
                              :type "function",
                              :signature ["[b]"],
                              :source {:code "(defn chunk [b]\n  (.chunk b))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [3196 3197]},
                              :full-name "cljs.core/chunk",
                              :full-name-encode "cljs.core/chunk",
                              :history [["+" "0.0-1424"]]},
           "cljs.core/conj!" {:ns "cljs.core",
                              :name "conj!",
                              :signature ["[]"
                                          "[coll]"
                                          "[tcoll val]"
                                          "[tcoll val & vals]"],
                              :history [["+" "0.0-1211"]],
                              :type "function",
                              :full-name-encode "cljs.core/conjBANG",
                              :source {:code "(defn conj!\n  ([] (transient []))\n  ([coll] coll)\n  ([tcoll val]\n    (-conj! tcoll val))\n  ([tcoll val & vals]\n    (let [ntcoll (-conj! tcoll val)]\n      (if vals\n        (recur ntcoll (first vals) (next vals))\n        ntcoll))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [3387 3398]},
                              :full-name "cljs.core/conj!",
                              :clj-symbol "clojure.core/conj!",
                              :docstring "Adds x to the transient collection, and return coll. The 'addition'\nmay happen at different 'places' depending on the concrete type."},
           "syntax/earmuffs" {:description "A naming convention for dynamic vars (unenforced).\n\n`(def ^:dynamic *foo* 1)`\n\nDynamic vars are global vars that you intend to temporarily rebind with\n[doc:cljs.core/binding].\n\nNOTE: Sometimes, the core library uses the earmuffs convention for non-dynamic\nspecial global vars (e.g. [doc:cljs.core/*clojurescript-version*],\n[doc:cljs.core/*main-cli-fn*]).",
                              :ns "syntax",
                              :name "earmuffs",
                              :history [["+" "0.0-927"]],
                              :type "convention",
                              :related ["cljs.core/binding"],
                              :full-name-encode "syntax/earmuffs",
                              :usage ["*foo*"],
                              :examples [{:id "91cf10",
                                          :content "```clj\n(def ^:dynamic *foo* 1)\n\n(def print-foo []\n  (println *foo*))\n\n(print-foo)\n;; 1\n\n(binding [*foo* 2]\n  (print-foo))\n;; 2\n\n(print-foo)\n;; 1\n```"}],
                              :full-name "syntax/earmuffs",
                              :display "*earmuffs*",
                              :clj-doc "http://clojure.org/cheatsheet"},
           "cljs.test/do-report" {:ns "cljs.test",
                                  :name "do-report",
                                  :signature ["[m]"],
                                  :history [["+" "0.0-2496"]],
                                  :type "function",
                                  :full-name-encode "cljs.test/do-report",
                                  :source {:code "(defn do-report [m]\n  (let [m (case (:type m)\n            :fail (merge (file-and-line (js/Error.) 4) m)\n            :error (merge (file-and-line (:actual m) 0) m)\n            m)]\n    (report m)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/test.cljs",
                                           :lines [407 412]},
                                  :full-name "cljs.test/do-report",
                                  :clj-symbol "clojure.test/do-report"},
           "cljs.core/print-map" {:ns "cljs.core",
                                  :name "print-map",
                                  :type "function",
                                  :signature ["[m print-one writer opts]"],
                                  :source {:code "(defn print-map [m print-one writer opts]\n  (pr-sequential-writer\n    writer\n    (fn [e w opts]\n      (do (print-one (key e) w opts)\n          (-write w \\space)\n          (print-one (val e) w opts)))\n    \"{\" \", \" \"}\"\n    opts (seq m)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [8980 8988]},
                                  :full-name "cljs.core/print-map",
                                  :full-name-encode "cljs.core/print-map",
                                  :history [["+" "0.0-2120"]]},
           "cljs.core/js->clj" {:description "Recursively transforms JavaScript arrays into ClojureScript vectors, and\nJavaScript objects into ClojureScript maps.\n\nWith option `{:keywordize-keys true}` will convert object fields from strings to\nkeywords.\n\nNote that `js->clj` is not optimized for speed and the [transit.cljs] library is\nrecommended for parsing large amounts of JSON data.\n\n[transit.cljs]:http://swannodette.github.io/2014/07/26/transit--clojurescript/",
                                :ns "cljs.core",
                                :name "js->clj",
                                :signature ["[x]" "[x & opts]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/clj->js"],
                                :full-name-encode "cljs.core/js-GTclj",
                                :source {:code "(defn js->clj\n  ([x] (js->clj x {:keywordize-keys false}))\n  ([x & opts]\n    (let [{:keys [keywordize-keys]} opts\n          keyfn (if keywordize-keys keyword str)\n          f (fn thisfn [x]\n              (cond\n                (satisfies? IEncodeClojure x)\n                (-js->clj x (apply array-map opts))\n\n                (seq? x)\n                (doall (map thisfn x))\n\n                (coll? x)\n                (into (empty x) (map thisfn x))\n\n                (array? x)\n                (vec (map thisfn x))\n                 \n                (identical? (type x) js/Object)\n                (into {} (for [k (js-keys x)]\n                           [(keyfn k) (thisfn (aget x k))]))\n\n                :else x))]\n      (f x))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [9340 9368]},
                                :examples [{:id "61d263",
                                            :content "Parse a JSON string:\n\n```clj\n(def json \"{\\\"foo\\\": 1, \\\"bar\\\": 2, \\\"baz\\\": [1,2,3]}\")\n(def a (.parse js/JSON json))\n;;=> #js {:foo 1, :bar 2, :baz #js [1 2 3]}\n```\n\nConvert JSON data `a` to ClojureScript data:\n\n```clj\n(js->clj a)\n;;=> {\"foo\" 1, \"bar\" 2, \"baz\" [1 2 3]}\n\n(js->clj a :keywordize-keys true)\n;;=> {:foo 1, :bar 2, :baz [1 2 3]}\n```"}],
                                :full-name "cljs.core/js->clj",
                                :docstring "Recursively transforms JavaScript arrays into ClojureScript\nvectors, and JavaScript objects into ClojureScript maps.  With\noption ':keywordize-keys true' will convert object fields from\nstrings to keywords."},
           "cljs.core/List" {:ns "cljs.core",
                             :name "List",
                             :signature ["[meta first rest count __hash]"],
                             :history [["+" "0.0-927"]],
                             :type "type",
                             :full-name-encode "cljs.core/List",
                             :source {:code "(deftype List [meta first rest count ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  IList\n\n  ICloneable\n  (-clone [_] (List. meta first rest count __hash))\n\n  IWithMeta\n  (-with-meta [coll meta] (List. meta first rest count __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ASeq\n  ISeq\n  (-first [coll] first)\n  (-rest [coll]\n    (if (== count 1)\n      ()\n      rest))\n\n  INext\n  (-next [coll]\n    (if (== count 1)\n      nil\n      rest))\n\n  IStack\n  (-peek [coll] first)\n  (-pop [coll] (-rest coll))\n\n  ICollection\n  (-conj [coll o] (List. meta o coll (inc count) nil))\n\n  IEmptyableCollection\n  (-empty [coll] (-with-meta (.-EMPTY List) meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ICounted\n  (-count [coll] count)\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [2697 2754]},
                             :full-name "cljs.core/List",
                             :clj-symbol "clojure.lang/PersistentList"},
           "cljs.core/identical?" {:description "Returns true if `x` and `y` are the same object, false otherwise.",
                                   :return-type boolean,
                                   :ns "cljs.core",
                                   :name "identical?",
                                   :signature ["[x y]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function/macro",
                                   :related ["cljs.core/="
                                             "cljs.core/=="],
                                   :full-name-encode "cljs.core/identicalQMARK",
                                   :source {:code "(defn ^boolean identical?\n  [x y]\n  (cljs.core/identical? x y))",
                                            :title "Function code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [181 184]},
                                   :extra-sources [{:code "(core/defmacro identical? [a b]\n  (bool-expr (core/list 'js* \"(~{} === ~{})\" a b)))",
                                                    :title "Macro code",
                                                    :repo "clojurescript",
                                                    :tag "r1.7.228",
                                                    :filename "src/main/clojure/cljs/core.cljc",
                                                    :lines [921 922]}],
                                   :full-name "cljs.core/identical?",
                                   :clj-symbol "clojure.core/identical?",
                                   :docstring "Tests if 2 arguments are the same object"},
           "cljs.core/*main-cli-fn*" {:ns "cljs.core",
                                      :name "*main-cli-fn*",
                                      :docstring "When compiled for a command-line target, whatever function\n*main-cli-fn* is set to will be called with the command-line\nargv as arguments",
                                      :type "var",
                                      :source {:code "(def\n  ^{:doc \"When compiled for a command-line target, whatever function\n  *main-cli-fn* is set to will be called with the command-line\n  argv as arguments\"}\n  *main-cli-fn* nil)",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [247 251]},
                                      :full-name "cljs.core/*main-cli-fn*",
                                      :full-name-encode "cljs.core/STARmain-cli-fnSTAR",
                                      :history [["+" "0.0-927"]]},
           "clojure.browser.dom/html->dom" {:ns "clojure.browser.dom",
                                            :name "html->dom",
                                            :type "function",
                                            :signature ["[s]"],
                                            :source {:code "(defn html->dom [s]\n  (gdom/htmlToDocumentFragment s))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.7.228",
                                                     :filename "src/main/cljs/clojure/browser/dom.cljs",
                                                     :lines [101 102]},
                                            :full-name "clojure.browser.dom/html->dom",
                                            :full-name-encode "clojure.browser.dom/html-GTdom",
                                            :history [["+" "0.0-927"]]},
           "cljs.repl.server/handlers" {:ns "cljs.repl.server",
                                        :name "handlers",
                                        :type "var",
                                        :source {:code "(defonce handlers (atom {}))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/clojure/cljs/repl/server.clj",
                                                 :lines [39]},
                                        :full-name "cljs.repl.server/handlers",
                                        :full-name-encode "cljs.repl.server/handlers",
                                        :history [["+" "0.0-1503"]]},
           "cljs.core/symbol-identical?" {:return-type boolean,
                                          :ns "cljs.core",
                                          :name "symbol-identical?",
                                          :signature ["[x y]"],
                                          :history [["+" "1.7.10"]],
                                          :type "function",
                                          :full-name-encode "cljs.core/symbol-identicalQMARK",
                                          :source {:code "(defn ^boolean symbol-identical?\n  [x y]\n  (if (identical? x y)\n    true\n    (if (and (symbol? x) (symbol? y))\n      (identical? (.-str x) (.-str y))\n      false)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/cljs/cljs/core.cljs",
                                                   :lines [2972 2979]},
                                          :full-name "cljs.core/symbol-identical?",
                                          :docstring "Efficient test to determine that two symbol are identical."},
           "cljs.repl.node/load-javascript" {:ns "cljs.repl.node",
                                             :name "load-javascript",
                                             :signature ["[repl-env provides url]"],
                                             :history [["+"
                                                        "0.0-2629"]],
                                             :type "function",
                                             :full-name-encode "cljs.repl.node/load-javascript",
                                             :source {:code "(defn load-javascript\n  [repl-env provides url]\n  (node-eval repl-env\n    (str \"goog.require('\" (comp/munge (first provides)) \"')\")))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.7.228",
                                                      :filename "src/main/clojure/cljs/repl/node.clj",
                                                      :lines [69 73]},
                                             :full-name "cljs.repl.node/load-javascript",
                                             :docstring "Load a Closure JavaScript file into the Node REPL process."},
           "cljs.core/LazyTransformer.create" {:ns "cljs.core",
                                               :name "LazyTransformer.create",
                                               :signature ["[xform coll]"],
                                               :history [["+"
                                                          "0.0-2301"]],
                                               :parent-type "LazyTransformer",
                                               :type "function",
                                               :full-name-encode "cljs.core/LazyTransformerDOTcreate",
                                               :source {:code "(set! (.-create LazyTransformer)\n  (fn [xform coll]\n    (LazyTransformer. (stepper xform (iter coll)) nil nil nil)))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.7.228",
                                                        :filename "src/main/cljs/cljs/core.cljs",
                                                        :lines [3723
                                                                3725]},
                                               :full-name "cljs.core/LazyTransformer.create"},
           "cljs.core/chunk-next" {:ns "cljs.core",
                                   :name "chunk-next",
                                   :type "function",
                                   :signature ["[s]"],
                                   :source {:code "(defn chunk-next [s]\n  (if (implements? IChunkedNext s)\n    (-chunked-next s)\n    (seq (-chunked-rest s))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [3205 3208]},
                                   :full-name "cljs.core/chunk-next",
                                   :full-name-encode "cljs.core/chunk-next",
                                   :history [["+" "0.0-1424"]]},
           "cljs.core/enable-console-print!" {:ns "cljs.core",
                                              :name "enable-console-print!",
                                              :signature ["[]"],
                                              :history [["+"
                                                         "0.0-2060"]],
                                              :type "function",
                                              :full-name-encode "cljs.core/enable-console-printBANG",
                                              :source {:code "(defn enable-console-print!\n  []\n  (set! *print-newline* false)\n  (set! *print-fn*\n    (fn [& args]\n      (.apply (.-log js/console) js/console (into-array args))))\n  (set! *print-err-fn*\n    (fn [& args]\n      (.apply (.-error js/console) js/console (into-array args))))\n  nil)",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.7.228",
                                                       :filename "src/main/cljs/cljs/core.cljs",
                                                       :lines [144
                                                               154]},
                                              :full-name "cljs.core/enable-console-print!",
                                              :docstring "Set *print-fn* to console.log"},
           "cljs.core/sorted?" {:description "Returns true if `coll` implements the `ISorted` protocol, false otherwise.\n\nSorted maps and sorted sets implement `ISorted`.",
                                :return-type boolean,
                                :ns "cljs.core",
                                :name "sorted?",
                                :signature ["[coll]"],
                                :history [["+" "0.0-2120"]],
                                :type "function",
                                :related ["cljs.core/sorted-map"
                                          "cljs.core/sorted-set"],
                                :full-name-encode "cljs.core/sortedQMARK",
                                :source {:code "(defn ^boolean sorted?\n  [x] (satisfies? ISorted x))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [1911 1913]},
                                :full-name "cljs.core/sorted?",
                                :clj-symbol "clojure.core/sorted?",
                                :docstring "Returns true if coll satisfies ISorted"},
           "cljs.core/some" {:description "Returns the first logical true value of `(pred x)` for any `x` in `coll`, else\nnil.\n\nA common idiom is to use a set as pred, for example this will return `:fred` if\n`:fred` is in the sequence, otherwise nil: `(some #{:fred} coll)`",
                             :ns "cljs.core",
                             :name "some",
                             :signature ["[pred coll]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/every?"
                                       "cljs.core/not-any?"
                                       "cljs.core/keep"
                                       "cljs.core/keep-indexed"
                                       "cljs.core/some-fn"],
                             :full-name-encode "cljs.core/some",
                             :source {:code "(defn some\n  [pred coll]\n    (when (seq coll)\n      (or (pred (first coll)) (recur pred (next coll)))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [3768 3775]},
                             :full-name "cljs.core/some",
                             :clj-symbol "clojure.core/some",
                             :docstring "Returns the first logical true value of (pred x) for any x in coll,\nelse nil.  One common idiom is to use a set as pred, for example\nthis will return :fred if :fred is in the sequence, otherwise nil:\n(some #{:fred} coll)"},
           "cljs.core/PersistentArrayMapSeq" {:ns "cljs.core",
                                              :name "PersistentArrayMapSeq",
                                              :type "type",
                                              :signature ["[arr i _meta]"],
                                              :source {:code "(deftype PersistentArrayMapSeq [arr i _meta]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  \n  IMeta\n  (-meta [coll] _meta)\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (PersistentArrayMapSeq. arr i new-meta))\n\n  ICounted\n  (-count [coll]\n    (/ (- (alength arr) i) 2))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ICollection\n  (-conj [coll o]\n    (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY List) _meta))\n\n  IHash\n  (-hash [coll] (hash-ordered-coll coll))\n  \n  ISeq\n  (-first [coll]\n    [(aget arr i) (aget arr (inc i))])\n\n  (-rest [coll]\n    (if (< i (- (alength arr) 2))\n      (PersistentArrayMapSeq. arr (+ i 2) _meta)\n      ()))\n\n  INext\n  (-next [coll]\n    (when (< i (- (alength arr) 2))\n      (PersistentArrayMapSeq. arr (+ i 2) _meta)))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.7.228",
                                                       :filename "src/main/cljs/cljs/core.cljs",
                                                       :lines [5777
                                                               5828]},
                                              :full-name "cljs.core/PersistentArrayMapSeq",
                                              :full-name-encode "cljs.core/PersistentArrayMapSeq",
                                              :history [["+"
                                                         "0.0-1820"]]},
           "cljs.reader/make-unicode-char" {:ns "cljs.reader",
                                            :name "make-unicode-char",
                                            :type "function",
                                            :signature ["[code-str]"],
                                            :source {:code "(defn make-unicode-char [code-str]\n    (let [code (js/parseInt code-str 16)]\n      (.fromCharCode js/String code)))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.7.228",
                                                     :filename "src/main/cljs/cljs/reader.cljs",
                                                     :lines [189 191]},
                                            :full-name "cljs.reader/make-unicode-char",
                                            :full-name-encode "cljs.reader/make-unicode-char",
                                            :history [["+" "0.0-1424"]]},
           "clojure.core.reducers/Cat" {:ns "clojure.core.reducers",
                                        :name "Cat",
                                        :signature ["[cnt left right]"],
                                        :history [["+" "0.0-1236"]],
                                        :type "type",
                                        :full-name-encode "clojure.core.reducers/Cat",
                                        :source {:code "(deftype Cat [cnt left right]\n  cljs.core/ICounted\n  (-count [_] cnt)\n\n  cljs.core/ISeqable\n  (-seq [_] (concat (seq left) (seq right)))\n\n  cljs.core/IReduce\n  (-reduce [this f1] (-reduce this f1 (f1)))\n  (-reduce\n    [_  f1 init]\n    (-reduce\n     right f1\n     (-reduce left f1 init)))\n\n  CollFold\n  (coll-fold\n    [this n combinef reducef]\n    (-reduce this reducef)))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/cljs/clojure/core/reducers.cljs",
                                                 :lines [193 211]},
                                        :full-name "clojure.core.reducers/Cat",
                                        :clj-symbol "clojure.core.reducers/Cat"},
           "cljs.build.api/add-implicit-options" {:ns "cljs.build.api",
                                                  :name "add-implicit-options",
                                                  :signature ["[opts]"],
                                                  :history [["+"
                                                             "0.0-3291"]],
                                                  :type "function",
                                                  :full-name-encode "cljs.build.api/add-implicit-options",
                                                  :source {:code "(defn add-implicit-options\n  [opts]\n  (closure/add-implicit-options opts))",
                                                           :title "Source code",
                                                           :repo "clojurescript",
                                                           :tag "r1.7.228",
                                                           :filename "src/main/clojure/cljs/build/api.clj",
                                                           :lines [150
                                                                   155]},
                                                  :full-name "cljs.build.api/add-implicit-options",
                                                  :docstring "Given a valid map of build options add any standard implicit options. For\nexample :optimizations :none implies :cache-analysis true and :source-map\ntrue."},
           "cljs.core/write-all" {:ns "cljs.core",
                                  :name "write-all",
                                  :type "function",
                                  :signature ["[writer & ss]"],
                                  :source {:code "(defn write-all [writer & ss]\n  (doseq [s ss]\n    (-write writer s)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [8767 8769]},
                                  :full-name "cljs.core/write-all",
                                  :full-name-encode "cljs.core/write-all",
                                  :history [["+" "0.0-1503"]]},
           "cljs.core/doall" {:description "Forces evaluation of a lazy sequence. Often used to see the effects of a\nsequence produced via functions that have side effects.\n\n`doall` walks through the successive `next`s of the sequence, returning the head\nand causing the entire sequence to reside in memory at one time.",
                              :ns "cljs.core",
                              :name "doall",
                              :signature ["[coll]" "[n coll]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/dorun"
                                        "cljs.core/doseq"],
                              :full-name-encode "cljs.core/doall",
                              :source {:code "(defn doall\n  ([coll]\n   (dorun coll)\n   coll)\n  ([n coll]\n   (dorun n coll)\n   coll))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [8677 8689]},
                              :full-name "cljs.core/doall",
                              :clj-symbol "clojure.core/doall",
                              :docstring "When lazy sequences are produced via functions that have side\neffects, any effects other than those needed to produce the first\nelement in the seq do not occur until the seq is consumed. doall can\nbe used to force any effects. Walks through the successive nexts of\nthe seq, retains the head and returns it, thus causing the entire\nseq to reside in memory at one time."},
           "cljs.core/condp" {:description "Takes a binary predicate, an expression, and a set of clauses. There are two\nkinds of clauses:\n\nBinary clause: `test-expr` `result-expr`\n\nTernary clause: `test-expr` `:>>` `result-fn`<br />\n(Note: `:>>` is an ordinary keyword)\n\nFor each clause, `(pred test-expr expr)` is evaluated. If it returns logical\ntrue, the clause is a match.\n\nIf a binary clause matches, its `result-expr` is returned.\n\nIf a ternary clause matches, its `result-fn` is called with the result of the\npredicate and returned by `condp`. `result-fn` should take one argument.\n\nA single default expression can follow the clauses, and its value will be\nreturned if no clause matches.\n\nIf no default expression is provided and no clause matches, an Error is thrown.",
                              :ns "cljs.core",
                              :name "condp",
                              :signature ["[pred expr & clauses]"],
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :related ["cljs.core/cond" "special/if"],
                              :full-name-encode "cljs.core/condp",
                              :source {:code "(core/defmacro condp\n  [pred expr & clauses]\n  (core/let [gpred (gensym \"pred__\")\n             gexpr (gensym \"expr__\")\n             emit (core/fn emit [pred expr args]\n                    (core/let [[[a b c :as clause] more]\n                               (split-at (if (= :>> (second args)) 3 2) args)\n                               n (count clause)]\n                      (core/cond\n                        (= 0 n) `(throw (js/Error. (core/str \"No matching clause: \" ~expr)))\n                        (= 1 n) a\n                        (= 2 n) `(if (~pred ~a ~expr)\n                                   ~b\n                                   ~(emit pred expr more))\n                        :else `(if-let [p# (~pred ~a ~expr)]\n                                 (~c p#)\n                                 ~(emit pred expr more)))))\n             gres (gensym \"res__\")]\n    `(let [~gpred ~pred\n           ~gexpr ~expr]\n       ~(emit gpred gexpr clauses))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/clojure/cljs/core.cljc",
                                       :lines [2028 2068]},
                              :full-name "cljs.core/condp",
                              :clj-symbol "clojure.core/condp",
                              :docstring "Takes a binary predicate, an expression, and a set of clauses.\nEach clause can take the form of either:\n\ntest-expr result-expr\n\ntest-expr :>> result-fn\n\nNote :>> is an ordinary keyword.\n\nFor each clause, (pred test-expr expr) is evaluated. If it returns\nlogical true, the clause is a match. If a binary clause matches, the\nresult-expr is returned, if a ternary clause matches, its result-fn,\nwhich must be a unary function, is called with the result of the\npredicate as its argument, the result of that call being the return\nvalue of condp. A single default expression can follow the clauses,\nand its value will be returned if no clause matches. If no default\nexpression is provided and no clause matches, an\nIllegalArgumentException is thrown."},
           "clojure.zip/down" {:ns "clojure.zip",
                               :name "down",
                               :signature ["[loc]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip/down",
                               :source {:code "(defn down\n  [loc]\n    (when (branch? loc)\n      (let [[node path] loc\n            [c & cnext :as cs] (children loc)]\n        (when cs\n          (with-meta [c {:l [] \n                         :pnodes (if path (conj (:pnodes path) node) [node]) \n                         :ppath path \n                         :r cnext}] (meta loc))))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/clojure/zip.cljs",
                                        :lines [98 109]},
                               :full-name "clojure.zip/down",
                               :clj-symbol "clojure.zip/down",
                               :docstring "Returns the loc of the leftmost child of the node at this loc, or\nnil if no children"},
           "cljs.pprint/simple-dispatch" {:ns "cljs.pprint",
                                          :name "simple-dispatch",
                                          :history [["+" "0.0-3255"]],
                                          :type "multimethod",
                                          :full-name-encode "cljs.pprint/simple-dispatch",
                                          :source {:code "(defmulti simple-dispatch\n  \"The pretty print dispatch function for simple data structure format.\"\n  type-dispatcher)",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/cljs/cljs/pprint.cljs",
                                                   :lines [2898 2900]},
                                          :full-name "cljs.pprint/simple-dispatch",
                                          :clj-symbol "clojure.pprint/simple-dispatch",
                                          :docstring "The pretty print dispatch function for simple data structure format."},
           "cljs.core/IPending" {:ns "cljs.core",
                                 :name "IPending",
                                 :history [["+" "0.0-927"]],
                                 :type "protocol",
                                 :full-name-encode "cljs.core/IPending",
                                 :source {:code "(defprotocol IPending\n  \"Protocol for types which can have a deferred realization. Currently only\n  implemented by Delay and LazySeq.\"\n  (^boolean -realized? [x]\n    \"Returns true if a value for x has been produced, false otherwise.\"))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [651 655]},
                                 :methods [{:name "-realized?",
                                            :signature ["[x]"],
                                            :docstring "Returns true if a value for x has been produced, false otherwise."}],
                                 :full-name "cljs.core/IPending",
                                 :clj-symbol "clojure.lang/IPending",
                                 :docstring "Protocol for types which can have a deferred realization. Currently only\n  implemented by Delay and LazySeq."},
           "cljs.core/count" {:description "Returns the number of items in `x`.\n\n`count` works on arrays, lists, maps, sets, strings, and vectors.\n\n`(count nil)` returns 0.",
                              :ns "cljs.core",
                              :name "count",
                              :signature ["[x]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/count",
                              :source {:code "(defn count\n  [coll]\n  (if-not (nil? coll)\n    (cond\n      (implements? ICounted coll)\n      (-count ^not-native coll)\n\n      (array? coll)\n      (alength coll)\n    \n      (string? coll)\n      (alength coll)\n\n      (implements? ISeqable coll)\n      (accumulating-seq-count coll)\n\n      :else (-count coll))\n    0))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [1594 1613]},
                              :examples [{:id "96e470",
                                          :content "```clj\n(count [1 2 3])\n;;=> 3\n\n(count [])\n;;=> 0\n\n(count nil)\n;;=> 0\n\n(count #{:a :b})\n;;=> 2\n\n(count {:key \"value\" :key2 \"value2\"})\n;;=> 2\n```"}],
                              :full-name "cljs.core/count",
                              :clj-symbol "clojure.core/count",
                              :docstring "Returns the number of items in the collection. (count nil) returns\n0.  Also works on strings, arrays, and Maps"},
           "cljs.core/bit-test" {:description "Test bit at index `n`. Returns `true` if 1, and `false` if 0. Same as `(x & (1 << y)) != 0` in JavaScript.",
                                 :return-type boolean,
                                 :ns "cljs.core",
                                 :name "bit-test",
                                 :signature ["[x n]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function/macro",
                                 :full-name-encode "cljs.core/bit-test",
                                 :source {:code "(defn ^boolean bit-test\n  [x n]\n  (cljs.core/bit-test x n))",
                                          :title "Function code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [2551 2554]},
                                 :extra-sources [{:code "(core/defmacro bit-test [x n]\n  (bool-expr (core/list 'js* \"((~{} & (1 << ~{})) != 0)\" x n)))",
                                                  :title "Macro code",
                                                  :repo "clojurescript",
                                                  :tag "r1.7.228",
                                                  :filename "src/main/clojure/cljs/core.cljc",
                                                  :lines [1125 1126]}],
                                 :examples [{:id "f64664",
                                             :content "Bits can be entered using radix notation:\n\n```clj\n(bit-test 2r0100 2)\n;;=> true\n\n(bit-test 2r0100 1)\n;;=> false\n```\n\nSame numbers in decimal:\n\n```clj\n(bit-test 4 2)\n;;=> true\n\n(bit-test 4 1)\n;;=> false\n```"}],
                                 :full-name "cljs.core/bit-test",
                                 :clj-symbol "clojure.core/bit-test",
                                 :docstring "Test bit at index n"},
           "cljs.core/js-mod" {:description "Returns the modulus of dividing numerator `n` by denominator `d`, with JavaScript's\noriginal behavior for negative numbers.\n\nReturns `NaN` when `d` is 0 (divide by 0 error).\n\nEquivalent to `x % y` in JavaScript.",
                               :ns "cljs.core",
                               :name "js-mod",
                               :signature ["[n d]"],
                               :history [["+" "0.0-1552"]],
                               :type "function/macro",
                               :related ["cljs.core/mod"],
                               :full-name-encode "cljs.core/js-mod",
                               :source {:code "(defn js-mod\n  [n d]\n  (cljs.core/js-mod n d))",
                                        :title "Function code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [2486 2489]},
                               :extra-sources [{:code "(core/defmacro ^::ana/numeric js-mod [num div]\n  (core/list 'js* \"(~{} % ~{})\" num div))",
                                                :title "Macro code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/clojure/cljs/core.cljc",
                                                :lines [1089 1090]}],
                               :examples [{:id "75fa6d",
                                           :content "```clj\n(js-mod -5 3)\n;;=> -2\n\n(js-mod 5 3)\n;;=> 2\n\n(js-mod 5 0)\n;;=> NaN\n```"}],
                               :full-name "cljs.core/js-mod",
                               :docstring "Modulus of num and div with original javascript behavior. i.e. bug for negative numbers"},
           "syntax/cond" {:description "(Only allowed in `.cljc` files or the REPL)\n\nAllows the reader to conditionally select from the given list of forms\ndepending on available \"feature\" keys.  For example:\n\n```clj\n#?(:clj \"Clojure\"\n   :cljs \"ClojureScript\")\n```\n\nClojureScript's reader is configured with the `:cljs` feature key, making the\nexpression above read as `\"ClojureScript\"`.  Clojure's reader is\nsimilarly configured with the `:clj` key.\n\nThis essentially allows us to write portable code for use in both Clojure and\nClojureScript.\n\n## For Macros\n\nReader conditionals are especially important when writing macros in\nClojureScript, since the macros may be handed off to Clojure for evaluation,\ndepending on the ClojureScript compiler version:\n\n| compiler version  | macros evaluated by |\n|-------------------|---------------------|\n| ClojureScript JVM | Clojure             |\n| ClojureScript JS  | ClojureScript       |\n\nThus, reader conditionals allow us to account for differences in both versions\nof the compiler.  See [doc:cljs.core/defmacro] for details.",
                          :ns "syntax",
                          :name "cond",
                          :history [["+" "0.0-3190"]],
                          :type "syntax",
                          :related ["syntax/cond-splicing"],
                          :full-name-encode "syntax/cond",
                          :extra-sources ({:code "(defn- read-cond\n  [rdr _ opts pending-forms]\n  (when (not (and opts (#{:allow :preserve} (:read-cond opts))))\n    (throw (RuntimeException. \"Conditional read not allowed\")))\n  (if-let [ch (read-char rdr)]\n    (let [splicing (= ch \\@)\n          ch (if splicing (read-char rdr) ch)]\n      (when splicing\n        (when-not *read-delim*\n          (reader-error rdr \"cond-splice not in list\")))\n      (if-let [ch (if (whitespace? ch) (read-past whitespace? rdr) ch)]\n        (if (not= ch \\()\n          (throw (RuntimeException. \"read-cond body must be a list\"))\n          (binding [*suppress-read* (or *suppress-read* (= :preserve (:read-cond opts)))]\n            (if *suppress-read*\n              (reader-conditional (read-list rdr ch opts pending-forms) splicing)\n              (read-cond-delimited rdr splicing opts pending-forms))))\n        (reader-error rdr \"EOF while reading character\")))\n    (reader-error rdr \"EOF while reading character\")))",
                                           :title "Reader code",
                                           :repo "tools.reader",
                                           :tag "tools.reader-1.0.0-alpha1",
                                           :filename "src/main/clojure/clojure/tools/reader.clj",
                                           :lines [496 514]}
                                          {:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    \\? read-cond\n    nil))",
                                           :title "Reader table",
                                           :repo "tools.reader",
                                           :tag "tools.reader-1.0.0-alpha1",
                                           :filename "src/main/clojure/clojure/tools/reader.clj",
                                           :lines [764 776]}),
                          :usage ["#?(...)"],
                          :examples [{:id "eec90f",
                                      :content "```clj\n#?(:clj \"Clojure\" :cljs \"ClojureScript\")\n;;=> \"ClojureScript\"\n```\n\nA function that works in Clojure and ClojureScript ([source]):\n\n[source]:https://github.com/lymingtonprecision/route-ccrs/blob/c579aea05504736f2cfbd31c3c755f7e25fdad77/src/route_ccrs/manufacturing_methods.cljc#L8-L10\n\n```clj\n(defn str->int [s]\n  #?(:clj  (java.lang.Integer/parseInt s)\n     :cljs (js/parseInt s)))\n\n(str->int \"123\")\n;;=> 123\n```"}],
                          :full-name "syntax/cond",
                          :display "#? reader conditional",
                          :clj-doc "http://clojure.org/reader#toc5"},
           "cljs.compiler.api/cljs-files-in" {:ns "cljs.compiler.api",
                                              :name "cljs-files-in",
                                              :signature ["[dir]"],
                                              :history [["+"
                                                         "0.0-3255"]],
                                              :type "function",
                                              :full-name-encode "cljs.compiler.api/cljs-files-in",
                                              :source {:code "(defn cljs-files-in\n  [dir]\n  (comp/cljs-files-in dir))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.7.228",
                                                       :filename "src/main/clojure/cljs/compiler/api.clj",
                                                       :lines [88 91]},
                                              :full-name "cljs.compiler.api/cljs-files-in",
                                              :docstring "Return a sequence of all .cljs and .cljc files in the given directory."},
           "cljs.core/es6-set-entries-iterator" {:ns "cljs.core",
                                                 :name "es6-set-entries-iterator",
                                                 :type "function",
                                                 :signature ["[coll]"],
                                                 :source {:code "(defn es6-set-entries-iterator [coll]\n  (ES6SetEntriesIterator. (seq coll)))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r1.7.228",
                                                          :filename "src/main/cljs/cljs/core.cljs",
                                                          :lines [5695
                                                                  5696]},
                                                 :full-name "cljs.core/es6-set-entries-iterator",
                                                 :full-name-encode "cljs.core/es6-set-entries-iterator",
                                                 :history [["+"
                                                            "0.0-2371"]]},
           "cljs.repl.browser/safari-st-el->frame" {:ns "cljs.repl.browser",
                                                    :name "safari-st-el->frame",
                                                    :signature ["[repl-env st-el opts]"],
                                                    :history [["+"
                                                               "0.0-3053"]
                                                              ["-"
                                                               "1.7.10"]],
                                                    :type "function",
                                                    :full-name-encode "cljs.repl.browser/safari-st-el-GTframe",
                                                    :source {:code "(defn safari-st-el->frame\n  [repl-env st-el opts]\n  (let [[function flc] (if (re-find #\"@\" st-el)\n                         (string/split st-el #\"@\")\n                         [nil st-el])\n        [file line column] (parse-file-line-column flc)]\n    (if (and file function line column)\n      {:file (parse-file repl-env file opts)\n       :function function\n       :line line\n       :column column}\n      (when-not (string/blank? function)\n        {:file nil\n         :function (string/trim function)\n         :line nil\n         :column nil}))))",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r3308",
                                                             :filename "src/main/clojure/cljs/repl/browser.clj",
                                                             :lines [318
                                                                     333]},
                                                    :full-name "cljs.repl.browser/safari-st-el->frame",
                                                    :removed {:in "1.7.10",
                                                              :last-seen "0.0-3308"}},
           "cljs.test/set-env!" {:ns "cljs.test",
                                 :name "set-env!",
                                 :type "function",
                                 :signature ["[new-env]"],
                                 :source {:code "(defn set-env! [new-env]\n  (set! *current-env* new-env))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/test.cljs",
                                          :lines [277 278]},
                                 :full-name "cljs.test/set-env!",
                                 :full-name-encode "cljs.test/set-envBANG",
                                 :history [["+" "0.0-2496"]]},
           "cljs.core/SetEntriesIterator" {:ns "cljs.core",
                                           :name "SetEntriesIterator",
                                           :signature ["[s]"],
                                           :history [["+" "0.0-2268"]
                                                     ["-" "0.0-2371"]],
                                           :type "type",
                                           :full-name-encode "cljs.core/SetEntriesIterator",
                                           :source {:code "(deftype SetEntriesIterator [^:mutable s]\n  Object\n  (next [_]\n    (if-not (nil? s)\n      (let [x (first s)]\n        (set! s (next s))\n        #js {:value #js [x x] :done false})\n      #js {:value nil :done true})))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2356",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [4887 4894]},
                                           :full-name "cljs.core/SetEntriesIterator",
                                           :removed {:in "0.0-2371",
                                                     :last-seen "0.0-2356"}},
           "cljs.core/loop" {:description "Evaluates the `body-exprs` in a lexical context in which the symbols in\nthe binding-forms are bound to their respective init-exprs, just like a `let` form.\nActs as a `recur` target, which will allow tail-call optimization.",
                             :ns "cljs.core",
                             :name "loop",
                             :signature ["[[& bindings] & body-exprs]"],
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :related ["special/recur"],
                             :full-name-encode "cljs.core/loop",
                             :source {:code "(core/defmacro loop\n  [bindings & body]\n  (assert-args loop\n    (vector? bindings) \"a vector for its binding\"\n    (even? (count bindings)) \"an even number of forms in binding vector\")\n  (core/let [db (destructure bindings)]\n    (if (= db bindings)\n      `(loop* ~bindings ~@body)\n      (core/let [vs (take-nth 2 (drop 1 bindings))\n                 bs (take-nth 2 bindings)\n                 gs (map (core/fn [b] (if (core/symbol? b) b (gensym))) bs)\n                 bfs (reduce (core/fn [ret [b v g]]\n                               (if (core/symbol? b)\n                                 (conj ret g v)\n                                 (conj ret g v b g)))\n                       [] (map core/vector bs vs gs))]\n        `(let ~bfs\n           (loop* ~(vec (interleave gs gs))\n             (let ~(vec (interleave bs gs))\n               ~@body)))))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/clojure/cljs/core.cljc",
                                      :lines [732 754]},
                             :examples [{:id "60291e",
                                         :content "```clj\n(loop [x 0]\n  (when (< x 10)\n    (println x)\n    (recur (+ x 2))))\n;; Prints:\n;; 0\n;; 2\n;; 4\n;; 6\n;; 8\n;;\n;;=> nil\n```"}],
                             :full-name "cljs.core/loop",
                             :clj-symbol "clojure.core/loop",
                             :docstring "Evaluates the exprs in a lexical context in which the symbols in\nthe binding-forms are bound to their respective init-exprs or parts\ntherein. Acts as a recur target."},
           "cljs.core/subvec" {:description "Returns a persistent vector of the items in `v` from `start` inclusive to `end`\nexclusive.\n\nIf `end` is not supplied, defaults to `(count v)`.\n\nThis operation is O(1) and very fast, as the resulting vector shares structure\nwith the original and no trimming is done.",
                               :ns "cljs.core",
                               :name "subvec",
                               :signature ["[v start]"
                                           "[v start end]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/vector"
                                         "cljs.core/vector?"],
                               :full-name-encode "cljs.core/subvec",
                               :source {:code "(defn subvec\n  ([v start]\n     (subvec v start (count v)))\n  ([v start end]\n     (build-subvec nil v start end nil)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [5164 5173]},
                               :full-name "cljs.core/subvec",
                               :clj-symbol "clojure.core/subvec",
                               :docstring "Returns a persistent vector of the items in vector from\nstart (inclusive) to end (exclusive).  If end is not supplied,\ndefaults to (count vector). This operation is O(1) and very fast, as\nthe resulting vector shares structure with the original and no\ntrimming is done."},
           "cljs.repl.browser/mime-type->encoding" {:ns "cljs.repl.browser",
                                                    :name "mime-type->encoding",
                                                    :type "var",
                                                    :source {:code "(def mime-type->encoding\n  {\"text/html\" \"UTF-8\"\n   \"text/css\" \"UTF-8\"\n   \"image/jpeg\" \"ISO-8859-1\"\n   \"image/png\" \"ISO-8859-1\"\n   \"image/gif\" \"ISO-8859-1\"\n   \"text/javascript\" \"UTF-8\"\n   \"text/x-clojure\" \"UTF-8\"\n   \"application/json\" \"UTF-8\"})",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r1.7.228",
                                                             :filename "src/main/clojure/cljs/repl/browser.clj",
                                                             :lines [44
                                                                     52]},
                                                    :full-name "cljs.repl.browser/mime-type->encoding",
                                                    :full-name-encode "cljs.repl.browser/mime-type-GTencoding",
                                                    :history [["+"
                                                               "0.0-3297"]]},
           "cljs.core/bit-clear" {:description "Clear bit at index `n`.  Same as `x & ~(1 << y)` in JavaScript.",
                                  :ns "cljs.core",
                                  :name "bit-clear",
                                  :signature ["[x n]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function/macro",
                                  :related ["cljs.core/bit-set"
                                            "cljs.core/bit-flip"],
                                  :full-name-encode "cljs.core/bit-clear",
                                  :source {:code "(defn bit-clear\n  [x n]\n  (cljs.core/bit-clear x n))",
                                           :title "Function code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [2532 2535]},
                                  :extra-sources [{:code "(core/defmacro ^::ana/numeric bit-clear [x n]\n  (core/list 'js* \"(~{} & ~(1 << ~{}))\" x n))",
                                                   :title "Macro code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/clojure/cljs/core.cljc",
                                                   :lines [1119 1120]}],
                                  :examples [{:id "0f6748",
                                              :content "Bits can be entered using radix notation:\n\n```clj\n(bit-clear 2r1111 2)\n;;=> 11\n;; 11 = 2r1011\n```\n\nSame numbers in decimal:\n\n```clj\n(bit-clear 15 2)\n;;=> 11\n```"}],
                                  :full-name "cljs.core/bit-clear",
                                  :clj-symbol "clojure.core/bit-clear",
                                  :docstring "Clear bit at index n"},
           "syntax/Math-namespace" {:description "A special namespace for direct access to the native JavaScript [Math library].\n\n`Math/foo` => `js/Math.foo`\n\n[Math library]:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math",
                                    :ns "syntax",
                                    :name "Math-namespace",
                                    :history [["+" "0.0-927"]],
                                    :type "special namespace",
                                    :related ["syntax/js-namespace"],
                                    :full-name-encode "syntax/Math-namespace",
                                    :usage ["Math/foo"],
                                    :examples [{:id "9cfeb0",
                                                :content "Math constants:\n\n```clj\nMath/E\n;;=> 2.718281828459045\n\nMath/PI\n;;=> 3.141592653589793\n\nMath/SQRT2\n;;=> 1.4142135623730951\n```\n\nMath functions:\n\n```clj\n(Math/cos 0)\n;;=> 1\n\n(Math/atan2 1 0)\n;;=> 1.5707963267948966\n\n(Math/log Math/E)\n;;=> 1\n\n(Math/pow 2 5)\n;;=> 32\n\n(Math/pow Math/E (Math/log 1))\n;;=> 1\n```"}],
                                    :full-name "syntax/Math-namespace",
                                    :display "Math/ namespace",
                                    :clj-doc "http://clojure.org/java_interop#toc6"},
           "cljs.repl/apropos" {:description "Given a regular expression or stringable thing, return a seq of all\npublic definitions in all currently-loaded namespaces that match the\n`str-or-pattern`.",
                                :ns "cljs.repl",
                                :name "apropos",
                                :signature ["[str-or-pattern]"],
                                :history [["+" "0.0-2985"]],
                                :type "macro",
                                :related ["cljs.repl/find-doc"],
                                :full-name-encode "cljs.repl/apropos",
                                :source {:code "(defmacro apropos\n  [str-or-pattern]\n  (let [matches? (if (instance? Pattern str-or-pattern)\n                   #(re-find str-or-pattern (str %))\n                   #(.contains (str %) (str str-or-pattern)))]\n    `(quote\n       ~(sort\n          (mapcat\n            (fn [ns]\n              (let [ns-name (str ns)]\n                (map #(symbol ns-name (str %))\n                  (filter matches? (keys (ana-api/ns-publics ns))))))\n            (ana-api/all-ns))))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/clojure/cljs/repl.cljc",
                                         :lines [1251 1266]},
                                :examples [{:id "aceda4",
                                            :content "```clj\n(apropos \"some\")\n;;=> (cljs.core/if-some\n;;    cljs.core/some\n;;    cljs.core/some->\n;;    cljs.core/some->>\n;;    cljs.core/some-fn\n;;    cljs.core/some?\n;;    cljs.core/when-some)\n```"}],
                                :full-name "cljs.repl/apropos",
                                :clj-symbol "clojure.repl/apropos",
                                :docstring "Given a regular expression or stringable thing, return a seq of all\npublic definitions in all currently-loaded namespaces that match the\nstr-or-pattern."},
           "cljs.core/gensym" {:ns "cljs.core",
                               :name "gensym",
                               :signature ["[]" "[prefix-string]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/gensym",
                               :source {:code "(defn gensym\n  ([] (gensym \"G__\"))\n  ([prefix-string]\n     (when (nil? gensym_counter)\n       (set! gensym_counter (atom 0)))\n     (symbol (str prefix-string (swap! gensym_counter inc)))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [9176 9184]},
                               :full-name "cljs.core/gensym",
                               :clj-symbol "clojure.core/gensym",
                               :docstring "Returns a new symbol with a unique name. If a prefix string is\nsupplied, the name is prefix# where # is some unique number. If\nprefix is not supplied, the prefix is 'G__'."},
           "special/recur" {:ns "special",
                            :name "recur",
                            :signature ["[exprs*]"],
                            :history [["+" "0.0-927"]],
                            :type "special form",
                            :full-name-encode "special/recur",
                            :source {:code "(defmethod parse 'recur\n  [op env [_ & exprs :as form] _ _]\n  (let [context (:context env)\n        frame (first *recur-frames*)\n        exprs (disallowing-recur (vec (map #(analyze (assoc env :context :expr) %) exprs)))]\n    (when-not frame\n      (throw (error env \"Can't recur here\")))\n    (when-not (= (count exprs) (count (:params frame)))\n      (throw (error env \"recur argument count mismatch\")))\n    (reset! (:flag frame) true)\n    (assoc {:env env :op :recur :form form}\n      :frame frame\n      :exprs exprs\n      :children exprs)))",
                                     :title "Parser code",
                                     :repo "clojurescript",
                                     :tag "r1.7.228",
                                     :filename "src/main/clojure/cljs/analyzer.cljc",
                                     :lines [1525 1538]},
                            :full-name "special/recur",
                            :clj-symbol "clojure.core/recur",
                            :docstring "Evaluates the exprs in order, then, in parallel, rebinds\nthe bindings of the recursion point to the values of the exprs.\nExecution then jumps back to the recursion point, a loop or fn method."},
           "cljs.core/Symbol" {:ns "cljs.core",
                               :name "Symbol",
                               :signature ["[ns name str _hash _meta]"],
                               :history [["+" "0.0-1798"]],
                               :type "type",
                               :full-name-encode "cljs.core/Symbol",
                               :source {:code "(deftype Symbol [ns name str ^:mutable _hash _meta]\n  Object\n  (toString [_] str)\n  (equiv [this other] (-equiv this other))\n\n  IEquiv\n  (-equiv [_ other]\n    (if (instance? Symbol other)\n      (identical? str (.-str other))\n      false))\n\n  IFn\n  (-invoke [sym coll]\n    (get coll sym))\n  (-invoke [sym coll not-found]\n    (get coll sym not-found))\n\n  IMeta\n  (-meta [_] _meta)\n\n  IWithMeta\n  (-with-meta [_ new-meta] (Symbol. ns name str _hash new-meta))\n\n  IHash\n  (-hash [sym]\n    (caching-hash sym hash-symbol _hash))\n\n  INamed\n  (-name [_] name)\n  (-namespace [_] ns)\n\n  IPrintWithWriter\n  (-pr-writer [o writer _] (-write writer str)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [934 966]},
                               :full-name "cljs.core/Symbol",
                               :clj-symbol "clojure.lang/Symbol"},
           "cljs.core/hash-string*" {:ns "cljs.core",
                                     :name "hash-string*",
                                     :type "function",
                                     :signature ["[s]"],
                                     :source {:code "(defn hash-string* [s]\n  (if-not (nil? s)\n    (let [len (alength s)]\n      (if (pos? len)\n        (loop [i 0 hash 0]\n          (if (< i len)\n            (recur (inc i) (+ (imul 31 hash) (.charCodeAt s i)))\n            hash))\n        0))\n    0))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/cljs/cljs/core.cljs",
                                              :lines [845 854]},
                                     :full-name "cljs.core/hash-string*",
                                     :full-name-encode "cljs.core/hash-stringSTAR",
                                     :history [["+" "0.0-2261"]]},
           "cljs.core/shuffle" {:description "Returns a random permutation of `coll`.",
                                :ns "cljs.core",
                                :name "shuffle",
                                :signature ["[coll]"],
                                :history [["+" "0.0-1424"]],
                                :type "function",
                                :full-name-encode "cljs.core/shuffle",
                                :source {:code "(defn shuffle\n  [coll]\n  (let [a (to-array coll)]\n    (garray/shuffle a)\n    (vec a)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [2164 2169]},
                                :full-name "cljs.core/shuffle",
                                :clj-symbol "clojure.core/shuffle",
                                :docstring "Return a random permutation of coll"},
           "cljs.core/+" {:description "Returns the sum of nums.\n\n`(+)` returns 0.",
                          :return-type number,
                          :ns "cljs.core",
                          :name "+",
                          :signature ["[]"
                                      "[x]"
                                      "[x y]"
                                      "[x y & more]"],
                          :history [["+" "0.0-927"]],
                          :type "function/macro",
                          :related ["cljs.core/*" "cljs.core/-"],
                          :full-name-encode "cljs.core/PLUS",
                          :source {:code "(defn ^number +\n  ([] 0)\n  ([x] x)\n  ([x y] (cljs.core/+ x y))\n  ([x y & more]\n    (reduce + (cljs.core/+ x y) more)))",
                                   :title "Function code",
                                   :repo "clojurescript",
                                   :tag "r1.7.228",
                                   :filename "src/main/cljs/cljs/core.cljs",
                                   :lines [2259 2265]},
                          :extra-sources [{:code "(core/defmacro ^::ana/numeric +\n  ([] 0)\n  ([x] x)\n  ([x y] (core/list 'js* \"(~{} + ~{})\" x y))\n  ([x y & more] `(+ (+ ~x ~y) ~@more)))",
                                           :title "Macro code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/clojure/cljs/core.cljc",
                                           :lines [957 961]}],
                          :examples [{:id "650668",
                                      :content "```clj\n(+)\n;;=> 0\n\n(+ 1)\n;;=> 1\n\n(+ -10)\n;;=> -10\n\n(+ 1 2)\n;;=> 3\n\n(+ 1 2 3)\n;;=> 6\n```"}],
                          :full-name "cljs.core/+",
                          :clj-symbol "clojure.core/+",
                          :docstring "Returns the sum of nums. (+) returns 0."},
           "cljs.core/clone" {:ns "cljs.core",
                              :name "clone",
                              :signature ["[value]"],
                              :history [["+" "0.0-2134"]],
                              :type "function",
                              :full-name-encode "cljs.core/clone",
                              :source {:code "(defn clone\n  [value]\n  (-clone value))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [1060 1063]},
                              :full-name "cljs.core/clone",
                              :docstring "Clone the supplied value which must implement ICloneable."},
           "cljs.core/comp" {:description "Takes a set of functions and returns a function that is the composition\nof those functions.\n\nThe returned function takes a variable number of arguments, applies the\nrightmost of `fns` to the arguments, whose result is subsequently applied to\nthe next left function, and so on.\n\n`((comp a b c) x y)` = `(a (b (c x y)))`",
                             :ns "cljs.core",
                             :name "comp",
                             :signature ["[& fns]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/partial"
                                       "cljs.core/juxt"],
                             :full-name-encode "cljs.core/comp",
                             :source {:code "(defn comp\n  ([] identity)\n  ([f] f)\n  ([f g]\n     (fn\n       ([] (f (g)))\n       ([x] (f (g x)))\n       ([x y] (f (g x y)))\n       ([x y z] (f (g x y z)))\n       ([x y z & args] (f (apply g x y z args)))))\n  ([f g h]\n     (fn\n       ([] (f (g (h))))\n       ([x] (f (g (h x))))\n       ([x y] (f (g (h x y))))\n       ([x y z] (f (g (h x y z))))\n       ([x y z & args] (f (g (apply h x y z args))))))\n  ([f1 f2 f3 & fs]\n    (let [fs (reverse (list* f1 f2 f3 fs))]\n      (fn [& args]\n        (loop [ret (apply (first fs) args) fs (next fs)]\n          (if fs\n            (recur ((first fs) ret) (next fs))\n            ret))))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [3806 3833]},
                             :examples [{:id "5d3250",
                                         :content "```clj\n(def f (comp str inc +))\n(f 1 2 3)\n;;=> \"7\"\n```"}],
                             :full-name "cljs.core/comp",
                             :clj-symbol "clojure.core/comp",
                             :docstring "Takes a set of functions and returns a fn that is the composition\nof those fns.  The returned fn takes a variable number of args,\napplies the rightmost of fns to the args, the next\nfn (right-to-left) to the result, etc."},
           "cljs.core/ArrayIter" {:ns "cljs.core",
                                  :name "ArrayIter",
                                  :signature ["[arr i]"],
                                  :history [["+" "0.0-2301"]],
                                  :type "type",
                                  :full-name-encode "cljs.core/ArrayIter",
                                  :source {:code "(deftype ArrayIter [arr ^:mutable i]\n  Object\n  (hasNext [_] (< i (alength arr)))\n  (next [_]\n    (let [ret (aget arr i)]\n      (set! i (inc i))\n      ret))\n  (remove [_] (js/Error. \"Unsupported operation\")))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [3540 3547]},
                                  :full-name "cljs.core/ArrayIter",
                                  :clj-symbol "clojure.lang/ArrayIter"},
           "syntax/comma" {:description "A comma is treated as whitespace when appearing outside a string.\n\nThis is mainly used to help delineate elements in a collection when necessary.\n\nCommas are used when printing maps in the REPL:\n\n```clj\n{:foo 1, :bar 2, :bar 3}\n```",
                           :ns "syntax",
                           :name "comma",
                           :history [["+" "0.0-927"]],
                           :type "special character",
                           :full-name-encode "syntax/comma",
                           :examples [{:id "68e4a0",
                                       :content "```clj\n[1, 2, 3, 4]\n;;=> [1 2 3 4]\n\n{:foo :bar :baz :quux}\n;;=> {:foo :bar, :baz :quux}\n```"}],
                           :edn-doc "https://github.com/edn-format/edn#general-considerations",
                           :full-name "syntax/comma",
                           :display ", comma",
                           :clj-doc "http://clojure.org/cheatsheet"},
           "cljs.core/var?" {:return-type boolean,
                             :ns "cljs.core",
                             :name "var?",
                             :signature ["[v]"],
                             :history [["+" "0.0-3255"]],
                             :type "function",
                             :full-name-encode "cljs.core/varQMARK",
                             :source {:code "(defn ^boolean var?\n  [v]\n  (instance? cljs.core.Var v))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [1046 1049]},
                             :full-name "cljs.core/var?",
                             :clj-symbol "clojure.core/var?",
                             :docstring "Returns true if v is of type cljs.core.Var"},
           "cljs.reader/desugar-meta" {:ns "cljs.reader",
                                       :name "desugar-meta",
                                       :type "function",
                                       :signature ["[f]"],
                                       :source {:code "(defn desugar-meta\n  [f]\n  (cond\n   (symbol? f) {:tag f}\n   (string? f) {:tag f}\n   (keyword? f) {f true}\n   :else f))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/cljs/reader.cljs",
                                                :lines [368 374]},
                                       :full-name "cljs.reader/desugar-meta",
                                       :full-name-encode "cljs.reader/desugar-meta",
                                       :history [["+" "0.0-927"]]},
           "cljs.repl/load-namespace" {:ns "cljs.repl",
                                       :name "load-namespace",
                                       :signature ["[repl-env ns]"
                                                   "[repl-env ns opts]"],
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "cljs.repl/load-namespace",
                                       :source {:code "(defn load-namespace\n  ([repl-env ns] (load-namespace repl-env ns nil))\n  ([repl-env ns opts]\n   (let [ns (if (and (seq? ns)\n                     (= (first ns) 'quote))\n               (second ns)\n               ns)\n         ;; TODO: add pre-condition to source-on-disk, the\n         ;; source must supply at least :url - David\n         sources (cljsc/add-dependencies\n                   (merge (env->opts repl-env) opts)\n                   {:requires [(name ns)]\n                    :type :seed\n                    :url (:uri (cljsc/source-for-namespace\n                                 ns env/*compiler*))})\n         deps (->> sources\n                (remove (comp #{[\"goog\"]} :provides))\n                (remove (comp #{:seed} :type))\n                (map #(select-keys % [:provides :url])))]\n     (if (:output-dir opts)\n       ;; REPLs that read from :output-dir just need to add deps,\n       ;; environment will handle actual loading - David\n       (let [sb (StringBuffer.)]\n         (doseq [source (->> sources\n                          (remove (comp #{:seed} :type))\n                          (map #(cljsc/source-on-disk opts %)))]\n           (when (:repl-verbose opts)\n             (println \"Loading:\" (:provides source)))\n           (.append sb (cljsc/add-dep-string opts source)))\n         (-evaluate repl-env \"<cljs repl>\" 1 (.toString sb)))\n       ;; REPLs that stream must manually load each dep - David\n       (doseq [{:keys [url provides]} deps]\n         (-load repl-env provides url))))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/clojure/cljs/repl.cljc",
                                                :lines [167 202]},
                                       :full-name "cljs.repl/load-namespace",
                                       :docstring "Load a namespace and all of its dependencies into the evaluation environment.\nThe environment is responsible for ensuring that each namespace is loaded once and\nonly once."},
           "cljs.pprint/fresh-line" {:ns "cljs.pprint",
                                     :name "fresh-line",
                                     :signature ["[]"],
                                     :history [["+" "0.0-3255"]],
                                     :type "function",
                                     :full-name-encode "cljs.pprint/fresh-line",
                                     :source {:code "(defn fresh-line\n  []\n  (if (satisfies? IDeref *out*)\n    (if (not (= 0 (get-column (:base @@*out*))))\n      (prn))\n    (prn)))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/cljs/cljs/pprint.cljs",
                                              :lines [2093 2100]},
                                     :full-name "cljs.pprint/fresh-line",
                                     :clj-symbol "clojure.pprint/fresh-line",
                                     :docstring "Make a newline if *out* is not already at the beginning of the line. If *out* is\nnot a pretty writer (which keeps track of columns), this function always outputs a newline."},
           "cljs.repl.rhino/wrap-fn" {:ns "cljs.repl.rhino",
                                      :name "wrap-fn",
                                      :type "function",
                                      :signature ["[form]"],
                                      :source {:code "(defn wrap-fn [form]\n  (cond\n    (and (seq? form) (= 'ns (first form))) identity\n    ('#{*1 *2 *3 *e} form) (fn [x] `(cljs.core.pr-str ~x))\n    :else\n    (fn [x]\n      `(cljs.core.pr-str\n         (let [ret# ~x]\n           (set! *3 *2)\n           (set! *2 *1)\n           (set! *1 ret#)\n           ret#)))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/clojure/cljs/repl/rhino.clj",
                                               :lines [160 171]},
                                      :full-name "cljs.repl.rhino/wrap-fn",
                                      :full-name-encode "cljs.repl.rhino/wrap-fn",
                                      :history [["+" "0.0-2985"]]},
           "cljs.core/pr" {:ns "cljs.core",
                           :name "pr",
                           :signature ["[& objs]"],
                           :history [["+" "0.0-927"]],
                           :type "function",
                           :full-name-encode "cljs.core/pr",
                           :source {:code "(defn pr\n  [& objs]\n  (pr-with-opts objs (pr-opts)))",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r1.7.228",
                                    :filename "src/main/cljs/cljs/core.cljs",
                                    :lines [8941 8947]},
                           :full-name "cljs.core/pr",
                           :clj-symbol "clojure.core/pr",
                           :docstring "Prints the object(s) using string-print.  Prints the\nobject(s), separated by spaces if there is more than one.\nBy default, pr and prn print in a way that objects can be\nread by the reader"},
           "cljs.test/run-tests" {:ns "cljs.test",
                                  :name "run-tests",
                                  :signature ["[]"
                                              "[env-or-ns]"
                                              "[env-or-ns & namespaces]"],
                                  :history [["+" "0.0-2496"]],
                                  :type "macro",
                                  :full-name-encode "cljs.test/run-tests",
                                  :source {:code "(defmacro run-tests\n  ([] `(run-tests (cljs.test/empty-env) '~ana/*cljs-ns*))\n  ([env-or-ns]\n   (if (ns? env-or-ns)\n     `(run-tests (cljs.test/empty-env) ~env-or-ns)\n     `(run-tests ~env-or-ns '~ana/*cljs-ns*)))\n  ([env-or-ns & namespaces]\n   `(cljs.test/run-block (run-tests-block ~env-or-ns ~@namespaces))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/test.clj",
                                           :lines [283 295]},
                                  :full-name "cljs.test/run-tests",
                                  :clj-symbol "clojure.test/run-tests",
                                  :docstring "Runs all tests in the given namespaces; prints results.\nDefaults to current namespace if none given. Does not return a meaningful\nvalue due to the possiblity of asynchronous execution. To detect test\ncompletion add a :end-run-tests method case to the cljs.test/report\nmultimethod."},
           "clojure.string/upper-case" {:description "Converts string to all upper-case.",
                                        :ns "clojure.string",
                                        :name "upper-case",
                                        :signature ["[s]"],
                                        :history [["+" "0.0-927"]],
                                        :type "function",
                                        :full-name-encode "clojure.string/upper-case",
                                        :source {:code "(defn upper-case\n  [s]\n  (.toUpperCase s))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/cljs/clojure/string.cljs",
                                                 :lines [85 88]},
                                        :full-name "clojure.string/upper-case",
                                        :clj-symbol "clojure.string/upper-case",
                                        :docstring "Converts string to all upper-case."},
           "cljs.core/chars" {:ns "cljs.core",
                              :name "chars",
                              :signature ["[x]"],
                              :history [["+" "0.0-1798"]],
                              :type "function",
                              :full-name-encode "cljs.core/chars",
                              :source {:code "(defn chars [x] x)",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [2479]},
                              :full-name "cljs.core/chars",
                              :clj-symbol "clojure.core/chars"},
           "cljs.analyzer.api/find-ns" {:ns "cljs.analyzer.api",
                                        :name "find-ns",
                                        :signature ["[sym]"
                                                    "[state sym]"],
                                        :history [["+" "0.0-2496"]],
                                        :type "function",
                                        :full-name-encode "cljs.analyzer.api/find-ns",
                                        :source {:code "(defn find-ns\n  ([sym]\n   (find-ns env/*compiler* sym))\n  ([state sym]\n   {:pre [(symbol? sym)]}\n   (get-in @state [::ana/namespaces sym])))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/clojure/cljs/analyzer/api.clj",
                                                 :lines [160 167]},
                                        :full-name "cljs.analyzer.api/find-ns",
                                        :clj-symbol "clojure.core/find-ns",
                                        :docstring "Given a namespace return the corresponding namespace analysis map. Analagous\nto clojure.core/find-ns."},
           "syntax/string" {:description "Create a string.  ClojureScript strings are the same as [JavaScript strings].\n\n[JavaScript strings]:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String\n\nStrings may span multiple lines.\n\nStandard escape characters such as `\\\"` are supported, as well as unicode\nescape characters:\n\n| unicode characters  | constraints                                   |\n|---------------------|-----------------------------------------------|\n| `\\uXXXX`            | XXXX must have 4 digits outside 0xD7FF-0xE000 |\n| `\\oXXX`             | XXX is octal between 0 and 0377               |",
                            :ns "syntax",
                            :name "string",
                            :history [["+" "0.0-927"]],
                            :type "syntax",
                            :related ["cljs.core/str"],
                            :full-name-encode "syntax/string",
                            :extra-sources ({:code "(defn- read-string*\n  [reader _ opts pending-forms]\n  (loop [sb (StringBuilder.)\n         ch (read-char reader)]\n    (case ch\n      nil (reader-error reader \"EOF while reading string\")\n      \\\\ (recur (doto sb (.append (escape-char sb reader)))\n                (read-char reader))\n      \\\" (str sb)\n      (recur (doto sb (.append ch)) (read-char reader)))))",
                                             :title "Reader code",
                                             :repo "tools.reader",
                                             :tag "tools.reader-1.0.0-alpha1",
                                             :filename "src/main/clojure/clojure/tools/reader.clj",
                                             :lines [292 301]}
                                            {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                             :title "Reader table",
                                             :repo "tools.reader",
                                             :tag "tools.reader-1.0.0-alpha1",
                                             :filename "src/main/clojure/clojure/tools/reader.clj",
                                             :lines [743 762]}),
                            :usage ["\"...\""],
                            :examples [{:id "eb97ac",
                                        :content "```clj\n\"foo\"\n;;=> \"foo\"\n\n\"hello\n     world\"\n;;=> \"hello\\n     world\"\n```\n\nCharacters can be escaped:\n\n```clj\n(println \"foo\\nbar\")\n;; prints:\n;;   foo\n;;   bar\n```"}],
                            :edn-doc "https://github.com/edn-format/edn#strings",
                            :full-name "syntax/string",
                            :display "\"\" string",
                            :clj-doc "http://clojure.org/reader#toc1"},
           "clojure.browser.event/expose" {:ns "clojure.browser.event",
                                           :name "expose",
                                           :type "function",
                                           :signature ["[e]"],
                                           :source {:code "(defn expose [e]\n  (events/expose e))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.7.228",
                                                    :filename "src/main/cljs/clojure/browser/event.cljs",
                                                    :lines [81 82]},
                                           :full-name "clojure.browser.event/expose",
                                           :full-name-encode "clojure.browser.event/expose",
                                           :history [["+" "0.0-927"]]},
           "clojure.browser.event/listen-once" {:ns "clojure.browser.event",
                                                :name "listen-once",
                                                :type "function",
                                                :signature ["[src type fn]"
                                                            "[src type fn capture?]"],
                                                :source {:code "(defn listen-once\n  ([src type fn]\n     (listen-once src type fn false))\n  ([src type fn capture?]\n     (events/listenOnce src\n                        (get (event-types src) type type)\n                        fn\n                        capture?)))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1.7.228",
                                                         :filename "src/main/cljs/clojure/browser/event.cljs",
                                                         :lines [55
                                                                 62]},
                                                :full-name "clojure.browser.event/listen-once",
                                                :full-name-encode "clojure.browser.event/listen-once",
                                                :history [["+"
                                                           "0.0-927"]]},
           "cljs.core/m3-C1" {:ns "cljs.core",
                              :name "m3-C1",
                              :type "var",
                              :source {:code "(def m3-C1 (int 0xcc9e2d51))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [797]},
                              :full-name "cljs.core/m3-C1",
                              :full-name-encode "cljs.core/m3-C1",
                              :history [["+" "0.0-2261"]]},
           "cljs.core/empty?" {:description "Returns true if `coll` has no items - same as `(not (seq coll))`.\n\nPlease use the idiom `(seq x)` rather than `(not (empty? x))`.",
                               :return-type boolean,
                               :ns "cljs.core",
                               :name "empty?",
                               :signature ["[coll]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/seq"],
                               :full-name-encode "cljs.core/emptyQMARK",
                               :source {:code "(defn ^boolean empty?\n  [coll] (or (nil? coll)\n             (not (seq coll))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [1883 1887]},
                               :full-name "cljs.core/empty?",
                               :clj-symbol "clojure.core/empty?",
                               :docstring "Returns true if coll has no items - same as (not (seq coll)).\nPlease use the idiom (seq x) rather than (not (empty? x))"},
           "cljs.core/m3-fmix" {:return-type number,
                                :ns "cljs.core",
                                :name "m3-fmix",
                                :signature ["[h1 len]"],
                                :history [["+" "0.0-2261"]],
                                :type "function",
                                :full-name-encode "cljs.core/m3-fmix",
                                :source {:code "(defn ^number m3-fmix [h1 len]\n  (as-> (int h1) h1\n    (bit-xor h1 len)\n    (bit-xor h1 (unsigned-bit-shift-right h1 16))\n    (imul h1 (int 0x85ebca6b))\n    (bit-xor h1 (unsigned-bit-shift-right h1 13))\n    (imul h1 (int 0xc2b2ae35))\n    (bit-xor h1 (unsigned-bit-shift-right h1 16))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [806 813]},
                                :full-name "cljs.core/m3-fmix"},
           "cljs.core/newline" {:ns "cljs.core",
                                :name "newline",
                                :signature ["[]" "[opts]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/newline",
                                :source {:code "(defn newline\n  ([] (newline nil))\n  ([opts]\n   (string-print \"\\n\")\n   (when (get opts :flush-on-newline)\n     (flush))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [8924 8929]},
                                :full-name "cljs.core/newline",
                                :clj-symbol "clojure.core/newline"},
           "cljs.core/PersistentHashMap" {:ns "cljs.core",
                                          :name "PersistentHashMap",
                                          :signature ["[meta cnt root has-nil? nil-val __hash]"],
                                          :history [["+" "0.0-1211"]],
                                          :type "type",
                                          :full-name-encode "cljs.core/PersistentHashMap",
                                          :source {:code "(deftype PersistentHashMap [meta cnt root ^boolean has-nil? nil-val ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  ;; EXPERIMENTAL: subject to change\n  (keys [coll]\n    (es6-iterator (keys coll)))\n  (entries [coll]\n    (es6-entries-iterator (seq coll)))\n  (values [coll]\n    (es6-iterator (vals coll)))\n  (has [coll k]\n    (contains? coll k))\n  (get [coll k not-found]\n    (-lookup coll k not-found))\n  (forEach [coll f]\n    (doseq [[k v] coll]\n      (f v k)))\n\n  ICloneable\n  (-clone [_] (PersistentHashMap. meta cnt root has-nil? nil-val __hash))\n\n  IIterable\n  (-iterator [coll]\n    (let [root-iter (if ^boolean root (-iterator root) nil-iter)]\n      (if has-nil?\n        (HashMapIter. nil-val root-iter false)\n        root-iter)))\n\n  IWithMeta\n  (-with-meta [coll meta] (PersistentHashMap. meta cnt root has-nil? nil-val __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (loop [ret coll es (seq entry)]\n        (if (nil? es)\n          ret\n          (let [e (first es)]\n            (if (vector? e)\n              (recur (-assoc ret (-nth e 0) (-nth e 1))\n                     (next es))\n              (throw (js/Error. \"conj on a map takes map entries or seqables of map entries\"))))))))\n\n  IEmptyableCollection\n  (-empty [coll] (-with-meta (.-EMPTY PersistentHashMap) meta))\n\n  IEquiv\n  (-equiv [coll other] (equiv-map coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-unordered-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (when (pos? cnt)\n      (let [s (if-not (nil? root) (.inode-seq root))]\n        (if has-nil?\n          (cons [nil nil-val] s)\n          s))))\n\n  ICounted\n  (-count [coll] cnt)\n\n  ILookup\n  (-lookup [coll k]\n    (-lookup coll k nil))\n\n  (-lookup [coll k not-found]\n    (cond (nil? k)    (if has-nil?\n                        nil-val\n                        not-found)\n          (nil? root) not-found\n          :else       (.inode-lookup root 0 (hash k) k not-found)))\n\n  IAssociative\n  (-assoc [coll k v]\n    (if (nil? k)\n      (if (and has-nil? (identical? v nil-val))\n        coll\n        (PersistentHashMap. meta (if has-nil? cnt (inc cnt)) root true v nil))\n      (let [added-leaf? (Box. false)\n            new-root    (-> (if (nil? root)\n                              (.-EMPTY BitmapIndexedNode)\n                              root)\n                            (.inode-assoc 0 (hash k) k v added-leaf?))]\n        (if (identical? new-root root)\n          coll\n          (PersistentHashMap. meta (if ^boolean (.-val added-leaf?) (inc cnt) cnt) new-root has-nil? nil-val nil)))))\n\n  (-contains-key? [coll k]\n    (cond (nil? k)    has-nil?\n          (nil? root) false\n          :else       (not (identical? (.inode-lookup root 0 (hash k) k lookup-sentinel)\n                                       lookup-sentinel))))\n\n  IMap\n  (-dissoc [coll k]\n    (cond (nil? k)    (if has-nil?\n                        (PersistentHashMap. meta (dec cnt) root false nil nil)\n                        coll)\n          (nil? root) coll\n          :else\n          (let [new-root (.inode-without root 0 (hash k) k)]\n            (if (identical? new-root root)\n              coll\n              (PersistentHashMap. meta (dec cnt) new-root has-nil? nil-val nil)))))\n\n  IKVReduce\n  (-kv-reduce [coll f init]\n    (let [init (if has-nil? (f init nil nil-val) init)]\n      (cond\n        (reduced? init)          @init\n        (not (nil? root)) (.kv-reduce root f init)\n        :else                    init)))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found))\n\n  IEditableCollection\n  (-as-transient [coll]\n    (TransientHashMap. (js-obj) root cnt has-nil? nil-val)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/cljs/cljs/core.cljs",
                                                   :lines [6807 6939]},
                                          :full-name "cljs.core/PersistentHashMap",
                                          :clj-symbol "clojure.lang/PersistentHashMap"},
           "cljs.pprint/pprint-set" {:ns "cljs.pprint",
                                     :name "pprint-set",
                                     :type "var",
                                     :source {:code "(def pprint-set (formatter-out \"~<#{~;~@{~w~^ ~:_~}~;}~:>\"))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/cljs/cljs/pprint.cljs",
                                              :lines [2860]},
                                     :full-name "cljs.pprint/pprint-set",
                                     :full-name-encode "cljs.pprint/pprint-set",
                                     :history [["+" "0.0-3255"]]},
           "cljs.pprint/deftype" {:ns "cljs.pprint",
                                  :name "deftype",
                                  :type "macro",
                                  :signature ["[type-name & fields]"],
                                  :source {:code "(defmacro deftype\n  [type-name & fields]\n  (let [name-str (name type-name)\n        fields (map (comp symbol name) fields)]\n    `(do\n       (defrecord ~type-name [~'type-tag ~@fields])\n       (defn- ~(symbol (str \"make-\" name-str))\n         ~(vec fields)\n         (~(symbol (str type-name \".\")) ~(keyword name-str) ~@fields))\n       (defn- ~(symbol (str name-str \"?\")) [x#] (= (:type-tag x#) ~(keyword name-str))))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/pprint.clj",
                                           :lines [39 48]},
                                  :full-name "cljs.pprint/deftype",
                                  :full-name-encode "cljs.pprint/deftype",
                                  :history [["+" "0.0-3255"]]},
           "cljs.core/replace" {:description "Given a map of replacement pairs `smap` and a vector/collection `coll`, returns\na vector/seq with any elements `=` to a key in `smap` replaced with the\ncorresponding val in `smap`.\n\nReturns a transducer when `coll` is not provided.",
                                :ns "cljs.core",
                                :name "replace",
                                :signature ["[smap]" "[smap coll]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/map"
                                          "clojure.walk/prewalk-replace"
                                          "clojure.walk/postwalk-replace"],
                                :full-name-encode "cljs.core/replace",
                                :source {:code "(defn replace\n  ([smap]\n     (map #(if-let [e (find smap %)] (val e) %)))\n  ([smap coll]\n     (if (vector? coll)\n       (let [n (count coll)]\n         (reduce (fn [v i]\n                   (if-let [e (find smap (nth v i))]\n                     (assoc v i (second e))\n                     v))\n           coll (take n (iterate inc 0))))\n       (map #(if-let [e (find smap %)] (second e) %) coll))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [8246 8261]},
                                :full-name "cljs.core/replace",
                                :clj-symbol "clojure.core/replace",
                                :docstring "Given a map of replacement pairs and a vector/collection, returns a\nvector/seq with any elements = a key in smap replaced with the\ncorresponding val in smap.  Returns a transducer when no collection\nis provided."},
           "cljs.core/rand" {:description "Returns a random floating point number between 0 inclusive and `n` exclusive.\n\n`n` defaults to 1.",
                             :ns "cljs.core",
                             :name "rand",
                             :signature ["[]" "[n]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/rand-int"
                                       "cljs.core/rand-nth"],
                             :full-name-encode "cljs.core/rand",
                             :source {:code "(defn rand\n  ([] (rand 1))\n  ([n] (* (Math/random) n)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [9401 9405]},
                             :full-name "cljs.core/rand",
                             :clj-symbol "clojure.core/rand",
                             :docstring "Returns a random floating point number between 0 (inclusive) and\nn (default 1) (exclusive)."},
           "cljs.core/add-watch" {:description "Adds a watch function `f` to atom `a` that will execute when the value of `a`\nchanges.\n\nThe watch function takes 4 arguments: a key, the atom, its old state, and its\nnew state.\n\n`key` should be a keyword and can be used with `remove-watch` to remove the\nwatch function.",
                                  :ns "cljs.core",
                                  :name "add-watch",
                                  :signature ["[a key f]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/remove-watch"],
                                  :full-name-encode "cljs.core/add-watch",
                                  :source {:code "(defn add-watch\n  [iref key f]\n  (-add-watch iref key f)\n  iref)",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [9141 9162]},
                                  :examples [{:id "2f2fe0",
                                              :content "```clj\n(def a (atom {}))\n\n(add-watch a :logger\n  (fn [_key _atom old-state new-state]\n    (println \"old:\" old-state)\n    (println \"new:\" new-state)))\n\n(swap! a assoc :foo \"bar\")\n;;=> will print the following:\n;; old: {}\n;; new: {:foo \"bar\"}\n```"}],
                                  :full-name "cljs.core/add-watch",
                                  :clj-symbol "clojure.core/add-watch",
                                  :docstring "Adds a watch function to an atom reference. The watch fn must be a\nfn of 4 args: a key, the reference, its old-state, its\nnew-state. Whenever the reference's state might have been changed,\nany registered watches will have their functions called. The watch\nfn will be called synchronously. Note that an atom's state\nmay have changed again prior to the fn call, so use old/new-state\nrather than derefing the reference. Keys must be unique per\nreference, and can be used to remove the watch with remove-watch,\nbut are otherwise considered opaque by the watch mechanism.  Bear in\nmind that regardless of the result or action of the watch fns the\natom's value will change.  Example:\n\n    (def a (atom 0))\n    (add-watch a :inc (fn [k r o n] (assert (== 0 n))))\n    (swap! a inc)\n    ;; Assertion Error\n    (deref a)\n    ;=> 1"},
           "cljs.repl.rhino/loaded-libs" {:ns "cljs.repl.rhino",
                                          :name "loaded-libs",
                                          :type "var",
                                          :source {:code "(def loaded-libs (atom #{}))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1552",
                                                   :filename "src/clj/cljs/repl/rhino.clj",
                                                   :lines [20]},
                                          :full-name "cljs.repl.rhino/loaded-libs",
                                          :full-name-encode "cljs.repl.rhino/loaded-libs",
                                          :history [["+" "0.0-927"]
                                                    ["-" "0.0-1576"]],
                                          :removed {:in "0.0-1576",
                                                    :last-seen "0.0-1552"}},
           "cljs.core/cloneable?" {:return-type boolean,
                                   :ns "cljs.core",
                                   :name "cloneable?",
                                   :signature ["[value]"],
                                   :history [["+" "0.0-2156"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/cloneableQMARK",
                                   :source {:code "(defn ^boolean cloneable?\n  [value]\n  (satisfies? ICloneable value))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [1065 1068]},
                                   :full-name "cljs.core/cloneable?",
                                   :docstring "Return true if x implements ICloneable protocol."},
           "clojure.string/capitalize" {:description "Converts first character of the string to upper-case, all other characters to\nlower-case.",
                                        :ns "clojure.string",
                                        :name "capitalize",
                                        :signature ["[s]"],
                                        :history [["+" "0.0-927"]],
                                        :type "function",
                                        :full-name-encode "clojure.string/capitalize",
                                        :source {:code "(defn capitalize\n  [s]\n  (if (< (count s) 2)\n    (upper-case s)\n    (str (upper-case (subs s 0 1))\n         (lower-case (subs s 1)))))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/cljs/clojure/string.cljs",
                                                 :lines [95 102]},
                                        :full-name "clojure.string/capitalize",
                                        :clj-symbol "clojure.string/capitalize",
                                        :docstring "Converts first character of the string to upper-case, all other\ncharacters to lower-case."},
           "cljs.core/short" {:return-type number,
                              :ns "cljs.core",
                              :name "short",
                              :signature ["[x]"],
                              :history [["+" "0.0-1798"]],
                              :type "function/macro",
                              :full-name-encode "cljs.core/short",
                              :source {:code "(defn ^number short [x] x)",
                                       :title "Function code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [2366]},
                              :extra-sources [{:code "(core/defmacro short [x] x)",
                                               :title "Macro code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/clojure/cljs/core.cljc",
                                               :lines [964]}],
                              :full-name "cljs.core/short",
                              :clj-symbol "clojure.core/short"},
           "cljs.core/replicate" {:ns "cljs.core",
                                  :name "replicate",
                                  :signature ["[n x]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/replicate",
                                  :source {:code "(defn replicate\n  [n x] (take n (repeat x)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [4350 4352]},
                                  :full-name "cljs.core/replicate",
                                  :clj-symbol "clojure.core/replicate",
                                  :docstring "Returns a lazy seq of n xs."},
           "cljs.core/es6-entries-iterator" {:ns "cljs.core",
                                             :name "es6-entries-iterator",
                                             :type "function",
                                             :signature ["[coll]"],
                                             :source {:code "(defn es6-entries-iterator [coll]\n  (ES6EntriesIterator. (seq coll)))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.7.228",
                                                      :filename "src/main/cljs/cljs/core.cljs",
                                                      :lines [5682
                                                              5683]},
                                             :full-name "cljs.core/es6-entries-iterator",
                                             :full-name-encode "cljs.core/es6-entries-iterator",
                                             :history [["+"
                                                        "0.0-2371"]]},
           "special/do" {:ns "special",
                         :name "do",
                         :signature ["[exprs*]"],
                         :history [["+" "0.0-927"]],
                         :type "special form",
                         :full-name-encode "special/do",
                         :source {:code "(defmethod parse 'do\n  [op env [_ & exprs :as form] _ _]\n  (let [statements (analyze-do-statements env exprs)]\n    (if (<= (count exprs) 1)\n      (let [ret      (analyze env (first exprs))\n            children (conj (vec statements) ret)]\n        {:op :do\n         :env env\n         :form form\n         :statements statements :ret ret\n         :children children})\n      (let [ret-env  (if (= :statement (:context env))\n                       (assoc env :context :statement)\n                       (assoc env :context :return))\n            ret      (analyze ret-env (last exprs))\n            children (conj (vec statements) ret)]\n        {:op :do\n         :env env\n         :form form\n         :statements statements\n         :ret ret\n         :children children}))))",
                                  :title "Parser code",
                                  :repo "clojurescript",
                                  :tag "r1.7.228",
                                  :filename "src/main/clojure/cljs/analyzer.cljc",
                                  :lines [1405 1426]},
                         :full-name "special/do",
                         :clj-symbol "clojure.core/do",
                         :docstring "Evaluates the expressions in order and returns the value of\nthe last. If no expressions are supplied, returns nil."},
           "cljs.core/ArrayChunk" {:ns "cljs.core",
                                   :name "ArrayChunk",
                                   :signature ["[arr off end]"],
                                   :history [["+" "0.0-1424"]],
                                   :type "type",
                                   :full-name-encode "cljs.core/ArrayChunk",
                                   :source {:code "(deftype ArrayChunk [arr off end]\n  ICounted\n  (-count [_] (- end off))\n\n  IIndexed\n  (-nth [coll i]\n    (aget arr (+ off i)))\n  (-nth [coll i not-found]\n    (if (and (>= i 0) (< i (- end off)))\n      (aget arr (+ off i))\n      not-found))\n\n  IChunk\n  (-drop-first [coll]\n    (if (== off end)\n      (throw (js/Error. \"-drop-first of empty chunk\"))\n      (ArrayChunk. arr (inc off) end)))\n\n  IReduce\n  (-reduce [coll f]\n    (array-reduce arr f (aget arr off) (inc off)))\n  (-reduce [coll f start]\n    (array-reduce arr f start off)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [3092 3114]},
                                   :full-name "cljs.core/ArrayChunk",
                                   :clj-symbol "clojure.lang/ArrayChunk"},
           "cljs.core/sequential?" {:description "Returns true if `coll` implements the `ISequential` protocol, false otherwise.\n\nLists and vectors are sequential.",
                                    :return-type boolean,
                                    :ns "cljs.core",
                                    :name "sequential?",
                                    :signature ["[coll]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :related ["cljs.core/seq?"
                                              "cljs.core/coll?"],
                                    :full-name-encode "cljs.core/sequentialQMARK",
                                    :source {:code "(defn ^boolean sequential?\n  [x] (satisfies? ISequential x))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [1907 1909]},
                                    :full-name "cljs.core/sequential?",
                                    :clj-symbol "clojure.core/sequential?",
                                    :docstring "Returns true if coll satisfies ISequential"},
           "cljs.core/underive" {:ns "cljs.core",
                                 :name "underive",
                                 :signature ["[tag parent]"
                                             "[h tag parent]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/underive",
                                 :source {:code "(defn underive\n  ([tag parent]\n    (swap-global-hierarchy! underive tag parent)\n    nil)\n  ([h tag parent]\n    (let [parentMap (:parents h)\n          childsParents (if (parentMap tag)\n                          (disj (parentMap tag) parent) #{})\n          newParents (if (not-empty childsParents)\n                      (assoc parentMap tag childsParents)\n                      (dissoc parentMap tag))\n          deriv-seq (flatten (map #(cons (first %) (interpose (first %) (second %)))\n                                  (seq newParents)))]\n      (if (contains? (parentMap tag) parent)\n        (reduce #(apply derive %1 %2) (make-hierarchy)\n                (partition 2 deriv-seq))\n        h))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [9526 9545]},
                                 :full-name "cljs.core/underive",
                                 :clj-symbol "clojure.core/underive",
                                 :docstring "Removes a parent/child relationship between parent and\ntag. h must be a hierarchy obtained from make-hierarchy, if not\nsupplied defaults to, and modifies, the global hierarchy."},
           "cljs.core/PersistentArrayMapIterator" {:ns "cljs.core",
                                                   :name "PersistentArrayMapIterator",
                                                   :type "type",
                                                   :signature ["[arr i cnt]"],
                                                   :source {:code "(deftype PersistentArrayMapIterator [arr ^:mutable i cnt]\n  Object\n  (hasNext [_]\n    (< i cnt))\n  (next [_]\n    (let [ret [(aget arr i) (aget arr (inc i))]]\n      (set! i (+ i 2))\n      ret)))",
                                                            :title "Source code",
                                                            :repo "clojurescript",
                                                            :tag "r1.7.228",
                                                            :filename "src/main/cljs/cljs/core.cljs",
                                                            :lines [5838
                                                                    5845]},
                                                   :full-name "cljs.core/PersistentArrayMapIterator",
                                                   :full-name-encode "cljs.core/PersistentArrayMapIterator",
                                                   :history [["+"
                                                              "0.0-2371"]]},
           "cljs.core/ns-unmap" {:ns "cljs.core",
                                 :name "ns-unmap",
                                 :signature ["[[quote0 ns] [quote1 sym]]"],
                                 :history [["+" "0.0-3169"]],
                                 :type "macro",
                                 :full-name-encode "cljs.core/ns-unmap",
                                 :source {:code "(core/defmacro ns-unmap\n  [[quote0 ns] [quote1 sym]]\n  (core/assert (core/and (= quote0 'quote) (core/symbol? ns)\n                         (= quote1 'quote) (core/symbol? sym))\n    \"Arguments to ns-unmap must be quoted symbols\")\n  (swap! env/*compiler* update-in [::ana/namespaces ns :defs] dissoc sym)\n  `(js-delete ~(comp/munge ns) ~(comp/munge (core/str sym))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/clojure/cljs/core.cljc",
                                          :lines [2617 2624]},
                                 :full-name "cljs.core/ns-unmap",
                                 :clj-symbol "clojure.core/ns-unmap",
                                 :docstring "Removes the mappings for the symbol from the namespace."},
           "cljs.core/macroexpand" {:description "(only intended as a REPL utility)\n\nIf the given quoted form is a macro call, expand it once, then repeat until a\nsubsequent result is _not_ a macro call.  NOTE: nested forms are _not_ expanded.\n\nSee [doc:cljs.core/macroexpand-1] if you only wish to expand a form once.",
                                    :ns "cljs.core",
                                    :name "macroexpand",
                                    :signature ["[quoted]"],
                                    :history [["+" "0.0-3165"]],
                                    :type "macro",
                                    :related ["cljs.core/macroexpand-1"
                                              "cljs.core/defmacro"],
                                    :full-name-encode "cljs.core/macroexpand",
                                    :source {:code "(core/defmacro macroexpand\n  [quoted]\n  (core/assert (core/= (core/first quoted) 'quote)\n    \"Argument to macroexpand must be quoted\")\n  (core/let [form (second quoted)\n             env &env]\n    (core/loop [form form form' (ana/macroexpand-1 env form)]\n      (core/if-not (core/identical? form form')\n        (recur form' (ana/macroexpand-1 env form'))\n        `(quote ~form')))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/clojure/cljs/core.cljc",
                                             :lines [2646 2658]},
                                    :examples [{:id "b773af",
                                                :content "See how [doc:cljs.core/when] expands to [doc:special/if]:\n\n```clj\n(macroexpand '(when true :foo))\n;;=> (if true (do :foo))\n```\n\nThe following goes through three expansion steps, but you can use\n[doc:cljs.core/macroexpand-1] to do one at a time instead.\n\n```clj\n(macroexpand '(-> 2 inc))\n;;=> (js* \"(~{} + ~{})\" 2 1)\n```\n\nNotice how the nested `inc` form is not expanded:\n\n```clj\n(macroexpand '(inc (inc 2)))\n;;=> (js* \"(~{} + ~{})\" (inc 2) 1)\n```"}],
                                    :full-name "cljs.core/macroexpand",
                                    :clj-symbol "clojure.core/macroexpand",
                                    :docstring "Repeatedly calls macroexpand-1 on form until it no longer\nrepresents a macro form, then returns it.  Note neither\nmacroexpand-1 nor macroexpand expand macros in subforms."},
           "clojure.browser.repl/get-ua-product" {:ns "clojure.browser.repl",
                                                  :name "get-ua-product",
                                                  :type "function",
                                                  :signature ["[]"],
                                                  :source {:code "(defn get-ua-product []\n  (cond\n    product/SAFARI :safari\n    product/CHROME :chrome\n    product/FIREFOX :firefox\n    product/IE :ie))",
                                                           :title "Source code",
                                                           :repo "clojurescript",
                                                           :tag "r1.7.228",
                                                           :filename "src/main/cljs/clojure/browser/repl.cljs",
                                                           :lines [47
                                                                   52]},
                                                  :full-name "clojure.browser.repl/get-ua-product",
                                                  :full-name-encode "clojure.browser.repl/get-ua-product",
                                                  :history [["+"
                                                             "0.0-3058"]]},
           "cljs.core/get-method" {:ns "cljs.core",
                                   :name "get-method",
                                   :signature ["[multifn dispatch-val]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/get-method",
                                   :source {:code "(defn get-method\n  [multifn dispatch-val] (-get-method multifn dispatch-val))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [9820 9823]},
                                   :full-name "cljs.core/get-method",
                                   :clj-symbol "clojure.core/get-method",
                                   :docstring "Given a multimethod and a dispatch value, returns the dispatch fn\nthat would apply to that value, or nil if none apply and no default"},
           "cljs.core/=" {:description "Returns true if the value of `x` equals the value of `y`, false otherwise.\n\n`=` is a value comparison, not an identity comparison.\n\nAll collections can be tested for value, regardless of \"depth\".",
                          :return-type boolean,
                          :ns "cljs.core",
                          :name "=",
                          :signature ["[x]" "[x y]" "[x y & more]"],
                          :history [["+" "0.0-927"]],
                          :type "function",
                          :related ["cljs.core/=="
                                    "cljs.core/not="
                                    "cljs.core/identical?"],
                          :full-name-encode "cljs.core/EQ",
                          :source {:code "(defn ^boolean =\n  ([x] true)\n  ([x y]\n    (if (nil? x)\n      (nil? y)\n      (or (identical? x y)\n        ^boolean (-equiv x y))))\n  ([x y & more]\n     (if (= x y)\n       (if (next more)\n         (recur y (first more) (next more))\n         (= y (first more)))\n       false)))",
                                   :title "Source code",
                                   :repo "clojurescript",
                                   :tag "r1.7.228",
                                   :filename "src/main/cljs/cljs/core.cljs",
                                   :lines [1126 1142]},
                          :examples [{:id "edffb6",
                                      :content "```clj\n(= 1)\n;;=> true\n\n(= 1 1)\n;;=> true\n\n(= 1 2)\n;;=> false\n\n(= 1 1 1)\n;;=> true\n\n(= 1 1 2)\n;;=> false\n```"}
                                     {:id "a2d064",
                                      :content "Sequences are considered equal in value if they have the same elements:\n\n```clj\n(= '(1 2) [1 2])\n;;=> true\n```\n\nBut you cannot compare JavaScript arrays until you convert them to sequences:\n\n```clj\n(def a #js [1 2])\n(def b #js [1 2])\n(= a b)\n;;=> false\n\n(= (seq a) (seq b))\n;;=> true\n```"}
                                     {:id "6c8424",
                                      :content "It is natural to compare deeply nested collections since value equality checks\nare cheap in ClojureScript:\n\n```clj\n(def a {:foo {:bar \"baz\"}})\n(def b {:foo {:bar \"baz\"}})\n(= a b)\n;;=> true\n\n(= [a b] [a b])\n;=> true\n```\n\nJavaScript objects cannot be compared in this way until they are converted to\nClojureScript collections:\n\n```clj\n(def a #js {:foo #js {:bar \"baz\"}})\n(def b #js {:foo #js {:bar \"baz\"}})\n(= a b)\n;;=> false\n\n(= (js->clj a)\n   (js->clj b))\n;;=> true\n```"}],
                          :full-name "cljs.core/=",
                          :clj-symbol "clojure.core/=",
                          :docstring "Equality. Returns true if x equals y, false if not. Compares\nnumbers and collections in a type-independent manner.  Clojure's immutable data\nstructures define -equiv (and thus =) as a value, not an identity,\ncomparison."},
           "cljs.repl.server/dispatch-on" {:ns "cljs.repl.server",
                                           :name "dispatch-on",
                                           :signature ["[method pred handler]"
                                                       "[method {:as m}]"],
                                           :history [["+" "0.0-1503"]],
                                           :type "function",
                                           :full-name-encode "cljs.repl.server/dispatch-on",
                                           :source {:code "(defn dispatch-on\n  ([method pred handler]\n    (dispatch-on method {:pred pred :handler handler}))\n  ([method {:as m}]\n    (swap! handlers\n      (fn [old]\n        (update-in old [method] #(conj (vec %) m))))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.7.228",
                                                    :filename "src/main/clojure/cljs/repl/server.clj",
                                                    :lines [41 53]},
                                           :full-name "cljs.repl.server/dispatch-on",
                                           :docstring "Registers a handler to be dispatched based on a request method and a\npredicate.\n\npred should be a function that accepts an options map, a connection,\nand a request map and returns a boolean value based on whether or not\nthat request should be dispatched to the related handler."},
           "cljs.reader/deregister-default-tag-parser!" {:ns "cljs.reader",
                                                         :name "deregister-default-tag-parser!",
                                                         :type "function",
                                                         :signature ["[]"],
                                                         :source {:code "(defn deregister-default-tag-parser!\n  []\n  (let [old-parser @*default-data-reader-fn*]\n    (swap! *default-data-reader-fn* (fn [_] nil))\n    old-parser))",
                                                                  :title "Source code",
                                                                  :repo "clojurescript",
                                                                  :tag "r1.7.228",
                                                                  :filename "src/main/cljs/cljs/reader.cljs",
                                                                  :lines [626
                                                                          630]},
                                                         :full-name "cljs.reader/deregister-default-tag-parser!",
                                                         :full-name-encode "cljs.reader/deregister-default-tag-parserBANG",
                                                         :history [["+"
                                                                    "0.0-1576"]]},
           "syntax/comment" {:description "\"Comments out\" everything after `;` on the current line.",
                             :ns "syntax",
                             :name "comment",
                             :history [["+" "0.0-927"]],
                             :type "syntax",
                             :related ["syntax/ignore"
                                       "cljs.core/comment"
                                       "syntax/shebang"],
                             :full-name-encode "syntax/comment",
                             :extra-sources ({:code "(defn read-comment\n  [rdr & _]\n  (skip-line rdr))",
                                              :title "Reader code",
                                              :repo "tools.reader",
                                              :tag "tools.reader-1.0.0-alpha1",
                                              :filename "src/main/clojure/clojure/tools/reader/impl/commons.clj",
                                              :lines [123 125]}
                                             {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                              :title "Reader table",
                                              :repo "tools.reader",
                                              :tag "tools.reader-1.0.0-alpha1",
                                              :filename "src/main/clojure/clojure/tools/reader.clj",
                                              :lines [743 762]}),
                             :examples [{:id "ab62d2",
                                         :content "Add comments to code:\n\n```clj\n(def a 1) ; this is a comment\n```\n\nIt is common to use `;;` for comments that have their own line:\n\n```clj\n;; this comment is on its own line\n```"}],
                             :edn-doc "https://github.com/edn-format/edn#comments",
                             :full-name "syntax/comment",
                             :display "; comment",
                             :clj-doc "http://clojure.org/reader#toc2"},
           "cljs.repl.browser/firefox-st-el->frame" {:ns "cljs.repl.browser",
                                                     :name "firefox-st-el->frame",
                                                     :signature ["[repl-env st-el opts]"],
                                                     :history [["+"
                                                                "0.0-3053"]
                                                               ["-"
                                                                "1.7.10"]],
                                                     :type "function",
                                                     :full-name-encode "cljs.repl.browser/firefox-st-el-GTframe",
                                                     :source {:code "(defn firefox-st-el->frame\n  [repl-env st-el opts]\n  (let [[function flc] (if (re-find #\"@\" st-el)\n                         (string/split st-el #\"@\")\n                         [nil st-el])\n        [file line column] (parse-file-line-column flc)]\n    (if (and file function line column)\n      {:file (parse-file repl-env file opts)\n       :function (firefox-clean-function function)\n       :line line\n       :column column}\n      (when-not (string/blank? function)\n        {:file nil\n         :function (firefox-clean-function function)\n         :line nil\n         :column nil}))))",
                                                              :title "Source code",
                                                              :repo "clojurescript",
                                                              :tag "r3308",
                                                              :filename "src/main/clojure/cljs/repl/browser.clj",
                                                              :lines [404
                                                                      419]},
                                                     :full-name "cljs.repl.browser/firefox-st-el->frame",
                                                     :removed {:in "1.7.10",
                                                               :last-seen "0.0-3308"}},
           "cljs.core/system-time" {:ns "cljs.core",
                                    :name "system-time",
                                    :signature ["[]"],
                                    :history [["+" "1.7.145"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/system-time",
                                    :source {:code "(defn system-time\n  []\n  (cond\n    (and (exists? js/performance)\n         (not (nil? (. js/performance -now))))\n    (.now js/performance)\n\n    (and (exists? js/process)\n         (not (nil? (. js/process -hrtime))))\n    (let [t (.hrtime js/process)]\n      (/ (+ (* (aget t 0) 1e9) (aget t 1)) 1e6))\n\n    :else (.getTime (js/Date.))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [339 352]},
                                    :full-name "cljs.core/system-time",
                                    :docstring "Returns highest resolution time offered by host in milliseconds."},
           "cljs.core/defn-" {:description "Same as `defn`, but adds `{:private true}` metadata to the definition.\n\nNote: `:private` metadata is not currently enforced by the ClojureScript\ncompiler.",
                              :ns "cljs.core",
                              :name "defn-",
                              :signature ["[name & decls]"],
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :related ["cljs.core/defn"],
                              :full-name-encode "cljs.core/defn-",
                              :source {:code "(defmacro defn-\n  [name & decls]\n    (list* `defn (with-meta name (assoc (meta name) :private true)) decls))",
                                       :title "Source code",
                                       :repo "clojure",
                                       :tag "clojure-1.7.0",
                                       :filename "src/clj/clojure/core.clj",
                                       :lines [4719 4723]},
                              :full-name "cljs.core/defn-",
                              :clj-symbol "clojure.core/defn-",
                              :docstring "same as defn, yielding non-public def"},
           "specialrepl/import" {:description "import-list => (closure-namespace constructor-name-symbols*)\n\nOnly usable from a REPL.\n\nImport Google Closure classes.",
                                 :ns "specialrepl",
                                 :name "import",
                                 :signature ["[& import-symbols-or-lists]"],
                                 :history [["+" "0.0-2985"]],
                                 :type "special form (repl)",
                                 :full-name-encode "specialrepl/import",
                                 :source {:code "(def default-special-fns\n  (let [load-file-fn\n        (fn self\n          ([repl-env env form]\n            (self repl-env env form nil))\n          ([repl-env env [_ file :as form] opts]\n            (load-file repl-env file opts)))\n        in-ns-fn\n        (fn self\n          ([repl-env env form]\n           (self repl-env env form nil))\n          ([repl-env env [_ [quote ns-name] :as form] _]\n            ;; guard against craziness like '5 which wreaks havoc\n           (when-not (and (= quote 'quote) (symbol? ns-name))\n             (throw (IllegalArgumentException. \"Argument to in-ns must be a symbol.\")))\n           (when-not (ana/get-namespace ns-name)\n             (swap! env/*compiler* assoc-in [::ana/namespaces ns-name] {:name ns-name})\n             (-evaluate repl-env \"<cljs repl>\" 1\n               (str \"goog.provide('\" (comp/munge ns-name) \"');\")))\n           (set! ana/*cljs-ns* ns-name)))]\n    (wrap-special-fns wrap-self\n     {'in-ns in-ns-fn\n      'clojure.core/in-ns in-ns-fn\n      'require\n      (fn self\n        ([repl-env env form]\n         (self repl-env env form nil))\n        ([repl-env env [_ & specs :as form] opts]\n         (let [is-self-require? (self-require? specs)\n               [target-ns restore-ns]\n               (if-not is-self-require?\n                 [ana/*cljs-ns* nil]\n                 ['cljs.user ana/*cljs-ns*])]\n           (evaluate-form repl-env env \"<cljs repl>\"\n                          (with-meta\n                            `(~'ns ~target-ns\n                               (:require ~@(-> specs canonicalize-specs decorate-specs)))\n                            {:merge true :line 1 :column 1})\n                          identity opts)\n           (when is-self-require?\n             (set! ana/*cljs-ns* restore-ns)))))\n      'require-macros\n      (fn self\n        ([repl-env env form]\n         (self repl-env env form nil))\n        ([repl-env env [_ & specs :as form] opts]\n         (evaluate-form repl-env env \"<cljs repl>\"\n                        (with-meta\n                          `(~'ns ~ana/*cljs-ns*\n                             (:require-macros ~@(-> specs canonicalize-specs decorate-specs)))\n                          {:merge true :line 1 :column 1})\n                        identity opts)))\n      'import\n      (fn self\n        ([repl-env env form]\n         (self repl-env env form nil))\n        ([repl-env env [_ & specs :as form] opts]\n         (evaluate-form repl-env env \"<cljs repl>\"\n                        (with-meta\n                          `(~'ns ~ana/*cljs-ns*\n                             (:import\n                              ~@(map\n                                 (fn [quoted-spec-or-kw]\n                                   (if (keyword? quoted-spec-or-kw)\n                                     quoted-spec-or-kw\n                                     (second quoted-spec-or-kw)))\n                                 specs)))\n                          {:merge true :line 1 :column 1})\n                        identity opts)))\n      'load-file load-file-fn\n      'clojure.core/load-file load-file-fn\n      'load-namespace\n      (fn self\n        ([repl-env env form]\n         (self env repl-env form nil))\n        ([repl-env env [_ ns :as form] opts]\n         (load-namespace repl-env ns opts)))})))",
                                          :title "repl specials table",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/clojure/cljs/repl.cljc",
                                          :lines [642 718]},
                                 :examples [{:id "03acc0",
                                             :content "```clj\n(import 'goog.math.Long\n        '[goog.math Vec2 Vec3]\n        '[goog.math Integer])\n\n(Long. 4 6)\n;;=> #<25769803780>\n\n(Vec2. 1 2)\n;;=> #<(1, 2)>\n\n(Vec3. 1 2 3)\n;;=> #<(1, 2, 3)>\n\n(Integer.fromString \"10\")\n;;=> #<10>\n```"}],
                                 :full-name "specialrepl/import",
                                 :clj-symbol "clojure.core/import",
                                 :docstring "import-list => (closure-namespace constructor-name-symbols*)\n\nFor each name in constructor-name-symbols, adds a mapping from name to the\nconstructor named by closure-namespace to the current namespace. Use :import in the ns\nmacro in preference to calling this directly."},
           "cljs.js/append-source-map" {:ns "cljs.js",
                                        :name "append-source-map",
                                        :signature ["[state name source sb sm-data {:keys [output-dir asset-path], :as opts}]"],
                                        :history [["+" "1.7.10"]
                                                  ["-" "1.7.28"]],
                                        :type "function",
                                        :full-name-encode "cljs.js/append-source-map",
                                        :source {:code "(defn append-source-map\n  [state name source sb sm-data {:keys [output-dir asset-path] :as opts}]\n   (let [t    (.valueOf (js/Date.))\n         smn  (if name\n                (string/replace (munge (str name)) \".\" \"/\")\n                (str \"cljs-\" t))\n         ts   (.valueOf (js/Date.))\n         out  (or output-dir asset-path)\n         src  (cond-> (str smn \".cljs?rel=\" ts)\n                out (prefix (str out \"/\")))\n         file (cond-> (str smn \".js?rel=\" ts)\n                out (prefix (str out \"/\")))\n         json (sm/encode {src (:source-map sm-data)}\n                {:lines (+ (:gen-line sm-data) 3)\n                 :file  file :sources-content [source]})]\n     (when (:verbose opts) (debug-prn json))\n     (swap! state assoc-in\n       [:source-maps name] (sm/invert-reverse-map (:source-map sm-data)))\n     (.append sb\n       (str \"\\n//# sourceURL=\" file\n            \"\\n//# sourceMappingURL=data:application/json;base64,\"\n            (base64/encodeString json)))))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.10",
                                                 :filename "src/main/cljs/cljs/js.cljs",
                                                 :lines [131 152]},
                                        :full-name "cljs.js/append-source-map",
                                        :removed {:in "1.7.28",
                                                  :last-seen "1.7.10"}},
           "cljs.reader/read-symbol" {:ns "cljs.reader",
                                      :name "read-symbol",
                                      :type "function",
                                      :signature ["[reader initch]"],
                                      :source {:code "(defn read-symbol\n  [reader initch]\n  (let [token (read-token reader initch)]\n    (if (and (gstring/contains token \"/\")\n             (not (== (.-length token) 1)))\n      (symbol (subs token 0 (.indexOf token \"/\"))\n              (subs token (inc (.indexOf token \"/\"))\n                (.-length token)))\n      (special-symbols token (symbol token)))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/cljs/cljs/reader.cljs",
                                               :lines [327 335]},
                                      :full-name "cljs.reader/read-symbol",
                                      :full-name-encode "cljs.reader/read-symbol",
                                      :history [["+" "0.0-927"]]},
           "cljs.reader/push-back-reader" {:ns "cljs.reader",
                                           :name "push-back-reader",
                                           :type "function",
                                           :signature ["[s]"],
                                           :source {:code "(defn push-back-reader [s]\n  \"Creates a StringPushbackReader from a given string\"\n  (StringPushbackReader. s (array) -1))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.7.228",
                                                    :filename "src/main/cljs/cljs/reader.cljs",
                                                    :lines [29 31]},
                                           :full-name "cljs.reader/push-back-reader",
                                           :full-name-encode "cljs.reader/push-back-reader",
                                           :history [["+" "0.0-927"]]},
           "cljs.core/deftype" {:ns "cljs.core",
                                :name "deftype",
                                :signature ["[t fields & impls]"],
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :full-name-encode "cljs.core/deftype",
                                :source {:code "(core/defmacro deftype\n  [t fields & impls]\n  (validate-fields \"deftype\" t fields)\n  (core/let [env &env\n             r (:name (cljs.analyzer/resolve-var (dissoc env :locals) t))\n             [fpps pmasks] (prepare-protocol-masks env impls)\n             protocols (collect-protocols impls env)\n             t (vary-meta t assoc\n                 :protocols protocols\n                 :skip-protocol-flag fpps) ]\n    `(do\n       (deftype* ~t ~fields ~pmasks\n         ~(if (seq impls)\n            `(extend-type ~t ~@(dt->et t impls fields))))\n       (set! (.-getBasis ~t) (fn [] '[~@fields]))\n       (set! (.-cljs$lang$type ~t) true)\n       (set! (.-cljs$lang$ctorStr ~t) ~(core/str r))\n       (set! (.-cljs$lang$ctorPrWriter ~t) (fn [this# writer# opt#] (-write writer# ~(core/str r))))\n\n       ~(build-positional-factory t r fields)\n       ~t)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/clojure/cljs/core.cljc",
                                         :lines [1576 1644]},
                                :full-name "cljs.core/deftype",
                                :clj-symbol "clojure.core/deftype",
                                :docstring "(deftype name [fields*]  options* specs*)\n\nCurrently there are no options.\n\nEach spec consists of a protocol or interface name followed by zero\nor more method bodies:\n\nprotocol-or-Object\n(methodName [args*] body)*\n\nThe type will have the (by default, immutable) fields named by\nfields, which can have type hints. Protocols and methods\nare optional. The only methods that can be supplied are those\ndeclared in the protocols/interfaces.  Note that method bodies are\nnot closures, the local environment includes only the named fields,\nand those fields can be accessed directly. Fields can be qualified\nwith the metadata :mutable true at which point (set! afield aval) will be\nsupported in method bodies. Note well that mutable fields are extremely\ndifficult to use correctly, and are present only to facilitate the building\nof higherlevel constructs, such as ClojureScript's reference types, in\nClojureScript itself. They are for experts only - if the semantics and\nimplications of :mutable are not immediately apparent to you, you should not\nbe using them.\n\nMethod definitions take the form:\n\n(methodname [args*] body)\n\nThe argument and return types can be hinted on the arg and\nmethodname symbols. If not supplied, they will be inferred, so type\nhints should be reserved for disambiguation.\n\nMethods should be supplied for all methods of the desired\nprotocol(s). You can also define overrides for methods of Object. Note that\na parameter must be supplied to correspond to the target object\n('this' in JavaScript parlance). Note also that recur calls to the method\nhead should *not* pass the target object, it will be supplied\nautomatically and can not be substituted.\n\nIn the method bodies, the (unqualified) name can be used to name the\nclass (for calls to new, instance? etc).\n\nOne constructor will be defined, taking the designated fields.  Note\nthat the field names __meta and __extmap are currently reserved and\nshould not be used when defining your own types.\n\nGiven (deftype TypeName ...), a factory function called ->TypeName\nwill be defined, taking positional parameters for the fields"},
           "cljs.repl/print-doc" {:ns "cljs.repl",
                                  :name "print-doc",
                                  :type "function",
                                  :signature ["[m]"],
                                  :source {:code "(defn print-doc [m]\n  (println \"-------------------------\")\n  (println (str (when-let [ns (:ns m)] (str ns \"/\")) (:name m)))\n  (when (:protocol m)\n    (println \"Protocol\"))\n  (cond\n    (:forms m) (doseq [f (:forms m)]\n                 (println \"  \" f))\n    (:arglists m) (let [arglists (:arglists m)]\n                    (if (or (:macro m)\n                         (:repl-special-function m))\n                     (prn arglists)\n                     (prn\n                       (if (= 'quote (first arglists))\n                         (second arglists)\n                         arglists)))))\n  (if (:special-form m)\n    (do\n      (println \"Special Form\")\n      (println \" \" (:doc m)) \n      (if (contains? m :url)\n        (when (:url m)\n          (println (str \"\\n  Please see http://clojure.org/\" (:url m))))\n        (println (str \"\\n  Please see http://clojure.org/special_forms#\"\n                   (:name m)))))\n    (do\n      (when (:macro m)\n        (println \"Macro\"))\n      (when (:repl-special-function m)\n        (println \"REPL Special Function\"))\n      (println \" \" (:doc m))\n      (when (:protocol m)\n        (doseq [[name {:keys [doc arglists]}] (:methods m)]\n          (println)\n          (println \" \" name)\n          (println \" \" arglists)\n          (when doc\n            (println \" \" doc)))))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/repl.cljs",
                                           :lines [12 49]},
                                  :full-name "cljs.repl/print-doc",
                                  :full-name-encode "cljs.repl/print-doc",
                                  :history [["+" "0.0-2496"]]},
           "cljs.core/longs" {:ns "cljs.core",
                              :name "longs",
                              :signature ["[x]"],
                              :history [["+" "0.0-1798"]],
                              :type "function",
                              :full-name-encode "cljs.core/longs",
                              :source {:code "(defn longs [x] x)",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [2484]},
                              :full-name "cljs.core/longs",
                              :clj-symbol "clojure.core/longs"},
           "cljs.core/Subvec" {:ns "cljs.core",
                               :name "Subvec",
                               :type "type",
                               :signature ["[meta v start end __hash]"],
                               :source {:code "(deftype Subvec [meta v start end ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  ICloneable\n  (-clone [_] (Subvec. meta v start end __hash))\n\n  IWithMeta\n  (-with-meta [coll meta] (build-subvec meta v start end __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IStack\n  (-peek [coll]\n    (-nth v (dec end)))\n  (-pop [coll]\n    (if (== start end)\n      (throw (js/Error. \"Can't pop empty vector\"))\n      (build-subvec meta v start (dec end) nil)))\n\n  ICollection\n  (-conj [coll o]\n    (build-subvec meta (-assoc-n v end o) start (inc end) nil))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY PersistentVector) meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (let [subvec-seq (fn subvec-seq [i]\n                       (when-not (== i end)\n                         (cons (-nth v i)\n                               (lazy-seq\n                                (subvec-seq (inc i))))))]\n      (subvec-seq start)))\n\n  IReversible\n  (-rseq [coll]\n    (if-not (== start end)\n      (RSeq. coll (dec (- end start)) nil)))\n\n  ICounted\n  (-count [coll] (- end start))\n\n  IIndexed\n  (-nth [coll n]\n    (if (or (neg? n) (<= end (+ start n)))\n      (vector-index-out-of-bounds n (- end start))\n      (-nth v (+ start n))))\n  (-nth [coll n not-found]\n    (if (or (neg? n) (<= end (+ start n)))\n      not-found\n      (-nth v (+ start n) not-found)))\n\n  ILookup\n  (-lookup [coll k] (-lookup coll k nil))\n  (-lookup [coll k not-found] (if (number? k)\n                                (-nth coll k not-found)\n                                not-found))\n\n  IAssociative\n  (-assoc [coll key val]\n    (if (number? key)\n      (-assoc-n coll key val)\n      (throw (js/Error. \"Subvec's key for assoc must be a number.\"))))\n\n  IVector\n  (-assoc-n [coll n val]\n    (let [v-pos (+ start n)]\n      (build-subvec meta (assoc v v-pos val) start (max end (inc v-pos)) nil)))\n\n  IReduce\n  (-reduce [coll f]\n    (ci-reduce coll f))\n  (-reduce [coll f start]\n    (ci-reduce coll f start))\n\n  IKVReduce\n  (-kv-reduce [coll f init]\n    (loop [i start j 0 init init]\n      (if (< i end)\n        (let [init (f init j (-nth v i))]\n          (if (reduced? init)\n            @init\n            (recur (inc i) (inc j) init)))\n        init)))\n\n  IFn\n  (-invoke [coll k]\n    (-nth coll k))\n  (-invoke [coll k not-found]\n    (-nth coll k not-found)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [5047 5149]},
                               :full-name "cljs.core/Subvec",
                               :full-name-encode "cljs.core/Subvec",
                               :history [["+" "0.0-927"]]},
           "cljs.repl.browser/run-in-order" {:ns "cljs.repl.browser",
                                             :name "run-in-order",
                                             :type "function",
                                             :signature ["[{:keys [expecting fns]}]"],
                                             :source {:code "(defn run-in-order [{:keys [expecting fns]}]\n  (loop [order expecting fns fns]\n    (if-let [f (get fns order)]\n      (do\n        (f)\n        (recur (inc order) (dissoc fns order)))\n      {:expecting order :fns fns})))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.7.228",
                                                      :filename "src/main/clojure/cljs/repl/browser.clj",
                                                      :lines [156 162]},
                                             :full-name "cljs.repl.browser/run-in-order",
                                             :full-name-encode "cljs.repl.browser/run-in-order",
                                             :history [["+" "0.0-927"]]},
           "cljs.repl.browser/compile-client-js" {:ns "cljs.repl.browser",
                                                  :name "compile-client-js",
                                                  :type "function",
                                                  :signature ["[opts]"],
                                                  :source {:code "(defn compile-client-js [opts]\n  (let [copts {:optimizations (:optimizations opts)\n               :output-dir (:working-dir opts)}]\n    ;; we're inside the REPL process where cljs.env/*compiler* is already\n    ;; established, need to construct a new one to avoid mutating the one\n    ;; the REPL uses\n    (cljsc/build\n      '[(ns clojure.browser.repl.client\n          (:require [goog.events :as event]\n                    [clojure.browser.repl :as repl]))\n        (defn start [url]\n          (event/listen js/window\n            \"load\"\n            (fn []\n              (repl/start-evaluator url))))]\n      copts (env/default-compiler-env copts))))",
                                                           :title "Source code",
                                                           :repo "clojurescript",
                                                           :tag "r1.7.228",
                                                           :filename "src/main/clojure/cljs/repl/browser.clj",
                                                           :lines [215
                                                                   230]},
                                                  :full-name "cljs.repl.browser/compile-client-js",
                                                  :full-name-encode "cljs.repl.browser/compile-client-js",
                                                  :history [["+"
                                                             "0.0-927"]]},
           "cljs.core/macroexpand-1" {:description "(only intended as a REPL utility)\n\nIf the given quoted form is a macro call, expand it once. NOTE: subforms are\n_not_ expanded.\n\nSee [doc:cljs.core/macroexpand] if you wish to repeatedly expand a form.",
                                      :ns "cljs.core",
                                      :name "macroexpand-1",
                                      :signature ["[quoted]"],
                                      :history [["+" "0.0-3165"]],
                                      :type "macro",
                                      :related ["cljs.core/macroexpand"
                                                "cljs.core/defmacro"],
                                      :full-name-encode "cljs.core/macroexpand-1",
                                      :source {:code "(core/defmacro macroexpand-1\n  [quoted]\n  (core/assert (core/= (core/first quoted) 'quote)\n    \"Argument to macroexpand-1 must be quoted\")\n  (core/let [form (second quoted)]\n    `(quote ~(ana/macroexpand-1 &env form))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/clojure/cljs/core.cljc",
                                               :lines [2637 2644]},
                                      :examples [{:id "1bc6af",
                                                  :content "See how `(-> 2 inc)` is progressively expanded:\n\n```clj\n(macroexpand-1 '(-> 2 inc))\n;;=> (inc 2)\n\n(macroexpand-1 '(inc 2))\n;;=> (cljs.core/+ 2 1)\n\n(macroexpand-1 '(cljs.core/+ 2 1))\n;;=> (js* \"(~{} + ~{})\" 2 1)\n```\n\nNotice how the nested `inc` form is not expanded:\n\n```clj\n(macroexpand-1 '(inc (inc 2)))\n;;=> (cljs.core/+ (inc 2) 1)\n```"}],
                                      :full-name "cljs.core/macroexpand-1",
                                      :clj-symbol "clojure.core/macroexpand-1",
                                      :docstring "If form represents a macro form, returns its expansion,\nelse returns form."},
           "syntax/js-namespace" {:description "A special namespace used for accessing any symbol defined\nin JavaScript's global scope.",
                                  :ns "syntax",
                                  :name "js-namespace",
                                  :history [["+" "0.0-927"]],
                                  :type "special namespace",
                                  :related ["syntax/Math-namespace"
                                            "special/."
                                            "cljs.core/aget"
                                            "cljs.core/aset"],
                                  :full-name-encode "syntax/js-namespace",
                                  :usage ["js/foo" "js/foo.bar"],
                                  :examples [{:id "06f234",
                                              :content "The following examples are run from a browser REPL.\n\nGet the JavaScript global `document` object:\n\n```clj\njs/document\n;;=> #<[object HTMLDocument]>\n```\n\nDisplay an alert:\n\n```clj\n(js/alert \"Hello World\")\n;; displays alert popup\n```\n\nLog to console:\n\n```clj\n(js/console.log \"Hello World\")\n;; displays in developer console\n```\n\nCreate a JavaScript date object:\n\n```clj\n(js/Date.)\n;;=> #inst \"2015-07-14T00:25:33.881-00:00\"\n```"}],
                                  :full-name "syntax/js-namespace",
                                  :display "js/ namespace"},
           "cljs.core/if-some" {:description "If `test` is not nil, evaluates `then` with `x` bound to the value of `test`. If\nnot, yields `else`.",
                                :ns "cljs.core",
                                :name "if-some",
                                :signature ["[[x test] then]"
                                            "[[x test] then else]"],
                                :history [["+" "0.0-2261"]],
                                :type "macro",
                                :related ["cljs.core/when-some"],
                                :full-name-encode "cljs.core/if-some",
                                :source {:code "(defmacro if-some\n  ([bindings then]\n   `(if-some ~bindings ~then nil))\n  ([bindings then else & oldform]\n   (assert-args\n     (vector? bindings) \"a vector for its binding\"\n     (nil? oldform) \"1 or 2 forms after binding vector\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n   (let [form (bindings 0) tst (bindings 1)]\n     `(let [temp# ~tst]\n        (if (nil? temp#)\n          ~else\n          (let [~form temp#]\n            ~then))))))",
                                         :title "Source code",
                                         :repo "clojure",
                                         :tag "clojure-1.7.0",
                                         :filename "src/clj/clojure/core.clj",
                                         :lines [1762 1780]},
                                :full-name "cljs.core/if-some",
                                :clj-symbol "clojure.core/if-some",
                                :docstring "bindings => binding-form test\n\nIf test is not nil, evaluates then with binding-form bound to the\nvalue of test, if not, yields else"},
           "cljs.test/js-filename" {:ns "cljs.test",
                                    :name "js-filename",
                                    :type "function",
                                    :signature ["[stack-element]"],
                                    :source {:code "(defn js-filename [stack-element]\n  (first (.split (last (.split stack-element \"/out/\")) \":\")))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/test.cljs",
                                             :lines [372 373]},
                                    :full-name "cljs.test/js-filename",
                                    :full-name-encode "cljs.test/js-filename",
                                    :history [["+" "0.0-2496"]]},
           "special/ns" {:description "Sets the namespace of the file.\n\n`ns` must be the first form in a `.cljs` file and there can only be one `ns`\ndeclaration per file. Namespaces must match the file name of their respective\n`.cljs` files, with the exception that dashes in namespaces become underscores\nin filenames. Thus, `(ns foo.bar-biz.baz)` should be the first form in file\n`foo/bar_biz/baz.cljs`.\n\n`references` can be zero or more forms used to import other namespaces, symbols,\nand libraries into the current namespace.\n\n```clj\n(ns example.core\n\n  ;; for excluding clojure symbols\n  (:refer-clojure :exclude [])\n\n  ;; for importing goog classes and enums\n  (:import\n    lib.ns\n    [lib.ns Ctor*])\n\n  (:require-macros\n    [lib.ns :refer []\n            :as alias\n            :reload\n            :reload-all])\n\n  (:require\n    [lib.ns :refer []\n            :refer-macros []\n            :include-macros true|false\n            :as alias\n            :reload\n            :reload-all])\n\n  (:use\n    [lib.ns :only []\n            :reload\n            :reload-all])\n\n  (:use-macros\n    [lib.ns :only []\n            :reload\n            :reload-all]))\n```",
                         :ns "special",
                         :name "ns",
                         :signature ["[name & references]"],
                         :history [["+" "0.0-927"]],
                         :type "special form",
                         :related ["specialrepl/in-ns"
                                   "specialrepl/load-namespace"
                                   "specialrepl/import"
                                   "specialrepl/require"
                                   "specialrepl/require-macros"],
                         :full-name-encode "special/ns",
                         :source {:code "(defmethod parse 'ns\n  [_ env [_ name & args :as form] _ opts]\n  (when-not (symbol? name)\n    (throw (error env \"Namespaces must be named by a symbol.\")))\n  (let [name (cond-> name (:macros-ns opts) macro-ns-name)]\n    (let [segments (string/split (clojure.core/name name) #\"\\.\")]\n      (when (= 1 (count segments))\n        (warning :single-segment-namespace env {:name name}))\n      (when (some js-reserved segments)\n        (warning :munged-namespace env {:name name}))\n      (find-def-clash env name segments)\n      #?(:clj\n         (when (some (complement util/valid-js-id-start?) segments)\n           (throw\n             (AssertionError.\n               (str \"Namespace \" name \" has a segment starting with an invaild \"\n                    \"JavaScript identifier\"))))))\n    (let [docstring    (if (string? (first args)) (first args))\n          mdocstr      (-> name meta :doc)\n          args         (if docstring (next args) args)\n          metadata     (if (map? (first args)) (first args))\n          form-meta    (meta form)\n          args         (desugar-ns-specs (if metadata (next args) args))\n          name         (vary-meta name merge metadata)\n          excludes     (parse-ns-excludes env args)\n          deps         (atom #{})\n          aliases      (atom {:fns {} :macros {}})\n          spec-parsers {:require        (partial parse-require-spec env false deps aliases)\n                        :require-macros (partial parse-require-spec env true deps aliases)\n                        :use            (comp (partial parse-require-spec env false deps aliases)\n                                          (partial use->require env))\n                        :use-macros     (comp (partial parse-require-spec env true deps aliases)\n                                          (partial use->require env))\n                        :import         (partial parse-import-spec env deps)}\n          valid-forms  (atom #{:use :use-macros :require :require-macros :import})\n          reload       (atom {:use nil :require nil :use-macros nil :require-macros nil})\n          reloads      (atom {})\n          {uses :use requires :require use-macros :use-macros require-macros :require-macros imports :import :as params}\n          (reduce\n            (fn [m [k & libs]]\n              (when-not (#{:use :use-macros :require :require-macros :import} k)\n                (throw (error env \"Only :refer-clojure, :require, :require-macros, :use, :use-macros, and :import libspecs supported\")))\n              (when-not (@valid-forms k)\n                (throw (error env (str \"Only one \" k \" form is allowed per namespace definition\"))))\n              (swap! valid-forms disj k)\n              ;; check for spec type reloads\n              (when-not (= :import k)\n                (when (some #{:reload} libs)\n                  (swap! reload assoc k :reload))\n                (when (some #{:reload-all} libs)\n                  (swap! reload assoc k :reload-all)))\n              ;; check for individual ns reloads from REPL interactions\n              (when-let [xs (seq (filter #(-> % meta :reload) libs))]\n                (swap! reloads assoc k\n                  (zipmap (map first xs) (map #(-> % meta :reload) xs))))\n              (apply merge-with merge m\n                (map (spec-parsers k)\n                  (remove #{:reload :reload-all} libs))))\n            {} (remove (fn [[r]] (= r :refer-clojure)) args))]\n      (set! *cljs-ns* name)\n      (let [ns-info\n            {:name           name\n             :doc            (or docstring mdocstr)\n             :excludes       excludes\n             :use-macros     use-macros\n             :require-macros require-macros\n             :uses           uses\n             :requires       requires\n             :imports        imports}\n            ns-info\n            (if (:merge form-meta)\n              ;; for merging information in via require usage in REPLs\n              (let [ns-info' (get-in @env/*compiler* [::namespaces name])]\n                (if (pos? (count ns-info'))\n                  (let [merge-keys\n                        [:use-macros :require-macros :uses :requires :imports]]\n                    (merge\n                      ns-info'\n                      (merge-with merge\n                        (select-keys ns-info' merge-keys)\n                        (select-keys ns-info merge-keys))))\n                  ns-info))\n              ns-info)]\n        (swap! env/*compiler* update-in [::namespaces name] merge ns-info)\n        (merge {:op      :ns\n                :env     env\n                :form    form\n                :deps    @deps\n                :reload  @reload\n                :reloads @reloads}\n          (cond-> ns-info\n            (@reload :use)\n            (update-in [:uses]\n              (fn [m] (with-meta m {(@reload :use) true})))\n            (@reload :require)\n            (update-in [:requires]\n              (fn [m] (with-meta m {(@reload :require) true})))))))))",
                                  :title "Parser code",
                                  :repo "clojurescript",
                                  :tag "r1.7.228",
                                  :filename "src/main/clojure/cljs/analyzer.cljc",
                                  :lines [1883 1979]},
                         :full-name "special/ns",
                         :clj-symbol "clojure.core/ns",
                         :docstring "You must currently use the ns form only with the following caveats\n\n  * You must use the :only form of :use\n  * :require supports :as and :refer\n    - both options can be skipped\n    - in this case a symbol can be used as a libspec directly\n      - that is, (:require lib.foo) and (:require [lib.foo]) are both\n        supported and mean the same thing\n    - prefix lists are not supported\n  * The only option for :refer-clojure is :exclude\n  * :import is available for importing Google Closure classes\n    - ClojureScript types and records should be brought in with :use\n      or :require :refer, not :import ed\n  * Macros are written in Clojure, and are referenced via the new\n    :require-macros / :use-macros options to ns\n    - :require-macros and :use-macros support the same forms that\n      :require and :use do\n\nImplicit macro loading: If a namespace is required or used, and that\nnamespace itself requires or uses macros from its own namespace, then\nthe macros will be implicitly required or used using the same\nspecifications. This oftentimes leads to simplified library usage,\nsuch that the consuming namespace need not be concerned about\nexplicitly distinguishing between whether certain vars are functions\nor macros.\n\nInline macro specification: As a convenience, :require can be given\neither :include-macros true or :refer-macros [syms...]. Both desugar\ninto forms which explicitly load the matching Clojure file containing\nmacros. (This works independently of whether the namespace being\nrequired internally requires or uses its own macros.) For example:\n\n(ns testme.core\n(:require [foo.core :as foo :refer [foo-fn] :include-macros true]\n          [woz.core :as woz :refer [woz-fn] :refer-macros [app jx]]))\n\nis sugar for\n\n(ns testme.core\n(:require [foo.core :as foo :refer [foo-fn]]\n          [woz.core :as woz :refer [woz-fn]])\n(:require-macros [foo.core :as foo]\n                 [woz.core :as woz :refer [app jx]]))"},
           "cljs.core/IReversible" {:ns "cljs.core",
                                    :name "IReversible",
                                    :history [["+" "0.0-1211"]],
                                    :type "protocol",
                                    :full-name-encode "cljs.core/IReversible",
                                    :source {:code "(defprotocol IReversible\n  \"Protocol for reversing a seq.\"\n  (^clj -rseq [coll]\n    \"Returns a seq of the items in coll in reversed order.\"))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [614 617]},
                                    :methods [{:name "-rseq",
                                               :signature ["[coll]"],
                                               :docstring "Returns a seq of the items in coll in reversed order."}],
                                    :full-name "cljs.core/IReversible",
                                    :clj-symbol "clojure.lang/Reversible",
                                    :docstring "Protocol for reversing a seq."},
           "cljs.core/extend-protocol" {:ns "cljs.core",
                                        :name "extend-protocol",
                                        :signature ["[p & specs]"],
                                        :history [["+" "0.0-927"]],
                                        :type "macro",
                                        :related ["cljs.core/extend-type"],
                                        :full-name-encode "cljs.core/extend-protocol",
                                        :source {:code "(defmacro extend-protocol \n  [p & specs]\n  (emit-extend-protocol p specs))",
                                                 :title "Source code",
                                                 :repo "clojure",
                                                 :tag "clojure-1.7.0",
                                                 :filename "src/clj/clojure/core_deftype.clj",
                                                 :lines [819 857]},
                                        :full-name "cljs.core/extend-protocol",
                                        :clj-symbol "clojure.core/extend-protocol",
                                        :docstring "Useful when you want to provide several implementations of the same\nprotocol all at once. Takes a single protocol and the implementation\nof that protocol for one or more types. Expands into calls to\nextend-type:\n\n(extend-protocol Protocol\n  AType\n    (foo [x] ...)\n    (bar [x y] ...)\n  BType\n    (foo [x] ...)\n    (bar [x y] ...)\n  AClass\n    (foo [x] ...)\n    (bar [x y] ...)\n  nil\n    (foo [x] ...)\n    (bar [x y] ...))\n\nexpands into:\n\n(do\n (clojure.core/extend-type AType Protocol \n   (foo [x] ...) \n   (bar [x y] ...))\n (clojure.core/extend-type BType Protocol \n   (foo [x] ...) \n   (bar [x y] ...))\n (clojure.core/extend-type AClass Protocol \n   (foo [x] ...) \n   (bar [x y] ...))\n (clojure.core/extend-type nil Protocol \n   (foo [x] ...) \n   (bar [x y] ...)))"},
           "cljs.reader/read" {:ns "cljs.reader",
                               :name "read",
                               :signature ["[reader eof-is-error sentinel is-recursive]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.reader/read",
                               :source {:code "(defn read\n  [reader eof-is-error sentinel is-recursive]\n  (let [ch (read-char reader)]\n    (cond\n     (nil? ch) (if eof-is-error (reader-error reader \"EOF while reading\") sentinel)\n     (whitespace? ch) (recur reader eof-is-error sentinel is-recursive)\n     (comment-prefix? ch) (recur (read-comment reader ch) eof-is-error sentinel is-recursive)\n     :else (let [f (macros ch)\n                 res\n                 (cond\n                  f (f reader ch)\n                  (number-literal? reader ch) (read-number reader ch)\n                  :else (read-symbol reader ch))]\n     (if (identical? res reader)\n       (recur reader eof-is-error sentinel is-recursive)\n       res)))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/reader.cljs",
                                        :lines [439 458]},
                               :full-name "cljs.reader/read",
                               :clj-symbol "clojure.core/read",
                               :docstring "Reads the first object from a PushbackReader. Returns the object read.\nIf EOF, throws if eof-is-error is true. Otherwise returns sentinel.\n\nOnly supports edn (similar to clojure.edn/read)"},
           "cljs.core/EmptyList" {:ns "cljs.core",
                                  :name "EmptyList",
                                  :signature ["[meta]"],
                                  :history [["+" "0.0-927"]],
                                  :type "type",
                                  :full-name-encode "cljs.core/EmptyList",
                                  :source {:code "(deftype EmptyList [meta]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  IList\n\n  ICloneable\n  (-clone [_] (EmptyList. meta))\n\n  IWithMeta\n  (-with-meta [coll meta] (EmptyList. meta))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] nil)\n  (-rest [coll] ())\n\n  INext\n  (-next [coll] nil)\n\n  IStack\n  (-peek [coll] nil)\n  (-pop [coll] (throw (js/Error. \"Can't pop empty list\")))\n\n  ICollection\n  (-conj [coll o] (List. meta o nil 1 nil))\n\n  IEmptyableCollection\n  (-empty [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other]\n    (if (or (list? other)\n            (sequential? other))\n      (nil? (seq other))\n      false))\n\n  IHash\n  (-hash [coll] empty-ordered-hash)\n\n  ISeqable\n  (-seq [coll] nil)\n\n  ICounted\n  (-count [coll] 0)\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [2763 2817]},
                                  :full-name "cljs.core/EmptyList",
                                  :clj-symbol "clojure.lang/EmptyList"},
           "cljs.core/specify!" {:ns "cljs.core",
                                 :name "specify!",
                                 :signature ["[expr & impls]"],
                                 :history [["+" "0.0-2156"]],
                                 :type "macro",
                                 :full-name-encode "cljs.core/specifyBANG",
                                 :source {:code "(core/defmacro specify!\n  [expr & impls]\n  (core/let [x (with-meta (gensym \"x\") {:extend :instance})]\n    `(let [~x ~expr]\n       (extend-type ~x ~@impls)\n       ~x)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/clojure/cljs/core.cljc",
                                          :lines [1278 1284]},
                                 :full-name "cljs.core/specify!",
                                 :docstring "Identical to reify but mutates its first argument."},
           "cljs.core/DEMUNGE_MAP" {:ns "cljs.core",
                                    :name "DEMUNGE_MAP",
                                    :type "var",
                                    :source {:code "(def ^{:jsdoc [\"@enum {string}\"]}\n  DEMUNGE_MAP\n  #js {\"_\"             \"-\"\n       \"_COLON_\"       \":\"\n       \"_PLUS_\"        \"+\"\n       \"_GT_\"          \">\"\n       \"_LT_\"          \"<\"\n       \"_EQ_\"          \"=\"\n       \"_TILDE_\"       \"~\"\n       \"_BANG_\"        \"!\"\n       \"_CIRCA_\"       \"@\"\n       \"_SHARP_\"       \"#\"\n       \"_SINGLEQUOTE_\" \"'\"\n       \"_DOUBLEQUOTE_\" \"\\\\\\\"\"\n       \"_PERCENT_\"     \"%\"\n       \"_CARET_\"       \"^\"\n       \"_AMPERSAND_\"   \"&\"\n       \"_STAR_\"        \"*\"\n       \"_BAR_\"         \"|\"\n       \"_LBRACE_\"      \"{\"\n       \"_RBRACE_\"      \"}\"\n       \"_LBRACK_\"      \"[\"\n       \"_RBRACK_\"      \"]\"\n       \"_SLASH_\"       \"/\"\n       \"_BSLASH_\"      \"\\\\\\\\\"\n       \"_QMARK_\"       \"?\"})",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [310 335]},
                                    :full-name "cljs.core/DEMUNGE_MAP",
                                    :full-name-encode "cljs.core/DEMUNGE_MAP",
                                    :history [["+" "1.7.10"]]},
           "cljs.core/cat" {:ns "cljs.core",
                            :name "cat",
                            :signature ["[rf]"],
                            :history [["+" "0.0-2341"]],
                            :type "function",
                            :full-name-encode "cljs.core/cat",
                            :source {:code "(defn cat\n  [rf]\n  (let [rf1 (preserving-reduced rf)]  \n    (fn\n      ([] (rf))\n      ([result] (rf result))\n      ([result input]\n         (reduce rf1 result input)))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.7.228",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [9228 9238]},
                            :full-name "cljs.core/cat",
                            :clj-symbol "clojure.core/cat",
                            :docstring "A transducer which concatenates the contents of each input, which must be a\ncollection, into the reduction."},
           "clojure.walk/postwalk" {:ns "clojure.walk",
                                    :name "postwalk",
                                    :signature ["[f form]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "clojure.walk/postwalk",
                                    :source {:code "(defn postwalk\n  [f form]\n  (walk (partial postwalk f) f form))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/clojure/walk.cljs",
                                             :lines [52 58]},
                                    :full-name "clojure.walk/postwalk",
                                    :clj-symbol "clojure.walk/postwalk",
                                    :docstring "Performs a depth-first, post-order traversal of form.  Calls f on\neach sub-form, uses f's return value in place of the original.\nRecognizes all Clojure data structures. Consumes seqs as with doall."},
           "cljs.core/PersistentArrayMap.HASHMAP-THRESHOLD" {:ns "cljs.core",
                                                             :name "PersistentArrayMap.HASHMAP-THRESHOLD",
                                                             :type "var",
                                                             :parent-type "PersistentArrayMap",
                                                             :source {:code "(set! (.-HASHMAP-THRESHOLD PersistentArrayMap) 8)",
                                                                      :title "Source code",
                                                                      :repo "clojurescript",
                                                                      :tag "r1.7.228",
                                                                      :filename "src/main/cljs/cljs/core.cljs",
                                                                      :lines [6007]},
                                                             :full-name "cljs.core/PersistentArrayMap.HASHMAP-THRESHOLD",
                                                             :full-name-encode "cljs.core/PersistentArrayMapDOTHASHMAP-THRESHOLD",
                                                             :history [["+"
                                                                        "0.0-2301"]]},
           "clojure.zip/edit" {:ns "clojure.zip",
                               :name "edit",
                               :signature ["[loc f & args]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip/edit",
                               :source {:code "(defn edit\n  [loc f & args]\n    (replace loc (apply f (node loc) args)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/clojure/zip.cljs",
                                        :lines [189 192]},
                               :full-name "clojure.zip/edit",
                               :clj-symbol "clojure.zip/edit",
                               :docstring "Replaces the node at this loc with the value of (f node args)"},
           "cljs.core/unreduced" {:ns "cljs.core",
                                  :name "unreduced",
                                  :signature ["[x]"],
                                  :history [["+" "0.0-2411"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/unreduced",
                                  :source {:code "(defn unreduced\n  [x]\n  (if (reduced? x) (deref x) x))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [1287 1290]},
                                  :full-name "cljs.core/unreduced",
                                  :clj-symbol "clojure.core/unreduced",
                                  :docstring "If x is reduced?, returns (deref x), else returns x"},
           "cljs.core/re-seq" {:description "Returns a lazy sequence of successive matches of regex `re` in string `s`.",
                               :ns "cljs.core",
                               :name "re-seq",
                               :signature ["[re s]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/re-find"
                                         "cljs.core/re-pattern"
                                         "cljs.core/re-matches"
                                         "cljs.core/subs"
                                         "clojure.string/split"],
                               :full-name-encode "cljs.core/re-seq",
                               :source {:code "(defn re-seq\n  [re s]\n  (let [match-data (re-find re s)\n        match-idx (.search s re)\n        match-str (if (coll? match-data) (first match-data) match-data)\n        post-match (subs s (+ match-idx (count match-str)))]\n    (when match-data (lazy-seq (cons match-data (when (seq post-match) (re-seq re post-match)))))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [8724 8731]},
                               :full-name "cljs.core/re-seq",
                               :clj-symbol "clojure.core/re-seq",
                               :docstring "Returns a lazy sequence of successive matches of re in s."},
           "cljs.reader/read-list" {:ns "cljs.reader",
                                    :name "read-list",
                                    :type "function",
                                    :signature ["[rdr _]"],
                                    :source {:code "(defn read-list\n  [rdr _]\n  (apply list (read-delimited-list \")\" rdr true)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/reader.cljs",
                                             :lines [264 266]},
                                    :full-name "cljs.reader/read-list",
                                    :full-name-encode "cljs.reader/read-list",
                                    :history [["+" "0.0-927"]]},
           "cljs.core/IKVReduce" {:ns "cljs.core",
                                  :name "IKVReduce",
                                  :history [["+" "0.0-1211"]],
                                  :type "protocol",
                                  :full-name-encode "cljs.core/IKVReduce",
                                  :source {:code "(defprotocol IKVReduce\n  \"Protocol for associative types that can reduce themselves\n  via a function of key and val. Called by cljs.core/reduce-kv.\"\n  (-kv-reduce [coll f init]\n    \"Reduces an associative collection and returns the result. f should be\n     a function that takes three arguments.\"))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [583 588]},
                                  :methods [{:name "-kv-reduce",
                                             :signature ["[coll f init]"],
                                             :docstring "Reduces an associative collection and returns the result. f should be\n     a function that takes three arguments."}],
                                  :full-name "cljs.core/IKVReduce",
                                  :docstring "Protocol for associative types that can reduce themselves\n  via a function of key and val. Called by cljs.core/reduce-kv."},
           "cljs.core/Atom" {:ns "cljs.core",
                             :name "Atom",
                             :signature ["[state meta validator watches]"],
                             :history [["+" "0.0-927"]],
                             :type "type",
                             :full-name-encode "cljs.core/Atom",
                             :source {:code "(deftype Atom [state meta validator watches]\n  Object\n  (equiv [this other]\n    (-equiv this other))\n\n  IAtom\n  \n  IEquiv\n  (-equiv [o other] (identical? o other))\n\n  IDeref\n  (-deref [_] state)\n\n  IMeta\n  (-meta [_] meta)\n\n  IWatchable\n  (-notify-watches [this oldval newval]\n    (doseq [[key f] watches]\n      (f key this oldval newval)))\n  (-add-watch [this key f]\n    (set! (.-watches this) (assoc watches key f))\n    this)\n  (-remove-watch [this key]\n    (set! (.-watches this) (dissoc watches key)))\n\n  IHash\n  (-hash [this] (goog/getUid this)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [3951 3978]},
                             :full-name "cljs.core/Atom",
                             :clj-symbol "clojure.lang/Atom"},
           "clojure.core.reducers/foldcat" {:ns "clojure.core.reducers",
                                            :name "foldcat",
                                            :signature ["[coll]"],
                                            :history [["+" "0.0-1236"]],
                                            :type "function",
                                            :full-name-encode "clojure.core.reducers/foldcat",
                                            :source {:code "(defn foldcat\n  [coll]\n  (fold cat append! coll))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.7.228",
                                                     :filename "src/main/cljs/clojure/core/reducers.cljs",
                                                     :lines [237 240]},
                                            :full-name "clojure.core.reducers/foldcat",
                                            :clj-symbol "clojure.core.reducers/foldcat",
                                            :docstring "Equivalent to (fold cat append! coll)"},
           "cljs.core/specify" {:ns "cljs.core",
                                :name "specify",
                                :signature ["[expr & impls]"],
                                :history [["+" "0.0-2138"]],
                                :type "macro",
                                :full-name-encode "cljs.core/specify",
                                :source {:code "(core/defmacro specify\n  [expr & impls]\n  `(cljs.core/specify! (cljs.core/clone ~expr)\n     ~@impls))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/clojure/cljs/core.cljc",
                                         :lines [1286 1291]},
                                :full-name "cljs.core/specify",
                                :docstring "Identical to specify but does not mutate its first argument. The first\nargument must be an ICloneable instance."},
           "cljs.repl.server/start" {:ns "cljs.repl.server",
                                     :name "start",
                                     :signature ["[opts]"],
                                     :history [["+" "0.0-1503"]],
                                     :type "function",
                                     :full-name-encode "cljs.repl.server/start",
                                     :source {:code "(defn start\n  [opts]\n  (let [ss (ServerSocket. (:port opts))]\n    (.start\n      (Thread.\n        ((ns-resolve 'clojure.core 'binding-conveyor-fn)\n          (fn [] (server-loop opts ss)))))\n    (swap! state (fn [old] (assoc old :socket ss :port (:port opts))))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/clojure/cljs/repl/server.clj",
                                              :lines [170 178]},
                                     :full-name "cljs.repl.server/start",
                                     :docstring "Start the server on the specified port."},
           "cljs.core/IMap" {:ns "cljs.core",
                             :name "IMap",
                             :history [["+" "0.0-927"]],
                             :type "protocol",
                             :full-name-encode "cljs.core/IMap",
                             :source {:code "(defprotocol IMap\n  \"Protocol for adding mapping functionality to collections.\"\n  #_(-assoc-ex [coll k v])\n  (^clj -dissoc [coll k]\n    \"Returns a new collection of coll without the mapping for key k.\"))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [524 528]},
                             :methods [{:name "-dissoc",
                                        :signature ["[coll k]"],
                                        :docstring "Returns a new collection of coll without the mapping for key k."}],
                             :full-name "cljs.core/IMap",
                             :docstring "Protocol for adding mapping functionality to collections."},
           "cljs.core/pr-sequential-writer" {:ns "cljs.core",
                                             :name "pr-sequential-writer",
                                             :type "function",
                                             :signature ["[writer print-one begin sep end opts coll]"],
                                             :source {:code "(defn pr-sequential-writer [writer print-one begin sep end opts coll]\n  (binding [*print-level* (when-not (nil? *print-level*) (dec *print-level*))]\n    (if (and (not (nil? *print-level*)) (neg? *print-level*))\n      (-write writer \"#\")\n      (do\n        (-write writer begin)\n        (if (zero? (:print-length opts))\n          (when (seq coll)\n            (-write writer (or (:more-marker opts) \"...\")))\n          (do\n            (when (seq coll)\n              (print-one (first coll) writer opts))\n            (loop [coll (next coll) n (dec (:print-length opts))]\n              (if (and coll (or (nil? n) (not (zero? n))))\n                (do\n                  (-write writer sep)\n                  (print-one (first coll) writer opts)\n                  (recur (next coll) (dec n)))\n                (when (and (seq coll) (zero? n))\n                  (-write writer sep)\n                  (-write writer (or (:more-marker opts) \"...\")))))))\n        (-write writer end)))))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.7.228",
                                                      :filename "src/main/cljs/cljs/core.cljs",
                                                      :lines [8744
                                                              8765]},
                                             :full-name "cljs.core/pr-sequential-writer",
                                             :full-name-encode "cljs.core/pr-sequential-writer",
                                             :history [["+"
                                                        "0.0-1503"]]},
           "cljs.core/unchecked-multiply" {:return-type number,
                                           :ns "cljs.core",
                                           :name "unchecked-multiply",
                                           :signature ["[]"
                                                       "[x]"
                                                       "[x y]"
                                                       "[x y & more]"],
                                           :history [["+" "0.0-1798"]],
                                           :type "function/macro",
                                           :full-name-encode "cljs.core/unchecked-multiply",
                                           :source {:code "(defn ^number unchecked-multiply\n  ([] 1)\n  ([x] x)\n  ([x y] (cljs.core/unchecked-multiply x y))\n  ([x y & more] (reduce unchecked-multiply (cljs.core/unchecked-multiply x y) more)))",
                                                    :title "Function code",
                                                    :repo "clojurescript",
                                                    :tag "r1.7.228",
                                                    :filename "src/main/cljs/cljs/core.cljs",
                                                    :lines [2413 2418]},
                                           :extra-sources [{:code "(core/defmacro ^::ana/numeric unchecked-multiply\n  ([& xs] `(* ~@xs)))",
                                                            :title "Macro code",
                                                            :repo "clojurescript",
                                                            :tag "r1.7.228",
                                                            :filename "src/main/clojure/cljs/core.cljc",
                                                            :lines [995
                                                                    996]}],
                                           :full-name "cljs.core/unchecked-multiply",
                                           :clj-symbol "clojure.core/unchecked-multiply",
                                           :docstring "Returns the product of nums. (*) returns 1."},
           "cljs.reader/read-vector" {:ns "cljs.reader",
                                      :name "read-vector",
                                      :type "function",
                                      :signature ["[rdr _]"],
                                      :source {:code "(defn read-vector\n  [rdr _]\n  (read-delimited-list \"]\" rdr true))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/cljs/cljs/reader.cljs",
                                               :lines [270 272]},
                                      :full-name "cljs.reader/read-vector",
                                      :full-name-encode "cljs.reader/read-vector",
                                      :history [["+" "0.0-927"]]},
           "clojure.set/join" {:ns "clojure.set",
                               :name "join",
                               :signature ["[xrel yrel]"
                                           "[xrel yrel km]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.set/join",
                               :source {:code "(defn join\n  ([xrel yrel] ;natural join\n   (if (and (seq xrel) (seq yrel))\n     (let [ks (intersection (set (keys (first xrel))) (set (keys (first yrel))))\n           [r s] (if (<= (count xrel) (count yrel))\n                   [xrel yrel]\n                   [yrel xrel])\n           idx (index r ks)]\n       (reduce (fn [ret x]\n                 (let [found (idx (select-keys x ks))]\n                   (if found\n                     (reduce #(conj %1 (merge %2 x)) ret found)\n                     ret)))\n               #{} s))\n     #{}))\n  ([xrel yrel km] ;arbitrary key mapping\n   (let [[r s k] (if (<= (count xrel) (count yrel))\n                   [xrel yrel (map-invert km)]\n                   [yrel xrel km])\n         idx (index r (vals k))]\n     (reduce (fn [ret x]\n               (let [found (idx (rename-keys (select-keys x (keys k)) k))]\n                 (if found\n                   (reduce #(conj %1 (merge %2 x)) ret found)\n                   ret)))\n             #{} s))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/clojure/set.cljs",
                                        :lines [101 129]},
                               :full-name "clojure.set/join",
                               :clj-symbol "clojure.set/join",
                               :docstring "When passed 2 rels, returns the rel corresponding to the natural\njoin. When passed an additional keymap, joins on the corresponding\nkeys."},
           "cljs.core/HashMap" {:ns "cljs.core",
                                :name "HashMap",
                                :signature ["[meta count hashobj __hash]"],
                                :history [["+" "0.0-927"]
                                          ["-" "0.0-1798"]],
                                :type "type",
                                :full-name-encode "cljs.core/HashMap",
                                :source {:code "(deftype HashMap [meta count hashobj ^:mutable __hash]\n  Object\n  (toString [this]\n    (pr-str this))\n\n  IWithMeta\n  (-with-meta [coll meta] (HashMap. meta count hashobj __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (reduce -conj\n              coll\n              entry)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.HashMap/EMPTY meta))\n\n  IEquiv\n  (-equiv [coll other] (equiv-map coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-imap __hash))\n\n  ISeqable\n  (-seq [coll]\n    (when (pos? count)\n      (let [hashes (.sort (js-keys hashobj))]\n        (mapcat #(map vec (partition 2 (aget hashobj %)))\n                hashes))))\n\n  ICounted\n  (-count [coll] count)\n\n  ILookup\n  (-lookup [coll k] (-lookup coll k nil))\n  (-lookup [coll k not-found]\n    (let [bucket (aget hashobj (hash k))\n          i (when bucket (scan-array 2 k bucket))]\n      (if i\n        (aget bucket (inc i))\n        not-found)))\n\n  IAssociative\n  (-assoc [coll k v]\n    (let [h (hash k)\n          bucket (aget hashobj h)]\n      (if bucket\n        (let [new-bucket (aclone bucket)\n              new-hashobj (goog.object/clone hashobj)]\n          (aset new-hashobj h new-bucket)\n          (if-let [i (scan-array 2 k new-bucket)]\n            (do                         ; found key, replace\n              (aset new-bucket (inc i) v)\n              (HashMap. meta count new-hashobj nil))\n            (do                         ; did not find key, append\n              (.push new-bucket k v)\n              (HashMap. meta (inc count) new-hashobj nil))))\n        (let [new-hashobj (goog.object/clone hashobj)] ; did not find bucket\n          (aset new-hashobj h (array k v))\n          (HashMap. meta (inc count) new-hashobj nil)))))\n  (-contains-key? [coll k]\n    (let [bucket (aget hashobj (hash k))\n          i (when bucket (scan-array 2 k bucket))]\n      (if i\n        true\n        false)))\n\n  IMap\n  (-dissoc [coll k]\n    (let [h (hash k)\n          bucket (aget hashobj h)\n          i (when bucket (scan-array 2 k bucket))]\n      (if (not i)\n        coll ; key not found, return coll unchanged\n        (let [new-hashobj (goog.object/clone hashobj)]\n          (if (> 3 (alength bucket))\n            (js-delete new-hashobj h)\n            (let [new-bucket (aclone bucket)]\n              (.splice new-bucket i 2)\n              (aset new-hashobj h new-bucket)))\n          (HashMap. meta (dec count) new-hashobj nil)))))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1586",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [3737 3828]},
                                :full-name "cljs.core/HashMap",
                                :removed {:in "0.0-1798",
                                          :last-seen "0.0-1586"}},
           "cljs.repl.browser/handle-get" {:ns "cljs.repl.browser",
                                           :name "handle-get",
                                           :signature ["[opts conn request]"],
                                           :history [["+" "0.0-927"]
                                                     ["-" "0.0-1503"]],
                                           :type "function",
                                           :full-name-encode "cljs.repl.browser/handle-get",
                                           :source {:code "(defn handle-get [opts conn request]\n  (let [path (:path request)]\n    (cond\n     (.startsWith path \"/repl\") (send-repl-client-page opts conn request)\n     (:serve-static opts) (send-static opts conn request)\n     :else (send-404 conn (:path request)))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1450",
                                                    :filename "src/clj/cljs/repl/browser.clj",
                                                    :lines [199 204]},
                                           :full-name "cljs.repl.browser/handle-get",
                                           :removed {:in "0.0-1503",
                                                     :last-seen "0.0-1450"}},
           "cljs.core/es6-iterable" {:ns "cljs.core",
                                     :name "es6-iterable",
                                     :type "macro",
                                     :signature ["[ty]"],
                                     :source {:code "(core/defmacro es6-iterable [ty]\n  `(aset (.-prototype ~ty) cljs.core/ITER_SYMBOL\n     (fn []\n       (this-as this#\n         (cljs.core/es6-iterator this#)))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/clojure/cljs/core.cljc",
                                              :lines [2600 2604]},
                                     :full-name "cljs.core/es6-iterable",
                                     :full-name-encode "cljs.core/es6-iterable",
                                     :history [["+" "0.0-2411"]]},
           "cljs.reader/int-pattern" {:ns "cljs.reader",
                                      :name "int-pattern",
                                      :type "var",
                                      :source {:code "(def int-pattern (re-pattern \"^([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+))(N)?$\"))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/cljs/cljs/reader.cljs",
                                               :lines [98]},
                                      :full-name "cljs.reader/int-pattern",
                                      :full-name-encode "cljs.reader/int-pattern",
                                      :history [["+" "0.0-927"]]},
           "cljs.core/swap!" {:description "Atomically swaps the value of atom to be: `(apply f current-value-of-atom\nargs)`\n\nNote that `f` may be called multiple times, and thus should be free of side\neffects.\n\nReturns the value that was swapped in.",
                              :ns "cljs.core",
                              :name "swap!",
                              :signature ["[a f]"
                                          "[a f x]"
                                          "[a f x y]"
                                          "[a f x y & more]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/atom"
                                        "cljs.core/reset!"],
                              :full-name-encode "cljs.core/swapBANG",
                              :source {:code "(defn swap!\n  ([a f]\n     (if (instance? Atom a)\n       (reset! a (f (.-state a)))\n       (-swap! a f)))\n  ([a f x]\n     (if (instance? Atom a)\n       (reset! a (f (.-state a) x))\n       (-swap! a f x)))\n  ([a f x y]\n     (if (instance? Atom a)\n       (reset! a (f (.-state a) x y))\n       (-swap! a f x y)))\n  ([a f x y & more]\n     (if (instance? Atom a)\n       (reset! a (apply f (.-state a) x y more))\n       (-swap! a f x y more))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [4014 4034]},
                              :full-name "cljs.core/swap!",
                              :clj-symbol "clojure.core/swap!",
                              :docstring "Atomically swaps the value of atom to be:\n(apply f current-value-of-atom args). Note that f may be called\nmultiple times, and thus should be free of side effects.  Returns\nthe value that was swapped in."},
           "cljs.core/dec" {:description "Returns a number one less than `x`.",
                            :ns "cljs.core",
                            :name "dec",
                            :signature ["[x]"],
                            :history [["+" "0.0-927"]],
                            :type "function/macro",
                            :related ["cljs.core/inc"],
                            :full-name-encode "cljs.core/dec",
                            :source {:code "(defn dec\n  [x] (- x 1))",
                                     :title "Function code",
                                     :repo "clojurescript",
                                     :tag "r1.7.228",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [2338 2340]},
                            :extra-sources [{:code "(core/defmacro ^::ana/numeric dec [x]\n  `(- ~x 1))",
                                             :title "Macro code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/clojure/cljs/core.cljc",
                                             :lines [1062 1063]}],
                            :full-name "cljs.core/dec",
                            :clj-symbol "clojure.core/dec",
                            :docstring "Returns a number one less than num."},
           "cljs.core/EntriesIterator" {:ns "cljs.core",
                                        :name "EntriesIterator",
                                        :signature ["[s]"],
                                        :history [["+" "0.0-2268"]
                                                  ["-" "0.0-2371"]],
                                        :type "type",
                                        :full-name-encode "cljs.core/EntriesIterator",
                                        :source {:code "(deftype EntriesIterator [^:mutable s]\n  Object\n  (next [_]\n    (if-not (nil? s)\n      (let [[k v] (first s)]\n        (set! s (next s))\n        #js {:value #js [k v] :done false})\n      #js {:value nil :done true})))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2356",
                                                 :filename "src/cljs/cljs/core.cljs",
                                                 :lines [4874 4881]},
                                        :full-name "cljs.core/EntriesIterator",
                                        :removed {:in "0.0-2371",
                                                  :last-seen "0.0-2356"}},
           "cljs.core/*clojurescript-version*" {:ns "cljs.core",
                                                :name "*clojurescript-version*",
                                                :type "var",
                                                :source {:code "(def *clojurescript-version*)",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1.7.228",
                                                         :filename "src/main/cljs/cljs/core.cljs",
                                                         :lines [16]},
                                                :full-name "cljs.core/*clojurescript-version*",
                                                :full-name-encode "cljs.core/STARclojurescript-versionSTAR",
                                                :clj-symbol "clojure.core/*clojure-version*",
                                                :history [["+"
                                                           "0.0-2014"]]},
           "cljs.js/dump-core" {:ns "cljs.js",
                                :name "dump-core",
                                :type "macro",
                                :signature ["[]"],
                                :source {:code "(defmacro dump-core []\n  (let [state @env/*compiler*]\n    (if-not (false? (get-in state [:options :dump-core]))\n      `(quote ~(get-in state [::ana/namespaces 'cljs.core]))\n      `(hash-map))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/js.clj",
                                         :lines [20 24]},
                                :full-name "cljs.js/dump-core",
                                :full-name-encode "cljs.js/dump-core",
                                :history [["+" "1.7.10"]]},
           "clojure.core.reducers/fold" {:ns "clojure.core.reducers",
                                         :name "fold",
                                         :signature ["[reducef coll]"
                                                     "[combinef reducef coll]"
                                                     "[n combinef reducef coll]"],
                                         :history [["+" "0.0-1236"]],
                                         :type "function",
                                         :full-name-encode "clojure.core.reducers/fold",
                                         :source {:code "(defn fold\n  ([reducef coll] (fold reducef reducef coll))\n  ([combinef reducef coll] (fold 512 combinef reducef coll))\n  ([n combinef reducef coll]\n     (coll-fold coll n combinef reducef)))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.7.228",
                                                  :filename "src/main/cljs/clojure/core/reducers.cljs",
                                                  :lines [49 64]},
                                         :full-name "clojure.core.reducers/fold",
                                         :clj-symbol "clojure.core.reducers/fold",
                                         :docstring "Reduces a collection using a (potentially parallel) reduce-combine\nstrategy. The collection is partitioned into groups of approximately\nn (default 512), each of which is reduced with reducef (with a seed\nvalue obtained by calling (combinef) with no arguments). The results\nof these reductions are then reduced with combinef (default\nreducef). combinef must be associative, and, when called with no\narguments, (combinef) must produce its identity element. These\noperations may be performed in parallel, but the results will\npreserve order.\n\nNote: Performing operations in parallel is currently not implemented."},
           "cljs.core/StringBufferWriter" {:ns "cljs.core",
                                           :name "StringBufferWriter",
                                           :type "type",
                                           :signature ["[sb]"],
                                           :source {:code "(deftype StringBufferWriter [sb]\n  IWriter\n  (-write [_ s] (.append sb s))\n  (-flush [_] nil))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.7.228",
                                                    :filename "src/main/cljs/cljs/core.cljs",
                                                    :lines [758 761]},
                                           :full-name "cljs.core/StringBufferWriter",
                                           :full-name-encode "cljs.core/StringBufferWriter",
                                           :history [["+" "0.0-1503"]]},
           "cljs.js/analyze" {:ns "cljs.js",
                              :name "analyze",
                              :signature ["[state source cb]"
                                          "[state source name cb]"
                                          "[state source name opts cb]"],
                              :history [["+" "1.7.10"] ["-" "1.7.28"]],
                              :type "function",
                              :full-name-encode "cljs.js/analyze",
                              :source {:code "(defn analyze\n  ([state source cb]\n   (analyze state source nil cb))\n  ([state source name cb]\n   (analyze state source name nil cb))\n  ([state source name opts cb]\n   {:pre [(atom? state) (string? source)\n          (valid-name? name) (valid-opts? opts) (fn? cb)]}\n   (analyze*\n     {:*compiler*     state\n      :*data-readers* tags/*cljs-data-readers*\n      :*load-fn*      (or (:load opts) *load-fn*)\n      :*eval-fn*      (or (:eval opts) *eval-fn*)}\n     source name opts cb)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.10",
                                       :filename "src/main/cljs/cljs/js.cljs",
                                       :lines [423 459]},
                              :full-name "cljs.js/analyze",
                              :docstring "Analyze ClojureScript source. The compiler state will be populated with\nthe results of analyzes. The parameters:\n\nstate (atom)\n  the compiler state\n\nsource (string)\n  the ClojureScript source\n\nname (symbol)\n  optional, the name of the source\n\nopts (map)\n  compilation options.\n\n:eval - the eval function to invoke, see *eval-fn*\n:load - library resolution function, see *load-fn*\n\ncb (function)\n  callback, will be invoked with a map. If successful the map will contain\n  a key :value, the actual value is not meaningful. If unsuccessful the\n  map will contain a key :error with an ex-info instance describing the cause\n  of failure.",
                              :removed {:in "1.7.28",
                                        :last-seen "1.7.10"}},
           "cljs.repl.nashorn/eval-resource" {:ns "cljs.repl.nashorn",
                                              :name "eval-resource",
                                              :signature ["[engine path debug]"],
                                              :history [["+"
                                                         "0.0-2814"]],
                                              :type "function",
                                              :full-name-encode "cljs.repl.nashorn/eval-resource",
                                              :source {:code "(defn eval-resource\n      [engine path debug]\n      (let [r (io/resource path)]\n        (eval-str engine (slurp r))\n        (when debug (println \"loaded: \" path))))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.7.228",
                                                       :filename "src/main/clojure/cljs/repl/nashorn.clj",
                                                       :lines [48 53]},
                                              :full-name "cljs.repl.nashorn/eval-resource",
                                              :docstring "Evaluate a file on the classpath in the engine."},
           "clojure.browser.dom/remove-children" {:ns "clojure.browser.dom",
                                                  :name "remove-children",
                                                  :signature ["[id]"],
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "clojure.browser.dom/remove-children",
                                                  :source {:code "(defn remove-children\n  [id]\n  (let [parent (gdom/getElement (name id))]\n    (do (gdom/removeChildren parent))))",
                                                           :title "Source code",
                                                           :repo "clojurescript",
                                                           :tag "r1.7.228",
                                                           :filename "src/main/cljs/clojure/browser/dom.cljs",
                                                           :lines [92
                                                                   96]},
                                                  :full-name "clojure.browser.dom/remove-children",
                                                  :docstring "Remove all children from the element with the passed id."},
           "cljs.core/BlackNode" {:ns "cljs.core",
                                  :name "BlackNode",
                                  :type "type",
                                  :signature ["[key val left right __hash]"],
                                  :source {:code "(deftype BlackNode [key val left right ^:mutable __hash]\n  Object\n  (add-left [node ins]\n    (.balance-left ins node))\n\n  (add-right [node ins]\n    (.balance-right ins node))\n\n  (remove-left [node del]\n    (balance-left-del key val del right))\n\n  (remove-right [node del]\n    (balance-right-del key val left del))\n\n  (blacken [node] node)\n\n  (redden [node] (RedNode. key val left right nil))\n\n  (balance-left [node parent]\n    (BlackNode. (.-key parent) (.-val parent) node (.-right parent) nil))\n\n  (balance-right [node parent]\n    (BlackNode. (.-key parent) (.-val parent) (.-left parent) node nil))\n\n  (replace [node key val left right]\n    (BlackNode. key val left right nil))\n\n  (kv-reduce [node f init]\n    (tree-map-kv-reduce node f init))\n\n  IMapEntry\n  (-key [node] key)\n  (-val [node] val)\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IMeta\n  (-meta [node] nil)\n\n  IWithMeta\n  (-with-meta [node meta]\n    (with-meta [key val] meta))\n\n  IStack\n  (-peek [node] val)\n\n  (-pop [node] [key])\n\n  ICollection\n  (-conj [node o] [key val o])\n\n  IEmptyableCollection\n  (-empty [node] [])\n\n  ISequential\n  ISeqable\n  (-seq [node] (list key val))\n\n  ICounted\n  (-count [node] 2)\n\n  IIndexed\n  (-nth [node n]\n    (cond (== n 0) key\n          (== n 1) val\n          :else    nil))\n\n  (-nth [node n not-found]\n    (cond (== n 0) key\n          (== n 1) val\n          :else    not-found))\n\n  ILookup\n  (-lookup [node k] (-nth node k nil))\n  (-lookup [node k not-found] (-nth node k not-found))\n\n  IAssociative\n  (-assoc [node k v]\n    (assoc [key val] k v))\n\n  IVector\n  (-assoc-n [node n v]\n    (-assoc-n [key val] n v))\n\n  IReduce\n  (-reduce [node f]\n    (ci-reduce node f))\n\n  (-reduce [node f start]\n    (ci-reduce node f start))\n\n  IFn\n  (-invoke [node k]\n    (-lookup node k))\n\n  (-invoke [node k not-found]\n    (-lookup node k not-found)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [7234 7334]},
                                  :full-name "cljs.core/BlackNode",
                                  :full-name-encode "cljs.core/BlackNode",
                                  :history [["+" "0.0-1211"]]},
           "syntax/Infinity" {:description "The IEEE 754 Floating Point representations of infinity.\n\n`Infinity` = `+Infinity` = positive infinity\n\n`-Infinity` = negative infinity",
                              :ns "syntax",
                              :name "Infinity",
                              :history [["+" "0.0-1853"]],
                              :type "special symbol",
                              :related ["syntax/number" "syntax/NaN"],
                              :full-name-encode "syntax/Infinity",
                              :extra-sources [{:code "(defn- read-symbol\n  [rdr initch]\n  (let [[line column] (starting-line-col-info rdr)]\n    (when-let [token (read-token rdr initch)]\n      (case token\n\n        ;; special symbols\n        \"nil\" nil\n        \"true\" true\n        \"false\" false\n        \"/\" '/\n        \"NaN\" Double/NaN\n        \"-Infinity\" Double/NEGATIVE_INFINITY\n        (\"Infinity\" \"+Infinity\") Double/POSITIVE_INFINITY\n\n        (or (when-let [p (parse-symbol token)]\n              (with-meta (symbol (p 0) (p 1))\n                (when line\n                  (merge\n                   (when-let [file (get-file-name rdr)]\n                     {:file file})\n                   (let [[end-line end-column] (ending-line-col-info rdr)]\n                     {:line line\n                      :column column\n                      :end-line end-line\n                      :end-column end-column})))))\n            (reader-error rdr \"Invalid token: \" token))))))",
                                               :title "Reader code",
                                               :repo "tools.reader",
                                               :tag "tools.reader-1.0.0-alpha1",
                                               :filename "src/main/clojure/clojure/tools/reader.clj",
                                               :lines [303 329]}],
                              :usage ["Infinity"
                                      "-Infinity"
                                      "+Infinity"],
                              :examples [{:id "463fd4",
                                          :content "```clj\nInfinity\n;;=> Infinity\n\n+Infinity\n;;=> Infinity\n\n-Infinity\n;;=> -Infinity\n```\n\nMath with infinities:\n\n```clj\n(/ 1 0)\n;;=> Infinity\n\n(Math/log 0)\n;;=> -Infinity\n\n(* 0 Infinity)\n;;=> NaN\n```\n\nThey are equivalent to the JavaScript symbols:\n\n```clj\njs/Infinity\n;;=> Infinity\n\njs/-Infinity\n;;=> -Infinity\n```"}],
                              :full-name "syntax/Infinity",
                              :display "Infinity"},
           "cljs.core/some->" {:description "When `expr` is not nil, threads it into the first form (via `->`), and when that\nresult is not nil, through the next, etc.",
                               :ns "cljs.core",
                               :name "some->",
                               :signature ["[expr & forms]"],
                               :history [["+" "0.0-1798"]],
                               :type "macro",
                               :related ["cljs.core/->"
                                         "cljs.core/->>"
                                         "cljs.core/some->>"
                                         "cljs.core/some"],
                               :full-name-encode "cljs.core/some-GT",
                               :source {:code "(defmacro some->\n  [expr & forms]\n  (let [g (gensym)\n        pstep (fn [step] `(if (nil? ~g) nil (-> ~g ~step)))]\n    `(let [~g ~expr\n           ~@(interleave (repeat g) (map pstep forms))]\n       ~g)))",
                                        :title "Source code",
                                        :repo "clojure",
                                        :tag "clojure-1.7.0",
                                        :filename "src/clj/clojure/core.clj",
                                        :lines [7271 7280]},
                               :full-name "cljs.core/some->",
                               :clj-symbol "clojure.core/some->",
                               :docstring "When expr is not nil, threads it into the first form (via ->),\nand when that result is not nil, through the next etc"},
           "cljs.core/get-validator" {:description "Returns the validator function for atom `a`.",
                                      :ns "cljs.core",
                                      :name "get-validator",
                                      :signature ["[a]"],
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :related ["cljs.core/atom"
                                                "cljs.core/set-validator!"],
                                      :full-name-encode "cljs.core/get-validator",
                                      :source {:code "(defn get-validator\n  [iref]\n  (.-validator iref))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [4055 4058]},
                                      :full-name "cljs.core/get-validator",
                                      :clj-symbol "clojure.core/get-validator",
                                      :docstring "Gets the validator-fn for a var/ref/agent/atom."},
           "cljs.core/coll?" {:description "Returns true if `x` is a collection, false otherwise.\n\nLists, maps, sets, and vectors are collections.",
                              :return-type boolean,
                              :ns "cljs.core",
                              :name "coll?",
                              :signature ["[x]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/seq?"
                                        "cljs.core/list?"
                                        "cljs.core/sequential?"],
                              :full-name-encode "cljs.core/collQMARK",
                              :source {:code "(defn ^boolean coll?\n  [x]\n  (if (nil? x)\n    false\n    (satisfies? ICollection x)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [1889 1894]},
                              :examples [{:id "d30884",
                                          :content "```clj\n(coll? [1 2 3])\n;;=> true\n\n(coll? '(1 2 3))\n;;=> true\n\n(coll? #{1 2 3})\n;;=> true\n\n(coll? {:foo 1 :bar 2})\n;;=> true\n```\n\nNot collections:\n\n```clj\n(coll? \"foo\")\n;;=> false\n\n(coll? 123)\n;;=> false\n\n(coll? nil)\n;;=> false\n```"}],
                              :full-name "cljs.core/coll?",
                              :clj-symbol "clojure.core/coll?",
                              :docstring "Returns true if x satisfies ICollection"},
           "cljs.core/unchecked-negate-int" {:ns "cljs.core",
                                             :name "unchecked-negate-int",
                                             :signature ["[x]"],
                                             :history [["+"
                                                        "0.0-1798"]],
                                             :type "function/macro",
                                             :full-name-encode "cljs.core/unchecked-negate-int",
                                             :source {:code "(defn unchecked-negate-int [x]\n  (cljs.core/unchecked-negate-int x))",
                                                      :title "Function code",
                                                      :repo "clojurescript",
                                                      :tag "r1.7.228",
                                                      :filename "src/main/cljs/cljs/core.cljs",
                                                      :lines [2430
                                                              2431]},
                                             :extra-sources [{:code "(core/defmacro ^::ana/numeric unchecked-negate-int\n  ([x] `(- ~x)))",
                                                              :title "Macro code",
                                                              :repo "clojurescript",
                                                              :tag "r1.7.228",
                                                              :filename "src/main/clojure/cljs/core.cljc",
                                                              :lines [1004
                                                                      1005]}],
                                             :full-name "cljs.core/unchecked-negate-int",
                                             :clj-symbol "clojure.core/unchecked-negate-int"},
           "cljs.core/bit-or" {:description "Bitwise \"or\". Same as `x | y` in JavaScript.",
                               :ns "cljs.core",
                               :name "bit-or",
                               :signature ["[x y]" "[x y & more]"],
                               :history [["+" "0.0-927"]],
                               :type "function/macro",
                               :related ["cljs.core/bit-and"
                                         "cljs.core/bit-xor"],
                               :full-name-encode "cljs.core/bit-or",
                               :source {:code "(defn bit-or\n  ([x y] (cljs.core/bit-or x y))\n  ([x y & more]\n     (reduce bit-or (cljs.core/bit-or x y) more)))",
                                        :title "Function code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [2520 2524]},
                               :extra-sources [{:code "(core/defmacro ^::ana/numeric bit-or\n  ([x y] (core/list 'js* \"(~{} | ~{})\" x y))\n  ([x y & more] `(bit-or (bit-or ~x ~y) ~@more)))",
                                                :title "Macro code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/clojure/cljs/core.cljc",
                                                :lines [1104 1106]}],
                               :examples [{:id "ecea10",
                                           :content "Bits can be entered using radix notation:\n\n```clj\n(bit-or 2r1100 2r1010)\n;;=> 14\n;; 14 = 2r1110\n```\n\nSame numbers in decimal:\n\n```clj\n(bit-or 12 10)\n;;=> 14\n```"}],
                               :full-name "cljs.core/bit-or",
                               :clj-symbol "clojure.core/bit-or",
                               :docstring "Bitwise or"},
           "cljs.core/nfirst" {:description "Same as `(next (first coll))`.",
                               :ns "cljs.core",
                               :name "nfirst",
                               :signature ["[coll]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/next"],
                               :full-name-encode "cljs.core/nfirst",
                               :source {:code "(defn nfirst\n  [coll]\n  (next (first coll)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [1540 1543]},
                               :examples [{:id "60b8a4",
                                           :content "```clj\n(nfirst [[1 2 3] [4 5]])\n;;=> (2 3)\n\n(nfirst [[1 2] [3 4]])\n;;=> (2)\n\n(nfirst [[1] [2 3]])\n;;=> nil\n\n(nfirst [[] [1 2]])\n;;=> nil\n```"}],
                               :full-name "cljs.core/nfirst",
                               :clj-symbol "clojure.core/nfirst",
                               :docstring "Same as (next (first x))"},
           "cljs.core/keep" {:description "Returns a lazy sequence of the non-nil results of `(f item)`. Note, this means\nfalse return values will be included.\n\n`f` must be free of side-effects.\n\nReturns a transducer when no collection is provided.",
                             :ns "cljs.core",
                             :name "keep",
                             :signature ["[f]" "[f coll]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/keep-indexed"
                                       "cljs.core/map"
                                       "cljs.core/filter"],
                             :full-name-encode "cljs.core/keep",
                             :source {:code "(defn keep\n  ([f]\n   (fn [rf]\n     (fn\n       ([] (rf))\n       ([result] (rf result))\n       ([result input]\n          (let [v (f input)]\n            (if (nil? v)\n              result\n              (rf result v)))))))\n  ([f coll]\n   (lazy-seq\n    (when-let [s (seq coll)]\n      (if (chunked-seq? s)\n        (let [c (chunk-first s)\n              size (count c)\n              b (chunk-buffer size)]\n          (dotimes [i size]\n            (let [x (f (-nth c i))]\n              (when-not (nil? x)\n                (chunk-append b x))))\n          (chunk-cons (chunk b) (keep f (chunk-rest s))))\n        (let [x (f (first s))]\n          (if (nil? x)\n            (keep f (rest s))\n            (cons x (keep f (rest s))))))))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [3917 3946]},
                             :full-name "cljs.core/keep",
                             :clj-symbol "clojure.core/keep",
                             :docstring "Returns a lazy sequence of the non-nil results of (f item). Note,\nthis means false return values will be included.  f must be free of\nside-effects.  Returns a transducer when no collection is provided."},
           "cljs.core/take" {:description "Returns a lazy sequence of the first `n` items in `coll`. Returns all the items\nif there are fewer than `n`.\n\nReturns a stateful transducer when no collection is provided.",
                             :ns "cljs.core",
                             :name "take",
                             :signature ["[n]" "[n coll]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/drop"
                                       "cljs.core/take-while"
                                       "cljs.core/take-last"
                                       "cljs.core/take-nth"],
                             :full-name-encode "cljs.core/take",
                             :source {:code "(defn take\n  ([n]\n   {:pre [(number? n)]}\n     (fn [rf]\n       (let [na (volatile! n)]\n         (fn\n           ([] (rf))\n           ([result] (rf result))\n           ([result input]\n              (let [n @na\n                    nn (vswap! na dec)\n                    result (if (pos? n)\n                             (rf result input)\n                             result)]\n                (if (not (pos? nn))\n                  (ensure-reduced result)\n                  result)))))))\n  ([n coll]\n   {:pre [(number? n)]}\n     (lazy-seq\n       (when (pos? n)\n         (when-let [s (seq coll)]\n           (cons (first s) (take (dec n) (rest s))))))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [4243 4268]},
                             :full-name "cljs.core/take",
                             :clj-symbol "clojure.core/take",
                             :docstring "Returns a lazy sequence of the first n items in coll, or all items if\nthere are fewer than n.  Returns a stateful transducer when\nno collection is provided."},
           "cljs.core/PersistentHashSet.EMPTY" {:ns "cljs.core",
                                                :name "PersistentHashSet.EMPTY",
                                                :history [["+"
                                                           "0.0-1211"]],
                                                :parent-type "PersistentHashSet",
                                                :type "var",
                                                :full-name-encode "cljs.core/PersistentHashSetDOTEMPTY",
                                                :source {:code "(set! (.-EMPTY PersistentHashSet)\n  (PersistentHashSet. nil (.-EMPTY PersistentArrayMap) empty-unordered-hash))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1.7.228",
                                                         :filename "src/main/cljs/cljs/core.cljs",
                                                         :lines [8054
                                                                 8055]},
                                                :full-name "cljs.core/PersistentHashSet.EMPTY",
                                                :clj-symbol "clojure.lang/PersistentHashSet.EMPTY"},
           "cljs.core/cond" {:description "`clauses` must be an even number of forms, ie: `(cond t1 e1, t2 e2, t3 e3)`.\nEach test `t` is evaluated one at a time. If a test returns logical true, `cond`\nevaluates and returns the corresponding expression `e` and does not evaluate any\nof the other tests or expressions.\n\nIt is idiomatic to provide a default case as the last test pair using the\nkeyword `:else` (a keyword always evaluates to logical true).\n\n`(cond)` returns nil.",
                             :ns "cljs.core",
                             :name "cond",
                             :signature ["[& clauses]"],
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :related ["cljs.core/condp"
                                       "cljs.core/case"
                                       "special/if"],
                             :full-name-encode "cljs.core/cond",
                             :source {:code "(defmacro cond\n  [& clauses]\n    (when clauses\n      (list 'if (first clauses)\n            (if (next clauses)\n                (second clauses)\n                (throw (IllegalArgumentException.\n                         \"cond requires an even number of forms\")))\n            (cons 'clojure.core/cond (next (next clauses))))))",
                                      :title "Source code",
                                      :repo "clojure",
                                      :tag "clojure-1.7.0",
                                      :filename "src/clj/clojure/core.clj",
                                      :lines [564 577]},
                             :examples [{:id "0cc9ac",
                                         :content "```\n(def a 42)\n(cond\n  (< a 10) \"a is less than 10\"\n  (= a 10) \"a is 10\"\n  (> a 10) \"a is bigger than 10\"\n  :else \"a is not a number!\")\n;;=> \"a is bigger than 10\"\n```"}],
                             :full-name "cljs.core/cond",
                             :clj-symbol "clojure.core/cond",
                             :docstring "Takes a set of test/expr pairs. It evaluates each test one at a\ntime.  If a test returns logical true, cond evaluates and returns\nthe value of the corresponding expr and doesn't evaluate any of the\nother tests or exprs. (cond) returns nil."},
           "cljs.core/bit-and" {:description "Bitwise \"and\".  Same as `x & y` in JavaScript.",
                                :ns "cljs.core",
                                :name "bit-and",
                                :signature ["[x y]" "[x y & more]"],
                                :history [["+" "0.0-927"]],
                                :type "function/macro",
                                :related ["cljs.core/bit-or"],
                                :full-name-encode "cljs.core/bit-and",
                                :source {:code "(defn bit-and\n  ([x y] (cljs.core/bit-and x y))\n  ([x y & more]\n     (reduce bit-and (cljs.core/bit-and x y) more)))",
                                         :title "Function code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [2514 2518]},
                                :extra-sources [{:code "(core/defmacro ^::ana/numeric bit-and\n  ([x y] (core/list 'js* \"(~{} & ~{})\" x y))\n  ([x y & more] `(bit-and (bit-and ~x ~y) ~@more)))",
                                                 :title "Macro code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/clojure/cljs/core.cljc",
                                                 :lines [1095 1097]}],
                                :examples [{:id "3c0470",
                                            :content "Bits can be entered using radix notation:\n\n```clj\n(bit-and 2r1100 2r1010)\n;;=> 8\n;; 8 = 2r1000\n```\n\nSame numbers in decimal:\n\n```clj\n(bit-and 12 10)\n;;=> 8\n```"}],
                                :full-name "cljs.core/bit-and",
                                :clj-symbol "clojure.core/bit-and",
                                :docstring "Bitwise and"},
           "cljs.core/MetaFn" {:ns "cljs.core",
                               :name "MetaFn",
                               :type "type",
                               :signature ["[afn meta]"],
                               :source {:code "(deftype MetaFn [afn meta]\n  IMeta\n  (-meta [_] meta)\n  IWithMeta\n  (-with-meta [_ new-meta]\n    (MetaFn. afn new-meta))\n  Fn\n  IFn\n  (-invoke [_]\n    (afn))\n  (-invoke [_ a]\n    (afn a))\n  (-invoke [_ a b]\n    (afn a b))\n  (-invoke [_ a b c]\n    (afn a b c))\n  (-invoke [_ a b c d]\n    (afn a b c d))\n  (-invoke [_ a b c d e]\n    (afn a b c d e))\n  (-invoke [_ a b c d e f]\n    (afn a b c d e f))\n  (-invoke [_ a b c d e f g]\n    (afn a b c d e f g))\n  (-invoke [_ a b c d e f g h]\n    (afn a b c d e f g h))\n  (-invoke [_ a b c d e f g h i]\n    (afn a b c d e f g h i))\n  (-invoke [_ a b c d e f g h i j]\n    (afn a b c d e f g h i j))\n  (-invoke [_ a b c d e f g h i j k]\n    (afn a b c d e f g h i j k))\n  (-invoke [_ a b c d e f g h i j k l]\n    (afn a b c d e f g h i j k l))\n  (-invoke [_ a b c d e f g h i j k l m]\n    (afn a b c d e f g h i j k l m))\n  (-invoke [_ a b c d e f g h i j k l m n]\n    (afn a b c d e f g h i j k l m n))\n  (-invoke [_ a b c d e f g h i j k l m n o]\n    (afn a b c d e f g h i j k l m n o))\n  (-invoke [_ a b c d e f g h i j k l m n o p]\n    (afn a b c d e f g h i j k l m n o p))\n  (-invoke [_ a b c d e f g h i j k l m n o p q]\n    (afn a b c d e f g h i j k l m n o p q))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r]\n    (afn a b c d e f g h i j k l m n o p q r))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r s]\n    (afn a b c d e f g h i j k l m n o p q r s))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r s t]\n    (afn a b c d e f g h i j k l m n o p q r s t))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r s t rest]\n    (apply afn a b c d e f g h i j k l m n o p q r s t rest)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [1785 1836]},
                               :full-name "cljs.core/MetaFn",
                               :full-name-encode "cljs.core/MetaFn",
                               :history [["+" "0.0-2234"]]},
           "cljs.core/ObjMap.fromObject" {:ns "cljs.core",
                                          :name "ObjMap.fromObject",
                                          :signature ["[ks obj]"],
                                          :history [["+" "0.0-927"]],
                                          :parent-type "ObjMap",
                                          :type "function",
                                          :full-name-encode "cljs.core/ObjMapDOTfromObject",
                                          :source {:code "(set! (.-fromObject ObjMap) (fn [ks obj] (ObjMap. nil ks obj 0 nil)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/cljs/cljs/core.cljs",
                                                   :lines [5657]},
                                          :full-name "cljs.core/ObjMap.fromObject"},
           "cljs.core/PersistentArrayMap" {:ns "cljs.core",
                                           :name "PersistentArrayMap",
                                           :signature ["[meta cnt arr __hash]"],
                                           :history [["+" "0.0-1211"]],
                                           :type "type",
                                           :full-name-encode "cljs.core/PersistentArrayMap",
                                           :source {:code "(deftype PersistentArrayMap [meta cnt arr ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  ;; EXPERIMENTAL: subject to change\n  (keys [coll]\n    (es6-iterator (keys coll)))\n  (entries [coll]\n    (es6-entries-iterator (seq coll)))\n  (values [coll]\n    (es6-iterator (vals coll)))\n  (has [coll k]\n    (contains? coll k))\n  (get [coll k not-found]\n    (-lookup coll k not-found))\n  (forEach [coll f]\n    (doseq [[k v] coll]\n      (f v k)))\n\n  ICloneable\n  (-clone [_] (PersistentArrayMap. meta cnt arr __hash))\n\n  IWithMeta\n  (-with-meta [coll meta] (PersistentArrayMap. meta cnt arr __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (loop [ret coll es (seq entry)]\n        (if (nil? es)\n          ret\n          (let [e (first es)]\n            (if (vector? e)\n              (recur (-assoc ret (-nth e 0) (-nth e 1))\n                     (next es))\n              (throw (js/Error. \"conj on a map takes map entries or seqables of map entries\"))))))))\n\n  IEmptyableCollection\n  (-empty [coll] (-with-meta (.-EMPTY PersistentArrayMap) meta))\n\n  IEquiv\n  (-equiv [coll other]\n    (if (implements? IMap other)\n      (let [alen (alength arr)\n            ^not-native other other]\n        (if (== cnt (-count other))\n          (loop [i 0]\n            (if (< i alen)\n              (let [v (-lookup other (aget arr i) lookup-sentinel)]\n                (if-not (identical? v lookup-sentinel)\n                  (if (= (aget arr (inc i)) v)\n                    (recur (+ i 2))\n                    false)\n                  false))\n              true))\n          false))\n      (equiv-map coll other)))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-unordered-coll __hash))\n\n  IIterable\n  (-iterator [this]\n    (PersistentArrayMapIterator. arr 0 (* cnt 2)))\n  \n  ISeqable\n  (-seq [coll]\n    (persistent-array-map-seq arr 0 nil))\n\n  ICounted\n  (-count [coll] cnt)\n\n  ILookup\n  (-lookup [coll k]\n    (-lookup coll k nil))\n\n  (-lookup [coll k not-found]\n    (let [idx (array-map-index-of coll k)]\n      (if (== idx -1)\n        not-found\n        (aget arr (inc idx)))))\n\n  IAssociative\n  (-assoc [coll k v]\n    (let [idx (array-map-index-of coll k)]\n      (cond\n        (== idx -1)\n        (if (< cnt (.-HASHMAP-THRESHOLD PersistentArrayMap))\n          (let [arr (array-map-extend-kv coll k v)]\n            (PersistentArrayMap. meta (inc cnt) arr nil))\n          (-> (into (.-EMPTY PersistentHashMap) coll)\n            (-assoc k v)\n            (-with-meta meta)))\n\n        (identical? v (aget arr (inc idx)))\n        coll\n\n        :else\n        (let [arr (doto (aclone arr)\n                    (aset (inc idx) v))]\n          (PersistentArrayMap. meta cnt arr nil)))))\n\n  (-contains-key? [coll k]\n    (not (== (array-map-index-of coll k) -1)))\n\n  IMap\n  (-dissoc [coll k]\n    (let [idx (array-map-index-of coll k)]\n      (if (>= idx 0)\n        (let [len     (alength arr)\n              new-len (- len 2)]\n          (if (zero? new-len)\n            (-empty coll)\n            (let [new-arr (make-array new-len)]\n              (loop [s 0 d 0]\n                (cond\n                  (>= s len) (PersistentArrayMap. meta (dec cnt) new-arr nil)\n                  (= k (aget arr s)) (recur (+ s 2) d)\n                  :else (do (aset new-arr d (aget arr s))\n                            (aset new-arr (inc d) (aget arr (inc s)))\n                            (recur (+ s 2) (+ d 2))))))))\n        coll)))\n\n  IKVReduce\n  (-kv-reduce [coll f init]\n    (let [len (alength arr)]\n      (loop [i 0 init init]\n        (if (< i len)\n          (let [init (f init (aget arr i) (aget arr (inc i)))]\n            (if (reduced? init)\n              @init\n              (recur (+ i 2) init)))\n          init))))\n  \n  IReduce\n  (-reduce [coll f]\n    (seq-reduce f coll))\n  (-reduce [coll f start]\n    (seq-reduce f start coll))\n  \n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found))\n\n  IEditableCollection\n  (-as-transient [coll]\n    (TransientArrayMap. (js-obj) (alength arr) (aclone arr))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.7.228",
                                                    :filename "src/main/cljs/cljs/core.cljs",
                                                    :lines [5847 6003]},
                                           :full-name "cljs.core/PersistentArrayMap",
                                           :clj-symbol "clojure.lang/PersistentArrayMap"},
           "cljs.core/HashMapIter" {:ns "cljs.core",
                                    :name "HashMapIter",
                                    :type "type",
                                    :signature ["[nil-val root-iter seen]"],
                                    :source {:code "(deftype HashMapIter [nil-val root-iter ^:mutable seen]\n  Object\n  (hasNext [_]\n    (and ^boolean seen ^boolean (.hasNext root-iter)))\n  (next [_]\n    (if-not ^boolean seen\n      (do\n        (set! seen true)\n        nil-val)\n      (.next root-iter)))\n  (remove [_] (js/Error. \"Unsupported operation\")))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [6795 6805]},
                                    :full-name "cljs.core/HashMapIter",
                                    :full-name-encode "cljs.core/HashMapIter",
                                    :history [["+" "1.7.28"]]},
           "clojure.browser.event/unique-event-id" {:ns "clojure.browser.event",
                                                    :name "unique-event-id",
                                                    :type "function",
                                                    :signature ["[event-type]"],
                                                    :source {:code "(defn unique-event-id [event-type])",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r1.7.228",
                                                             :filename "src/main/cljs/clojure/browser/event.cljs",
                                                             :lines [94]},
                                                    :full-name "clojure.browser.event/unique-event-id",
                                                    :full-name-encode "clojure.browser.event/unique-event-id",
                                                    :history [["+"
                                                               "0.0-927"]]},
           "cljs.core/vswap!" {:ns "cljs.core",
                               :name "vswap!",
                               :signature ["[vol f & args]"],
                               :history [["+" "0.0-2496"]],
                               :type "macro",
                               :related ["cljs.core/vreset!"
                                         "cljs.core/volatile!"],
                               :full-name-encode "cljs.core/vswapBANG",
                               :source {:code "(core/defmacro vswap!\n  [vol f & args]\n  `(-vreset! ~vol (~f (-deref ~vol) ~@args)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/clojure/cljs/core.cljc",
                                        :lines [2626 2631]},
                               :full-name "cljs.core/vswap!",
                               :clj-symbol "clojure.core/vswap!",
                               :docstring "Non-atomically swaps the value of the volatile as if:\n(apply f current-value-of-vol args). Returns the value that\nwas swapped in."},
           "cljs.repl.browser/ext->mime-type" {:ns "cljs.repl.browser",
                                               :name "ext->mime-type",
                                               :type "var",
                                               :source {:code "(def ext->mime-type\n  {\".html\" \"text/html\"\n   \".css\" \"text/css\"\n\n   \".jpg\" \"image/jpeg\"\n   \".png\" \"image/png\"\n   \".gif\" \"image/gif\"\n\n   \".js\" \"text/javascript\"\n   \".json\" \"application/json\"\n   \".clj\" \"text/x-clojure\"\n   \".cljs\" \"text/x-clojure\"\n   \".cljc\" \"text/x-clojure\"\n   \".edn\" \"text/x-clojure\"\n   \".map\" \"application/json\"})",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.7.228",
                                                        :filename "src/main/clojure/cljs/repl/browser.clj",
                                                        :lines [28 42]},
                                               :full-name "cljs.repl.browser/ext->mime-type",
                                               :full-name-encode "cljs.repl.browser/ext-GTmime-type",
                                               :history [["+"
                                                          "0.0-3291"]]},
           "cljs.core/ObjMap.HASHMAP_THRESHOLD" {:ns "cljs.core",
                                                 :name "ObjMap.HASHMAP_THRESHOLD",
                                                 :type "var",
                                                 :parent-type "ObjMap",
                                                 :source {:code "(set! (.-HASHMAP_THRESHOLD ObjMap) 8)",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r1.7.228",
                                                          :filename "src/main/cljs/cljs/core.cljs",
                                                          :lines [5655]},
                                                 :full-name "cljs.core/ObjMap.HASHMAP_THRESHOLD",
                                                 :full-name-encode "cljs.core/ObjMapDOTHASHMAP_THRESHOLD",
                                                 :history [["+"
                                                            "0.0-1211"]]},
           "clojure.set/project" {:ns "clojure.set",
                                  :name "project",
                                  :signature ["[xrel ks]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.set/project",
                                  :source {:code "(defn project\n  [xrel ks]\n    (set (map #(select-keys % ks) xrel)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/clojure/set.cljs",
                                           :lines [67 70]},
                                  :full-name "clojure.set/project",
                                  :clj-symbol "clojure.set/project",
                                  :docstring "Returns a rel of the elements of xrel with only the keys in ks"},
           "cljs.core/int" {:description "Coerces `x` to an integer by stripping decimal places.",
                            :ns "cljs.core",
                            :name "int",
                            :signature ["[x]"],
                            :history [["+" "0.0-1211"]],
                            :type "function/macro",
                            :related ["cljs.core/char"
                                      "cljs.core/integer?"],
                            :full-name-encode "cljs.core/int",
                            :source {:code "(defn int\n  [x]\n  (bit-or x 0))",
                                     :title "Function code",
                                     :repo "clojurescript",
                                     :tag "r1.7.228",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [2457 2460]},
                            :extra-sources [{:code "(core/defmacro ^::ana/numeric int [x]\n  `(bit-or ~x 0))",
                                             :title "Macro code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/clojure/cljs/core.cljc",
                                             :lines [1108 1109]}],
                            :full-name "cljs.core/int",
                            :clj-symbol "clojure.core/int",
                            :docstring "Coerce to int by stripping decimal places."},
           "cljs.repl/js-src->cljs-src" {:return-type File,
                                         :ns "cljs.repl",
                                         :name "js-src->cljs-src",
                                         :signature ["[f]"],
                                         :history [["+" "0.0-2814"]],
                                         :type "function",
                                         :full-name-encode "cljs.repl/js-src-GTcljs-src",
                                         :source {:code "(defn ^File js-src->cljs-src\n  [f]\n  (let [f (io/file f)\n        dir (.getParentFile f)\n        base-name (string/replace (.getName f) \".js\" \"\")\n        cljsf (io/file dir (str base-name \".cljs\"))]\n    (if (.exists cljsf)\n      cljsf\n      (let [cljcf (io/file dir (str base-name \".cljc\"))]\n        (if (.exists cljcf)\n          cljcf)))))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.7.228",
                                                  :filename "src/main/clojure/cljs/repl.cljc",
                                                  :lines [210 222]},
                                         :full-name "cljs.repl/js-src->cljs-src",
                                         :docstring "Map a JavaScript output file back to the original ClojureScript source\nfile (.cljs or .cljc)."},
           "special/js*" {:ns "special",
                          :name "js*",
                          :type "special form",
                          :source {:code "(defmethod parse 'js*\n  [op env [_ jsform & args :as form] _ _]\n  (when-not (string? jsform)\n    (throw (error env \"Invalid js* form\")))\n  (if-not (nil? args)\n    (analyze-js-star env jsform args form)\n    (let [code      (apply str (js-star-interp env jsform))\n          tag       (get-js-tag form)\n          form-meta (meta form)\n          js-op     (:js-op form-meta)\n          numeric   (:numeric form-meta)]\n      {:op :js\n       :env env\n       :form form\n       :code code\n       :tag tag\n       :js-op js-op\n       :numeric numeric})))",
                                   :title "Parser code",
                                   :repo "clojurescript",
                                   :tag "r1.7.228",
                                   :filename "src/main/clojure/cljs/analyzer.cljc",
                                   :lines [2196 2213]},
                          :full-name "special/js*",
                          :full-name-encode "special/jsSTAR",
                          :history [["+" "0.0-927"]]},
           "clojure.reflect/macroexpand" {:ns "clojure.reflect",
                                          :name "macroexpand",
                                          :signature ["[form]"],
                                          :history [["+" "0.0-1503"]],
                                          :type "function",
                                          :full-name-encode "clojure.reflect/macroexpand",
                                          :source {:code "(defn macroexpand\n  [form]\n  (query-reflection (str \"macroform=\" (js/encodeURIComponent (str form))) println))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/cljs/clojure/reflect.cljs",
                                                   :lines [33 37]},
                                          :full-name "clojure.reflect/macroexpand",
                                          :docstring "Queries the reflection api with a quoted macro form, then calls the\ncallback function with the macroexpanded form, as a string."},
           "syntax/quote" {:description "`'foo` is sugar for [`(quote foo)`][doc:special/quote].\n\nPrevent the evaluation of the following form.",
                           :ns "syntax",
                           :name "quote",
                           :history [["+" "0.0-927"]],
                           :type "syntax",
                           :related ["special/quote"],
                           :full-name-encode "syntax/quote",
                           :extra-sources ({:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                            :title "Reader table",
                                            :repo "tools.reader",
                                            :tag "tools.reader-1.0.0-alpha1",
                                            :filename "src/main/clojure/clojure/tools/reader.clj",
                                            :lines [743 762]}),
                           :examples [{:id "0d2c26",
                                       :content "```clj\n'foo\n;;=> foo\n\n'(a b c)\n;;=> (a b c)\n\n'[a b c]\n;;=> [a b c]\n\n'(a b (c d))\n;;=> (a b (c d))\n```"}],
                           :full-name "syntax/quote",
                           :display "' quote",
                           :clj-doc "http://clojure.org/reader#toc2"},
           "cljs.pprint/with-pretty-writer" {:ns "cljs.pprint",
                                             :name "with-pretty-writer",
                                             :type "macro",
                                             :signature ["[base-writer & body]"],
                                             :source {:code "(defmacro with-pretty-writer [base-writer & body]\n  `(let [base-writer# ~base-writer\n         new-writer# (not (pretty-writer? base-writer#))]\n     (cljs.core/binding [cljs.core/*out* (if new-writer#\n                         (make-pretty-writer base-writer# *print-right-margin* *print-miser-width*)\n                         base-writer#)]\n       ~@body\n       (-ppflush cljs.core/*out*))))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.7.228",
                                                      :filename "src/main/cljs/cljs/pprint.clj",
                                                      :lines [17 24]},
                                             :full-name "cljs.pprint/with-pretty-writer",
                                             :full-name-encode "cljs.pprint/with-pretty-writer",
                                             :history [["+"
                                                        "0.0-3255"]]},
           "clojure.string/trim-newline" {:description "Removes all trailing newline `\\n` or return `\\r` characters from string.\n\nSimilar to Perl's chomp.",
                                          :ns "clojure.string",
                                          :name "trim-newline",
                                          :signature ["[s]"],
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "clojure.string/trim-newline",
                                          :source {:code "(defn trim-newline\n  [s]\n  (loop [index (.-length s)]\n    (if (zero? index)\n      \"\"\n      (let [ch (get s (dec index))]\n        (if (or (identical? \\newline ch)\n                (identical? \\return ch))\n          (recur (dec index))\n          (.substring s 0 index))))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/cljs/clojure/string.cljs",
                                                   :lines [180 191]},
                                          :full-name "clojure.string/trim-newline",
                                          :clj-symbol "clojure.string/trim-newline",
                                          :docstring "Removes all trailing newline \\n or return \\r characters from\nstring.  Similar to Perl's chomp."},
           "cljs.repl.reflect/parse-param" {:ns "cljs.repl.reflect",
                                            :name "parse-param",
                                            :signature ["[path]"],
                                            :history [["+" "0.0-1503"]],
                                            :type "function",
                                            :full-name-encode "cljs.repl.reflect/parse-param",
                                            :source {:code "(defn parse-param\n  [path]\n  (-> (str/split path #\"\\?\")\n      (last)\n      (str/split #\"=\")))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.7.228",
                                                     :filename "src/main/clojure/cljs/repl/reflect.clj",
                                                     :lines [44 50]},
                                            :full-name "cljs.repl.reflect/parse-param",
                                            :docstring "Parses the query parameter of a path of the form \"/reflect?var=foo\"\ninto the vector [\"var\" \"foo\"]."},
           "cljs.repl/print-mapped-stacktrace" {:ns "cljs.repl",
                                                :name "print-mapped-stacktrace",
                                                :signature ["[stacktrace]"
                                                            "[stacktrace opts]"],
                                                :history [["+"
                                                           "0.0-2814"]],
                                                :type "function",
                                                :full-name-encode "cljs.repl/print-mapped-stacktrace",
                                                :source {:code "(defn print-mapped-stacktrace\n  ([stacktrace] (print-mapped-stacktrace stacktrace *repl-opts*))\n  ([stacktrace opts]\n   (doseq [{:keys [function file line column]}\n           (mapped-stacktrace stacktrace opts)]\n     (err-out\n       (println \"\\t\"\n         (str (when function (str function \" \"))\n           \"(\" file (when line (str \":\" line)) (when column (str \":\" column)) \")\"))))))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1.7.228",
                                                         :filename "src/main/clojure/cljs/repl.cljc",
                                                         :lines [343
                                                                 353]},
                                                :full-name "cljs.repl/print-mapped-stacktrace",
                                                :docstring "Given a vector representing the canonicalized JavaScript stacktrace\nprint the ClojureScript stacktrace. See mapped-stacktrace."},
           "specialrepl/in-ns" {:description "Only usable from a REPL.\n\nChanges to the namespace `name`, creating it if needed.\n\nSets `*cljs-ns*` to the namespace `name`.",
                                :ns "specialrepl",
                                :name "in-ns",
                                :signature ["[name]"],
                                :history [["+" "0.0-927"]],
                                :type "special form (repl)",
                                :full-name-encode "specialrepl/in-ns",
                                :source {:code "(def default-special-fns\n  (let [load-file-fn\n        (fn self\n          ([repl-env env form]\n            (self repl-env env form nil))\n          ([repl-env env [_ file :as form] opts]\n            (load-file repl-env file opts)))\n        in-ns-fn\n        (fn self\n          ([repl-env env form]\n           (self repl-env env form nil))\n          ([repl-env env [_ [quote ns-name] :as form] _]\n            ;; guard against craziness like '5 which wreaks havoc\n           (when-not (and (= quote 'quote) (symbol? ns-name))\n             (throw (IllegalArgumentException. \"Argument to in-ns must be a symbol.\")))\n           (when-not (ana/get-namespace ns-name)\n             (swap! env/*compiler* assoc-in [::ana/namespaces ns-name] {:name ns-name})\n             (-evaluate repl-env \"<cljs repl>\" 1\n               (str \"goog.provide('\" (comp/munge ns-name) \"');\")))\n           (set! ana/*cljs-ns* ns-name)))]\n    (wrap-special-fns wrap-self\n     {'in-ns in-ns-fn\n      'clojure.core/in-ns in-ns-fn\n      'require\n      (fn self\n        ([repl-env env form]\n         (self repl-env env form nil))\n        ([repl-env env [_ & specs :as form] opts]\n         (let [is-self-require? (self-require? specs)\n               [target-ns restore-ns]\n               (if-not is-self-require?\n                 [ana/*cljs-ns* nil]\n                 ['cljs.user ana/*cljs-ns*])]\n           (evaluate-form repl-env env \"<cljs repl>\"\n                          (with-meta\n                            `(~'ns ~target-ns\n                               (:require ~@(-> specs canonicalize-specs decorate-specs)))\n                            {:merge true :line 1 :column 1})\n                          identity opts)\n           (when is-self-require?\n             (set! ana/*cljs-ns* restore-ns)))))\n      'require-macros\n      (fn self\n        ([repl-env env form]\n         (self repl-env env form nil))\n        ([repl-env env [_ & specs :as form] opts]\n         (evaluate-form repl-env env \"<cljs repl>\"\n                        (with-meta\n                          `(~'ns ~ana/*cljs-ns*\n                             (:require-macros ~@(-> specs canonicalize-specs decorate-specs)))\n                          {:merge true :line 1 :column 1})\n                        identity opts)))\n      'import\n      (fn self\n        ([repl-env env form]\n         (self repl-env env form nil))\n        ([repl-env env [_ & specs :as form] opts]\n         (evaluate-form repl-env env \"<cljs repl>\"\n                        (with-meta\n                          `(~'ns ~ana/*cljs-ns*\n                             (:import\n                              ~@(map\n                                 (fn [quoted-spec-or-kw]\n                                   (if (keyword? quoted-spec-or-kw)\n                                     quoted-spec-or-kw\n                                     (second quoted-spec-or-kw)))\n                                 specs)))\n                          {:merge true :line 1 :column 1})\n                        identity opts)))\n      'load-file load-file-fn\n      'clojure.core/load-file load-file-fn\n      'load-namespace\n      (fn self\n        ([repl-env env form]\n         (self env repl-env form nil))\n        ([repl-env env [_ ns :as form] opts]\n         (load-namespace repl-env ns opts)))})))",
                                         :title "repl specials table",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/clojure/cljs/repl.cljc",
                                         :lines [642 718]},
                                :examples [{:id "e81eb3",
                                            :content "```clj\n(in-ns 'foo.core)\n```"}],
                                :full-name "specialrepl/in-ns",
                                :clj-symbol "clojure.core/in-ns",
                                :docstring "Sets *cljs-ns* to the namespace named by the symbol, creating it if needed."},
           "special/let*" {:ns "special",
                           :name "let*",
                           :type "special form",
                           :source {:code "(defmethod parse 'let*\n  [op encl-env form _ _]\n  (analyze-let encl-env form false))",
                                    :title "Parser code",
                                    :repo "clojurescript",
                                    :tag "r1.7.228",
                                    :filename "src/main/clojure/cljs/analyzer.cljc",
                                    :lines [1517 1519]},
                           :full-name "special/let*",
                           :full-name-encode "special/letSTAR",
                           :history [["+" "0.0-927"]]},
           "cljs.core/pr-seq-writer" {:ns "cljs.core",
                                      :name "pr-seq-writer",
                                      :type "function",
                                      :signature ["[objs writer opts]"],
                                      :source {:code "(defn pr-seq-writer [objs writer opts]\n  (pr-writer (first objs) writer opts)\n  (doseq [obj (next objs)]\n    (-write writer \" \")\n    (pr-writer obj writer opts)))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [8888 8892]},
                                      :full-name "cljs.core/pr-seq-writer",
                                      :full-name-encode "cljs.core/pr-seq-writer",
                                      :history [["+" "0.0-1503"]]},
           "cljs.repl/analyze-source" {:ns "cljs.repl",
                                       :name "analyze-source",
                                       :signature ["[src-dir]"
                                                   "[src-dir opts]"],
                                       :history [["+" "0.0-1503"]],
                                       :type "function",
                                       :full-name-encode "cljs.repl/analyze-source",
                                       :source {:code "(defn analyze-source\n  ([src-dir] (analyze-source src-dir nil))\n  ([src-dir opts]\n    (if-let [src-dir (and (not (empty? src-dir))\n                       (File. src-dir))]\n      (doseq [file (comp/cljs-files-in src-dir)]\n        (ana/analyze-file (str \"file://\" (.getAbsolutePath file)) opts)))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/clojure/cljs/repl.cljc",
                                                :lines [720 728]},
                                       :full-name "cljs.repl/analyze-source",
                                       :docstring "Given a source directory, analyzes all .cljs files. Used to populate\n(:cljs.analyzer/namespaces compiler-env) so as to support code reflection."},
           "cljs.repl.browser/stop-server" {:moved "cljs.repl.server/stop",
                                            :ns "cljs.repl.browser",
                                            :name "stop-server",
                                            :signature ["[]"],
                                            :history [["+" "0.0-927"]
                                                      ["-" "0.0-1503"]],
                                            :type "function",
                                            :full-name-encode "cljs.repl.browser/stop-server",
                                            :source {:code "(defn stop-server\n  []\n  (.close (:socket @server-state)))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1450",
                                                     :filename "src/clj/cljs/repl/browser.clj",
                                                     :lines [272 274]},
                                            :full-name "cljs.repl.browser/stop-server",
                                            :removed {:in "0.0-1503",
                                                      :last-seen "0.0-1450"}},
           "special/throw" {:description "`expr` is evaluated and thrown, hopefully to be caught by a `try` expression.\n\n`(throw (js/Error. \"Oops!\"))`",
                            :ns "special",
                            :name "throw",
                            :signature ["[expr]"],
                            :history [["+" "0.0-927"]],
                            :type "special form",
                            :related ["special/try"
                                      "special/catch"
                                      "special/finally"],
                            :full-name-encode "special/throw",
                            :source {:code "(defmethod parse 'throw\n  [op env [_ throw :as form] name _]\n  (let [throw-expr (disallowing-recur (analyze (assoc env :context :expr) throw))]\n    {:env env :op :throw :form form\n     :throw throw-expr\n     :children [throw-expr]}))",
                                     :title "Parser code",
                                     :repo "clojurescript",
                                     :tag "r1.7.228",
                                     :filename "src/main/clojure/cljs/analyzer.cljc",
                                     :lines [1001 1006]},
                            :full-name "special/throw",
                            :clj-symbol "clojure.core/throw",
                            :docstring "The expr is evaluated and thrown."},
           "cljs.core/chunk-cons" {:ns "cljs.core",
                                   :name "chunk-cons",
                                   :type "function",
                                   :signature ["[chunk rest]"],
                                   :source {:code "(defn chunk-cons [chunk rest]\n  (if (zero? (-count chunk))\n    rest\n    (ChunkedCons. chunk rest nil nil)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [3188 3191]},
                                   :full-name "cljs.core/chunk-cons",
                                   :full-name-encode "cljs.core/chunk-cons",
                                   :history [["+" "0.0-1424"]]},
           "syntax/namespace" {:description "`/` can appear once inside a symbol. The left side of `/` must always be a namespace.\nThe right side completes the reference to the symbol.\n\nIt should be noted that this __differs from Clojure__.  For example,\nnotice `/` appearing before `PersistentVector` in Clojure:\n\n- Clojure: `clojure.lang.PersistentVector/EMPTY`\n- ClojureScript: `cljs.core/PersistentVector.EMPTY`\n\n[doc:cljs.core//] is the division function if it is by itself.\n\nSee [doc:syntax/dot] for usage of dots on either side of `/`",
                               :ns "syntax",
                               :name "namespace",
                               :history [["+" "0.0-927"]],
                               :type "special character",
                               :related ["syntax/dot"],
                               :full-name-encode "syntax/namespace",
                               :usage ["foo/baz" "foo.bar/baz"],
                               :edn-doc "https://github.com/edn-format/edn#symbols",
                               :full-name "syntax/namespace",
                               :display "/ namespace slash",
                               :clj-doc "http://clojure.org/cheatsheet"},
           "clojure.zip/insert-left" {:ns "clojure.zip",
                                      :name "insert-left",
                                      :signature ["[loc item]"],
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "clojure.zip/insert-left",
                                      :source {:code "(defn insert-left\n  [loc item]\n    (let [[node {l :l :as path}] loc]\n      (if (nil? path)\n        (throw \"Insert at top\")\n        (with-meta [node (assoc path :l (conj l item) :changed? true)] (meta loc)))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/cljs/clojure/zip.cljs",
                                               :lines [165 172]},
                                      :full-name "clojure.zip/insert-left",
                                      :clj-symbol "clojure.zip/insert-left",
                                      :docstring "Inserts the item as the left sibling of the node at this loc,\nwithout moving"},
           "cljs.core/*print-level*" {:ns "cljs.core",
                                      :name "*print-level*",
                                      :history [["+" "0.0-2120"]],
                                      :type "dynamic var",
                                      :full-name-encode "cljs.core/STARprint-levelSTAR",
                                      :source {:code "(def\n  ^{:dynamic true\n    :doc \"*print-level* controls how many levels deep the printer will\n  print nested objects. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  level to print. Each argument to print is at level 0; if an argument is a\n  collection, its items are at level 1; and so on. If an object is a\n  collection and is at a level greater than or equal to the value bound to\n  *print-level*, the printer prints '#' to represent it. The root binding\n  is nil indicating no limit.\"\n    :jsdoc [\"@type {null|number}\"]}\n  *print-level* nil)",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [117 128]},
                                      :full-name "cljs.core/*print-level*",
                                      :clj-symbol "clojure.core/*print-level*",
                                      :docstring "*print-level* controls how many levels deep the printer will\nprint nested objects. If it is bound to logical false, there is no\nlimit. Otherwise, it must be bound to an integer indicating the maximum\nlevel to print. Each argument to print is at level 0; if an argument is a\ncollection, its items are at level 1; and so on. If an object is a\ncollection and is at a level greater than or equal to the value bound to\n*print-level*, the printer prints '#' to represent it. The root binding\nis nil indicating no limit."},
           "cljs.repl/*repl-opts*" {:ns "cljs.repl",
                                    :name "*repl-opts*",
                                    :type "dynamic var",
                                    :source {:code "(def ^:dynamic *repl-opts* nil)",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/clojure/cljs/repl.cljc",
                                             :lines [36]},
                                    :full-name "cljs.repl/*repl-opts*",
                                    :full-name-encode "cljs.repl/STARrepl-optsSTAR",
                                    :history [["+" "0.0-2911"]]},
           "cljs.core/true?" {:description "Returns true if `x` is the value true, false otherwise.",
                              :return-type boolean,
                              :ns "cljs.core",
                              :name "true?",
                              :signature ["[x]"],
                              :history [["+" "0.0-927"]],
                              :type "function/macro",
                              :related ["cljs.core/false?"],
                              :full-name-encode "cljs.core/trueQMARK",
                              :source {:code "(defn ^boolean true?\n  [x] (cljs.core/true? x))",
                                       :title "Function code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [1986 1988]},
                              :extra-sources [{:code "(core/defmacro true? [x]\n  (bool-expr (core/list 'js* \"~{} === true\" x)))",
                                               :title "Macro code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/clojure/cljs/core.cljc",
                                               :lines [898 899]}],
                              :full-name "cljs.core/true?",
                              :clj-symbol "clojure.core/true?",
                              :docstring "Returns true if x is the value true, false otherwise."},
           "cljs.core/unchecked-substract-int" {:moved "cljs.core/unchecked-subtract-int",
                                                :return-type number,
                                                :ns "cljs.core",
                                                :name "unchecked-substract-int",
                                                :signature ["[x]"
                                                            "[x y]"
                                                            "[x y & more]"],
                                                :history [["+"
                                                           "0.0-1798"]
                                                          ["-"
                                                           "0.0-2277"]],
                                                :type "function",
                                                :full-name-encode "cljs.core/unchecked-substract-int",
                                                :source {:code "(defn ^number unchecked-substract-int\n  ([x] (cljs.core/unchecked-subtract-int x))\n  ([x y] (cljs.core/unchecked-subtract-int x y))\n  ([x y & more] (reduce unchecked-substract-int (cljs.core/unchecked-subtract-int x y) more)))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r2268",
                                                         :filename "src/cljs/cljs/core.cljs",
                                                         :lines [1812
                                                                 1817]},
                                                :full-name "cljs.core/unchecked-substract-int",
                                                :docstring "If no ys are supplied, returns the negation of x, else subtracts\nthe ys from x and returns the result.",
                                                :removed {:in "0.0-2277",
                                                          :last-seen "0.0-2268"}},
           "clojure.browser.net/xpc-connection" {:ns "clojure.browser.net",
                                                 :name "xpc-connection",
                                                 :signature ["[]"
                                                             "[config]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.browser.net/xpc-connection",
                                                 :source {:code "(defn xpc-connection\n  ([]\n     (when-let [config (.getParameterValue\n                        (Uri. (.-href (.-location js/window)))\n                        \"xpc\")]\n       (CrossPageChannel. (gjson/parse config))))\n  ([config]\n     (CrossPageChannel.\n      (reduce (fn [sum [k v]]\n                (if-let [field (get xpc-config-fields k)]\n                  (doto sum (aset field v))\n                  sum))\n              (js-obj)\n              config))))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r1.7.228",
                                                          :filename "src/main/cljs/clojure/browser/net.cljs",
                                                          :lines [116
                                                                  138]},
                                                 :full-name "clojure.browser.net/xpc-connection",
                                                 :docstring "When passed with a config hash-map, returns a parent\nCrossPageChannel object. Keys in the config hash map are downcased\nversions of the goog.net.xpc.CfgFields enum keys,\ne.g. goog.net.xpc.CfgFields.PEER_URI becomes :peer_uri in the config\nhash.\n\nWhen passed with no args, creates a child CrossPageChannel object,\nand the config is automatically taken from the URL param 'xpc', as\nper the CrossPageChannel API."},
           "cljs.core/ES6EntriesIterator" {:ns "cljs.core",
                                           :name "ES6EntriesIterator",
                                           :type "type",
                                           :signature ["[s]"],
                                           :source {:code "(deftype ES6EntriesIterator [^:mutable s]\n  Object\n  (next [_]\n    (if-not (nil? s)\n      (let [[k v] (first s)]\n        (set! s (next s))\n        #js {:value #js [k v] :done false})\n      #js {:value nil :done true})))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.7.228",
                                                    :filename "src/main/cljs/cljs/core.cljs",
                                                    :lines [5673 5680]},
                                           :full-name "cljs.core/ES6EntriesIterator",
                                           :full-name-encode "cljs.core/ES6EntriesIterator",
                                           :history [["+" "0.0-2371"]]},
           "cljs.core/not" {:description "Returns true if `x` is logical false, false otherwise.",
                            :return-type boolean,
                            :ns "cljs.core",
                            :name "not",
                            :signature ["[x]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/complement"
                                      "cljs.core/false?"],
                            :full-name-encode "cljs.core/not",
                            :source {:code "(defn ^boolean not\n  [x]\n  (cond\n    (nil? x) true\n    (false? x) true\n    :else false))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.7.228",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [203 209]},
                            :full-name "cljs.core/not",
                            :clj-symbol "clojure.core/not",
                            :docstring "Returns true if x is logical false, false otherwise."},
           "cljs.core/js-obj" {:description "Returns a new JavaScript object using the supplied mappings.\n\n`keyvals` must be an even number of forms.",
                               :ns "cljs.core",
                               :name "js-obj",
                               :signature ["[& keyvals]"],
                               :history [["+" "0.0-927"]],
                               :type "function/macro",
                               :related ["syntax/js-literal"
                                         "cljs.core/array"
                                         "cljs.core/clj->js"],
                               :full-name-encode "cljs.core/js-obj",
                               :source {:code "(defn js-obj\n  ([]\n     (cljs.core/js-obj))\n  ([& keyvals]\n     (apply gobject/create keyvals)))",
                                        :title "Function code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [1942 1948]},
                               :extra-sources [{:code "(core/defmacro js-obj [& rest]\n  (core/let [sym-or-str? (core/fn [x] (core/or (core/symbol? x) (core/string? x)))\n             filter-on-keys (core/fn [f coll]\n                              (core/->> coll\n                                (filter (core/fn [[k _]] (f k)))\n                                (into {})))\n             kvs (into {} (map vec (partition 2 rest)))\n             sym-pairs (filter-on-keys core/symbol? kvs)\n             expr->local (zipmap\n                           (filter (complement sym-or-str?) (keys kvs))\n                           (repeatedly gensym))\n             obj (gensym \"obj\")]\n    (if (empty? rest)\n      (js-obj* '())\n      `(let [~@(apply concat (clojure.set/map-invert expr->local))\n            ~obj ~(js-obj* (filter-on-keys core/string? kvs))]\n        ~@(map (core/fn [[k v]] `(aset ~obj ~k ~v)) sym-pairs)\n        ~@(map (core/fn [[k v]] `(aset ~obj ~v ~(core/get kvs k))) expr->local)\n        ~obj))))",
                                                :title "Macro code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/clojure/cljs/core.cljc",
                                                :lines [2396 2414]}],
                               :examples [{:id "657cd7",
                                           :content "```clj\n(js-obj \"foo\" 1 \"bar\" 2)\n;;=> #js {:foo 1, :bar 2}\n```"}],
                               :full-name "cljs.core/js-obj",
                               :docstring "Create JavaSript object from an even number arguments representing\ninterleaved keys and values."},
           "cljs.core/complement" {:description "Takes a function `f` and returns a function that takes the same arguments as\n`f`, has the same effects, if any, and returns the opposite truth value.",
                                   :return-type boolean,
                                   :ns "cljs.core",
                                   :name "complement",
                                   :signature ["[f]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/not"],
                                   :full-name-encode "cljs.core/complement",
                                   :source {:code "(defn ^boolean complement\n  [f]\n  (fn\n    ([] (not (f)))\n    ([x] (not (f x)))\n    ([x y] (not (f x y)))\n    ([x y & zs] (not (apply f x y zs)))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [3792 3800]},
                                   :examples [{:id "69e359",
                                               :content "```clj\n(def a 10)\n((complement #(= a %)) 12)\n;;=> true\n```"}],
                                   :full-name "cljs.core/complement",
                                   :clj-symbol "clojure.core/complement",
                                   :docstring "Takes a fn f and returns a fn that takes the same arguments as f,\nhas the same effects, if any, and returns the opposite truth value."},
           "cljs.core/spread" {:ns "cljs.core",
                               :name "spread",
                               :type "function",
                               :signature ["[arglist]"],
                               :source {:code "(defn spread\n  [arglist]\n  (cond\n   (nil? arglist) nil\n   (nil? (next arglist)) (seq (first arglist))\n   :else (cons (first arglist)\n               (spread (next arglist)))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [3329 3335]},
                               :full-name "cljs.core/spread",
                               :full-name-encode "cljs.core/spread",
                               :history [["+" "0.0-927"]]},
           "cljs.core/unchecked-double" {:return-type number,
                                         :ns "cljs.core",
                                         :name "unchecked-double",
                                         :signature ["[x]"],
                                         :history [["+" "0.0-1798"]],
                                         :type "function/macro",
                                         :full-name-encode "cljs.core/unchecked-double",
                                         :source {:code "(defn ^number unchecked-double [x] x)",
                                                  :title "Function code",
                                                  :repo "clojurescript",
                                                  :tag "r1.7.228",
                                                  :filename "src/main/cljs/cljs/core.cljs",
                                                  :lines [2374]},
                                         :extra-sources [{:code "(core/defmacro unchecked-double [x] x)",
                                                          :title "Macro code",
                                                          :repo "clojurescript",
                                                          :tag "r1.7.228",
                                                          :filename "src/main/clojure/cljs/core.cljc",
                                                          :lines [972]}],
                                         :full-name "cljs.core/unchecked-double",
                                         :clj-symbol "clojure.core/unchecked-double"},
           "cljs.repl.browser/chrome-st-el->frame" {:ns "cljs.repl.browser",
                                                    :name "chrome-st-el->frame",
                                                    :signature ["[repl-env st-el opts]"],
                                                    :history [["+"
                                                               "0.0-3053"]
                                                              ["-"
                                                               "1.7.10"]],
                                                    :type "function",
                                                    :full-name-encode "cljs.repl.browser/chrome-st-el-GTframe",
                                                    :source {:code "(defn chrome-st-el->frame\n  [repl-env st-el opts]\n  (let [xs (-> st-el\n             (string/replace #\"\\s+at\\s+\" \"\")\n             (string/split #\"\\s+\"))\n        [function flc] (if (== (count xs) 1)\n                         [nil (first xs)]\n                         [(first xs) (last xs)])\n        [file line column] (parse-file-line-column flc)]\n    (if (and file function line column)\n      {:file (parse-file repl-env file opts)\n       :function (string/replace function #\"Object\\.\" \"\")\n       :line line\n       :column column}\n      (when-not (string/blank? function)\n        {:file nil\n         :function (string/replace function #\"Object\\.\" \"\")\n         :line nil\n         :column nil}))))",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r3308",
                                                             :filename "src/main/clojure/cljs/repl/browser.clj",
                                                             :lines [248
                                                                     266]},
                                                    :full-name "cljs.repl.browser/chrome-st-el->frame",
                                                    :removed {:in "1.7.10",
                                                              :last-seen "0.0-3308"}},
           "cljs.core/keyword" {:ns "cljs.core",
                                :name "keyword",
                                :signature ["[name]" "[ns name]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/keyword",
                                :source {:code "(defn keyword\n  ([name] (cond\n            (keyword? name) name\n            (symbol? name) (Keyword.\n                             (cljs.core/namespace name)\n                             (cljs.core/name name) (.-str name) nil)\n            (string? name) (let [parts (.split name \"/\")]\n                             (if (== (alength parts) 2)\n                               (Keyword. (aget parts 0) (aget parts 1) name nil)\n                               (Keyword. nil (aget parts 0) name nil)))))\n  ([ns name] (Keyword. ns name (str (when ns (str ns \"/\")) name) nil)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [2988 3000]},
                                :full-name "cljs.core/keyword",
                                :clj-symbol "clojure.core/keyword",
                                :docstring "Returns a Keyword with the given namespace and name.  Do not use :\nin the keyword strings, it will be added automatically."},
           "syntax/keyword-qualify" {:description "Keywords starting with `::` will evaluate to regular keywords with a namespace qualification.\nThe namespace will resolve to either of the following:\n\n- current namespace if none is specified\n- given namespace if it exists\n- full namespace if the given one is an alias\n- reader error if given namespace doesn't exist",
                                     :ns "syntax",
                                     :name "keyword-qualify",
                                     :history [["+" "0.0-927"]],
                                     :type "syntax",
                                     :related ["syntax/keyword"
                                               "cljs.core/keyword"
                                               "cljs.core/keyword?"],
                                     :full-name-encode "syntax/keyword-qualify",
                                     :extra-sources ({:code "(defn- read-keyword\n  [reader initch opts pending-forms]\n  (let [ch (read-char reader)]\n    (if-not (whitespace? ch)\n      (let [token (read-token reader ch)\n            s (parse-symbol token)]\n        (if s\n          (let [^String ns (s 0)\n                ^String name (s 1)]\n            (if (identical? \\: (nth token 0))\n              (if ns\n                (let [ns (resolve-ns (symbol (subs ns 1)))]\n                  (if ns\n                    (keyword (str ns) name)\n                    (reader-error reader \"Invalid token: :\" token)))\n                (keyword (str *ns*) (subs name 1)))\n              (keyword ns name)))\n          (reader-error reader \"Invalid token: :\" token)))\n      (reader-error reader \"Invalid token: :\"))))",
                                                      :title "Reader code",
                                                      :repo "tools.reader",
                                                      :tag "tools.reader-1.0.0-alpha1",
                                                      :filename "src/main/clojure/clojure/tools/reader.clj",
                                                      :lines [343 361]}
                                                     {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                                      :title "Reader table",
                                                      :repo "tools.reader",
                                                      :tag "tools.reader-1.0.0-alpha1",
                                                      :filename "src/main/clojure/clojure/tools/reader.clj",
                                                      :lines [743 762]}),
                                     :usage ["::foo" "::foo/bar"],
                                     :examples [{:id "b0a135",
                                                 :content "If we are in the `user` namespace:\n\n```clj\n::foo\n;;=> :user/foo\n```\n\nWe can use namespace aliases:\n\n```clj\n(require '[example.util :as util])\n\n::util/foo\n;;=> :example.util/foo\n```\n\nExisting namespaces will resolve normally:\n\n```clj\n::cljs.core/foo\n;;=> :cljs.core/foo\n```\n\nNon-existing namespaces will throw a reader exception:\n\n```clj\n::foo/bar\n;; clojure.lang.ExceptionInfo: Invalid token: ::foo/bar {:type :reader-exception, ...\n```"}],
                                     :full-name "syntax/keyword-qualify",
                                     :display ":: keyword",
                                     :clj-doc "http://clojure.org/reader#toc1"},
           "cljs.core/sort" {:description "Returns a sorted sequence of the items in `coll`.\n\n`comp` can be a boolean-valued comparison funcion, or a -/0/+ valued comparator.\n\n`comp` defaults to `compare`.",
                             :ns "cljs.core",
                             :name "sort",
                             :signature ["[coll]" "[comp coll]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/sort-by"],
                             :full-name-encode "cljs.core/sort",
                             :source {:code "(defn sort\n  ([coll]\n   (sort compare coll))\n  ([comp coll]\n   (if (seq coll)\n     (let [a (to-array coll)]\n       ;; matching Clojure's stable sort, though docs don't promise it\n       (garray/stableSort a (fn->comparator comp))\n       (seq a))\n     ())))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [2123 2135]},
                             :full-name "cljs.core/sort",
                             :clj-symbol "clojure.core/sort",
                             :docstring "Returns a sorted sequence of the items in coll. Comp can be\nboolean-valued comparison function, or a -/0/+ valued comparator.\nComp defaults to compare."},
           "clojure.string/trim" {:description "Removes whitespace from both ends of string.",
                                  :ns "clojure.string",
                                  :name "trim",
                                  :signature ["[s]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.string/trim",
                                  :source {:code "(defn trim\n  [s]\n  (gstring/trim s))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/clojure/string.cljs",
                                           :lines [165 168]},
                                  :full-name "clojure.string/trim",
                                  :clj-symbol "clojure.string/trim",
                                  :docstring "Removes whitespace from both ends of string."},
           "cljs.core/meta" {:ns "cljs.core",
                             :name "meta",
                             :signature ["[o]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/meta",
                             :source {:code "(defn meta\n  [o]\n  (when (and (not (nil? o))\n             (satisfies? IMeta o))\n    (-meta o)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [1847 1852]},
                             :full-name "cljs.core/meta",
                             :clj-symbol "clojure.core/meta",
                             :docstring "Returns the metadata of obj, returns nil if there is no metadata."},
           "cljs.repl/IParseError" {:ns "cljs.repl",
                                    :name "IParseError",
                                    :type "protocol",
                                    :full-name-encode "cljs.repl/IParseError",
                                    :source {:code "(defprotocol IParseError\n  (-parse-error [repl-env error build-options]\n    \"Given the original JavaScript error return the error to actually\n     use.\"))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/clojure/cljs/repl.cljc",
                                             :lines [118 121]},
                                    :methods [{:name "-parse-error",
                                               :signature ["[repl-env error build-options]"],
                                               :docstring "Given the original JavaScript error return the error to actually\n     use."}],
                                    :full-name "cljs.repl/IParseError",
                                    :history [["+" "0.0-3030"]]},
           "clojure.core.reducers/monoid" {:ns "clojure.core.reducers",
                                           :name "monoid",
                                           :signature ["[op ctor]"],
                                           :history [["+" "0.0-1236"]],
                                           :type "function",
                                           :full-name-encode "clojure.core.reducers/monoid",
                                           :source {:code "(defn monoid\n  [op ctor]\n  (fn m\n    ([] (ctor))\n    ([a b] (op a b))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.7.228",
                                                    :filename "src/main/cljs/clojure/core/reducers.cljs",
                                                    :lines [242 249]},
                                           :full-name "clojure.core.reducers/monoid",
                                           :clj-symbol "clojure.core.reducers/monoid",
                                           :docstring "Builds a combining fn out of the supplied operator and identity\nconstructor. op must be associative and ctor called with no args\nmust return an identity value for it."},
           "cljs.core/time" {:ns "cljs.core",
                             :name "time",
                             :signature ["[expr]"],
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :full-name-encode "cljs.core/time",
                             :source {:code "(core/defmacro time\n  [expr]\n  `(let [start# (system-time)\n         ret# ~expr]\n     (prn (cljs.core/str \"Elapsed time: \"\n            (.toFixed (- (system-time) start#) 6)\n            \" msecs\"))\n     ret#))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/clojure/cljs/core.cljc",
                                      :lines [2522 2530]},
                             :full-name "cljs.core/time",
                             :clj-symbol "clojure.core/time",
                             :docstring "Evaluates expr and prints the time it took. Returns the value of expr."},
           "cljs.core/boolean" {:description "Return `false` if `x` is false or nil.  Otherwise return `true`.  This is the\ntruthiness condition used by `if` expressions.",
                                :return-type boolean,
                                :ns "cljs.core",
                                :name "boolean",
                                :signature ["[x]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["special/if"],
                                :full-name-encode "cljs.core/boolean",
                                :source {:code "(defn ^boolean boolean\n  [x]\n  (cond\n    (nil? x) false\n    (false? x) false\n    :else true))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [2007 2013]},
                                :examples [{:id "9edf3a",
                                            :content "```clj\n(boolean 1)\n;;=> true\n\n(boolean 0)\n;;=> true\n\n(boolean nil)\n;;=> false\n```"}],
                                :full-name "cljs.core/boolean",
                                :clj-symbol "clojure.core/boolean",
                                :docstring "Coerce to boolean"},
           "cljs.reader/read-token" {:ns "cljs.reader",
                                     :name "read-token",
                                     :type "function",
                                     :signature ["[rdr initch]"],
                                     :source {:code "(defn read-token\n  [rdr initch]\n  (loop [sb (StringBuffer. initch)\n         ch (read-char rdr)]\n    (if (or (nil? ch)\n            (whitespace? ch)\n            (macro-terminating? ch))\n      (do (unread rdr ch) (.toString sb))\n      (recur (do (.append sb ch) sb) (read-char rdr)))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/cljs/cljs/reader.cljs",
                                              :lines [79 87]},
                                     :full-name "cljs.reader/read-token",
                                     :full-name-encode "cljs.reader/read-token",
                                     :history [["+" "0.0-927"]]},
           "cljs.core/update-in" {:description "\"Updates\" a value in a nested associative structure, where `ks` is a sequence of\nkeys and `f` is a function that will take the old value and any supplied\narguments and return the new value. Returns a new nested structure.\n\nIf any levels do not exist, hash-maps will be created.",
                                  :ns "cljs.core",
                                  :name "update-in",
                                  :signature ["[m [k & ks] f]"
                                              "[m [k & ks] f a]"
                                              "[m [k & ks] f a b]"
                                              "[m [k & ks] f a b c]"
                                              "[m [k & ks] f a b c & args]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/assoc-in"
                                            "cljs.core/get-in"],
                                  :full-name-encode "cljs.core/update-in",
                                  :source {:code "(defn update-in\n  ([m [k & ks] f]\n   (if ks\n     (assoc m k (update-in (get m k) ks f))\n     (assoc m k (f (get m k)))))\n  ([m [k & ks] f a]\n   (if ks\n     (assoc m k (update-in (get m k) ks f a))\n     (assoc m k (f (get m k) a))))\n  ([m [k & ks] f a b]\n   (if ks\n     (assoc m k (update-in (get m k) ks f a b))\n     (assoc m k (f (get m k) a b))))\n  ([m [k & ks] f a b c]\n   (if ks\n     (assoc m k (update-in (get m k) ks f a b c))\n     (assoc m k (f (get m k) a b c))))\n  ([m [k & ks] f a b c & args]\n   (if ks\n     (assoc m k (apply update-in (get m k) ks f a b c args))\n     (assoc m k (apply f (get m k) a b c args)))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [4577 4602]},
                                  :full-name "cljs.core/update-in",
                                  :clj-symbol "clojure.core/update-in",
                                  :docstring "'Updates' a value in a nested associative structure, where ks is a\nsequence of keys and f is a function that will take the old value\nand any supplied args and return the new value, and returns a new\nnested structure.  If any levels do not exist, hash-maps will be\ncreated."},
           "cljs.core/map-indexed" {:description "Returns a lazy sequence consisting of the result of applying `f` to 0 and the\nfirst item of `coll`, followed by applying `f` to 1 and the second item in\n`coll`, etc, until `coll` is exhausted.\n\nFunction `f` should accept 2 arguments, index and item.",
                                    :ns "cljs.core",
                                    :name "map-indexed",
                                    :signature ["[f coll]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :related ["cljs.core/map"
                                              "cljs.core/keep-indexed"],
                                    :full-name-encode "cljs.core/map-indexed",
                                    :source {:code "(defn map-indexed\n  ([f]\n    (fn [rf]\n      (let [i (volatile! -1)]\n        (fn\n          ([] (rf))\n          ([result] (rf result))\n          ([result input]\n            (rf result (f (vswap! i inc) input)))))))\n  ([f coll]\n    (letfn [(mapi [idx coll]\n              (lazy-seq\n                (when-let [s (seq coll)]\n                  (if (chunked-seq? s)\n                    (let [c (chunk-first s)\n                          size (count c)\n                          b (chunk-buffer size)]\n                      (dotimes [i size]\n                        (chunk-append b (f (+ idx i) (-nth c i))))\n                      (chunk-cons (chunk b) (mapi (+ idx size) (chunk-rest s))))\n                    (cons (f idx (first s)) (mapi (inc idx) (rest s)))))))]\n      (mapi 0 coll))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [3889 3915]},
                                    :full-name "cljs.core/map-indexed",
                                    :clj-symbol "clojure.core/map-indexed",
                                    :docstring "Returns a lazy sequence consisting of the result of applying f to 0\nand the first item of coll, followed by applying f to 1 and the second\nitem in coll, etc, until coll is exhausted. Thus function f should\naccept 2 arguments, index and item. Returns a stateful transducer when\nno collection is provided."},
           "cljs.core/IVolatile" {:ns "cljs.core",
                                  :name "IVolatile",
                                  :history [["+" "0.0-2496"]],
                                  :type "protocol",
                                  :full-name-encode "cljs.core/IVolatile",
                                  :source {:code "(defprotocol IVolatile\n  \"Protocol for adding volatile functionality.\"\n  (-vreset! [o new-value]\n    \"Sets the value of volatile o to new-value without regard for the\n     current value. Returns new-value.\"))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [745 749]},
                                  :methods [{:name "-vreset!",
                                             :signature ["[o new-value]"],
                                             :docstring "Sets the value of volatile o to new-value without regard for the\n     current value. Returns new-value."}],
                                  :full-name "cljs.core/IVolatile",
                                  :docstring "Protocol for adding volatile functionality."},
           "cljs.core/printf" {:ns "cljs.core",
                               :name "printf",
                               :signature ["[fmt & args]"],
                               :history [["+" "0.0-1443"]
                                         ["-" "0.0-1885"]],
                               :type "function",
                               :full-name-encode "cljs.core/printf",
                               :source {:code "(defn printf\n  [fmt & args]\n  (print (apply format fmt args)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1878",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [6758 6761]},
                               :full-name "cljs.core/printf",
                               :clj-symbol "clojure.core/printf",
                               :docstring "Prints formatted output, as per format",
                               :removed {:in "0.0-1885",
                                         :last-seen "0.0-1878"}},
           "clojure.core.reducers/map" {:ns "clojure.core.reducers",
                                        :name "map",
                                        :signature ["[f]" "[f coll]"],
                                        :history [["+" "0.0-1236"]],
                                        :type "function",
                                        :full-name-encode "clojure.core.reducers/map",
                                        :source {:code "(defcurried map\n  \"Applies f to every value in the reduction of coll. Foldable.\"\n  {}\n  [f coll]\n  (folder coll\n   (fn [f1]\n     (rfn [f1 k]\n          ([ret k v]\n             (f1 ret (f k v)))))))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/cljs/clojure/core/reducers.cljs",
                                                 :lines [96 104]},
                                        :full-name "clojure.core.reducers/map",
                                        :clj-symbol "clojure.core.reducers/map",
                                        :docstring "Applies f to every value in the reduction of coll. Foldable."},
           "cljs.core/IStack" {:ns "cljs.core",
                               :name "IStack",
                               :history [["+" "0.0-927"]],
                               :type "protocol",
                               :full-name-encode "cljs.core/IStack",
                               :source {:code "(defprotocol IStack\n  \"Protocol for collections to provide access to their items as stacks. The top\n  of the stack should be accessed in the most efficient way for the different\n  data structures.\"\n  (-peek [coll]\n    \"Returns the item from the top of the stack. Is used by cljs.core/peek.\")\n  (^clj -pop [coll]\n    \"Returns a new stack without the item on top of the stack. Is used\n     by cljs.core/pop.\"))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [542 550]},
                               :methods [{:name "-peek",
                                          :signature ["[coll]"],
                                          :docstring "Returns the item from the top of the stack. Is used by cljs.core/peek."}
                                         {:name "-pop",
                                          :signature ["[coll]"],
                                          :docstring "Returns a new stack without the item on top of the stack. Is used\n     by cljs.core/pop."}],
                               :full-name "cljs.core/IStack",
                               :clj-symbol "clojure.lang/IPersistentStack",
                               :docstring "Protocol for collections to provide access to their items as stacks. The top\n  of the stack should be accessed in the most efficient way for the different\n  data structures."},
           "cljs.repl/pst" {:description "Print Stack Trace for a given exception `e` or the most recent\nexception, stored implicitly by [doc:cljs.core/*e].",
                            :ns "cljs.repl",
                            :name "pst",
                            :signature ["[e]"],
                            :history [["+" "0.0-2985"]],
                            :type "macro",
                            :full-name-encode "cljs.repl/pst",
                            :source {:code "(defmacro pst\n  ([] `(pst *e))\n  ([e]\n   (let [{:keys [repl-env] :as env} &env]\n     (when (and e repl-env)\n       (when-let [ret (if (satisfies? IGetError repl-env)\n                   (-get-error repl-env e env *repl-opts*)\n                   (edn/read-string\n                     (evaluate-form repl-env env \"<cljs repl>\"\n                       `(when ~e\n                          (pr-str\n                            {:value (str ~e)\n                             :stacktrace (.-stack ~e)})))))]\n         (display-error repl-env\n           (if (satisfies? IParseError repl-env)\n             (-parse-error repl-env ret *repl-opts*)\n             ret)\n           nil *repl-opts*))))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.7.228",
                                     :filename "src/main/clojure/cljs/repl.cljc",
                                     :lines [1274 1291]},
                            :full-name "cljs.repl/pst",
                            :clj-symbol "clojure.repl/pst"},
           "cljs.reader/parse-and-validate-timestamp" {:ns "cljs.reader",
                                                       :name "parse-and-validate-timestamp",
                                                       :type "function",
                                                       :signature ["[s]"],
                                                       :source {:code "(defn parse-and-validate-timestamp [s]\n  (let [[_ years months days hours minutes seconds fraction offset-sign offset-hours offset-minutes :as v] \n        (re-matches timestamp-regex s)]\n    (if-not v\n      (reader-error nil (str \"Unrecognized date/time syntax: \" s))\n      (let [years (parse-int years)\n            months (or (parse-int months) 1)\n            days (or (parse-int days) 1)\n            hours (or (parse-int hours) 0)\n            minutes (or (parse-int minutes) 0)\n            seconds (or (parse-int seconds) 0)\n            fraction (or (parse-int (zero-fill-right-and-truncate fraction 3)) 0)\n            offset-sign (if (= offset-sign \"-\") -1 1)\n            offset-hours (or (parse-int offset-hours) 0)\n            offset-minutes (or (parse-int offset-minutes) 0)\n            offset (* offset-sign (+ (* offset-hours 60) offset-minutes))]\n        [years\n         (check 1 months 12 \"timestamp month field must be in range 1..12\")\n         (check 1 days (days-in-month months (leap-year? years)) \"timestamp day field must be in range 1..last day in month\")\n         (check 0 hours 23 \"timestamp hour field must be in range 0..23\")\n         (check 0 minutes 59 \"timestamp minute field must be in range 0..59\")\n         (check 0 seconds (if (= minutes 59) 60 59) \"timestamp second field must be in range 0..60\")\n         (check 0 fraction 999 \"timestamp millisecond field must be in range 0..999\")\n         offset]))))",
                                                                :title "Source code",
                                                                :repo "clojurescript",
                                                                :tag "r1.7.228",
                                                                :filename "src/main/cljs/cljs/reader.cljs",
                                                                :lines [510
                                                                        533]},
                                                       :full-name "cljs.reader/parse-and-validate-timestamp",
                                                       :full-name-encode "cljs.reader/parse-and-validate-timestamp",
                                                       :history [["+"
                                                                  "0.0-1853"]]},
           "cljs.core/ISorted" {:ns "cljs.core",
                                :name "ISorted",
                                :history [["+" "0.0-1211"]],
                                :type "protocol",
                                :full-name-encode "cljs.core/ISorted",
                                :source {:code "(defprotocol ISorted\n  \"Protocol for a collection which can represent their items\n  in a sorted manner. \"\n  (^clj -sorted-seq [coll ascending?]\n    \"Returns a sorted seq from coll in either ascending or descending order.\")\n  (^clj -sorted-seq-from [coll k ascending?]\n    \"Returns a sorted seq from coll in either ascending or descending order.\n     If ascending is true, the result should contain all items which are > or >=\n     than k. If ascending is false, the result should contain all items which\n     are < or <= than k, e.g.\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 true) => (3 4 5)\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 false) => (3 2 1)\")\n  (-entry-key [coll entry]\n    \"Returns the key for entry.\")\n  (-comparator [coll]\n    \"Returns the comparator for coll.\"))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [619 634]},
                                :methods [{:name "-sorted-seq",
                                           :signature ["[coll ascending?]"],
                                           :docstring "Returns a sorted seq from coll in either ascending or descending order."}
                                          {:name "-sorted-seq-from",
                                           :signature ["[coll k ascending?]"],
                                           :docstring "Returns a sorted seq from coll in either ascending or descending order.\n     If ascending is true, the result should contain all items which are > or >=\n     than k. If ascending is false, the result should contain all items which\n     are < or <= than k, e.g.\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 true) => (3 4 5)\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 false) => (3 2 1)"}
                                          {:name "-entry-key",
                                           :signature ["[coll entry]"],
                                           :docstring "Returns the key for entry."}
                                          {:name "-comparator",
                                           :signature ["[coll]"],
                                           :docstring "Returns the comparator for coll."}],
                                :full-name "cljs.core/ISorted",
                                :clj-symbol "clojure.lang/Sorted",
                                :docstring "Protocol for a collection which can represent their items\n  in a sorted manner. "},
           "cljs.test/file-and-line" {:ns "cljs.test",
                                      :name "file-and-line",
                                      :type "function",
                                      :signature ["[exception depth]"],
                                      :source {:code "(defn file-and-line [exception depth]\n  ;; TODO: flesh out\n  (if-let [stack-element (and (string? (.-stack exception))\n                              (some-> (.-stack exception)\n                                      string/split-lines\n                                      (get depth)\n                                      string/trim))]\n    (let [fname (js-filename stack-element)\n          [line column] (js-line-and-column stack-element)\n          [fname line column] (mapped-line-and-column fname line column)]\n      {:file fname :line line :column column})\n    {:file (.-fileName exception)\n     :line (.-lineNumber exception)}))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/cljs/cljs/test.cljs",
                                               :lines [393 405]},
                                      :full-name "cljs.test/file-and-line",
                                      :full-name-encode "cljs.test/file-and-line",
                                      :history [["+" "0.0-2496"]]},
           "cljs.core/IIndexed" {:ns "cljs.core",
                                 :name "IIndexed",
                                 :history [["+" "0.0-927"]],
                                 :type "protocol",
                                 :full-name-encode "cljs.core/IIndexed",
                                 :source {:code "(defprotocol IIndexed\n  \"Protocol for collections to provide indexed-based access to their items.\"\n  (-nth [coll n] [coll n not-found]\n    \"Returns the value at the index n in the collection coll.\n     Returns not-found if index n is out of bounds and not-found is supplied.\"))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [482 486]},
                                 :methods [{:name "-nth",
                                            :signature ["[coll n]"
                                                        "[coll n not-found]"],
                                            :docstring "Returns the value at the index n in the collection coll.\n     Returns not-found if index n is out of bounds and not-found is supplied."}],
                                 :full-name "cljs.core/IIndexed",
                                 :clj-symbol "clojure.lang/Indexed",
                                 :docstring "Protocol for collections to provide indexed-based access to their items."},
           "clojure.browser.repl/repl-print" {:ns "clojure.browser.repl",
                                              :name "repl-print",
                                              :type "function",
                                              :signature ["[data]"],
                                              :source {:code "(defn repl-print [data]\n  (.push print-queue (pr-str data))\n  (when-let [conn @xpc-connection]\n    (flush-print-queue! conn)))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.7.228",
                                                       :filename "src/main/cljs/clojure/browser/repl.cljs",
                                                       :lines [38 41]},
                                              :full-name "clojure.browser.repl/repl-print",
                                              :full-name-encode "clojure.browser.repl/repl-print",
                                              :history [["+"
                                                         "0.0-927"]]},
           "clojure.browser.net/xpc-config-fields" {:ns "clojure.browser.net",
                                                    :name "xpc-config-fields",
                                                    :type "var",
                                                    :source {:code "(def xpc-config-fields\n  (into {}\n        (map\n         (fn [[k v]]\n           [(keyword (.toLowerCase k))\n            v])\n         (js->clj CfgFields))))",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r1.7.228",
                                                             :filename "src/main/cljs/clojure/browser/net.cljs",
                                                             :lines [73
                                                                     79]},
                                                    :full-name "clojure.browser.net/xpc-config-fields",
                                                    :full-name-encode "clojure.browser.net/xpc-config-fields",
                                                    :history [["+"
                                                               "0.0-927"]]},
           "cljs.js/compile*" {:ns "cljs.js",
                               :name "compile*",
                               :signature ["[bound-vars source name opts cb]"],
                               :history [["+" "1.7.10"]
                                         ["-" "1.7.28"]],
                               :type "function",
                               :full-name-encode "cljs.js/compileSTAR",
                               :source {:code "(defn compile* [bound-vars source name opts cb]\n  (let [rdr        (rt/indexing-push-back-reader source 1 name)\n        eof        (js-obj)\n        aenv       (ana/empty-env)\n        sb         (StringBuffer.)\n        the-ns     (or (:ns opts) 'cljs.user)\n        bound-vars (cond-> (merge bound-vars {:*cljs-ns* the-ns})\n                     (:source-map opts) (assoc :*sm-data* (sm-data)))]\n    ((fn compile-loop []\n       (binding [env/*compiler*         (:*compiler* bound-vars)\n                 *eval-fn*              (:*eval-fn* bound-vars)\n                 ana/*cljs-ns*          (:*cljs-ns* bound-vars)\n                 *ns*                   (create-ns (:*cljs-ns* bound-vars))\n                 r/*data-readers*       (:*data-readers* bound-vars)\n                 comp/*source-map-data* (:*sm-data* bound-vars)]\n         (let [res (try\n                     {:value (r/read {:eof eof :read-cond :allow :features #{:cljs}} rdr)}\n                     (catch :default cause\n                       (wrap-error\n                         (ana/error aenv\n                           (str \"Could not compile \" name) cause))))]\n           (if (:error res)\n             (cb res)\n             (let [form (:value res)]\n               (if-not (identical? eof form)\n                 (let [aenv (cond-> (assoc aenv :ns (ana/get-namespace ana/*cljs-ns*))\n                              (:context opts) (assoc :context (:context opts))\n                              (:def-emits-var opts) (assoc :def-emits-var true))\n                       ast  (try\n                              (ana/analyze aenv form nil opts)\n                              (catch :default cause\n                                (wrap-error\n                                  (ana/error aenv\n                                    (str \"Could not compile \" name) cause))))]\n                   (.append sb (with-out-str (comp/emit ast)))\n                   (if (= :ns (:op ast))\n                     (ns-side-effects bound-vars aenv ast opts\n                       (fn [res]\n                         (if (:error res)\n                           (cb res)\n                           (compile-loop))))\n                     (recur)))\n                 (do\n                   (when (:source-map opts)\n                     (append-source-map env/*compiler*\n                       name source sb @comp/*source-map-data* opts))\n                   (cb {:value (.toString sb)})))))))))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.10",
                                        :filename "src/main/cljs/cljs/js.cljs",
                                        :lines [532 578]},
                               :full-name "cljs.js/compile*",
                               :removed {:in "1.7.28",
                                         :last-seen "1.7.10"}},
           "cljs.core/ISwap" {:ns "cljs.core",
                              :name "ISwap",
                              :history [["+" "0.0-2173"]],
                              :type "protocol",
                              :full-name-encode "cljs.core/ISwap",
                              :source {:code "(defprotocol ISwap\n  \"Protocol for adding swapping functionality.\"\n  (-swap! [o f] [o f a] [o f a b] [o f a b xs]\n    \"Swaps the value of o to be (apply f current-value-of-atom args).\"))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [740 743]},
                              :methods [{:name "-swap!",
                                         :signature ["[o f]"
                                                     "[o f a]"
                                                     "[o f a b]"
                                                     "[o f a b xs]"],
                                         :docstring "Swaps the value of o to be (apply f current-value-of-atom args)."}],
                              :full-name "cljs.core/ISwap",
                              :docstring "Protocol for adding swapping functionality."},
           "cljs.core/nnext" {:description "Same as `(next (next coll))`.",
                              :ns "cljs.core",
                              :name "nnext",
                              :signature ["[coll]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/next"],
                              :full-name-encode "cljs.core/nnext",
                              :source {:code "(defn nnext\n  [coll]\n  (next (next coll)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [1550 1553]},
                              :full-name "cljs.core/nnext",
                              :clj-symbol "clojure.core/nnext",
                              :docstring "Same as (next (next x))"},
           "cljs.core/*print-meta*" {:ns "cljs.core",
                                     :name "*print-meta*",
                                     :history [["+" "0.0-927"]],
                                     :type "dynamic var",
                                     :full-name-encode "cljs.core/STARprint-metaSTAR",
                                     :source {:code "(def\n  ^{:dynamic true\n    :doc \"If set to logical true, when printing an object, its metadata will also\n  be printed in a form that can be read back by the reader.\n\n  Defaults to false.\"}\n  *print-meta* false)",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/cljs/cljs/core.cljs",
                                              :lines [89 95]},
                                     :full-name "cljs.core/*print-meta*",
                                     :clj-symbol "clojure.core/*print-meta*",
                                     :docstring "If set to logical true, when printing an object, its metadata will also\nbe printed in a form that can be read back by the reader.\n\nDefaults to false."},
           "cljs.reader/read-dispatch" {:ns "cljs.reader",
                                        :name "read-dispatch",
                                        :type "function",
                                        :signature ["[rdr _]"],
                                        :source {:code "(defn read-dispatch\n  [rdr _]\n  (let [ch (read-char rdr)\n        dm (dispatch-macros ch)]\n    (if dm\n      (dm rdr _)\n      (if-let [obj (maybe-read-tagged-type rdr ch)]\n        obj\n        (reader-error rdr \"No dispatch macro for \" ch)))))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/cljs/cljs/reader.cljs",
                                                 :lines [250 258]},
                                        :full-name "cljs.reader/read-dispatch",
                                        :full-name-encode "cljs.reader/read-dispatch",
                                        :history [["+" "0.0-927"]]},
           "cljs.test/run-block" {:ns "cljs.test",
                                  :name "run-block",
                                  :signature ["[fns]"],
                                  :history [["+" "0.0-2814"]],
                                  :type "function",
                                  :full-name-encode "cljs.test/run-block",
                                  :source {:code "(defn run-block\n  [fns]\n  (when-first [f fns]\n    (let [obj (f)]\n      (if (async? obj)\n        (obj (let [d (delay (run-block (rest fns)))]\n               (fn []\n                 (if (realized? d)\n                   (println \"WARNING: Async test called done more than one time.\")\n                   @d))))\n        (recur (cond->> (rest fns)\n                 (::block? (meta obj)) (concat obj)))))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/test.cljs",
                                           :lines [426 443]},
                                  :full-name "cljs.test/run-block",
                                  :docstring "Invoke all functions in fns with no arguments. A fn can optionally\nreturn\n\nan async test - is invoked with a continuation running left fns\n\na seq of fns tagged per block - are invoked immediately after fn"},
           "cljs.analyzer.api/get-options" {:ns "cljs.analyzer.api",
                                            :name "get-options",
                                            :signature ["[]"
                                                        "[state]"],
                                            :history [["+" "1.7.10"]],
                                            :type "function",
                                            :full-name-encode "cljs.analyzer.api/get-options",
                                            :source {:code "(defn get-options\n  ([] (get-options env/*compiler*))\n  ([state]\n   (get @state :options)))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.7.228",
                                                     :filename "src/main/clojure/cljs/analyzer/api.clj",
                                                     :lines [55 59]},
                                            :full-name "cljs.analyzer.api/get-options",
                                            :docstring "Return the compiler options from compiler state."},
           "cljs.core/*print-err-fn*" {:ns "cljs.core",
                                       :name "*print-err-fn*",
                                       :docstring "Each runtime environment provides a different way to print error output.\nWhatever function *print-fn* is bound to will be passed any\nStrings which should be printed.",
                                       :type "dynamic var",
                                       :source {:code "(defonce\n  ^{:doc \"Each runtime environment provides a different way to print error output.\n  Whatever function *print-fn* is bound to will be passed any\n  Strings which should be printed.\" :dynamic true}\n  *print-err-fn*\n  (fn [_]\n    (throw (js/Error. \"No *print-err-fn* fn set for evaluation environment\"))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/cljs/core.cljs",
                                                :lines [51 57]},
                                       :full-name "cljs.core/*print-err-fn*",
                                       :full-name-encode "cljs.core/STARprint-err-fnSTAR",
                                       :history [["+" "1.7.10"]]},
           "cljs.core/distinct" {:description "Returns a lazy sequence of the elements of `coll` with duplicates removed.",
                                 :ns "cljs.core",
                                 :name "distinct",
                                 :signature ["[coll]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :related ["cljs.core/distinct?"],
                                 :full-name-encode "cljs.core/distinct",
                                 :source {:code "(defn distinct\n  ([]\n    (fn [rf]\n      (let [seen (volatile! #{})]\n        (fn\n          ([] (rf))\n          ([result] (rf result))\n          ([result input]\n            (if (contains? @seen input)\n              result\n              (do (vswap! seen conj input)\n                  (rf result input))))))))\n  ([coll]\n    (let [step (fn step [xs seen]\n                 (lazy-seq\n                   ((fn [[f :as xs] seen]\n                      (when-let [s (seq xs)]\n                        (if (contains? seen f)\n                          (recur (rest s) seen)\n                          (cons f (step (rest s) (conj seen f))))))\n                     xs seen)))]\n      (step coll #{}))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [8263 8286]},
                                 :full-name "cljs.core/distinct",
                                 :clj-symbol "clojure.core/distinct",
                                 :docstring "Returns a lazy sequence of the elements of coll with duplicates removed.\nReturns a stateful transducer when no collection is provided."},
           "cljs.reader/wrapping-reader" {:ns "cljs.reader",
                                          :name "wrapping-reader",
                                          :type "function",
                                          :signature ["[sym]"],
                                          :source {:code "(defn wrapping-reader\n  [sym]\n  (fn [rdr _]\n    (list sym (read rdr true nil true))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/cljs/cljs/reader.cljs",
                                                   :lines [376 379]},
                                          :full-name "cljs.reader/wrapping-reader",
                                          :full-name-encode "cljs.reader/wrapping-reader",
                                          :history [["+" "0.0-927"]]},
           "cljs.core/LazyTransformer" {:ns "cljs.core",
                                        :name "LazyTransformer",
                                        :type "type",
                                        :signature ["[stepper first rest meta]"],
                                        :source {:code "(deftype LazyTransformer [^:mutable stepper ^:mutable first ^:mutable rest meta]\n  IWithMeta\n  (-with-meta [this new-meta]\n    (LazyTransformer. stepper first rest new-meta))\n\n  ICollection\n  (-conj [this o]\n    (cons o (-seq this)))\n\n  IEmptyableCollection\n  (-empty [this]\n    ())\n\n  ISequential\n  IEquiv\n  (-equiv [this other]\n    (let [s (-seq this)]\n      (if-not (nil? s)\n        (equiv-sequential this other)\n        (and (sequential? other)\n             (nil? (seq other))))))\n\n  IHash\n  (-hash [this]\n    (hash-ordered-coll this))\n\n  ISeqable\n  (-seq [this]\n    (when-not (nil? stepper)\n      (.step stepper this))\n    (if (nil? rest)\n      nil\n      this))\n\n  ISeq\n  (-first [this]\n    (when-not (nil? stepper)\n      (-seq this))\n    (if (nil? rest)\n      nil\n      first))\n\n  (-rest [this]\n    (when-not (nil? stepper)\n      (-seq this))\n    (if (nil? rest)\n      ()\n      rest))\n\n  INext\n  (-next [this]\n    (when-not (nil? stepper)\n      (-seq this))\n    (if (nil? rest)\n      nil\n      (-seq rest))))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/cljs/cljs/core.cljs",
                                                 :lines [3664 3719]},
                                        :full-name "cljs.core/LazyTransformer",
                                        :full-name-encode "cljs.core/LazyTransformer",
                                        :history [["+" "0.0-2301"]]},
           "cljs.core/double-array" {:ns "cljs.core",
                                     :name "double-array",
                                     :signature ["[size-or-seq]"
                                                 "[size init-val-or-seq]"],
                                     :history [["+" "0.0-1211"]],
                                     :type "function",
                                     :full-name-encode "cljs.core/double-array",
                                     :source {:code "(defn double-array\n  ([size-or-seq]\n     (if (number? size-or-seq)\n       (double-array size-or-seq nil)\n       (into-array size-or-seq)))\n  ([size init-val-or-seq]\n     (let [a (make-array size)]\n       (if (seq? init-val-or-seq)\n         (let [s (seq init-val-or-seq)]\n           (loop [i 0 s s]\n             (if (and s (< i size))\n               (do\n                 (aset a i (first s))\n                 (recur (inc i) (next s)))\n               a)))\n         (do\n           (dotimes [i size]\n             (aset a i init-val-or-seq))\n           a)))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/cljs/cljs/core.cljs",
                                              :lines [3277 3297]},
                                     :full-name "cljs.core/double-array",
                                     :clj-symbol "clojure.core/double-array",
                                     :docstring "Creates an array of doubles. Does not coerce array, provided for compatibility\nwith Clojure."},
           "cljs.core/prn" {:ns "cljs.core",
                            :name "prn",
                            :signature ["[& objs]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core/prn",
                            :source {:code "(defn prn\n  [& objs]\n  (pr-with-opts objs (pr-opts))\n  (when *print-newline*\n    (newline (pr-opts))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.7.228",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [8973 8978]},
                            :full-name "cljs.core/prn",
                            :clj-symbol "clojure.core/prn",
                            :docstring "Same as pr followed by (newline)."},
           "cljs.core/chunked-seq" {:ns "cljs.core",
                                    :name "chunked-seq",
                                    :type "function",
                                    :signature ["[vec i off]"
                                                "[vec node i off]"
                                                "[vec node i off meta]"],
                                    :source {:code "(defn chunked-seq\n  ([vec i off] (ChunkedSeq. vec (array-for vec i) i off nil nil))\n  ([vec node i off] (ChunkedSeq. vec node i off nil nil))\n  ([vec node i off meta]\n     (ChunkedSeq. vec node i off meta nil)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [5039 5043]},
                                    :full-name "cljs.core/chunked-seq",
                                    :full-name-encode "cljs.core/chunked-seq",
                                    :history [["+" "0.0-1424"]]},
           "clojure.zip/leftmost" {:ns "clojure.zip",
                                   :name "leftmost",
                                   :signature ["[loc]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "clojure.zip/leftmost",
                                   :source {:code "(defn leftmost\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (if (and path (seq l))\n        (with-meta [(first l) (assoc path :l [] :r (concat (rest l) [node] r))] (meta loc))\n        loc)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/clojure/zip.cljs",
                                            :lines [157 163]},
                                   :full-name "clojure.zip/leftmost",
                                   :clj-symbol "clojure.zip/leftmost",
                                   :docstring "Returns the loc of the leftmost sibling of the node at this loc, or self"},
           "cljs.core/nthrest" {:description "Returns the `nth` rest of `coll`.\n\nReturns `coll` when `n` is 0.",
                                :ns "cljs.core",
                                :name "nthrest",
                                :signature ["[coll n]"],
                                :history [["+" "0.0-2411"]],
                                :type "function",
                                :related ["cljs.core/drop"
                                          "cljs.core/nthnext"
                                          "cljs.core/nth"],
                                :full-name-encode "cljs.core/nthrest",
                                :source {:code "(defn nthrest\n  [coll n]\n    (loop [n n xs coll]\n      (if (and (pos? n) (seq xs))\n        (recur (dec n) (rest xs))\n        xs)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [1699 1705]},
                                :full-name "cljs.core/nthrest",
                                :clj-symbol "clojure.core/nthrest",
                                :docstring "Returns the nth rest of coll, coll when n is 0."},
           "cljs.core/js-in" {:description "Determines if property `key` is in JavaScript object `obj`.\n\nEquivalent to `key in obj` in JavaScript.",
                              :ns "cljs.core",
                              :name "js-in",
                              :signature ["[key obj]"],
                              :history [["+" "0.0-2411"]],
                              :type "macro",
                              :related ["cljs.core/contains?"],
                              :full-name-encode "cljs.core/js-in",
                              :source {:code "(core/defmacro js-in [key obj]\n  (core/list 'js* \"~{} in ~{}\" key obj))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/clojure/cljs/core.cljc",
                                       :lines [863 864]},
                              :examples [{:id "a45b18",
                                          :content "```clj\n(def a #js {:foo 1 :bar 2})\n\n(js-in \"foo\" a)\n;;=> true\n\n(js-in \"hello\" a)\n;;=> false\n```\n\nProperties inherited from prototype chain are also detected:\n\n```clj\n(js-in \"toString\" a)\n;;=> true\n```"}],
                              :full-name "cljs.core/js-in"},
           "cljs.core/>=" {:description "Returns true if each successive number argument is less than or equal to the\nprevious one, false otherwise.",
                           :return-type boolean,
                           :ns "cljs.core",
                           :name ">=",
                           :signature ["[x]" "[x y]" "[x y & more]"],
                           :history [["+" "0.0-927"]],
                           :type "function/macro",
                           :related ["cljs.core/>"],
                           :full-name-encode "cljs.core/GTEQ",
                           :source {:code "(defn ^boolean >=\n  ([x] true)\n  ([x y] (cljs.core/>= x y))\n  ([x y & more]\n   (if (cljs.core/>= x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (cljs.core/>= y (first more)))\n     false)))",
                                    :title "Function code",
                                    :repo "clojurescript",
                                    :tag "r1.7.228",
                                    :filename "src/main/cljs/cljs/core.cljs",
                                    :lines [2326 2336]},
                           :extra-sources [{:code "(core/defmacro ^::ana/numeric >=\n  ([x] true)\n  ([x y] (bool-expr (core/list 'js* \"(~{} >= ~{})\" x y)))\n  ([x y & more] `(and (>= ~x ~y) (>= ~y ~@more))))",
                                            :title "Macro code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/clojure/cljs/core.cljc",
                                            :lines [1052 1055]}],
                           :examples [{:id "de73d7",
                                       :content "```clj\n(>= 2 1)\n;;=> true\n\n(>= 2 2)\n;;=> true\n\n(>= 1 2)\n;;=> false\n\n(>= 6 5 4 3 2)\n;;=> true\n```"}],
                           :full-name "cljs.core/>=",
                           :clj-symbol "clojure.core/>=",
                           :docstring "Returns non-nil if nums are in monotonically non-increasing order,\notherwise false."},
           "clojure.browser.net/websocket-connection" {:ns "clojure.browser.net",
                                                       :name "websocket-connection",
                                                       :type "function",
                                                       :signature ["[]"
                                                                   "[auto-reconnect?]"
                                                                   "[auto-reconnect? next-reconnect-fn]"],
                                                       :source {:code "(defn websocket-connection\n  ([]\n     (websocket-connection nil nil))\n  ([auto-reconnect?]\n     (websocket-connection auto-reconnect? nil))\n  ([auto-reconnect? next-reconnect-fn]\n     (WebSocket. auto-reconnect? next-reconnect-fn)))",
                                                                :title "Source code",
                                                                :repo "clojurescript",
                                                                :tag "r1.7.228",
                                                                :filename "src/main/cljs/clojure/browser/net.cljs",
                                                                :lines [174
                                                                        180]},
                                                       :full-name "clojure.browser.net/websocket-connection",
                                                       :full-name-encode "clojure.browser.net/websocket-connection",
                                                       :history [["+"
                                                                  "0.0-2911"]]},
           "cljs.repl.browser/read-request" {:moved "cljs.repl.server/read-request",
                                             :ns "cljs.repl.browser",
                                             :name "read-request",
                                             :signature ["[rdr]"],
                                             :history [["+" "0.0-927"]
                                                       ["-"
                                                        "0.0-1503"]],
                                             :type "function",
                                             :full-name-encode "cljs.repl.browser/read-request",
                                             :source {:code "(defn read-request [rdr]\n  (let [line (.readLine rdr)]\n    (cond (.startsWith line \"POST\") (read-post line rdr)\n          (.startsWith line \"GET\") (read-get line rdr)\n          :else {:method :unknown :content line})))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1450",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [161 165]},
                                             :full-name "cljs.repl.browser/read-request",
                                             :removed {:in "0.0-1503",
                                                       :last-seen "0.0-1450"}},
           "cljs.analyzer.api/remove-ns" {:ns "cljs.analyzer.api",
                                          :name "remove-ns",
                                          :signature ["[ns]"
                                                      "[state ns]"],
                                          :history [["+" "0.0-3208"]],
                                          :type "function",
                                          :full-name-encode "cljs.analyzer.api/remove-ns",
                                          :source {:code "(defn remove-ns\n  ([ns]\n   (remove-ns env/*compiler* ns))\n  ([state ns]\n   {:pre [(symbol? ns)]}\n   (swap! state update-in [::ana/namespaces] dissoc ns)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/clojure/cljs/analyzer/api.clj",
                                                   :lines [202 208]},
                                          :full-name "cljs.analyzer.api/remove-ns",
                                          :clj-symbol "clojure.core/remove-ns",
                                          :docstring "Removes the namespace named by the symbol."},
           "cljs.core/default-dispatch-val" {:ns "cljs.core",
                                             :name "default-dispatch-val",
                                             :signature ["[multifn]"],
                                             :history [["+"
                                                        "0.0-3165"]],
                                             :type "function",
                                             :full-name-encode "cljs.core/default-dispatch-val",
                                             :source {:code "(defn default-dispatch-val\n  [multifn] (-default-dispatch-val multifn))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.7.228",
                                                      :filename "src/main/cljs/cljs/core.cljs",
                                                      :lines [9829
                                                              9831]},
                                             :full-name "cljs.core/default-dispatch-val",
                                             :docstring "Given a multimethod, return it's default-dispatch-val."},
           "cljs.reader/macros" {:ns "cljs.reader",
                                 :name "macros",
                                 :type "function",
                                 :signature ["[c]"],
                                 :source {:code "(defn macros [c]\n  (cond\n   (identical? c \\\") read-string*\n   (identical? c \\:) read-keyword\n   (identical? c \\;) read-comment\n   (identical? c \\') (wrapping-reader 'quote)\n   (identical? c \\@) (wrapping-reader 'deref)\n   (identical? c \\^) read-meta\n   (identical? c \\`) not-implemented\n   (identical? c \\~) not-implemented\n   (identical? c \\() read-list\n   (identical? c \\)) read-unmatched-delimiter\n   (identical? c \\[) read-vector\n   (identical? c \\]) read-unmatched-delimiter\n   (identical? c \\{) read-map\n   (identical? c \\}) read-unmatched-delimiter\n   (identical? c \\\\) read-literal\n   (identical? c \\#) read-dispatch\n   :else nil))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/reader.cljs",
                                          :lines [409 427]},
                                 :full-name "cljs.reader/macros",
                                 :full-name-encode "cljs.reader/macros",
                                 :history [["+" "0.0-927"]]},
           "cljs.build.api/target-file-for-cljs-ns" {:return-type File,
                                                     :ns "cljs.build.api",
                                                     :name "target-file-for-cljs-ns",
                                                     :signature ["[ns-sym]"
                                                                 "[ns-sym output-dir]"],
                                                     :history [["+"
                                                                "0.0-2496"]],
                                                     :type "function",
                                                     :full-name-encode "cljs.build.api/target-file-for-cljs-ns",
                                                     :source {:code "(defn ^File target-file-for-cljs-ns\n  ([ns-sym] (target-file-for-cljs-ns ns-sym nil))\n  ([ns-sym output-dir]\n    (util/to-target-file\n      (util/output-directory {:output-dir output-dir})\n      {:ns ns-sym})))",
                                                              :title "Source code",
                                                              :repo "clojurescript",
                                                              :tag "r1.7.228",
                                                              :filename "src/main/clojure/cljs/build/api.clj",
                                                              :lines [28
                                                                      39]},
                                                     :full-name "cljs.build.api/target-file-for-cljs-ns",
                                                     :docstring "Given an output directory and a clojurescript namespace return the\ncompilation target file for that namespace.\n\nFor example:\n(target-file-from-cljs-ns \"resources/out\" 'example.core) ->\n<File: \"resources/out/example/core.js\">"},
           "cljs.core/doseq" {:description "Repeatedly executes `body` (presumably for side-effects) with bindings and\nfiltering as provided by `for`. Does not retain the head of the sequence.\n\nReturns nil.",
                              :ns "cljs.core",
                              :name "doseq",
                              :signature ["[seq-exprs & body]"],
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :related ["cljs.core/doall"
                                        "cljs.core/dorun"
                                        "cljs.core/for"
                                        "cljs.core/dotimes"],
                              :full-name-encode "cljs.core/doseq",
                              :source {:code "(core/defmacro doseq\n  [seq-exprs & body]\n  (assert-args doseq\n    (vector? seq-exprs) \"a vector for its binding\"\n    (even? (count seq-exprs)) \"an even number of forms in binding vector\")\n  (core/let [err (core/fn [& msg] (throw (ex-info (apply core/str msg) {})))\n             step (core/fn step [recform exprs]\n                    (core/if-not exprs\n                      [true `(do ~@body)]\n                      (core/let [k (first exprs)\n                                 v (second exprs)\n\n                                 seqsym (gensym \"seq__\")\n                                 recform (if (core/keyword? k) recform `(recur (next ~seqsym) nil 0 0))\n                                 steppair (step recform (nnext exprs))\n                                 needrec (steppair 0)\n                                 subform (steppair 1)]\n                        (core/cond\n                          (= k :let) [needrec `(let ~v ~subform)]\n                          (= k :while) [false `(when ~v\n                                                 ~subform\n                                                 ~@(core/when needrec [recform]))]\n                          (= k :when) [false `(if ~v\n                                                (do\n                                                  ~subform\n                                                  ~@(core/when needrec [recform]))\n                                                ~recform)]\n                          (core/keyword? k) (err \"Invalid 'doseq' keyword\" k)\n                          :else (core/let [chunksym (with-meta (gensym \"chunk__\")\n                                                      {:tag 'not-native})\n                                           countsym (gensym \"count__\")\n                                           isym     (gensym \"i__\")\n                                           recform-chunk  `(recur ~seqsym ~chunksym ~countsym (unchecked-inc ~isym))\n                                           steppair-chunk (step recform-chunk (nnext exprs))\n                                           subform-chunk  (steppair-chunk 1)]\n                                  [true `(loop [~seqsym   (seq ~v)\n                                                ~chunksym nil\n                                                ~countsym 0\n                                                ~isym     0]\n                                           (if (coercive-boolean (< ~isym ~countsym))\n                                             (let [~k (-nth ~chunksym ~isym)]\n                                               ~subform-chunk\n                                               ~@(core/when needrec [recform-chunk]))\n                                             (when-let [~seqsym (seq ~seqsym)]\n                                               (if (chunked-seq? ~seqsym)\n                                                 (let [c# (chunk-first ~seqsym)]\n                                                   (recur (chunk-rest ~seqsym) c#\n                                                     (count c#) 0))\n                                                 (let [~k (first ~seqsym)]\n                                                   ~subform\n                                                   ~@(core/when needrec [recform]))))))])))))]\n    (nth (step nil (seq seq-exprs)) 1)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/clojure/cljs/core.cljc",
                                       :lines [2264 2318]},
                              :full-name "cljs.core/doseq",
                              :clj-symbol "clojure.core/doseq",
                              :docstring "Repeatedly executes body (presumably for side-effects) with\nbindings and filtering as provided by \"for\".  Does not retain\nthe head of the sequence. Returns nil."},
           "cljs.core/*" {:description "Returns the product of nums.\n\n`(*)` returns 1.",
                          :return-type number,
                          :ns "cljs.core",
                          :name "*",
                          :signature ["[]"
                                      "[x]"
                                      "[x y]"
                                      "[x y & more]"],
                          :history [["+" "0.0-927"]],
                          :type "function/macro",
                          :related ["cljs.core/+" "cljs.core//"],
                          :full-name-encode "cljs.core/STAR",
                          :source {:code "(defn ^number *\n  ([] 1)\n  ([x] x)\n  ([x y] (cljs.core/* x y))\n  ([x y & more] (reduce * (cljs.core/* x y) more)))",
                                   :title "Function code",
                                   :repo "clojurescript",
                                   :tag "r1.7.228",
                                   :filename "src/main/cljs/cljs/core.cljs",
                                   :lines [2274 2279]},
                          :extra-sources [{:code "(core/defmacro ^::ana/numeric *\n  ([] 1)\n  ([x] x)\n  ([x y] (core/list 'js* \"(~{} * ~{})\" x y))\n  ([x y & more] `(* (* ~x ~y) ~@more)))",
                                           :title "Macro code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/clojure/cljs/core.cljc",
                                           :lines [1021 1025]}],
                          :examples [{:id "bc4a1f",
                                      :content "```clj\n;; there is an implicit 1\n(*)\n;;=> 1\n\n;; the implicit 1 comes into play\n(* 6)\n;;=> 6\n\n(* 2 3)\n;;=> 6\n\n(* 2 3 4)\n;;=> 24\n```"}],
                          :full-name "cljs.core/*",
                          :clj-symbol "clojure.core/*",
                          :docstring "Returns the product of nums. (*) returns 1."},
           "cljs.core/into" {:description "Returns a new collection consisting of `to` with all of the items of `from`\n\"added\" using `conj`.\n\nA transducer may be supplied as `xform`.",
                             :ns "cljs.core",
                             :name "into",
                             :signature ["[to from]"
                                         "[to xform from]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/conj"],
                             :full-name-encode "cljs.core/into",
                             :source {:code "(defn into\n  ([to from]\n     (if-not (nil? to)\n       (if (implements? IEditableCollection to)\n         (with-meta (persistent! (reduce -conj! (transient to) from)) (meta to))\n         (reduce -conj to from))\n       (reduce conj () from)))\n  ([to xform from]\n     (if (implements? IEditableCollection to)\n       (with-meta (persistent! (transduce xform conj! (transient to) from)) (meta to))\n       (transduce xform conj to from))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [4486 4498]},
                             :full-name "cljs.core/into",
                             :clj-symbol "clojure.core/into",
                             :docstring "Returns a new coll consisting of to-coll with all of the items of\nfrom-coll conjoined. A transducer may be supplied."},
           "cljs.repl.server/state" {:ns "cljs.repl.server",
                                     :name "state",
                                     :type "dynamic var",
                                     :source {:code "(def ^:dynamic state nil)",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/clojure/cljs/repl/server.clj",
                                              :lines [8]},
                                     :full-name "cljs.repl.server/state",
                                     :full-name-encode "cljs.repl.server/state",
                                     :history [["+" "0.0-1503"]]},
           "cljs.core/defmethod" {:ns "cljs.core",
                                  :name "defmethod",
                                  :signature ["[multifn dispatch-val & fn-tail]"],
                                  :history [["+" "0.0-927"]],
                                  :type "macro",
                                  :full-name-encode "cljs.core/defmethod",
                                  :source {:code "(core/defmacro defmethod\n  [multifn dispatch-val & fn-tail]\n  `(-add-method ~(with-meta multifn {:tag 'cljs.core/MultiFn}) ~dispatch-val (fn ~@fn-tail)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/clojure/cljs/core.cljc",
                                           :lines [2517 2520]},
                                  :full-name "cljs.core/defmethod",
                                  :clj-symbol "clojure.core/defmethod",
                                  :docstring "Creates and installs a new method of multimethod associated with dispatch-value. "},
           "cljs.core/rest" {:description "Returns a possibly empty sequence of the items after the first item.\n\nCalls `seq` on its argument.",
                             :return-type seq,
                             :ns "cljs.core",
                             :name "rest",
                             :signature ["[coll]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/next"
                                       "cljs.core/first"
                                       "cljs.core/drop"
                                       "cljs.core/pop"],
                             :full-name-encode "cljs.core/rest",
                             :source {:code "(defn ^seq rest\n  [coll]\n  (if-not (nil? coll)\n    (if (implements? ISeq coll)\n      (-rest ^not-native coll)\n      (let [s (seq coll)]\n        (if s\n          (-rest ^not-native s)\n          ())))\n    ()))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [1104 1115]},
                             :examples [{:id "0869af",
                                         :content "```clj\n(rest [1 2 3])\n;;=> (2 3)\n\n(rest [1 2])\n;;=> (2)\n\n(rest [1])\n;;=> ()\n\n(rest [])\n;;=> ()\n```"}],
                             :full-name "cljs.core/rest",
                             :clj-symbol "clojure.core/rest",
                             :docstring "Returns a possibly empty seq of the items after the first. Calls seq on its\nargument."},
           "cljs.reader/unicode-4-pattern" {:ns "cljs.reader",
                                            :name "unicode-4-pattern",
                                            :type "var",
                                            :source {:code "(def unicode-4-pattern (re-pattern \"^[0-9A-Fa-f]{4}$\"))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.7.228",
                                                     :filename "src/main/cljs/cljs/reader.cljs",
                                                     :lines [182]},
                                            :full-name "cljs.reader/unicode-4-pattern",
                                            :full-name-encode "cljs.reader/unicode-4-pattern",
                                            :history [["+" "0.0-1424"]]},
           "clojure.browser.repl/bootstrap" {:ns "clojure.browser.repl",
                                             :name "bootstrap",
                                             :signature ["[]"],
                                             :history [["+"
                                                        "0.0-3115"]],
                                             :type "function",
                                             :full-name-encode "clojure.browser.repl/bootstrap",
                                             :source {:code "(defn bootstrap\n  []\n  ;; Monkey-patch goog.provide if running under optimizations :none - David\n  (when-not js/COMPILED\n    (set! (.-require__ js/goog) js/goog.require)\n    ;; suppress useless Google Closure error about duplicate provides\n    (set! (.-isProvided_ js/goog) (fn [name] false))\n    ;; provide cljs.user\n    (goog/constructNamespace_ \"cljs.user\")\n    (set! (.-writeScriptTag__ js/goog)\n      (fn [src opt_sourceText]\n        ;; the page is already loaded, we can no longer leverage document.write\n        ;; instead construct script tag elements and append them to the body\n        ;; of the page, to avoid parallel script loading enforce sequential\n        ;; load with a simple load queue\n        (let [loaded (atom false)\n              onload (fn []\n                       (when (and load-queue (false? @loaded))\n                         (swap! loaded not)\n                         (if (zero? (alength load-queue))\n                           (set! load-queue nil)\n                           (.apply js/goog.writeScriptTag__ nil (.shift load-queue)))))]\n          (.appendChild js/document.body\n            (as-> (.createElement js/document \"script\") script\n              (doto script\n                (gobj/set \"type\" \"text/javascript\")\n                (gobj/set \"onload\" onload)\n                (gobj/set \"onreadystatechange\" onload)) ;; IE\n              (if (nil? opt_sourceText)\n                (doto script (gobj/set \"src\" src))\n                (doto script (gdom/setTextContext opt_sourceText))))))))\n    ;; queue or load\n    (set! (.-writeScriptTag_ js/goog)\n      (fn [src opt_sourceText]\n        (if load-queue\n          (.push load-queue #js [src opt_sourceText])\n          (do\n            (set! load-queue #js [])\n            (js/goog.writeScriptTag__ src opt_sourceText)))))\n    ;; we must reuse Closure library dev time dependency management, under namespace\n    ;; reload scenarios we simply delete entries from the correct private locations\n    (set! (.-require js/goog)\n      (fn [src reload]\n        (when (= reload \"reload-all\")\n          (set! (.-cljsReloadAll_ js/goog) true))\n        (let [reload? (or reload (.-cljsReloadAll__ js/goog))]\n          (when reload?\n            (let [path (aget js/goog.dependencies_.nameToPath src)]\n              (gobj/remove js/goog.dependencies_.visited path)\n              (gobj/remove js/goog.dependencies_.written path)\n              (gobj/remove js/goog.dependencies_.written\n                (str js/goog.basePath path))))\n          (let [ret (.require__ js/goog src)]\n            (when (= reload \"reload-all\")\n              (set! (.-cljsReloadAll_ js/goog) false))\n            ret))))))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.7.228",
                                                      :filename "src/main/cljs/clojure/browser/repl.cljs",
                                                      :lines [125 182]},
                                             :full-name "clojure.browser.repl/bootstrap",
                                             :docstring "Reusable browser REPL bootstrapping. Patches the essential functions\nin goog.base to support re-loading of namespaces after page load."},
           "cljs.core/dotimes" {:description "Repeatedly executes `body` (presumably for side-effects) with `name` bound to\nintegers from 0 through `n`-1.",
                                :ns "cljs.core",
                                :name "dotimes",
                                :signature ["[[name n] & body]"],
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :related ["cljs.core/repeat"
                                          "cljs.core/for"
                                          "cljs.core/doseq"],
                                :full-name-encode "cljs.core/dotimes",
                                :source {:code "(core/defmacro dotimes\n  [bindings & body]\n  (core/let [i (first bindings)\n             n (second bindings)]\n    `(let [n# ~n]\n       (loop [~i 0]\n         (when (< ~i n#)\n           ~@body\n           (recur (inc ~i)))))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/clojure/cljs/core.cljc",
                                         :lines [2447 2459]},
                                :full-name "cljs.core/dotimes",
                                :clj-symbol "clojure.core/dotimes",
                                :docstring "bindings => name n\n\nRepeatedly executes body (presumably for side-effects) with name\nbound to integers from 0 through n-1."},
           "cljs.core/dedupe" {:ns "cljs.core",
                               :name "dedupe",
                               :signature ["[]" "[coll]"],
                               :history [["+" "0.0-2301"]],
                               :type "function",
                               :full-name-encode "cljs.core/dedupe",
                               :source {:code "(defn dedupe\n  ([]\n   (fn [rf]\n     (let [pa (volatile! ::none)]\n       (fn\n         ([] (rf))\n         ([result] (rf result))\n         ([result input]\n            (let [prior @pa]\n              (vreset! pa input)\n              (if (= prior input)\n                result\n                (rf result input))))))))\n  ([coll] (sequence (dedupe) coll)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [9240 9255]},
                               :full-name "cljs.core/dedupe",
                               :clj-symbol "clojure.core/dedupe",
                               :docstring "Returns a lazy sequence removing consecutive duplicates in coll.\nReturns a transducer when no collection is provided."},
           "clojure.zip/lefts" {:ns "clojure.zip",
                                :name "lefts",
                                :signature ["[loc]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "clojure.zip/lefts",
                                :source {:code "(defn lefts\n  [loc]\n    (seq (:l (loc 1))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/clojure/zip.cljs",
                                         :lines [87 90]},
                                :full-name "clojure.zip/lefts",
                                :clj-symbol "clojure.zip/lefts",
                                :docstring "Returns a seq of the left siblings of this loc"},
           "clojure.browser.dom/ensure-element" {:ns "clojure.browser.dom",
                                                 :name "ensure-element",
                                                 :signature ["[e]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.browser.dom/ensure-element",
                                                 :source {:code "(defn ensure-element\n  [e]\n  (cond (keyword? e) (get-element e)\n        (string? e) (html->dom e)\n        :else e))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r1.7.228",
                                                          :filename "src/main/cljs/clojure/browser/dom.cljs",
                                                          :lines [107
                                                                  112]},
                                                 :full-name "clojure.browser.dom/ensure-element",
                                                 :docstring "Coerce the argument to a dom element if possible."},
           "cljs.core/defmacro" {:description "Defines a macro, which is essentially a function that runs at compile time.\nMacros can be used to define syntactic constructs which would require\nprimitives or built-in support in other languages.\n\nUsing macros is as easy as using functions, but writing them is a little more\ndifficult.  Also, creating macros is generally discouraged if you can\naccomplish the same goal with a function.\n\n## Rules and Details\n\nThere is a strict rule for when you can use `defmacro` -- you can only use it\nin what we call a _macro namespace_, effectively forcing you to separate your\ncompile time and runtime code.\n\nA side effect of this is that you cannot use `defmacro` from a REPL.  Sorry!\n\nThis strict rule is due to the nature of differing compile time environments\nfor the optimized \"ClojureScript JVM\" compiler and the newer bootstrapped\n\"ClojureScript JS\" compiler.\n\nIn order to create macros that are portable between either compiler version,\nyou must place macros in a `.cljc` file, but a `.clj` file is sufficient if no\n[reader conditionals][doc:syntax/cond] are needed.  Why would they be needed?\nBecause ClojureScript macro namespaces may be handed off to Clojure for\nevaluation, depending on the compiler version:\n\n| compiler version  | macro namespaces evaluated by |\n|-------------------|-------------------------------|\n| ClojureScript JVM | Clojure                       |\n| ClojureScript JS  | ClojureScript                 |\n\nPlease see the examples section below for a more concrete look.",
                                 :ns "cljs.core",
                                 :name "defmacro",
                                 :signature ["[name doc-string? attr-map? [params*] body]"
                                             "[name doc-string? attr-map? ([params*] body) + attr-map?]"],
                                 :history [["+" "0.0-927"]],
                                 :type "macro",
                                 :related ["syntax/syntax-quote"
                                           "syntax/unquote"
                                           "cljs.core/macroexpand"
                                           "cljs.core/macroexpand-1"],
                                 :full-name-encode "cljs.core/defmacro",
                                 :source {:code "(core/defn defmacro\n  [&form &env name & args]\n  (core/let [prefix (core/loop [p (core/list (vary-meta name assoc :macro true)) args args]\n                      (core/let [f (first args)]\n                        (if (core/string? f)\n                          (recur (cons f p) (next args))\n                          (if (map? f)\n                            (recur (cons f p) (next args))\n                            p))))\n             fdecl (core/loop [fd args]\n                     (if (core/string? (first fd))\n                       (recur (next fd))\n                       (if (map? (first fd))\n                         (recur (next fd))\n                         fd)))\n             fdecl (if (vector? (first fdecl))\n                     (core/list fdecl)\n                     fdecl)\n             add-implicit-args (core/fn [fd]\n                                 (core/let [args (first fd)]\n                                   (cons (vec (cons '&form (cons '&env args))) (next fd))))\n             add-args (core/fn [acc ds]\n                        (if (core/nil? ds)\n                          acc\n                          (core/let [d (first ds)]\n                            (if (map? d)\n                              (conj acc d)\n                              (recur (conj acc (add-implicit-args d)) (next ds))))))\n             fdecl (seq (add-args [] fdecl))\n             decl (core/loop [p prefix d fdecl]\n                    (if p\n                      (recur (next p) (cons (first p) d))\n                      d))]\n    (core/list 'do\n      (cons `defn decl)\n      (core/list 'set! `(. ~name ~'-cljs$lang$macro) true))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/clojure/cljs/core.cljc",
                                          :lines [2882 2923]},
                                 :examples [{:id "8040c8",
                                             :content "Here is a `str->int` macro that works for either ClojureScript compiler\nversion.  It simply expands to a `js/parseInt` call:\n\n```clj\n;; in macros.clj\n(ns foo.macros)\n\n;; expands to a runtime call\n(defmacro str->int [s]\n  `(js/parseInt s))\n```\n\nIf we want to evaluate the conversion at _compile time_ instead of expanding it\nto a runtime call, we must use reader conditionals (in a `.cljc` file) to\nchoose the function appropriate for each compiler's evaluation environment.\n\n```clj\n;; in macros.cljc\n(ns foo.macros)\n\n;; expands to the result of the conversion\n(defmacro str->int [s]\n  #?(:clj  (Integer/parseInt s)\n     :cljs (js/parseInt s)))\n```"}],
                                 :full-name "cljs.core/defmacro",
                                 :clj-symbol "clojure.core/defmacro",
                                 :docstring "Like defn, but the resulting function name is declared as a\nmacro and will be used as a macro by the compiler when it is\ncalled."},
           "cljs.core/remove" {:description "Returns a lazy sequence of the items in `coll` for which `(pred item)` returns\nfalse.\n\n`pred` must be free of side-effects.\n\nReturns a transducer when no collection is provided.",
                               :ns "cljs.core",
                               :name "remove",
                               :signature ["[pred]" "[pred coll]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/filter"],
                               :full-name-encode "cljs.core/remove",
                               :source {:code "(defn remove\n  ([pred] (filter (complement pred)))\n  ([pred coll]\n     (filter (complement pred) coll)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [4455 4461]},
                               :full-name "cljs.core/remove",
                               :clj-symbol "clojure.core/remove",
                               :docstring "Returns a lazy sequence of the items in coll for which\n(pred item) returns false. pred must be free of side-effects.\nReturns a transducer when no collection is provided."},
           "cljs.test/test-all-vars" {:ns "cljs.test",
                                      :name "test-all-vars",
                                      :signature ["[[quote ns :as form]]"],
                                      :history [["+" "0.0-2496"]],
                                      :type "macro",
                                      :full-name-encode "cljs.test/test-all-vars",
                                      :source {:code "(defmacro test-all-vars\n  [[quote ns :as form]]\n  `(cljs.test/run-block\n     (concat (test-all-vars-block ~form)\n             [(fn []\n                (report {:type :end-test-all-vars :ns ~form}))])))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/cljs/cljs/test.clj",
                                               :lines [334 341]},
                                      :full-name "cljs.test/test-all-vars",
                                      :clj-symbol "clojure.test/test-all-vars",
                                      :docstring "Calls test-vars on every var with :test metadata interned in the\nnamespace, with fixtures."},
           "cljs.core/set-print-fn!" {:ns "cljs.core",
                                      :name "set-print-fn!",
                                      :signature ["[f]"],
                                      :history [["+" "0.0-1798"]],
                                      :type "function",
                                      :full-name-encode "cljs.core/set-print-fnBANG",
                                      :source {:code "(defn set-print-fn!\n  [f] (set! *print-fn* f))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [59 61]},
                                      :full-name "cljs.core/set-print-fn!",
                                      :docstring "Set *print-fn* to f."},
           "cljs.core/PersistentArrayMap.HASHMAP_THRESHOLD" {:ns "cljs.core",
                                                             :name "PersistentArrayMap.HASHMAP_THRESHOLD",
                                                             :history [["+"
                                                                        "0.0-1211"]
                                                                       ["-"
                                                                        "0.0-2301"]],
                                                             :parent-type "PersistentArrayMap",
                                                             :type "var",
                                                             :full-name-encode "cljs.core/PersistentArrayMapDOTHASHMAP_THRESHOLD",
                                                             :source {:code "(set! cljs.core.PersistentArrayMap.HASHMAP_THRESHOLD 8)",
                                                                      :title "Source code",
                                                                      :repo "clojurescript",
                                                                      :tag "r2280",
                                                                      :filename "src/cljs/cljs/core.cljs",
                                                                      :lines [4672]},
                                                             :full-name "cljs.core/PersistentArrayMap.HASHMAP_THRESHOLD",
                                                             :removed {:in "0.0-2301",
                                                                       :last-seen "0.0-2280"}},
           "cljs.core/if-not" {:description "If `test` is false or nil, evaluates and returns `then`. Otherwise, evaluates\nand returns `else`. `else` defaults to nil if not provided.",
                               :ns "cljs.core",
                               :name "if-not",
                               :signature ["[test then]"
                                           "[test then else]"],
                               :history [["+" "0.0-927"]],
                               :type "macro",
                               :related ["special/if"
                                         "cljs.core/when-not"],
                               :full-name-encode "cljs.core/if-not",
                               :source {:code "(defmacro if-not\n  ([test then] `(if-not ~test ~then nil))\n  ([test then else]\n   `(if (not ~test) ~then ~else)))",
                                        :title "Source code",
                                        :repo "clojure",
                                        :tag "clojure-1.7.0",
                                        :filename "src/clj/clojure/core.clj",
                                        :lines [732 738]},
                               :full-name "cljs.core/if-not",
                               :clj-symbol "clojure.core/if-not",
                               :docstring "Evaluates test. If logical false, evaluates and returns then expr, \notherwise else expr, if supplied, else nil."},
           "cljs.repl.reflect/macroexpand" {:ns "cljs.repl.reflect",
                                            :name "macroexpand",
                                            :type "function",
                                            :signature ["[form]"],
                                            :source {:code "(defn macroexpand [form]\n  \"Fully expands a cljs macro form.\"\n  (let [mform (analyzer/macroexpand-1 {} form)]\n    (if (identical? form mform)\n      mform\n      (macroexpand mform))))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.7.228",
                                                     :filename "src/main/clojure/cljs/repl/reflect.clj",
                                                     :lines [32 37]},
                                            :full-name "cljs.repl.reflect/macroexpand",
                                            :full-name-encode "cljs.repl.reflect/macroexpand",
                                            :history [["+" "0.0-1503"]]},
           "cljs.core/string-iter" {:ns "cljs.core",
                                    :name "string-iter",
                                    :type "function",
                                    :signature ["[x]"],
                                    :source {:code "(defn string-iter [x]\n  (StringIter. x 0))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [3537 3538]},
                                    :full-name "cljs.core/string-iter",
                                    :full-name-encode "cljs.core/string-iter",
                                    :history [["+" "0.0-2301"]]},
           "cljs.repl.browser/-main" {:ns "cljs.repl.browser",
                                      :name "-main",
                                      :type "function",
                                      :signature ["[]"],
                                      :source {:code "(defn -main []\n  (repl/repl (repl-env)))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/clojure/cljs/repl/browser.clj",
                                               :lines [330 331]},
                                      :full-name "cljs.repl.browser/-main",
                                      :full-name-encode "cljs.repl.browser/-main",
                                      :history [["+" "0.0-3165"]]},
           "cljs.core/set-print-err-fn!" {:ns "cljs.core",
                                          :name "set-print-err-fn!",
                                          :signature ["[f]"],
                                          :history [["+" "1.7.10"]],
                                          :type "function",
                                          :full-name-encode "cljs.core/set-print-err-fnBANG",
                                          :source {:code "(defn set-print-err-fn!\n  [f] (set! *print-err-fn* f))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/cljs/cljs/core.cljs",
                                                   :lines [63 65]},
                                          :full-name "cljs.core/set-print-err-fn!",
                                          :docstring "Set *print-err-fn* to f."},
           "cljs.js/analyze*" {:ns "cljs.js",
                               :name "analyze*",
                               :signature ["[bound-vars source name opts cb]"],
                               :history [["+" "1.7.10"]
                                         ["-" "1.7.28"]],
                               :type "function",
                               :full-name-encode "cljs.js/analyzeSTAR",
                               :source {:code "(defn analyze* [bound-vars source name opts cb]\n  (let [rdr        (rt/indexing-push-back-reader source 1 name)\n        eof        (js-obj)\n        aenv       (ana/empty-env)\n        the-ns     (or (:ns opts) 'cljs.user)\n        bound-vars (cond-> (merge bound-vars {:*cljs-ns* the-ns})\n                     (:source-map opts) (assoc :*sm-data* (sm-data)))]\n    ((fn analyze-loop []\n       (binding [env/*compiler*         (:*compiler* bound-vars)\n                 ana/*cljs-ns*          (:*cljs-ns* bound-vars)\n                 *ns*                   (create-ns (:*cljs-ns* bound-vars))\n                 r/*data-readers*       (:*data-readers* bound-vars)\n                 comp/*source-map-data* (:*sm-data* bound-vars)]\n         (let [res (try\n                     {:value (r/read {:eof eof :read-cond :allow :features #{:cljs}} rdr)}\n                     (catch :default cause\n                       (wrap-error\n                         (ana/error aenv\n                           (str \"Could not analyze \" name) cause))))]\n           (if (:error res)\n             (cb res)\n             (let [form (:value res)]\n               (if-not (identical? eof form)\n                 (let [aenv (cond-> (assoc aenv :ns (ana/get-namespace ana/*cljs-ns*))\n                              (:context opts) (assoc :context (:context opts))\n                              (:def-emits-var opts) (assoc :def-emits-var true))\n                       res  (try\n                              {:value (ana/analyze aenv form nil opts)}\n                              (catch :default cause\n                                (wrap-error\n                                  (ana/error aenv\n                                    (str \"Could not analyze \" name) cause))))]\n                   (if (:error res)\n                     (cb res)\n                     (let [ast (:value res)]\n                       (if (= :ns (:op ast))\n                         (ns-side-effects bound-vars aenv ast opts\n                           (fn [res]\n                             (if (:error res)\n                               (cb res)\n                               (analyze-loop))))\n                         (recur)))))\n                 (cb {:value nil}))))))))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.10",
                                        :filename "src/main/cljs/cljs/js.cljs",
                                        :lines [379 421]},
                               :full-name "cljs.js/analyze*",
                               :removed {:in "1.7.28",
                                         :last-seen "1.7.10"}},
           "specialrepl/require" {:description "Only usable from a REPL.\n\nLoads libs, skipping any that are already loaded. Each argument is\neither a libspec that identifies a lib or a flag that modifies how all the identified\nlibs are loaded.\n\n## Libspecs\n\nA libspec is a lib name or a vector containing a lib name followed by\noptions expressed as sequential keywords and arguments.\n\nRecognized options:\n\n- `:as` takes a symbol as its argument and makes that symbol an alias to the\n  lib's namespace in the current namespace.\n- `:refer` takes a list of symbols to refer from the namespace..\n- `:refer-macros` takes a list of macro symbols to refer from the namespace.\n- `:include-macros` takes a list of macro symbols to refer from the namespace.\n\n## Flags\n\nA flag is a keyword. Recognized flags:\n\n- `:reload` forces loading of all the identified libs even if they are\n  already loaded\n- `:reload-all` implies :reload and also forces loading of all libs that the\n  identified libs directly or indirectly load via require or use\n- `:verbose` triggers printing information about each load, alias, and refer",
                                  :ns "specialrepl",
                                  :name "require",
                                  :signature ["[& args]"],
                                  :history [["+" "0.0-2629"]],
                                  :type "special form (repl)",
                                  :related ["specialrepl/require-macros"],
                                  :full-name-encode "specialrepl/require",
                                  :source {:code "(def default-special-fns\n  (let [load-file-fn\n        (fn self\n          ([repl-env env form]\n            (self repl-env env form nil))\n          ([repl-env env [_ file :as form] opts]\n            (load-file repl-env file opts)))\n        in-ns-fn\n        (fn self\n          ([repl-env env form]\n           (self repl-env env form nil))\n          ([repl-env env [_ [quote ns-name] :as form] _]\n            ;; guard against craziness like '5 which wreaks havoc\n           (when-not (and (= quote 'quote) (symbol? ns-name))\n             (throw (IllegalArgumentException. \"Argument to in-ns must be a symbol.\")))\n           (when-not (ana/get-namespace ns-name)\n             (swap! env/*compiler* assoc-in [::ana/namespaces ns-name] {:name ns-name})\n             (-evaluate repl-env \"<cljs repl>\" 1\n               (str \"goog.provide('\" (comp/munge ns-name) \"');\")))\n           (set! ana/*cljs-ns* ns-name)))]\n    (wrap-special-fns wrap-self\n     {'in-ns in-ns-fn\n      'clojure.core/in-ns in-ns-fn\n      'require\n      (fn self\n        ([repl-env env form]\n         (self repl-env env form nil))\n        ([repl-env env [_ & specs :as form] opts]\n         (let [is-self-require? (self-require? specs)\n               [target-ns restore-ns]\n               (if-not is-self-require?\n                 [ana/*cljs-ns* nil]\n                 ['cljs.user ana/*cljs-ns*])]\n           (evaluate-form repl-env env \"<cljs repl>\"\n                          (with-meta\n                            `(~'ns ~target-ns\n                               (:require ~@(-> specs canonicalize-specs decorate-specs)))\n                            {:merge true :line 1 :column 1})\n                          identity opts)\n           (when is-self-require?\n             (set! ana/*cljs-ns* restore-ns)))))\n      'require-macros\n      (fn self\n        ([repl-env env form]\n         (self repl-env env form nil))\n        ([repl-env env [_ & specs :as form] opts]\n         (evaluate-form repl-env env \"<cljs repl>\"\n                        (with-meta\n                          `(~'ns ~ana/*cljs-ns*\n                             (:require-macros ~@(-> specs canonicalize-specs decorate-specs)))\n                          {:merge true :line 1 :column 1})\n                        identity opts)))\n      'import\n      (fn self\n        ([repl-env env form]\n         (self repl-env env form nil))\n        ([repl-env env [_ & specs :as form] opts]\n         (evaluate-form repl-env env \"<cljs repl>\"\n                        (with-meta\n                          `(~'ns ~ana/*cljs-ns*\n                             (:import\n                              ~@(map\n                                 (fn [quoted-spec-or-kw]\n                                   (if (keyword? quoted-spec-or-kw)\n                                     quoted-spec-or-kw\n                                     (second quoted-spec-or-kw)))\n                                 specs)))\n                          {:merge true :line 1 :column 1})\n                        identity opts)))\n      'load-file load-file-fn\n      'clojure.core/load-file load-file-fn\n      'load-namespace\n      (fn self\n        ([repl-env env form]\n         (self env repl-env form nil))\n        ([repl-env env [_ ns :as form] opts]\n         (load-namespace repl-env ns opts)))})))",
                                           :title "repl specials table",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/clojure/cljs/repl.cljc",
                                           :lines [642 718]},
                                  :examples [{:id "ab0355",
                                              :content "```clj\n(require '[clojure/string :as string])\n```"}],
                                  :full-name "specialrepl/require",
                                  :clj-symbol "clojure.core/require",
                                  :docstring "  Loads libs, skipping any that are already loaded. Each argument is\neither a libspec that identifies a lib or a flag that modifies how all the identified\nlibs are loaded. Use :require in the ns macro in preference to calling this\ndirectly.\n\nLibs\n\nA 'lib' is a named set of resources in classpath whose contents define a\nlibrary of ClojureScript code. Lib names are symbols and each lib is associated\nwith a ClojureScript namespace. A lib's name also locates its root directory\nwithin classpath using Java's package name to classpath-relative path mapping.\nAll resources in a lib should be contained in the directory structure under its\nroot directory. All definitions a lib makes should be in its associated namespace.\n\n'require loads a lib by loading its root resource. The root resource path\nis derived from the lib name in the following manner:\nConsider a lib named by the symbol 'x.y.z; it has the root directory\n<classpath>/x/y/, and its root resource is <classpath>/x/y/z.clj. The root\nresource should contain code to create the lib's namespace (usually by using\nthe ns macro) and load any additional lib resources.\n\nLibspecs\n\nA libspec is a lib name or a vector containing a lib name followed by\noptions expressed as sequential keywords and arguments.\n\nRecognized options:\n:as takes a symbol as its argument and makes that symbol an alias to the\n  lib's namespace in the current namespace.\n:refer takes a list of symbols to refer from the namespace..\n:refer-macros takes a list of macro symbols to refer from the namespace.\n:include-macros true causes macros from the namespace to be required.\n\nFlags\n\nA flag is a keyword.\nRecognized flags: :reload, :reload-all, :verbose\n:reload forces loading of all the identified libs even if they are\n  already loaded\n:reload-all implies :reload and also forces loading of all libs that the\n  identified libs directly or indirectly load via require or use\n:verbose triggers printing information about each load, alias, and refer\n\nExample:\n\nThe following would load the library clojure.string :as string.\n\n(require '[clojure/string :as string])"},
           "clojure.zip/path" {:ns "clojure.zip",
                               :name "path",
                               :signature ["[loc]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip/path",
                               :source {:code "(defn path\n  [loc]\n    (:pnodes (loc 1)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/clojure/zip.cljs",
                                        :lines [82 85]},
                               :full-name "clojure.zip/path",
                               :clj-symbol "clojure.zip/path",
                               :docstring "Returns a seq of nodes leading to this loc"},
           "cljs.core/mapcat" {:description "Returns the result of applying `concat` to the result of applying `map` to `f`\nand `colls`.\n\nFunction `f` should return a collection.\n\nReturns a transducer when no collections are provided.",
                               :ns "cljs.core",
                               :name "mapcat",
                               :signature ["[f]" "[f & colls]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/map"
                                         "cljs.core/concat"],
                               :full-name-encode "cljs.core/mapcat",
                               :source {:code "(defn mapcat\n  ([f] (comp (map f) cat))\n  ([f & colls]\n     (apply concat (apply map f colls))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [4416 4424]},
                               :full-name "cljs.core/mapcat",
                               :clj-symbol "clojure.core/mapcat",
                               :docstring "Returns the result of applying concat to the result of applying map\nto f and colls.  Thus function f should return a collection. Returns\na transducer when no collections are provided"},
           "cljs.repl.node/platform-path" {:ns "cljs.repl.node",
                                           :name "platform-path",
                                           :type "function",
                                           :signature ["[v]"],
                                           :source {:code "(defn platform-path [v]\n  (str \"path.join.apply(null, \" (seq->js-array v) \")\"))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.7.228",
                                                    :filename "src/main/clojure/cljs/repl/node.clj",
                                                    :lines [78 79]},
                                           :full-name "cljs.repl.node/platform-path",
                                           :full-name-encode "cljs.repl.node/platform-path",
                                           :history [["+" "0.0-2814"]]},
           "cljs.core/m3-mix-H1" {:return-type number,
                                  :ns "cljs.core",
                                  :name "m3-mix-H1",
                                  :signature ["[h1 k1]"],
                                  :history [["+" "0.0-2261"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/m3-mix-H1",
                                  :source {:code "(defn ^number m3-mix-H1 [h1 k1]\n  (int (-> (int h1) (bit-xor (int k1)) (int-rotate-left 13) (imul 5) (+ (int 0xe6546b64)))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [803 804]},
                                  :full-name "cljs.core/m3-mix-H1"},
           "cljs.core/IWatchable" {:ns "cljs.core",
                                   :name "IWatchable",
                                   :history [["+" "0.0-927"]],
                                   :type "protocol",
                                   :full-name-encode "cljs.core/IWatchable",
                                   :source {:code "(defprotocol IWatchable\n  \"Protocol for types that can be watched. Currently only implemented by Atom.\"\n  (-notify-watches [this oldval newval]\n    \"Calls all watchers with this, oldval and newval.\")\n  (-add-watch [this key f]\n    \"Adds a watcher function f to this. Keys must be unique per reference,\n     and can be used to remove the watch with -remove-watch.\")\n  (-remove-watch [this key]\n    \"Removes watcher that corresponds to key from this.\"))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [657 665]},
                                   :methods [{:name "-notify-watches",
                                              :signature ["[this oldval newval]"],
                                              :docstring "Calls all watchers with this, oldval and newval."}
                                             {:name "-add-watch",
                                              :signature ["[this key f]"],
                                              :docstring "Adds a watcher function f to this. Keys must be unique per reference,\n     and can be used to remove the watch with -remove-watch."}
                                             {:name "-remove-watch",
                                              :signature ["[this key]"],
                                              :docstring "Removes watcher that corresponds to key from this."}],
                                   :full-name "cljs.core/IWatchable",
                                   :docstring "Protocol for types that can be watched. Currently only implemented by Atom."},
           "cljs.core/PersistentHashMap.fromArray" {:ns "cljs.core",
                                                    :name "PersistentHashMap.fromArray",
                                                    :signature ["[arr no-clone]"],
                                                    :history [["+"
                                                               "0.0-2719"]],
                                                    :parent-type "PersistentHashMap",
                                                    :type "function",
                                                    :full-name-encode "cljs.core/PersistentHashMapDOTfromArray",
                                                    :source {:code "(set! (.-fromArray PersistentHashMap)\n  (fn [arr ^boolean no-clone]\n    (let [arr (if no-clone arr (aclone arr))\n          len (alength arr)]\n      (loop [i 0 ret (transient (.-EMPTY PersistentHashMap))]\n        (if (< i len)\n          (recur (+ i 2)\n            (-assoc! ret (aget arr i) (aget arr (inc i))))\n          (-persistent! ret))))))",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r1.7.228",
                                                             :filename "src/main/cljs/cljs/core.cljs",
                                                             :lines [6943
                                                                     6951]},
                                                    :full-name "cljs.core/PersistentHashMap.fromArray"},
           "cljs.core/run!" {:ns "cljs.core",
                             :name "run!",
                             :signature ["[proc coll]"],
                             :history [["+" "0.0-2301"]],
                             :type "function",
                             :full-name-encode "cljs.core/runBANG",
                             :source {:code "(defn run!\n  [proc coll]\n  (reduce #(proc %2) nil coll))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [9292 9296]},
                             :full-name "cljs.core/run!",
                             :clj-symbol "clojure.core/run!",
                             :docstring "Runs the supplied procedure (via reduce), for purposes of side\neffects, on successive items in the collection. Returns nil"},
           "cljs.repl.browser/es" {:ns "cljs.repl.browser",
                                   :name "es",
                                   :type "dynamic var",
                                   :source {:code "(def ^:dynamic es nil)",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/clojure/cljs/repl/browser.clj",
                                            :lines [26]},
                                   :full-name "cljs.repl.browser/es",
                                   :full-name-encode "cljs.repl.browser/es",
                                   :history [["+" "0.0-3148"]]},
           "cljs.core/IndexedSeqIterator" {:ns "cljs.core",
                                           :name "IndexedSeqIterator",
                                           :type "type",
                                           :signature ["[arr i]"],
                                           :source {:code "(deftype IndexedSeqIterator [arr ^:mutable i]\n  Object\n  (hasNext [_]\n    (< i (alength arr)))\n  (next [_]\n    (let [ret (aget arr i)]\n      (set! i (inc i))\n      ret)))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.7.228",
                                                    :filename "src/main/cljs/cljs/core.cljs",
                                                    :lines [1376 1383]},
                                           :full-name "cljs.core/IndexedSeqIterator",
                                           :full-name-encode "cljs.core/IndexedSeqIterator",
                                           :history [["+" "0.0-2371"]]},
           "cljs.core/unchecked-inc-int" {:ns "cljs.core",
                                          :name "unchecked-inc-int",
                                          :signature ["[x]"],
                                          :history [["+" "0.0-1798"]],
                                          :type "function/macro",
                                          :full-name-encode "cljs.core/unchecked-inc-int",
                                          :source {:code "(defn unchecked-inc-int [x]\n  (cljs.core/unchecked-inc-int x))",
                                                   :title "Function code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/cljs/cljs/core.cljs",
                                                   :lines [2410 2411]},
                                          :extra-sources [{:code "(core/defmacro ^::ana/numeric unchecked-inc-int\n  ([x] `(inc ~x)))",
                                                           :title "Macro code",
                                                           :repo "clojurescript",
                                                           :tag "r1.7.228",
                                                           :filename "src/main/clojure/cljs/core.cljc",
                                                           :lines [992
                                                                   993]}],
                                          :full-name "cljs.core/unchecked-inc-int",
                                          :clj-symbol "clojure.core/unchecked-inc-int"},
           "cljs.test/testing-vars-str" {:ns "cljs.test",
                                         :name "testing-vars-str",
                                         :signature ["[m]"],
                                         :history [["+" "0.0-2496"]],
                                         :type "function",
                                         :full-name-encode "cljs.test/testing-vars-str",
                                         :source {:code "(defn testing-vars-str\n  [m]\n  (let [{:keys [file line column]} m]\n    (str\n      (reverse (map #(:name (meta %)) (:testing-vars (get-current-env))))\n      \" (\" file \":\" line (when column (str \":\" column)) \")\")))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.7.228",
                                                  :filename "src/main/cljs/cljs/test.cljs",
                                                  :lines [289 297]},
                                         :full-name "cljs.test/testing-vars-str",
                                         :clj-symbol "clojure.test/testing-vars-str",
                                         :docstring "Returns a string representation of the current test.  Renders names\nin *testing-vars* as a list, then the source file and line of\ncurrent assertion."},
           "clojure.zip/rightmost" {:ns "clojure.zip",
                                    :name "rightmost",
                                    :signature ["[loc]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "clojure.zip/rightmost",
                                    :source {:code "(defn rightmost\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (if (and path r)\n        (with-meta [(last r) (assoc path :l (apply conj l node (butlast r)) :r nil)] (meta loc))\n        loc)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/clojure/zip.cljs",
                                             :lines [142 148]},
                                    :full-name "clojure.zip/rightmost",
                                    :clj-symbol "clojure.zip/rightmost",
                                    :docstring "Returns the loc of the rightmost sibling of the node at this loc, or self"},
           "cljs.core/PersistentArrayMap.EMPTY" {:ns "cljs.core",
                                                 :name "PersistentArrayMap.EMPTY",
                                                 :history [["+"
                                                            "0.0-1211"]],
                                                 :parent-type "PersistentArrayMap",
                                                 :type "var",
                                                 :full-name-encode "cljs.core/PersistentArrayMapDOTEMPTY",
                                                 :source {:code "(set! (.-EMPTY PersistentArrayMap) (PersistentArrayMap. nil 0 (array) empty-unordered-hash))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r1.7.228",
                                                          :filename "src/main/cljs/cljs/core.cljs",
                                                          :lines [6005]},
                                                 :full-name "cljs.core/PersistentArrayMap.EMPTY",
                                                 :clj-symbol "clojure.lang/PersistentArrayMap.EMPTY"},
           "cljs.core/m3-C2" {:ns "cljs.core",
                              :name "m3-C2",
                              :type "var",
                              :source {:code "(def m3-C2 (int 0x1b873593))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [798]},
                              :full-name "cljs.core/m3-C2",
                              :full-name-encode "cljs.core/m3-C2",
                              :history [["+" "0.0-2261"]]},
           "cljs.repl.server/read-request" {:ns "cljs.repl.server",
                                            :name "read-request",
                                            :type "function",
                                            :signature ["[rdr]"],
                                            :source {:code "(defn read-request [rdr]\n  (if-let [line (.readLine rdr)]\n    (cond\n      (.startsWith line \"POST\") (read-post line rdr)\n      (.startsWith line \"GET\") (read-get line rdr)\n      :else {:method :unknown :content line})\n    {:method :unknown :content nil}))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.7.228",
                                                     :filename "src/main/clojure/cljs/repl/server.clj",
                                                     :lines [92 98]},
                                            :full-name "cljs.repl.server/read-request",
                                            :full-name-encode "cljs.repl.server/read-request",
                                            :history [["+" "0.0-1503"]]},
           "cljs.test/compose-fixtures" {:ns "cljs.test",
                                         :name "compose-fixtures",
                                         :signature ["[f1 f2]"],
                                         :history [["+" "0.0-2496"]],
                                         :type "function",
                                         :full-name-encode "cljs.test/compose-fixtures",
                                         :source {:code "(defn compose-fixtures\n  [f1 f2]\n  (fn [g] (f1 (fn [] (f2 g)))))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.7.228",
                                                  :filename "src/main/cljs/cljs/test.cljs",
                                                  :lines [496 502]},
                                         :full-name "cljs.test/compose-fixtures",
                                         :clj-symbol "clojure.test/compose-fixtures",
                                         :docstring "Composes two fixture functions, creating a new fixture function\nthat combines their behavior.\n\nNOTE: Incompatible with map fixtures."},
           "cljs.repl/load-file" {:ns "cljs.repl",
                                  :name "load-file",
                                  :type "function",
                                  :signature ["[repl-env f]"
                                              "[repl-env f opts]"],
                                  :source {:code "(defn load-file\n  ([repl-env f] (load-file repl-env f *repl-opts*))\n  ([repl-env f opts]\n    (if (:output-dir opts)\n      (let [src (cond\n                  (util/url? f) f\n                  (.exists (io/file f)) (io/file f)\n                  :else (io/resource f))\n            compiled (binding [ana/*reload-macros* true]\n                       (cljsc/compile src\n                         (assoc opts\n                           :output-file (cljsc/src-file->target-file src)\n                           :force true\n                           :mode :interactive)))]\n        ;; copy over the original source file if source maps enabled\n        (when-let [ns (and (:source-map opts) (first (:provides compiled)))]\n          (spit\n            (io/file (io/file (util/output-directory opts))\n              (util/ns->relpath ns (util/ext (:source-url compiled))))\n            (slurp src)))\n        ;; need to load dependencies first\n        (load-dependencies repl-env (:requires compiled) opts)\n        (-evaluate repl-env f 1 (cljsc/add-dep-string opts compiled))\n        (-evaluate repl-env f 1\n          (cljsc/src-file->goog-require src\n            {:wrap true :reload true :macros-ns (:macros-ns compiled)})))\n      (binding [ana/*cljs-ns* ana/*cljs-ns*]\n        (let [res (if (= File/separatorChar (first f)) f (io/resource f))]\n          (assert res (str \"Can't find \" f \" in classpath\"))\n          (load-stream repl-env f res))))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/clojure/cljs/repl.cljc",
                                           :lines [506 535]},
                                  :full-name "cljs.repl/load-file",
                                  :full-name-encode "cljs.repl/load-file",
                                  :history [["+" "0.0-927"]]},
           "cljs.core/unchecked-subtract" {:return-type number,
                                           :ns "cljs.core",
                                           :name "unchecked-subtract",
                                           :signature ["[x]"
                                                       "[x y]"
                                                       "[x y & more]"],
                                           :history [["+" "0.0-1798"]],
                                           :type "function/macro",
                                           :full-name-encode "cljs.core/unchecked-subtract",
                                           :source {:code "(defn ^number unchecked-subtract\n  ([x] (cljs.core/unchecked-subtract x))\n  ([x y] (cljs.core/unchecked-subtract x y))\n  ([x y & more] (reduce unchecked-subtract (cljs.core/unchecked-subtract x y) more)))",
                                                    :title "Function code",
                                                    :repo "clojurescript",
                                                    :tag "r1.7.228",
                                                    :filename "src/main/cljs/cljs/core.cljs",
                                                    :lines [2438 2443]},
                                           :extra-sources [{:code "(core/defmacro ^::ana/numeric unchecked-subtract\n  ([& xs] `(- ~@xs)))",
                                                            :title "Macro code",
                                                            :repo "clojurescript",
                                                            :tag "r1.7.228",
                                                            :filename "src/main/clojure/cljs/core.cljc",
                                                            :lines [1010
                                                                    1011]}],
                                           :full-name "cljs.core/unchecked-subtract",
                                           :clj-symbol "clojure.core/unchecked-subtract",
                                           :docstring "If no ys are supplied, returns the negation of x, else subtracts\nthe ys from x and returns the result."},
           "cljs.repl/IParseErrorMessage" {:ns "cljs.repl",
                                           :name "IParseErrorMessage",
                                           :history [["+" "0.0-2985"]
                                                     ["-" "0.0-3030"]],
                                           :type "protocol",
                                           :full-name-encode "cljs.repl/IParseErrorMessage",
                                           :source {:code "(defprotocol IParseErrorMessage\n  (-parse-error-message [repl-env message error build-options]\n    \"Given the original JavaScript error message return the string to actually\n     use.\"))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2985",
                                                    :filename "src/clj/cljs/repl.clj",
                                                    :lines [112 115]},
                                           :methods [{:name "-parse-error-message",
                                                      :signature ["[repl-env message error build-options]"],
                                                      :docstring "Given the original JavaScript error message return the string to actually\n     use."}],
                                           :full-name "cljs.repl/IParseErrorMessage",
                                           :removed {:in "0.0-3030",
                                                     :last-seen "0.0-2985"}},
           "cljs.js/load-macros" {:ns "cljs.js",
                                  :name "load-macros",
                                  :signature ["[bound-vars k macros reload reloads opts cb]"],
                                  :history [["+" "1.7.10"]
                                            ["-" "1.7.28"]],
                                  :type "function",
                                  :full-name-encode "cljs.js/load-macros",
                                  :source {:code "(defn load-macros [bound-vars k macros reload reloads opts cb]\n  (if (seq macros)\n    (let [nsym (first (vals macros))\n          k    (or (k reload)\n                   (get-in reloads [k nsym])\n                   (and (= nsym name) (:*reload-macros* bound-vars) :reload))]\n      (require bound-vars nsym k\n        (-> opts\n          (assoc :macros-ns true)\n          (dissoc :context)\n          (dissoc :ns))\n        (fn [res]\n          (if-not (:error res)\n            (load-macros bound-vars k (next macros) reload reloads opts cb)\n            (cb res)))))\n    (cb {:value nil})))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.10",
                                           :filename "src/main/cljs/cljs/js.cljs",
                                           :lines [300 315]},
                                  :full-name "cljs.js/load-macros",
                                  :removed {:in "1.7.28",
                                            :last-seen "1.7.10"}},
           "cljs.repl.nashorn/eval-str" {:ns "cljs.repl.nashorn",
                                         :name "eval-str",
                                         :type "function",
                                         :signature ["[engine s]"],
                                         :source {:code "(defn eval-str [^ScriptEngine engine ^String s]\n      (.eval engine s))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.7.228",
                                                  :filename "src/main/clojure/cljs/repl/nashorn.clj",
                                                  :lines [45 46]},
                                         :full-name "cljs.repl.nashorn/eval-str",
                                         :full-name-encode "cljs.repl.nashorn/eval-str",
                                         :history [["+" "0.0-2814"]]},
           "cljs.core/->" {:description "The thread-first macro \"threads\" an expression through several forms as the\nsecond item in a list.\n\nInserts `x` as the second item in the first form, making a list of it if it is\nnot a list already. If there are more forms, inserts the first form as the\nsecond item in second form, etc.\n\n<table class=\"code-tbl-9bef6\">\n  <thead>\n    <tr>\n      <th>Code</th>\n      <th>Expands To</th></tr></thead>\n  <tbody>\n    <tr>\n      <td><pre>\n(-> x\n  (a b c)\n  d\n  (x y z))</pre></td>\n      <td><pre>\n(x (d (a x b c)) y z)</pre></td></tr></tbody></table>",
                           :ns "cljs.core",
                           :name "->",
                           :signature ["[x & forms]"],
                           :history [["+" "0.0-927"]],
                           :type "macro",
                           :related ["cljs.core/->>"],
                           :full-name-encode "cljs.core/-GT",
                           :source {:code "(defmacro ->\n  [x & forms]\n  (loop [x x, forms forms]\n    (if forms\n      (let [form (first forms)\n            threaded (if (seq? form)\n                       (with-meta `(~(first form) ~x ~@(next form)) (meta form))\n                       (list form x))]\n        (recur threaded (next forms)))\n      x)))",
                                    :title "Source code",
                                    :repo "clojure",
                                    :tag "clojure-1.7.0",
                                    :filename "src/clj/clojure/core.clj",
                                    :lines [1564 1578]},
                           :examples [{:id "19b460",
                                       :content "The first is arguably a bit more cumbersome to read than the second:\n\n```clj\n(first (.split (.replace (.toUpperCase \"a b c d\") \"A\" \"X\") \" \"))\n;;=> \"X\"\n\n(-> \"a b c d\"\n    .toUpperCase\n    (.replace \"A\" \"X\")\n    (.split \" \")\n    first)\n;;=> \"X\"\n```"}
                                      {:id "78ad8f",
                                       :content "It can also be useful for pulling values out of deeply-nested\ndata structures:\n\n```clj\n(def person\n  {:name \"Mark Volkmann\"\n   :address {:street \"644 Glen Summit\"\n             :city \"St. Charles\"\n             :state \"Missouri\"\n             :zip 63304}\n   :employer {:name \"Object Computing, Inc.\"\n              :address {:street \"12140 Woodcrest Dr.\"\n                        :city \"Creve Coeur\"\n                        :state \"Missouri\"\n                        :zip 63141}}})\n\n(-> person :employer :address :city)\n;;=> \"Creve Coeur\"\n```\n\nSame as above, but with more nesting:\n\n```clj\n(:city (:address (:employer person)))\n;;=> \"Creve Coeur\"\n```"}
                                      {:id "5fe621",
                                       :content "It can also help with arithmetic:\n\n```clj\n(def c 5)\n(-> c (+ 3) (/ 2) (- 1))\n;;=> 3\n```\n\nSame as above, but with more nesting:\n\n```clj\n(- (/ (+ c 3) 2) 1)\n;;=> 3\n```"}],
                           :known-as "thread first",
                           :full-name "cljs.core/->",
                           :clj-symbol "clojure.core/->",
                           :docstring "Threads the expr through the forms. Inserts x as the\nsecond item in the first form, making a list of it if it is not a\nlist already. If there are more forms, inserts the first form as the\nsecond item in second form, etc."},
           "cljs.core/remove-all-methods" {:ns "cljs.core",
                                           :name "remove-all-methods",
                                           :signature ["[multifn]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core/remove-all-methods",
                                           :source {:code "(defn remove-all-methods\n [multifn]\n (-reset multifn))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.7.228",
                                                    :filename "src/main/cljs/cljs/core.cljs",
                                                    :lines [9800 9803]},
                                           :full-name "cljs.core/remove-all-methods",
                                           :clj-symbol "clojure.core/remove-all-methods",
                                           :docstring "Removes all of the methods of multimethod."},
           "cljs.core/unchecked-add-int" {:return-type number,
                                          :ns "cljs.core",
                                          :name "unchecked-add-int",
                                          :signature ["[]"
                                                      "[x]"
                                                      "[x y]"
                                                      "[x y & more]"],
                                          :history [["+" "0.0-1798"]],
                                          :type "function/macro",
                                          :full-name-encode "cljs.core/unchecked-add-int",
                                          :source {:code "(defn ^number unchecked-add-int\n  ([] 0)\n  ([x] x)\n  ([x y] (cljs.core/unchecked-add-int x y))\n  ([x y & more] (reduce unchecked-add-int (cljs.core/unchecked-add-int x y) more)))",
                                                   :title "Function code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/cljs/cljs/core.cljs",
                                                   :lines [2383 2388]},
                                          :extra-sources [{:code "(core/defmacro ^::ana/numeric unchecked-add-int\n  ([& xs] `(+ ~@xs)))",
                                                           :title "Macro code",
                                                           :repo "clojurescript",
                                                           :tag "r1.7.228",
                                                           :filename "src/main/clojure/cljs/core.cljc",
                                                           :lines [977
                                                                   978]}],
                                          :full-name "cljs.core/unchecked-add-int",
                                          :clj-symbol "clojure.core/unchecked-add-int",
                                          :docstring "Returns the sum of nums. (+) returns 0."},
           "clojure.string/replace-first" {:description "Replaces the first instance of `match` with `replacement` in `s`.\n\nThe options for match / replacement are:\n\n| match  | replacement |\n|--------|-------------|\n| string | string      |\n| regex  | string      |\n| regex  | function    |",
                                           :ns "clojure.string",
                                           :name "replace-first",
                                           :signature ["[s match replacement]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "clojure.string/replace-first",
                                           :source {:code "(defn replace-first\n  [s match replacement]\n  (.replace s match replacement))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.7.228",
                                                    :filename "src/main/cljs/clojure/string.cljs",
                                                    :lines [57 64]},
                                           :full-name "clojure.string/replace-first",
                                           :clj-symbol "clojure.string/replace-first",
                                           :docstring "Replaces the first instance of match with replacement in s.\nmatch/replacement can be:\n\nstring / string\npattern / (string or function of match)."},
           "cljs.core/reduced?" {:return-type boolean,
                                 :ns "cljs.core",
                                 :name "reduced?",
                                 :signature ["[r]"],
                                 :history [["+" "0.0-1211"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/reducedQMARK",
                                 :source {:code "(defn ^boolean reduced?\n  [r]\n  (instance? Reduced r))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [1277 1280]},
                                 :full-name "cljs.core/reduced?",
                                 :clj-symbol "clojure.core/reduced?",
                                 :docstring "Returns true if x is the result of a call to reduced"},
           "clojure.browser.dom/get-value" {:ns "clojure.browser.dom",
                                            :name "get-value",
                                            :signature ["[e]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "clojure.browser.dom/get-value",
                                            :source {:code "(defn get-value\n  [e]\n  (.-value (ensure-element e)))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.7.228",
                                                     :filename "src/main/cljs/clojure/browser/dom.cljs",
                                                     :lines [131 134]},
                                            :full-name "clojure.browser.dom/get-value",
                                            :docstring "Get the value of an element."},
           "clojure.core.reducers/CollFold" {:ns "clojure.core.reducers",
                                             :name "CollFold",
                                             :type "protocol",
                                             :full-name-encode "clojure.core.reducers/CollFold",
                                             :source {:code "(defprotocol CollFold\n  (coll-fold [coll n combinef reducef]))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.7.228",
                                                      :filename "src/main/cljs/clojure/core/reducers.cljs",
                                                      :lines [46 47]},
                                             :methods [{:name "coll-fold",
                                                        :signature ["[coll n combinef reducef]"],
                                                        :docstring nil}],
                                             :full-name "clojure.core.reducers/CollFold",
                                             :history [["+"
                                                        "0.0-2120"]]},
           "cljs.nodejs/process" {:ns "cljs.nodejs",
                                  :name "process",
                                  :type "var",
                                  :source {:code "(def process (js* \"process\"))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/nodejs.cljs",
                                           :lines [16]},
                                  :full-name "cljs.nodejs/process",
                                  :full-name-encode "cljs.nodejs/process",
                                  :history [["+" "0.0-927"]]},
           "cljs.core/some->>" {:description "When `expr` is not nil, threads it into the first form (via `->>`), and when\nthat result is not nil, through the next, etc.",
                                :ns "cljs.core",
                                :name "some->>",
                                :signature ["[expr & forms]"],
                                :history [["+" "0.0-1798"]],
                                :type "macro",
                                :related ["cljs.core/->"
                                          "cljs.core/->>"
                                          "cljs.core/some->"
                                          "cljs.core/some"],
                                :full-name-encode "cljs.core/some-GTGT",
                                :source {:code "(defmacro some->>\n  [expr & forms]\n  (let [g (gensym)\n        pstep (fn [step] `(if (nil? ~g) nil (->> ~g ~step)))]\n    `(let [~g ~expr\n           ~@(interleave (repeat g) (map pstep forms))]\n       ~g)))",
                                         :title "Source code",
                                         :repo "clojure",
                                         :tag "clojure-1.7.0",
                                         :filename "src/clj/clojure/core.clj",
                                         :lines [7282 7291]},
                                :full-name "cljs.core/some->>",
                                :clj-symbol "clojure.core/some->>",
                                :docstring "When expr is not nil, threads it into the first form (via ->>),\nand when that result is not nil, through the next etc"},
           "cljs.core/unchecked-inc" {:ns "cljs.core",
                                      :name "unchecked-inc",
                                      :signature ["[x]"],
                                      :history [["+" "0.0-1798"]],
                                      :type "function/macro",
                                      :full-name-encode "cljs.core/unchecked-inc",
                                      :source {:code "(defn unchecked-inc [x]\n  (cljs.core/unchecked-inc x))",
                                               :title "Function code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [2407 2408]},
                                      :extra-sources [{:code "(core/defmacro ^::ana/numeric unchecked-inc\n  ([x] `(inc ~x)))",
                                                       :title "Macro code",
                                                       :repo "clojurescript",
                                                       :tag "r1.7.228",
                                                       :filename "src/main/clojure/cljs/core.cljc",
                                                       :lines [989
                                                               990]}],
                                      :full-name "cljs.core/unchecked-inc",
                                      :clj-symbol "clojure.core/unchecked-inc"},
           "cljs.core/not=" {:description "Returns the opposite of `=`.\n\nSame as `(not (= x y))`",
                             :return-type boolean,
                             :ns "cljs.core",
                             :name "not=",
                             :signature ["[x]" "[x y]" "[x y & more]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/=" "cljs.core/not"],
                             :full-name-encode "cljs.core/notEQ",
                             :source {:code "(defn ^boolean not=\n  ([x] false)\n  ([x y] (not (= x y)))\n  ([x y & more]\n   (not (apply = x y more))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [3510 3515]},
                             :full-name "cljs.core/not=",
                             :clj-symbol "clojure.core/not=",
                             :docstring "Same as (not (= obj1 obj2))"},
           "cljs.core/unchecked-subtract-int" {:return-type number,
                                               :ns "cljs.core",
                                               :name "unchecked-subtract-int",
                                               :signature ["[x]"
                                                           "[x y]"
                                                           "[x y & more]"],
                                               :history [["+"
                                                          "0.0-1798"]],
                                               :type "function/macro",
                                               :full-name-encode "cljs.core/unchecked-subtract-int",
                                               :source {:code "(defn ^number unchecked-subtract-int\n  ([x] (cljs.core/unchecked-subtract-int x))\n  ([x y] (cljs.core/unchecked-subtract-int x y))\n  ([x y & more] (reduce unchecked-subtract-int (cljs.core/unchecked-subtract-int x y) more)))",
                                                        :title "Function code",
                                                        :repo "clojurescript",
                                                        :tag "r1.7.228",
                                                        :filename "src/main/cljs/cljs/core.cljs",
                                                        :lines [2445
                                                                2450]},
                                               :extra-sources [{:code "(core/defmacro ^::ana/numeric unchecked-subtract-int\n  ([& xs] `(- ~@xs)))",
                                                                :title "Macro code",
                                                                :repo "clojurescript",
                                                                :tag "r1.7.228",
                                                                :filename "src/main/clojure/cljs/core.cljc",
                                                                :lines [1013
                                                                        1014]}],
                                               :full-name "cljs.core/unchecked-subtract-int",
                                               :clj-symbol "clojure.core/unchecked-subtract-int",
                                               :docstring "If no ys are supplied, returns the negation of x, else subtracts\nthe ys from x and returns the result."},
           "cljs.core/ex-data" {:ns "cljs.core",
                                :name "ex-data",
                                :signature ["[ex]"],
                                :history [["+" "0.0-1576"]],
                                :type "function",
                                :full-name-encode "cljs.core/ex-data",
                                :source {:code "(defn ex-data\n  [ex]\n  (when (instance? ExceptionInfo ex)\n    (.-data ex)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [9928 9933]},
                                :full-name "cljs.core/ex-data",
                                :clj-symbol "clojure.core/ex-data",
                                :docstring "Returns exception data (a map) if ex is an ExceptionInfo.\nOtherwise returns nil."},
           "cljs.core/PersistentTreeMapSeq" {:ns "cljs.core",
                                             :name "PersistentTreeMapSeq",
                                             :type "type",
                                             :signature ["[meta stack ascending? cnt __hash]"],
                                             :source {:code "(deftype PersistentTreeMapSeq [meta stack ^boolean ascending? cnt ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  ISeqable\n  (-seq [this] this)\n\n  ISequential\n  ISeq\n  (-first [this] (peek stack))\n  (-rest [this]\n    (let [t (first stack)\n          next-stack (tree-map-seq-push (if ascending? (.-right t) (.-left t))\n                                        (next stack)\n                                        ascending?)]\n      (if-not (nil? next-stack)\n        (PersistentTreeMapSeq. nil next-stack ascending? (dec cnt) nil)\n        ())))\n\n  ICounted\n  (-count [coll]\n    (if (neg? cnt)\n      (inc (count (next coll)))\n      cnt))\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY List) meta))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IWithMeta\n  (-with-meta [coll meta]\n    (PersistentTreeMapSeq. meta stack ascending? cnt __hash))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.7.228",
                                                      :filename "src/main/cljs/cljs/core.cljs",
                                                      :lines [7075
                                                              7124]},
                                             :full-name "cljs.core/PersistentTreeMapSeq",
                                             :full-name-encode "cljs.core/PersistentTreeMapSeq",
                                             :history [["+"
                                                        "0.0-1211"]]},
           "cljs.core/js-keys" {:description "Returns the keys for the JavaScript object `obj`.",
                                :ns "cljs.core",
                                :name "js-keys",
                                :signature ["[obj]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/keys"],
                                :full-name-encode "cljs.core/js-keys",
                                :source {:code "(defn js-keys\n  [obj]\n  (let [keys (array)]\n    (gobject/forEach obj (fn [val key obj] (.push keys key)))\n    keys))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [1950 1955]},
                                :examples [{:id "5dd933",
                                            :content "```clj\n(js-keys #js {:foo 1 :bar 2})\n;;=> #js [\"foo\" \"bar\"]\n```"}],
                                :full-name "cljs.core/js-keys",
                                :docstring "Return the JavaScript keys for an object."},
           "cljs.repl.browser/browser-eval" {:ns "cljs.repl.browser",
                                             :name "browser-eval",
                                             :signature ["[form]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.repl.browser/browser-eval",
                                             :source {:code "(defn browser-eval\n  [form]\n  (let [return-value (promise)]\n    (send-for-eval form\n      (fn [val] (deliver return-value val)))\n    (let [ret @return-value]\n      (try\n        (read-string ret)\n        (catch Exception e\n          {:status :error\n           :value (str \"Could not read return value: \" ret)})))))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.7.228",
                                                      :filename "src/main/clojure/cljs/repl/browser.clj",
                                                      :lines [184 200]},
                                             :full-name "cljs.repl.browser/browser-eval",
                                             :docstring "Given a string of JavaScript, evaluate it in the browser and return a map representing the\nresult of the evaluation. The map will contain the keys :type and :value. :type can be\n:success, :exception, or :error. :success means that the JavaScript was evaluated without\nexception and :value will contain the return value of the evaluation. :exception means that\nthere was an exception in the browser while evaluating the JavaScript and :value will\ncontain the error message. :error means that some other error has occured."},
           "clojure.zip/seq-zip" {:ns "clojure.zip",
                                  :name "seq-zip",
                                  :signature ["[root]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.zip/seq-zip",
                                  :source {:code "(defn seq-zip\n  [root]\n    (zipper seq?\n            identity\n            (fn [node children] (with-meta children (meta node)))\n            root))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/clojure/zip.cljs",
                                           :lines [34 40]},
                                  :full-name "clojure.zip/seq-zip",
                                  :clj-symbol "clojure.zip/seq-zip",
                                  :docstring "Returns a zipper for nested sequences, given a root sequence"},
           "cljs.core/lazy-transformer" {:ns "cljs.core",
                                         :name "lazy-transformer",
                                         :type "function",
                                         :signature ["[stepper]"],
                                         :source {:code "(defn lazy-transformer [stepper]\n  (LazyTransformer. stepper nil nil nil))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.7.228",
                                                  :filename "src/main/cljs/cljs/core.cljs",
                                                  :lines [3587 3588]},
                                         :full-name "cljs.core/lazy-transformer",
                                         :full-name-encode "cljs.core/lazy-transformer",
                                         :history [["+" "0.0-2301"]]},
           "cljs.repl.browser/server-state" {:ns "cljs.repl.browser",
                                             :name "server-state",
                                             :type "var",
                                             :source {:code "(defonce server-state (atom {:socket nil\n                             :connection nil\n                             :promised-conn nil\n                             :return-value-fn nil\n                             :client-js nil}))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1450",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [24 28]},
                                             :full-name "cljs.repl.browser/server-state",
                                             :full-name-encode "cljs.repl.browser/server-state",
                                             :history [["+" "0.0-927"]
                                                       ["-"
                                                        "0.0-1503"]],
                                             :removed {:in "0.0-1503",
                                                       :last-seen "0.0-1450"},
                                             :moved "cljs.repl.server/state"},
           "cljs.core/random-sample" {:ns "cljs.core",
                                      :name "random-sample",
                                      :signature ["[prob]"
                                                  "[prob coll]"],
                                      :history [["+" "0.0-2301"]],
                                      :type "function",
                                      :full-name-encode "cljs.core/random-sample",
                                      :source {:code "(defn random-sample\n  ([prob]\n     (filter (fn [_] (< (rand) prob))))\n  ([prob coll]\n     (filter (fn [_] (< (rand) prob)) coll)))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [9259 9265]},
                                      :full-name "cljs.core/random-sample",
                                      :clj-symbol "clojure.core/random-sample",
                                      :docstring "Returns items from coll with random probability of prob (0.0 -\n1.0).  Returns a transducer when no collection is provided."},
           "cljs.core/IVector" {:ns "cljs.core",
                                :name "IVector",
                                :history [["+" "0.0-927"]],
                                :type "protocol",
                                :full-name-encode "cljs.core/IVector",
                                :source {:code "(defprotocol IVector\n  \"Protocol for adding vector functionality to collections.\"\n  (^clj -assoc-n [coll n val]\n    \"Returns a new vector with value val added at position n.\"))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [552 555]},
                                :methods [{:name "-assoc-n",
                                           :signature ["[coll n val]"],
                                           :docstring "Returns a new vector with value val added at position n."}],
                                :full-name "cljs.core/IVector",
                                :clj-symbol "clojure.lang/IPersistentVector",
                                :docstring "Protocol for adding vector functionality to collections."},
           "cljs.core/iter" {:ns "cljs.core",
                             :name "iter",
                             :type "function",
                             :signature ["[coll]"],
                             :source {:code "(defn iter [coll]\n  (cond\n    (nil? coll) (nil-iter)\n    (string? coll) (string-iter coll)\n    (array? coll) (array-iter coll)\n    (iterable? coll) (-iterator coll)\n    (seqable? coll) (seq-iter coll)\n    :else (throw (js/Error. (str \"Cannot create iterator from \" coll)))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [3576 3583]},
                             :full-name "cljs.core/iter",
                             :full-name-encode "cljs.core/iter",
                             :history [["+" "0.0-2301"]]},
           "cljs.core/persistent!" {:ns "cljs.core",
                                    :name "persistent!",
                                    :signature ["[tcoll]"],
                                    :history [["+" "0.0-1211"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/persistentBANG",
                                    :source {:code "(defn persistent!\n  [tcoll]\n  (-persistent! tcoll))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [3380 3385]},
                                    :full-name "cljs.core/persistent!",
                                    :clj-symbol "clojure.core/persistent!",
                                    :docstring "Returns a new, persistent version of the transient collection, in\nconstant time. The transient collection cannot be used after this\ncall, any such use will throw an exception."},
           "cljs.core/empty" {:description "Returns an empty collection of the same category as `coll`.\n\nReturns nil if `coll` is nil.",
                              :ns "cljs.core",
                              :name "empty",
                              :signature ["[coll]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/not-empty"],
                              :full-name-encode "cljs.core/empty",
                              :source {:code "(defn empty\n  [coll]\n  (when-not (nil? coll)\n    (-empty coll)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [1582 1586]},
                              :full-name "cljs.core/empty",
                              :clj-symbol "clojure.core/empty",
                              :docstring "Returns an empty collection of the same category as coll, or nil"},
           "cljs.core/re-matches" {:description "Returns the result of `(re-find re s)` if `re` fully matches `s`.",
                                   :ns "cljs.core",
                                   :name "re-matches",
                                   :signature ["[re s]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/re-matches",
                                   :source {:code "(defn re-matches\n  [re s]\n  (if (string? s)\n    (let [matches (.exec re s)]\n      (when (= (first matches) s)\n        (if (== (count matches) 1)\n          (first matches)\n          (vec matches))))\n    (throw (js/TypeError. \"re-matches must match against a string.\"))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [8698 8707]},
                                   :full-name "cljs.core/re-matches",
                                   :clj-symbol "clojure.core/re-matches",
                                   :docstring "Returns the result of (re-find re s) if re fully matches s."},
           "syntax/meta" {:description "Attaches metadata to the following form.  Metadata can only be attached to a\nsymbol or collection.\n\nMetadata will assume the following transformations depending on its type:\n\n- keyword `^:foo` => `^{:foo true}`\n- string `^\"foo\"` => `^{:tag \"foo\"}`\n- symbol `^foo` => `^{:tag <value of foo>}`",
                          :ns "syntax",
                          :name "meta",
                          :history [["+" "0.0-927"]],
                          :type "syntax",
                          :related ["cljs.core/meta"
                                    "cljs.core/with-meta"
                                    "cljs.core/vary-meta"
                                    "cljs.core/alter-meta!"],
                          :full-name-encode "syntax/meta",
                          :extra-sources ({:code "(defn- read-meta\n  [rdr _ opts pending-forms]\n  (log-source rdr\n    (let [[line column] (starting-line-col-info rdr)\n          m (desugar-meta (read* rdr true nil opts pending-forms))]\n      (when-not (map? m)\n        (reader-error rdr \"Metadata must be Symbol, Keyword, String or Map\"))\n      (let [o (read* rdr true nil opts pending-forms)]\n        (if (instance? IMeta o)\n          (let [m (if (and line (seq? o))\n                    (assoc m :line line :column column)\n                    m)]\n            (if (instance? IObj o)\n              (with-meta o (merge (meta o) m))\n              (reset-meta! o m)))\n          (reader-error rdr \"Metadata can only be applied to IMetas\"))))))",
                                           :title "Reader code",
                                           :repo "tools.reader",
                                           :tag "tools.reader-1.0.0-alpha1",
                                           :filename "src/main/clojure/clojure/tools/reader.clj",
                                           :lines [369 385]}
                                          {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                           :title "Reader table",
                                           :repo "tools.reader",
                                           :tag "tools.reader-1.0.0-alpha1",
                                           :filename "src/main/clojure/clojure/tools/reader.clj",
                                           :lines [743 762]}),
                          :usage ["^{...}" "^:foo" "^\"foo\"" "^foo"],
                          :examples [{:id "5b8fec",
                                      :content "Attach metadata to a collection:\n\n```clj\n^:foo [1 2 3]\n;;=> [1 2 3]\n```\n\nView the resulting metadata:\n\n```clj\n(meta ^:foo [1 2 3])\n;;=> {:foo true}\n\n(meta ^{:foo \"bar\"} [1 2 3])\n;;=> {:foo \"bar\"}\n\n(meta ^\"foo\" [1 2 3])\n;;=> {:tag \"foo\"}\n\n(def foo 1)\n(meta ^foo [1 2 3])\n;;=> {:tag 1}\n```\n\nChain metadata:\n\n```clj\n(meta ^:foo ^\"foo\" [1 2 3])\n;;=> {:foo true, :tag \"foo\"}\n```"}],
                          :full-name "syntax/meta",
                          :display "^ meta",
                          :clj-doc "http://clojure.org/reader#toc2"},
           "clojure.browser.dom/DOMBuilder" {:ns "clojure.browser.dom",
                                             :name "DOMBuilder",
                                             :type "protocol",
                                             :full-name-encode "clojure.browser.dom/DOMBuilder",
                                             :source {:code "(defprotocol DOMBuilder\n  (-element [this] [this attrs-or-children] [this attrs children]))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.7.228",
                                                      :filename "src/main/cljs/clojure/browser/dom.cljs",
                                                      :lines [17 18]},
                                             :methods [{:name "-element",
                                                        :signature ["[this]"
                                                                    "[this attrs-or-children]"
                                                                    "[this attrs children]"],
                                                        :docstring nil}],
                                             :full-name "clojure.browser.dom/DOMBuilder",
                                             :history [["+" "0.0-927"]]},
           "syntax/regex" {:description "Signifies a regular expression. Represented as native [JavaScript regular expressions].\n\n[JavaScript regular expressions]:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions\n\nAn inline modifier can be included at the beginning of the regex:\n\n|  modifier          | ClojureScript | JavaScript |\n|--------------------|---------------|------------|\n|  global match      | N/A           | `/foo/g`   |\n|  case-insensitive  | `#\"(?i)foo\"`  | `/foo/i`   |\n|  multi-line        | `#\"(?m)f.*o\"` | `/f.*o/m`  |\n\nGlobal matches (i.e. multiple matches per line) can be achieved using `re-seq`.",
                           :ns "syntax",
                           :name "regex",
                           :history [["+" "0.0-927"]],
                           :type "syntax",
                           :related ["cljs.core/re-pattern"
                                     "cljs.core/re-find"
                                     "cljs.core/re-seq"
                                     "cljs.core/re-matches"],
                           :full-name-encode "syntax/regex",
                           :extra-sources ({:code "(defn read-regex\n  [rdr ch opts pending-forms]\n  (let [sb (StringBuilder.)]\n    (loop [ch (read-char rdr)]\n      (if (identical? \\\" ch)\n        (Pattern/compile (str sb))\n        (if (nil? ch)\n          (reader-error rdr \"EOF while reading regex\")\n          (do\n            (.append sb ch )\n            (when (identical? \\\\ ch)\n              (let [ch (read-char rdr)]\n                (if (nil? ch)\n                  (reader-error rdr \"EOF while reading regex\"))\n                (.append sb ch)))\n            (recur (read-char rdr))))))))",
                                            :title "Reader code",
                                            :repo "tools.reader",
                                            :tag "tools.reader-1.0.0-alpha1",
                                            :filename "src/main/clojure/clojure/tools/reader.clj",
                                            :lines [82 97]}
                                           {:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    \\? read-cond\n    nil))",
                                            :title "Reader table",
                                            :repo "tools.reader",
                                            :tag "tools.reader-1.0.0-alpha1",
                                            :filename "src/main/clojure/clojure/tools/reader.clj",
                                            :lines [764 776]}),
                           :usage ["#\"...\""],
                           :examples [{:id "dacf80",
                                       :content "```clj\n#\"foo\"\n;;=> #\"foo\"\n\n(re-seq #\"foo\" \"FOO BAR foo bar\")\n;;=> (\"foo\")\n```\n\nCase-insensitive matching:\n\n```clj\n#\"(?i)foo\"\n;;=> #\"foo\"\n\n(re-seq #\"(?i)foo\" \"FOO BAR foo bar\")\n;;=> (\"FOO\" \"foo\")\n```"}],
                           :full-name "syntax/regex",
                           :display "#\"\" regex",
                           :clj-doc "http://clojure.org/reader#toc2"},
           "cljs.core/extend-type" {:description "Extend a [type] to implement one or more [protocols].\n\n`type-sym` can be the result of a [doc:cljs.core/deftype] or any JS constructor\nfunction (e.g. `js/Date`).  But when targetting JS base types (e.g.\n`js/Number`, `js/String`), you must use special _type symbols_ instead.  These\ntype symbols are associated with type strings deduced by [`goog/typeOf`]:\n\n| type symbol  | corresponding `goog/typeOf` value |\n|--------------|-------------|\n| `nil`        | `\"null\"` |\n| `object`     | `\"object\"` |\n| `string`     | `\"string\"` |\n| `number`     | `\"number\"` |\n| `array`      | `\"array\"` |\n| `function`   | `\"function\"` |\n| `boolean`    | `\"boolean\"` |\n\n`type-sym` can also be specified as `default` in order to provide default\nimplementations for protocols.\n\n[`goog/typeOf`]:http://google.github.io/closure-library/api/namespace_goog.html#typeOf",
                                    :ns "cljs.core",
                                    :name "extend-type",
                                    :signature ["[type-sym & impls]"],
                                    :history [["+" "0.0-927"]],
                                    :type "macro",
                                    :related ["cljs.core/extend-protocol"],
                                    :full-name-encode "cljs.core/extend-type",
                                    :source {:code "(core/defmacro extend-type\n  [type-sym & impls]\n  (core/let [env &env\n             _ (validate-impls env impls)\n             resolve (partial resolve-var env)\n             impl-map (->impl-map impls)\n             [type assign-impls] (core/if-let [type (base-type type-sym)]\n                                   [type base-assign-impls]\n                                   [(resolve type-sym) proto-assign-impls])]\n    (core/when (core/and (:extending-base-js-type cljs.analyzer/*cljs-warnings*)\n            (js-base-type type-sym))\n      (cljs.analyzer/warning :extending-base-js-type env\n        {:current-symbol type-sym :suggested-symbol (js-base-type type-sym)}))\n    `(do ~@(mapcat #(assign-impls env resolve type-sym type %) impl-map))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/clojure/cljs/core.cljc",
                                             :lines [1485 1508]},
                                    :full-name "cljs.core/extend-type",
                                    :clj-symbol "clojure.core/extend-type",
                                    :docstring "Extend a type to a series of protocols. Useful when you are\n supplying the definitions explicitly inline. Propagates the\n type as a type hint on the first argument of all fns.\n\n(extend-type MyType\n  ICounted\n  (-count [c] ...)\n  Foo\n  (bar [x y] ...)\n  (baz ([x] ...) ([x y & zs] ...))"},
           "cljs.core/ISeqable" {:ns "cljs.core",
                                 :name "ISeqable",
                                 :history [["+" "0.0-927"]],
                                 :type "protocol",
                                 :full-name-encode "cljs.core/ISeqable",
                                 :source {:code "(defprotocol ISeqable\n  \"Protocol for adding the ability to a type to be transformed into a sequence.\"\n  (^clj-or-nil -seq [o]\n    \"Returns a seq of o, or nil if o is empty.\"))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [600 603]},
                                 :methods [{:name "-seq",
                                            :signature ["[o]"],
                                            :docstring "Returns a seq of o, or nil if o is empty."}],
                                 :full-name "cljs.core/ISeqable",
                                 :clj-symbol "clojure.lang/Seqable",
                                 :docstring "Protocol for adding the ability to a type to be transformed into a sequence."},
           "cljs.core/assoc" {:description "assoc(iate)\n\nWhen applied to a map, returns a new map that contains the mapping of key(s) to\nval(s).\n\nHas no effect on the map type (hashed/sorted).\n\nWhen applied to a vector, returns a new vector that contains value `v` at index\n`k`.",
                              :ns "cljs.core",
                              :name "assoc",
                              :signature ["[coll k v]"
                                          "[coll k v & kvs]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/assoc-in"
                                        "cljs.core/dissoc"
                                        "cljs.core/merge"],
                              :full-name-encode "cljs.core/assoc",
                              :source {:code "(defn assoc\n  ([coll k v]\n    (if-not (nil? coll)\n      (-assoc coll k v)\n      (hash-map k v)))\n  ([coll k v & kvs]\n     (let [ret (assoc coll k v)]\n       (if kvs\n         (recur ret (first kvs) (second kvs) (nnext kvs))\n         ret))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [1751 1764]},
                              :examples [{:id "2fa7e0",
                                          :content "```clj\n(def my-map {:foo 1})\n\n(assoc my-map :foo 2)\n;;=> {:foo 2}\n\n(assoc my-map :bar 2)\n;;=> {:foo 1 :bar 2}\n\n(assoc my-map :a 3 :b 4 :c 5 :d 6)\n;;=> {:foo 1 :a 3 :b 4 :c 5 :d 6}\n\n;; you must pass a value for every key\n(assoc my-map :foo)\n;;=> WARNING: Wrong number of args (2) passed to cljs.core/assoc\n```"}
                                         {:id "c06eac",
                                          :content "```clj\n(def my-vec [1 2 3])\n\n(assoc my-vec 0 \"foo\")\n;;=> [\"foo\" 2 3]\n\n(assoc my-vec 3 \"foo\")\n;;=> Error: Index 3 out of bounds  [0,0]\n```"}],
                              :known-as "associate",
                              :full-name "cljs.core/assoc",
                              :clj-symbol "clojure.core/assoc",
                              :docstring "assoc[iate]. When applied to a map, returns a new map of the\nsame (hashed/sorted) type, that contains the mapping of key(s) to\nval(s). When applied to a vector, returns a new vector that\ncontains val at index."},
           "clojure.browser.repl/xpc-connection" {:ns "clojure.browser.repl",
                                                  :name "xpc-connection",
                                                  :type "var",
                                                  :source {:code "(def xpc-connection (atom nil))",
                                                           :title "Source code",
                                                           :repo "clojurescript",
                                                           :tag "r1.7.228",
                                                           :filename "src/main/cljs/clojure/browser/repl.cljs",
                                                           :lines [30]},
                                                  :full-name "clojure.browser.repl/xpc-connection",
                                                  :full-name-encode "clojure.browser.repl/xpc-connection",
                                                  :history [["+"
                                                             "0.0-927"]]},
           "cljs.core/IDerefWithTimeout" {:ns "cljs.core",
                                          :name "IDerefWithTimeout",
                                          :type "protocol",
                                          :full-name-encode "cljs.core/IDerefWithTimeout",
                                          :source {:code "(defprotocol IDerefWithTimeout\n  (-deref-with-timeout [o msec timeout-val]))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/cljs/cljs/core.cljs",
                                                   :lines [562 563]},
                                          :methods [{:name "-deref-with-timeout",
                                                     :signature ["[o msec timeout-val]"],
                                                     :docstring nil}],
                                          :full-name "cljs.core/IDerefWithTimeout",
                                          :history [["+" "0.0-927"]]},
           "syntax/eval" {:description "Allows the reader to evaluate the following form.\n\nThis feature is carried from tools.reader is not intended for use in ClojureScript,\nthough it works for basic forms not using symbols.",
                          :ns "syntax",
                          :name "eval",
                          :history [["+" "0.0-927"]],
                          :type "syntax",
                          :full-name-encode "syntax/eval",
                          :extra-sources ({:code "(defn- read-eval\n  [rdr _ opts pending-forms]\n  (when-not *read-eval*\n    (reader-error rdr \"#= not allowed when *read-eval* is false\"))\n  (eval (read* rdr true nil opts pending-forms)))",
                                           :title "Reader code",
                                           :repo "tools.reader",
                                           :tag "tools.reader-1.0.0-alpha1",
                                           :filename "src/main/clojure/clojure/tools/reader.clj",
                                           :lines [579 584]}
                                          {:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    \\? read-cond\n    nil))",
                                           :title "Reader table",
                                           :repo "tools.reader",
                                           :tag "tools.reader-1.0.0-alpha1",
                                           :filename "src/main/clojure/clojure/tools/reader.clj",
                                           :lines [764 776]}),
                          :usage ["#=..."],
                          :examples [{:id "ef1acd",
                                      :content "```clj\n#=123\n;;=> 123\n\n#=\"foo\"\n;;=> foo\n\n(def foo 1)\n#='foo\n;;=> 1\n```\n\nThe following is the output for the ClojureScript compiler on the JVM:\n\n```clj\n#=(+ 1 2)\n;; java.lang.RuntimeException: Unable to resolve symbol: + in this context\n\n#=(clojure.core/+ 1 2)\n;;=> 3\n```"}],
                          :full-name "syntax/eval",
                          :display "#= eval",
                          :clj-doc "https://github.com/clojure/clojure/blob/clojure-1.7.0-RC1/src/jvm/clojure/lang/LispReader.java#L113"},
           "cljs.core/multi-stepper" {:ns "cljs.core",
                                      :name "multi-stepper",
                                      :type "function",
                                      :signature ["[xform iters]"
                                                  "[xform iters nexts]"],
                                      :source {:code "(defn multi-stepper\n  ([xform iters]\n     (multi-stepper xform iters\n       (make-array (alength iters))))\n  ([xform iters nexts]\n     (letfn [(stepfn\n               ([result]\n                  (let [lt (if (reduced? result)\n                             @result\n                             result)]\n                    (set! (.-stepper lt) nil)\n                    lt))\n               ([result input]\n                  (let [lt result]\n                    (set! (.-first lt) input)\n                    (set! (.-rest lt) (lazy-transformer (.-stepper lt)))\n                    (set! (.-stepper lt) nil)\n                    (.-rest lt))))]\n       (MultiStepper. (xform stepfn) iters nexts))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [3644 3662]},
                                      :full-name "cljs.core/multi-stepper",
                                      :full-name-encode "cljs.core/multi-stepper",
                                      :history [["+" "0.0-2301"]]},
           "clojure.core.reducers/cat" {:ns "clojure.core.reducers",
                                        :name "cat",
                                        :signature ["[]"
                                                    "[ctor]"
                                                    "[left right]"],
                                        :history [["+" "0.0-1236"]],
                                        :type "function",
                                        :full-name-encode "clojure.core.reducers/cat",
                                        :source {:code "(defn cat\n  ([] (array))\n  ([ctor]\n     (fn\n       ([] (ctor))\n       ([left right] (cat left right))))\n  ([left right]\n     (cond\n       (zero? (count left)) right\n       (zero? (count right)) left\n       :else\n       (Cat. (+ (count left) (count right)) left right))))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/cljs/clojure/core/reducers.cljs",
                                                 :lines [213 230]},
                                        :full-name "clojure.core.reducers/cat",
                                        :clj-symbol "clojure.core.reducers/cat",
                                        :docstring "A high-performance combining fn that yields the catenation of the\nreduced values. The result is reducible, foldable, seqable and\ncounted, providing the identity collections are reducible, seqable\nand counted. The single argument version will build a combining fn\nwith the supplied identity constructor. Tests for identity\nwith (zero? (count x)). See also foldcat."},
           "cljs.core/unchecked-substract" {:moved "cljs.core/unchecked-subtract",
                                            :return-type number,
                                            :ns "cljs.core",
                                            :name "unchecked-substract",
                                            :signature ["[x]"
                                                        "[x y]"
                                                        "[x y & more]"],
                                            :history [["+" "0.0-1798"]
                                                      ["-" "0.0-2277"]],
                                            :type "function",
                                            :full-name-encode "cljs.core/unchecked-substract",
                                            :source {:code "(defn ^number unchecked-substract\n  ([x] (cljs.core/unchecked-subtract x))\n  ([x y] (cljs.core/unchecked-subtract x y))\n  ([x y & more] (reduce unchecked-substract (cljs.core/unchecked-subtract x y) more)))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2268",
                                                     :filename "src/cljs/cljs/core.cljs",
                                                     :lines [1805
                                                             1810]},
                                            :full-name "cljs.core/unchecked-substract",
                                            :docstring "If no ys are supplied, returns the negation of x, else subtracts\nthe ys from x and returns the result.",
                                            :removed {:in "0.0-2277",
                                                      :last-seen "0.0-2268"}},
           "cljs.core/Iteration" {:ns "cljs.core",
                                  :name "Iteration",
                                  :signature ["[xform coll]"],
                                  :history [["+" "0.0-2301"]
                                            ["-" "0.0-2371"]],
                                  :type "type",
                                  :full-name-encode "cljs.core/Iteration",
                                  :source {:code "(deftype Iteration [xform coll]\n   ISequential\n   \n   ISeqable\n   (-seq [_] (seq (sequence xform coll)))\n\n   IReduce\n   (-reduce [_ f init] (transduce xform f init coll))\n\n   IPrintWithWriter\n   (-pr-writer [coll writer opts]\n     (pr-sequential-writer writer pr-writer \"(\" \" \" \")\" opts coll)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2356",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [8192 8203]},
                                  :full-name "cljs.core/Iteration",
                                  :removed {:in "0.0-2371",
                                            :last-seen "0.0-2356"}},
           "clojure.browser.repl/start-evaluator" {:ns "clojure.browser.repl",
                                                   :name "start-evaluator",
                                                   :signature ["[url]"],
                                                   :history [["+"
                                                              "0.0-927"]],
                                                   :type "function",
                                                   :full-name-encode "clojure.browser.repl/start-evaluator",
                                                   :source {:code "(defn start-evaluator\n  [url]\n  (if-let [repl-connection (net/xpc-connection)]\n    (let [connection (net/xhr-connection)]\n      (event/listen connection\n        :success\n        (fn [e]\n          (net/transmit\n            repl-connection\n            :evaluate-javascript\n            (.getResponseText (.-currentTarget e)\n              ()))))\n\n      (net/register-service repl-connection\n        :send-result\n        (fn [data]\n          (send-result connection url (wrap-message :result data))))\n\n      (net/register-service repl-connection\n        :print\n        (fn [data]\n          (send-print url (wrap-message :print data))))\n\n      (net/connect repl-connection\n        (constantly nil))\n\n      (js/setTimeout #(send-result connection url (wrap-message :ready \"ready\")) 50))\n    (js/alert \"No 'xpc' param provided to child iframe.\")))",
                                                            :title "Source code",
                                                            :repo "clojurescript",
                                                            :tag "r1.7.228",
                                                            :filename "src/main/cljs/clojure/browser/repl.cljs",
                                                            :lines [93
                                                                    121]},
                                                   :full-name "clojure.browser.repl/start-evaluator",
                                                   :docstring "Start the REPL server connection."},
           "cljs.pprint/setf" {:ns "cljs.pprint",
                               :name "setf",
                               :signature ["[sym new-val]"],
                               :history [["+" "0.0-3255"]],
                               :type "macro",
                               :full-name-encode "cljs.pprint/setf",
                               :source {:code "(defmacro setf\n  [sym new-val]\n  `(swap! @~'this assoc ~sym ~new-val))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/pprint.clj",
                                        :lines [34 37]},
                               :full-name "cljs.pprint/setf",
                               :docstring "Set the value of the field SYM to NEW-VAL"},
           "cljs.repl.browser/send-for-eval" {:ns "cljs.repl.browser",
                                              :name "send-for-eval",
                                              :signature ["[form return-value-fn]"
                                                          "[conn form return-value-fn]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.repl.browser/send-for-eval",
                                              :source {:code "(defn send-for-eval\n  ([form return-value-fn]\n    (send-for-eval @(server/connection) form return-value-fn))\n  ([conn form return-value-fn]\n    (set-return-value-fn return-value-fn)\n    (server/send-and-close conn 200 form \"text/javascript\")))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.7.228",
                                                       :filename "src/main/clojure/cljs/repl/browser.clj",
                                                       :lines [60 68]},
                                              :full-name "cljs.repl.browser/send-for-eval",
                                              :docstring "Given a form and a return value function, send the form to the\nbrowser for evaluation. The return value function will be called\nwhen the return value is received."},
           "clojure.browser.event/unlisten" {:ns "clojure.browser.event",
                                             :name "unlisten",
                                             :type "function",
                                             :signature ["[src type fn]"
                                                         "[src type fn capture?]"],
                                             :source {:code "(defn unlisten\n  ([src type fn]\n     (unlisten src type fn false))\n  ([src type fn capture?]\n     (events/unlisten src\n                      (get (event-types src) type type)\n                      fn\n                      capture?)))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.7.228",
                                                      :filename "src/main/cljs/clojure/browser/event.cljs",
                                                      :lines [64 71]},
                                             :full-name "clojure.browser.event/unlisten",
                                             :full-name-encode "clojure.browser.event/unlisten",
                                             :history [["+" "0.0-927"]]},
           "cljs.test/is" {:ns "cljs.test",
                           :name "is",
                           :signature ["[form]" "[form msg]"],
                           :history [["+" "0.0-2496"]],
                           :type "macro",
                           :full-name-encode "cljs.test/is",
                           :source {:code "(defmacro is\n  ([form] `(cljs.test/is ~form nil))\n  ([form msg]\n   `(cljs.test/try-expr ~msg ~form)))",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r1.7.228",
                                    :filename "src/main/cljs/cljs/test.clj",
                                    :lines [149 165]},
                           :full-name "cljs.test/is",
                           :clj-symbol "clojure.test/is",
                           :docstring "Generic assertion macro.  'form' is any predicate test.\n'msg' is an optional message to attach to the assertion.\n\nExample: (is (= 4 (+ 2 2)) \"Two plus two should be 4\")\n\nSpecial forms:\n\n(is (thrown? c body)) checks that an instance of c is thrown from\nbody, fails if not; then returns the thing thrown.\n\n(is (thrown-with-msg? c re body)) checks that an instance of c is\nthrown AND that the message on the exception matches (with\nre-find) the regular expression re."},
           "syntax/dot" {:description "Dots can be used inside symbols. Its meaning depends on its position in the symbol:\n\n- `.` (by itself), `.-foo`, `.foo` all refer to the interop [`. (special form)`][doc:special/.].\n- `foo.` is constructor sugar, meaning [`(new foo)`][doc:special/new].\n- `(ns foo.bar)` and `foo.bar/baz` means that `foo.bar` is a nested namespace.\n- `foo/bar.baz` or `bar.baz` means `bar.baz` is nested JS property access (__not allowed in clojure__).",
                         :ns "syntax",
                         :name "dot",
                         :history [["+" "0.0-927"]],
                         :type "special character",
                         :related ["syntax/symbol" "syntax/namespace"],
                         :full-name-encode "syntax/dot",
                         :examples [{:id "61a0a1",
                                     :content "For interop:\n\n```clj\n(def obj #js {:age 28, :greet #(str \"Hi \" %)})\n\n(. obj greet \"Bob\")\n;;=> \"Hi Bob\"\n\n(.greet obj \"Bob\")\n;;=> \"Hi Bob\"\n\n(. obj -age)\n;;=> 28\n\n(.-age obj)\n;;=> 28\n```\n\nFor constructor:\n\n```clj\n(deftype Foo [x]\n   Object\n   (toString [_] (str \"Foo:\" x)))\n\n(Foo. 1)\n;;=> #<Foo: 1>\n\n(new Foo 1)\n;;=> #<Foo: 1>\n```\n\nFor nested namespaces:\n\n```clj\n(ns example.nested.core)\n(def foo 1)\nexample.nested.core/foo\n;;=> 1\n```\n\nFor nested JS properties.  The following pairs are equivalent:\n\n```clj\n(js/console.log \"HELLO\")\n;; \"HELLO\"\n\n(.log js/console \"HELLO\")\n;; \"HELLO\"\n```\n\n```clj\ncljs.core/PersistentQueue.EMPTY\n;;=> #queue []\n\n(.-EMPTY cljs.core/PersistentQueue)\n;;=> #queue []\n```"}],
                         :full-name "syntax/dot",
                         :display ". dot",
                         :clj-doc "http://clojure.org/reader#toc1"},
           "syntax/unused" {:description "`_` is a valid symbol name that indicates an unused or disregarded value.\nThis is not enforced by the compiler.\n\nFor example, create a function whose first two arguments are ignored:\n\n```clj\n(fn [_ _ a]\n  (println a))\n```\n\nIgnore the first and third value of a [destructured][doc:syntax/destructure-vector] sequence:\n\n```clj\n(let [ [_ a b _ c]\n       [1 2 3 4 5] ]\n  (println a b c))\n;; 2 3 5\n```\n\nIgnore return values of debug statements in a [doc:cljs.core/let] block:\n\n```clj\n(let [a 1\n      _ (println a)\n      b (+ a 2)\n      _ (println b)\n      c (+ b 3)]\n  ...)\n```\n\nMultiple `_`'s can be used in each of the previous examples because duplicate\nnames will shadow those previously occurring.  Thus, `_` actually holds the\nvalue of its last binding, but using it should be strictly avoided to prevent\nconfusion.  This is the only encouraged use-case for duplicating parameter\nnames.",
                            :ns "syntax",
                            :name "unused",
                            :history [["+" "0.0-927"]],
                            :type "convention",
                            :full-name-encode "syntax/unused",
                            :examples [{:id "705f5e",
                                        :content "It is common to use `_` to ignore all but the latest value of a changing atom\ninside an [doc:cljs.core/add-watch] callback:\n\n```clj\n(def a (atom 1))\n\n(add-watch a :foo\n  (fn [_ _ _ s]\n    (println s)))\n\n(reset! a 2)\n;; 2\n```"}],
                            :full-name "syntax/unused",
                            :display "_ unused",
                            :clj-doc "http://clojure.org/cheatsheet"},
           "cljs.test/use-fixtures" {:ns "cljs.test",
                                     :name "use-fixtures",
                                     :signature ["[type & fns]"],
                                     :history [["+" "0.0-2498"]],
                                     :type "macro",
                                     :full-name-encode "cljs.test/use-fixtures",
                                     :source {:code "(defmacro use-fixtures [type & fns]\n  (condp = type\n    :once\n    `(def ~'cljs-test-once-fixtures\n       [~@fns])\n    :each\n    `(def ~'cljs-test-each-fixtures\n       [~@fns])\n    :else\n    (throw\n      (Exception. \"First argument to cljs.test/use-fixtures must be :once or :each\"))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/cljs/cljs/test.clj",
                                              :lines [377 387]},
                                     :full-name "cljs.test/use-fixtures",
                                     :clj-symbol "clojure.test/use-fixtures"},
           "cljs.pprint/float?" {:return-type boolean,
                                 :ns "cljs.pprint",
                                 :name "float?",
                                 :signature ["[n]"],
                                 :history [["+" "0.0-3255"]],
                                 :type "function",
                                 :full-name-encode "cljs.pprint/floatQMARK",
                                 :source {:code "(defn ^boolean float?\n  [n]\n  (and (number? n)\n       (not ^boolean (js/isNaN n))\n       (not (identical? n js/Infinity))\n       (not (== (js/parseFloat n) (js/parseInt n 10)))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/pprint.cljs",
                                          :lines [54 60]},
                                 :full-name "cljs.pprint/float?",
                                 :docstring "Returns true if n is an float."},
           "cljs.core/PersistentHashMap.fromArrays" {:ns "cljs.core",
                                                     :name "PersistentHashMap.fromArrays",
                                                     :signature ["[ks vs]"],
                                                     :history [["+"
                                                                "0.0-1211"]],
                                                     :parent-type "PersistentHashMap",
                                                     :type "function",
                                                     :full-name-encode "cljs.core/PersistentHashMapDOTfromArrays",
                                                     :source {:code "(set! (.-fromArrays PersistentHashMap)\n  (fn [ks vs]\n    (let [len (alength ks)]\n      (loop [i 0 ^not-native out (transient (.-EMPTY PersistentHashMap))]\n        (if (< i len)\n          (recur (inc i) (-assoc! out (aget ks i) (aget vs i)))\n          (persistent! out))))))",
                                                              :title "Source code",
                                                              :repo "clojurescript",
                                                              :tag "r1.7.228",
                                                              :filename "src/main/cljs/cljs/core.cljs",
                                                              :lines [6953
                                                                      6959]},
                                                     :full-name "cljs.core/PersistentHashMap.fromArrays"},
           "cljs.core/special-symbol?" {:return-type boolean,
                                        :ns "cljs.core",
                                        :name "special-symbol?",
                                        :signature ["[x]"],
                                        :history [["+" "0.0-1803"]],
                                        :type "function",
                                        :full-name-encode "cljs.core/special-symbolQMARK",
                                        :source {:code "(defn ^boolean special-symbol? [x]\n  (contains?\n    '#{if def fn* do let* loop* letfn* throw try\n       recur new set! ns deftype* defrecord* . js* & quote}\n    x))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/cljs/cljs/core.cljs",
                                                 :lines [9956 9960]},
                                        :full-name "cljs.core/special-symbol?",
                                        :clj-symbol "clojure.core/special-symbol?"},
           "cljs.repl.browser/constrain-order" {:ns "cljs.repl.browser",
                                                :name "constrain-order",
                                                :signature ["[order f]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.repl.browser/constrain-order",
                                                :source {:code "(defn constrain-order\n  [order f]\n  (send-via es ordering add-in-order order f)\n  (send-via es ordering run-in-order))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1.7.228",
                                                         :filename "src/main/clojure/cljs/repl/browser.clj",
                                                         :lines [164
                                                                 169]},
                                                :full-name "cljs.repl.browser/constrain-order",
                                                :docstring "Elements to be printed in the REPL will arrive out of order. Ensure\nthat they are printed in the correct order."},
           "cljs.js/load-deps" {:ns "cljs.js",
                                :name "load-deps",
                                :signature ["[bound-vars ana-env lib deps cb]"
                                            "[bound-vars ana-env lib deps opts cb]"],
                                :history [["+" "1.7.10"]
                                          ["-" "1.7.28"]],
                                :type "function",
                                :full-name-encode "cljs.js/load-deps",
                                :source {:code "(defn load-deps\n  ([bound-vars ana-env lib deps cb]\n   (analyze-deps bound-vars ana-env lib deps nil cb))\n  ([bound-vars ana-env lib deps opts cb]\n   (when (:verbose opts)\n     (debug-prn \"Loading dependencies for\" lib))\n   (binding [ana/*cljs-dep-set* (vary-meta (conj (:*cljs-dep-set* bound-vars) lib)\n                                  update-in [:dep-path] conj lib)]\n     (assert (every? #(not (contains? (:*cljs-dep-set* bound-vars) %)) deps)\n       (str \"Circular dependency detected \"\n         (-> (:*cljs-dep-set* bound-vars) meta :dep-path)))\n     (if (seq deps)\n       (let [dep (first deps)]\n         (require bound-vars dep\n           (-> opts\n             (dissoc :context)\n             (dissoc :ns))\n           (fn [res]\n             (if-not (:error res)\n               (load-deps bound-vars ana-env lib (next deps) opts cb)\n               (cb res)))))\n       (cb {:value nil})))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.10",
                                         :filename "src/main/cljs/cljs/js.cljs",
                                         :lines [236 257]},
                                :full-name "cljs.js/load-deps",
                                :removed {:in "1.7.28",
                                          :last-seen "1.7.10"}},
           "cljs.core/js-debugger" {:description "Creates breakpoint that will stop the debugger if the browser's devtools are\nopen.  Equivalent to `debugger;` in JavaScript.",
                                    :ns "cljs.core",
                                    :name "js-debugger",
                                    :signature ["[]"],
                                    :history [["+" "0.0-2496"]],
                                    :type "macro",
                                    :full-name-encode "cljs.core/js-debugger",
                                    :source {:code "(core/defmacro js-debugger\n  []\n  (core/list 'do\n             (core/list 'js* \"debugger\")\n             nil))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/clojure/cljs/core.cljc",
                                             :lines [866 871]},
                                    :examples [{:id "87f2fa",
                                                :content "```clj\n(defn foo []\n  (println \"HI\")\n  (js-debugger)\n  (println \"WORLD\"))\n\n(foo)\n;; will print \"HI\" then pause JS inside this function\n;; if browser devtools are open.\n```"}],
                                    :full-name "cljs.core/js-debugger",
                                    :docstring "Emit JavaScript \"debugger;\" statement"},
           "cljs.core/ns-interns*" {:ns "cljs.core",
                                    :name "ns-interns*",
                                    :type "function",
                                    :signature ["[sym]"],
                                    :source {:code "(defn ns-interns* [sym]\n  (let [ns-obj (find-ns-obj sym)\n        ns     (Namespace. ns-obj sym)]\n    (letfn [(step [ret k]\n              (let [var-sym (symbol (demunge k))]\n                (assoc ret\n                  var-sym (Var. #(gobject/get ns-obj k)\n                            (symbol (str sym) (str var-sym)) {:ns ns}))))]\n      (reduce step {} (js-keys ns-obj)))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [10157 10165]},
                                    :full-name "cljs.core/ns-interns*",
                                    :full-name-encode "cljs.core/ns-internsSTAR",
                                    :history [["+" "1.7.10"]]},
           "cljs.repl/default-special-fns" {:ns "cljs.repl",
                                            :name "default-special-fns",
                                            :type "var",
                                            :source {:code "(def default-special-fns\n  (let [load-file-fn\n        (fn self\n          ([repl-env env form]\n            (self repl-env env form nil))\n          ([repl-env env [_ file :as form] opts]\n            (load-file repl-env file opts)))\n        in-ns-fn\n        (fn self\n          ([repl-env env form]\n           (self repl-env env form nil))\n          ([repl-env env [_ [quote ns-name] :as form] _]\n            ;; guard against craziness like '5 which wreaks havoc\n           (when-not (and (= quote 'quote) (symbol? ns-name))\n             (throw (IllegalArgumentException. \"Argument to in-ns must be a symbol.\")))\n           (when-not (ana/get-namespace ns-name)\n             (swap! env/*compiler* assoc-in [::ana/namespaces ns-name] {:name ns-name})\n             (-evaluate repl-env \"<cljs repl>\" 1\n               (str \"goog.provide('\" (comp/munge ns-name) \"');\")))\n           (set! ana/*cljs-ns* ns-name)))]\n    (wrap-special-fns wrap-self\n     {'in-ns in-ns-fn\n      'clojure.core/in-ns in-ns-fn\n      'require\n      (fn self\n        ([repl-env env form]\n         (self repl-env env form nil))\n        ([repl-env env [_ & specs :as form] opts]\n         (let [is-self-require? (self-require? specs)\n               [target-ns restore-ns]\n               (if-not is-self-require?\n                 [ana/*cljs-ns* nil]\n                 ['cljs.user ana/*cljs-ns*])]\n           (evaluate-form repl-env env \"<cljs repl>\"\n                          (with-meta\n                            `(~'ns ~target-ns\n                               (:require ~@(-> specs canonicalize-specs decorate-specs)))\n                            {:merge true :line 1 :column 1})\n                          identity opts)\n           (when is-self-require?\n             (set! ana/*cljs-ns* restore-ns)))))\n      'require-macros\n      (fn self\n        ([repl-env env form]\n         (self repl-env env form nil))\n        ([repl-env env [_ & specs :as form] opts]\n         (evaluate-form repl-env env \"<cljs repl>\"\n                        (with-meta\n                          `(~'ns ~ana/*cljs-ns*\n                             (:require-macros ~@(-> specs canonicalize-specs decorate-specs)))\n                          {:merge true :line 1 :column 1})\n                        identity opts)))\n      'import\n      (fn self\n        ([repl-env env form]\n         (self repl-env env form nil))\n        ([repl-env env [_ & specs :as form] opts]\n         (evaluate-form repl-env env \"<cljs repl>\"\n                        (with-meta\n                          `(~'ns ~ana/*cljs-ns*\n                             (:import\n                              ~@(map\n                                 (fn [quoted-spec-or-kw]\n                                   (if (keyword? quoted-spec-or-kw)\n                                     quoted-spec-or-kw\n                                     (second quoted-spec-or-kw)))\n                                 specs)))\n                          {:merge true :line 1 :column 1})\n                        identity opts)))\n      'load-file load-file-fn\n      'clojure.core/load-file load-file-fn\n      'load-namespace\n      (fn self\n        ([repl-env env form]\n         (self env repl-env form nil))\n        ([repl-env env [_ ns :as form] opts]\n         (load-namespace repl-env ns opts)))})))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.7.228",
                                                     :filename "src/main/clojure/cljs/repl.cljc",
                                                     :lines [642 718]},
                                            :full-name "cljs.repl/default-special-fns",
                                            :full-name-encode "cljs.repl/default-special-fns",
                                            :history [["+" "0.0-993"]]},
           "cljs.core/format" {:ns "cljs.core",
                               :name "format",
                               :signature ["[fmt & args]"],
                               :history [["+" "0.0-1443"]
                                         ["-" "0.0-1885"]],
                               :type "function",
                               :full-name-encode "cljs.core/format",
                               :source {:code "(defn format\n  [fmt & args]\n  (apply gstring/format fmt args))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1878",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1771 1774]},
                               :full-name "cljs.core/format",
                               :clj-symbol "clojure.core/format",
                               :docstring "Formats a string using goog.string.format.",
                               :removed {:in "0.0-1885",
                                         :last-seen "0.0-1878"}},
           "cljs.core/sorted-set" {:description "Returns a new sorted set with supplied `keys`.",
                                   :ns "cljs.core",
                                   :name "sorted-set",
                                   :signature ["[& keys]"],
                                   :history [["+" "0.0-1211"]],
                                   :type "function",
                                   :related ["cljs.core/sorted-set-by"
                                             "cljs.core/subseq"
                                             "cljs.core/rsubseq"
                                             "cljs.core/sorted-map"],
                                   :full-name-encode "cljs.core/sorted-set",
                                   :source {:code "(defn sorted-set\n  ([& keys]\n   (reduce -conj (.-EMPTY PersistentTreeSet) keys)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [8234 8237]},
                                   :full-name "cljs.core/sorted-set",
                                   :clj-symbol "clojure.core/sorted-set",
                                   :docstring "Returns a new sorted set with supplied keys."},
           "cljs.core/fnil" {:description "Takes a function `f`, and returns a function that calls `f`, replacing a nil\nfirst argument to `f` with the supplied value `x`. Higher arity versions can\nreplace arguments in the second and third positions (`y`, `z`).\n\nNote that the function `f` can take any number of arguments, not just the one(s)\nbeing nil-patched.",
                             :ns "cljs.core",
                             :name "fnil",
                             :signature ["[f x]"
                                         "[f x y]"
                                         "[f x y z]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/fnil",
                             :source {:code "(defn fnil\n  ([f x]\n   (fn\n     ([a] (f (if (nil? a) x a)))\n     ([a b] (f (if (nil? a) x a) b))\n     ([a b c] (f (if (nil? a) x a) b c))\n     ([a b c & ds] (apply f (if (nil? a) x a) b c ds))))\n  ([f x y]\n   (fn\n     ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))\n     ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) c))\n     ([a b c & ds] (apply f (if (nil? a) x a) (if (nil? b) y b) c ds))))\n  ([f x y z]\n   (fn\n     ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))\n     ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) (if (nil? c) z c)))\n     ([a b c & ds] (apply f (if (nil? a) x a) (if (nil? b) y b) (if (nil? c) z c) ds)))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [3864 3885]},
                             :full-name "cljs.core/fnil",
                             :clj-symbol "clojure.core/fnil",
                             :docstring "Takes a function f, and returns a function that calls f, replacing\na nil first argument to f with the supplied value x. Higher arity\nversions can replace arguments in the second and third\npositions (y, z). Note that the function f can take any number of\narguments, not just the one(s) being nil-patched."},
           "cljs.core/update" {:ns "cljs.core",
                               :name "update",
                               :signature ["[m k f]"
                                           "[m k f x]"
                                           "[m k f x y]"
                                           "[m k f x y z]"
                                           "[m k f x y z & more]"],
                               :history [["+" "0.0-2411"]],
                               :type "function",
                               :full-name-encode "cljs.core/update",
                               :source {:code "(defn update\n  ([m k f]\n   (assoc m k (f (get m k))))\n  ([m k f x]\n   (assoc m k (f (get m k) x)))\n  ([m k f x y]\n   (assoc m k (f (get m k) x y)))\n  ([m k f x y z]\n   (assoc m k (f (get m k) x y z)))\n  ([m k f x y z & more]\n   (assoc m k (apply f (get m k) x y z more))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [4604 4618]},
                               :full-name "cljs.core/update",
                               :clj-symbol "clojure.core/update",
                               :docstring "'Updates' a value in an associative structure, where k is a\nkey and f is a function that will take the old value\nand any supplied args and return the new value, and returns a new\nstructure.  If the key does not exist, nil is passed as the old value."},
           "cljs.core/this-as" {:ns "cljs.core",
                                :name "this-as",
                                :signature ["[name & body]"],
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :full-name-encode "cljs.core/this-as",
                                :source {:code "(core/defmacro this-as\n  [name & body]\n  `(let [~name (js-this)]\n     ~@body))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/clojure/cljs/core.cljc",
                                         :lines [1296 1300]},
                                :full-name "cljs.core/this-as",
                                :docstring "Defines a scope where JavaScript's implicit \"this\" is bound to the name provided."},
           "cljs.repl.rhino/rhino-eval" {:ns "cljs.repl.rhino",
                                         :name "rhino-eval",
                                         :type "function",
                                         :signature ["[{:keys [scope], :as repl-env} filename line js]"],
                                         :source {:code "(defn rhino-eval\n  [{:keys [scope] :as repl-env} filename line js]\n  (try\n    (let [linenum (or line Integer/MIN_VALUE)]\n      {:status :success\n       :value (eval-result (-eval js repl-env filename linenum))})\n    (catch Throwable ex\n      ;; manually set *e\n      (let [top-level (-> scope\n                        (ScriptableObject/getProperty \"cljs\")\n                        (ScriptableObject/getProperty \"core\"))]\n        (ScriptableObject/putProperty top-level \"_STAR_e\"\n          (Context/javaToJS ex scope))\n        {:status :exception\n         :value (.toString ex)\n         :stacktrace (stacktrace ex)}))))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.7.228",
                                                  :filename "src/main/clojure/cljs/repl/rhino.clj",
                                                  :lines [72 87]},
                                         :full-name "cljs.repl.rhino/rhino-eval",
                                         :full-name-encode "cljs.repl.rhino/rhino-eval",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/PersistentQueueSeq" {:ns "cljs.core",
                                           :name "PersistentQueueSeq",
                                           :type "type",
                                           :signature ["[meta front rear __hash]"],
                                           :source {:code "(deftype PersistentQueueSeq [meta front rear ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  IWithMeta\n  (-with-meta [coll meta] (PersistentQueueSeq. meta front rear __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] (first front))\n  (-rest  [coll]\n    (if-let [f1 (next front)]\n      (PersistentQueueSeq. meta f1 rear nil)\n      (if (nil? rear)\n        (-empty coll)\n        (PersistentQueueSeq. meta rear nil nil))))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY List) meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  ISeqable\n  (-seq [coll] coll))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.7.228",
                                                    :filename "src/main/cljs/cljs/core.cljs",
                                                    :lines [5378 5414]},
                                           :full-name "cljs.core/PersistentQueueSeq",
                                           :full-name-encode "cljs.core/PersistentQueueSeq",
                                           :history [["+" "0.0-927"]]},
           "cljs.core/counted?" {:description "Returns true if `x` executes `count` in constant time, false otherwise.\n\nLists, maps, sets, strings, and vectors can be counted in constant time.",
                                 :return-type boolean,
                                 :ns "cljs.core",
                                 :name "counted?",
                                 :signature ["[x]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/countedQMARK",
                                 :source {:code "(defn ^boolean counted?\n  [x] (satisfies? ICounted x))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [1368 1370]},
                                 :full-name "cljs.core/counted?",
                                 :clj-symbol "clojure.core/counted?",
                                 :docstring "Returns true if coll implements count in constant time"},
           "cljs.repl.browser/read-headers" {:moved "cljs.repl.server/read-headers",
                                             :ns "cljs.repl.browser",
                                             :name "read-headers",
                                             :signature ["[rdr]"],
                                             :history [["+" "0.0-927"]
                                                       ["-"
                                                        "0.0-1503"]],
                                             :type "function",
                                             :full-name-encode "cljs.repl.browser/read-headers",
                                             :source {:code "(defn read-headers [rdr]\n  (loop [next-line (.readLine rdr)\n         header-lines []]\n    (if (= \"\" next-line)\n      header-lines                      ;we're done reading headers\n      (recur (.readLine rdr) (conj header-lines next-line)))))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1450",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [136 141]},
                                             :full-name "cljs.repl.browser/read-headers",
                                             :removed {:in "0.0-1503",
                                                       :last-seen "0.0-1450"}},
           "cljs.analyzer.api/warning-enabled?" {:ns "cljs.analyzer.api",
                                                 :name "warning-enabled?",
                                                 :signature ["[warning-type]"],
                                                 :history [["+"
                                                            "1.7.10"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.analyzer.api/warning-enabledQMARK",
                                                 :source {:code "(defn warning-enabled?\n  [warning-type]\n  (ana/*cljs-warnings* warning-type))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r1.7.228",
                                                          :filename "src/main/clojure/cljs/analyzer/api.clj",
                                                          :lines [43
                                                                  46]},
                                                 :full-name "cljs.analyzer.api/warning-enabled?",
                                                 :docstring "Test if the given warning-type is enabled."},
           "clojure.string/trimr" {:description "Removes whitespace from the right side of string.",
                                   :ns "clojure.string",
                                   :name "trimr",
                                   :signature ["[s]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "clojure.string/trimr",
                                   :source {:code "(defn trimr\n  [s]\n  (gstring/trimRight s))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/clojure/string.cljs",
                                            :lines [175 178]},
                                   :full-name "clojure.string/trimr",
                                   :clj-symbol "clojure.string/trimr",
                                   :docstring "Removes whitespace from the right side of string."},
           "clojure.core.reducers/take" {:ns "clojure.core.reducers",
                                         :name "take",
                                         :signature ["[n]" "[n coll]"],
                                         :history [["+" "0.0-1236"]],
                                         :type "function",
                                         :full-name-encode "clojure.core.reducers/take",
                                         :source {:code "(defcurried take\n  \"Ends the reduction of coll after consuming n values.\"\n  {}\n  [n coll]\n  (reducer coll\n   (fn [f1]\n     (let [cnt (atom n)]\n       (rfn [f1 k]\n         ([ret k v]\n            (swap! cnt dec)\n            (if (neg? @cnt)\n              (reduced ret)\n              (f1 ret k v))))))))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.7.228",
                                                  :filename "src/main/cljs/clojure/core/reducers.cljs",
                                                  :lines [164 176]},
                                         :full-name "clojure.core.reducers/take",
                                         :clj-symbol "clojure.core.reducers/take",
                                         :docstring "Ends the reduction of coll after consuming n values."},
           "cljs.repl/IReplEnvOptions" {:ns "cljs.repl",
                                        :name "IReplEnvOptions",
                                        :type "protocol",
                                        :full-name-encode "cljs.repl/IReplEnvOptions",
                                        :source {:code "(defprotocol IReplEnvOptions\n  (-repl-options [repl-env] \"Return default REPL options for a REPL Env\"))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/clojure/cljs/repl.cljc",
                                                 :lines [104 105]},
                                        :methods [{:name "-repl-options",
                                                   :signature ["[repl-env]"],
                                                   :docstring "Return default REPL options for a REPL Env"}],
                                        :full-name "cljs.repl/IReplEnvOptions",
                                        :history [["+" "0.0-2719"]]},
           "cljs.core/force" {:ns "cljs.core",
                              :name "force",
                              :signature ["[x]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/force",
                              :source {:code "(defn force\n  [x]\n  (if (delay? x)\n    (deref x)\n    x))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [9209 9214]},
                              :full-name "cljs.core/force",
                              :clj-symbol "clojure.core/force",
                              :docstring "If x is a Delay, returns the (possibly cached) value of its expression, else returns x"},
           "cljs.core/compare-and-set!" {:description "Atomically sets the value of atom `a` to `newval` if and only if the current\nvalue of the atom is identical to `oldval`.\n\nReturns true if set happened, false otherwise.",
                                         :ns "cljs.core",
                                         :name "compare-and-set!",
                                         :signature ["[a oldval newval]"],
                                         :history [["+" "0.0-927"]],
                                         :type "function",
                                         :related ["cljs.core/atom"
                                                   "cljs.core/reset!"
                                                   "cljs.core/swap!"],
                                         :full-name-encode "cljs.core/compare-and-setBANG",
                                         :source {:code "(defn compare-and-set!\n  [^not-native a oldval newval]\n  (if (= (-deref a) oldval)\n    (do (reset! a newval) true)\n    false))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.7.228",
                                                  :filename "src/main/cljs/cljs/core.cljs",
                                                  :lines [4036 4043]},
                                         :examples [{:id "1fa306",
                                                     :content "```clj\n(def a (atom \"abc\"))\n\n(compare-and-set! a \"abc\" \"def\")\n;;=> true\n\n@a\n;;=> \"def\"\n\n(compare-and-set! a \"abc\" \"def\")\n;;=> false\n\n@a\n;;=> \"def\"\n```"}],
                                         :full-name "cljs.core/compare-and-set!",
                                         :clj-symbol "clojure.core/compare-and-set!",
                                         :docstring "Atomically sets the value of atom to newval if and only if the\ncurrent value of the atom is equal to oldval. Returns true if\nset happened, else false."},
           "cljs.core/set?" {:description "Returns true if `x` is a set, false otherwise.",
                             :return-type boolean,
                             :ns "cljs.core",
                             :name "set?",
                             :signature ["[x]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/set"],
                             :full-name-encode "cljs.core/setQMARK",
                             :source {:code "(defn ^boolean set?\n  [x]\n  (if (nil? x)\n    false\n    (satisfies? ISet x)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [1896 1901]},
                             :full-name "cljs.core/set?",
                             :clj-symbol "clojure.core/set?",
                             :docstring "Returns true if x satisfies ISet"},
           "cljs.core/hash-string" {:ns "cljs.core",
                                    :name "hash-string",
                                    :type "function",
                                    :signature ["[k]"],
                                    :source {:code "(defn hash-string [k]\n  (when (> string-hash-cache-count 255)\n    (set! string-hash-cache (js-obj))\n    (set! string-hash-cache-count 0))\n  (let [h (aget string-hash-cache k)]\n    (if (number? h)\n      h\n      (add-to-string-hash-cache k))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [862 869]},
                                    :full-name "cljs.core/hash-string",
                                    :full-name-encode "cljs.core/hash-string",
                                    :history [["+" "0.0-2261"]]},
           "cljs.repl.server/set-connection" {:ns "cljs.repl.server",
                                              :name "set-connection",
                                              :signature ["[conn]"],
                                              :history [["+"
                                                         "0.0-1503"]],
                                              :type "function",
                                              :full-name-encode "cljs.repl.server/set-connection",
                                              :source {:code "(defn set-connection\n  [conn]\n  (if-let [promised-conn (:promised-conn @state)]\n    (do\n      (swap! state\n        (fn [old]\n          (-> old\n            (assoc :connection nil)\n            (assoc :promised-conn nil))))\n      (deliver promised-conn conn))\n    (swap! state (fn [old] (assoc old :connection conn)))))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.7.228",
                                                       :filename "src/main/clojure/cljs/repl/server.clj",
                                                       :lines [24 37]},
                                              :full-name "cljs.repl.server/set-connection",
                                              :docstring "Given a new available connection, either use it to deliver the\nconnection which was promised or store the connection for later\nuse."},
           "syntax/unquote-splicing" {:description "(Only intended for use in Clojure macros, which can be used from but not\nwritten in ClojureScript.)\n\nIntended for use inside a [doc:syntax/syntax-quote].\n\nForces evaluation of the following form and expands its children into the\nparent form.",
                                      :ns "syntax",
                                      :name "unquote-splicing",
                                      :history [["+" "0.0-927"]],
                                      :type "syntax",
                                      :related ["syntax/syntax-quote"
                                                "syntax/unquote"],
                                      :full-name-encode "syntax/unquote-splicing",
                                      :extra-sources ({:code "(defn- read-unquote\n  [rdr comma opts pending-forms]\n  (if-let [ch (peek-char rdr)]\n    (if (identical? \\@ ch)\n      ((wrapping-reader 'clojure.core/unquote-splicing) (doto rdr read-char) \\@ opts pending-forms)\n      ((wrapping-reader 'clojure.core/unquote) rdr \\~ opts pending-forms))))",
                                                       :title "Reader code",
                                                       :repo "tools.reader",
                                                       :tag "tools.reader-1.0.0-alpha1",
                                                       :filename "src/main/clojure/clojure/tools/reader.clj",
                                                       :lines [588
                                                               593]}
                                                      {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                                       :title "Reader table",
                                                       :repo "tools.reader",
                                                       :tag "tools.reader-1.0.0-alpha1",
                                                       :filename "src/main/clojure/clojure/tools/reader.clj",
                                                       :lines [743
                                                               762]}),
                                      :examples [{:id "e6f73d",
                                                  :content "```clj\n(def foo '[a b c])\n`(~@foo)\n;;=> (a b c)\n```"}],
                                      :full-name "syntax/unquote-splicing",
                                      :display "~@ unquote splicing",
                                      :clj-doc "http://clojure.org/reader#toc2"},
           "cljs.core/unchecked-dec" {:ns "cljs.core",
                                      :name "unchecked-dec",
                                      :signature ["[x]"],
                                      :history [["+" "0.0-1798"]],
                                      :type "function/macro",
                                      :full-name-encode "cljs.core/unchecked-dec",
                                      :source {:code "(defn unchecked-dec\n  [x]\n  (cljs.core/unchecked-dec x))",
                                               :title "Function code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [2390 2393]},
                                      :extra-sources [{:code "(core/defmacro ^::ana/numeric unchecked-dec\n  ([x] `(dec ~x)))",
                                                       :title "Macro code",
                                                       :repo "clojurescript",
                                                       :tag "r1.7.228",
                                                       :filename "src/main/clojure/cljs/core.cljc",
                                                       :lines [980
                                                               981]}],
                                      :full-name "cljs.core/unchecked-dec",
                                      :clj-symbol "clojure.core/unchecked-dec",
                                      :docstring "Returns a number one less than x, an int."},
           "cljs.core/PersistentVector.EMPTY-NODE" {:ns "cljs.core",
                                                    :name "PersistentVector.EMPTY-NODE",
                                                    :type "var",
                                                    :parent-type "PersistentVector",
                                                    :source {:code "(set! (.-EMPTY-NODE PersistentVector) (VectorNode. nil (make-array 32)))",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r1.7.228",
                                                             :filename "src/main/cljs/cljs/core.cljs",
                                                             :lines [4923]},
                                                    :full-name "cljs.core/PersistentVector.EMPTY-NODE",
                                                    :full-name-encode "cljs.core/PersistentVectorDOTEMPTY-NODE",
                                                    :history [["+"
                                                               "0.0-2301"]]},
           "clojure.string/escape" {:description "Return a new string, using `cmap` to escape each character `ch` from `s` as follows:\n\nIf `(cmap ch)` is nil, append ch to the new string.\n\nIf `(cmap ch)` is non-nil, append `(str (cmap ch))` instead.",
                                    :ns "clojure.string",
                                    :name "escape",
                                    :signature ["[s cmap]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "clojure.string/escape",
                                    :source {:code "(defn escape\n  [s cmap]\n  (let [buffer (StringBuffer.)\n        length (.-length s)]\n    (loop [index 0]\n      (if (== length index)\n        (. buffer (toString))\n        (let [ch (.charAt s index)\n              replacement (get cmap ch)]\n          (if-not (nil? replacement)\n            (.append buffer (str replacement))\n            (.append buffer ch))\n          (recur (inc index)))))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/clojure/string.cljs",
                                             :lines [198 215]},
                                    :full-name "clojure.string/escape",
                                    :clj-symbol "clojure.string/escape",
                                    :docstring "Return a new string, using cmap to escape each character ch\nfrom s as follows:\n\nIf (cmap ch) is nil, append ch to the new string.\nIf (cmap ch) is non-nil, append (str (cmap ch)) instead."},
           "syntax/cond-splicing" {:description "(Only allowed in `.cljc` files or the REPL)\n\nLike [doc:syntax/cond], except:\n\n- each conditional value must be a sequence,\n- the selected sequence is spliced into the parent form,\n- and it must have a parent form to be spliced into (not top level).\n\n`(def #?@(:cljs [foo 1])` is read as `(def foo 1)`.",
                                   :ns "syntax",
                                   :name "cond-splicing",
                                   :history [["+" "0.0-3190"]],
                                   :type "syntax",
                                   :related ["syntax/cond"],
                                   :full-name-encode "syntax/cond-splicing",
                                   :extra-sources ({:code "(defn- read-cond\n  [rdr _ opts pending-forms]\n  (when (not (and opts (#{:allow :preserve} (:read-cond opts))))\n    (throw (RuntimeException. \"Conditional read not allowed\")))\n  (if-let [ch (read-char rdr)]\n    (let [splicing (= ch \\@)\n          ch (if splicing (read-char rdr) ch)]\n      (when splicing\n        (when-not *read-delim*\n          (reader-error rdr \"cond-splice not in list\")))\n      (if-let [ch (if (whitespace? ch) (read-past whitespace? rdr) ch)]\n        (if (not= ch \\()\n          (throw (RuntimeException. \"read-cond body must be a list\"))\n          (binding [*suppress-read* (or *suppress-read* (= :preserve (:read-cond opts)))]\n            (if *suppress-read*\n              (reader-conditional (read-list rdr ch opts pending-forms) splicing)\n              (read-cond-delimited rdr splicing opts pending-forms))))\n        (reader-error rdr \"EOF while reading character\")))\n    (reader-error rdr \"EOF while reading character\")))",
                                                    :title "Reader code",
                                                    :repo "tools.reader",
                                                    :tag "tools.reader-1.0.0-alpha1",
                                                    :filename "src/main/clojure/clojure/tools/reader.clj",
                                                    :lines [496 514]}
                                                   {:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    \\? read-cond\n    nil))",
                                                    :title "Reader table",
                                                    :repo "tools.reader",
                                                    :tag "tools.reader-1.0.0-alpha1",
                                                    :filename "src/main/clojure/clojure/tools/reader.clj",
                                                    :lines [764 776]}),
                                   :usage ["#?@(...)"],
                                   :examples [{:id "9d0020",
                                               :content "```clj\n'(def #?@(:cljs [a 1]\n          :clj  [b 2]))\n;;=> (def a 1)\n```"}],
                                   :full-name "syntax/cond-splicing",
                                   :display "#?@ reader conditional splicing",
                                   :clj-doc "http://clojure.org/reader#toc5"},
           "cljs.core/remove-watch" {:description "Removes a watch function identified by `key` from atom `a`.  The function must\nhave originally been set by `add-watch`.",
                                     :ns "cljs.core",
                                     :name "remove-watch",
                                     :signature ["[a key]"],
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :related ["cljs.core/add-watch"],
                                     :full-name-encode "cljs.core/remove-watch",
                                     :source {:code "(defn remove-watch\n  [iref key]\n  (-remove-watch iref key)\n  iref)",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/cljs/cljs/core.cljs",
                                              :lines [9164 9168]},
                                     :examples [{:id "70044a",
                                                 :content "```clj\n(def a (atom {}))\n\n(add-watch a :logger\n  (fn [_key _atom old-state new-state]\n    (println \"old:\" old-state)\n    (println \"new:\" new-state)))\n\n(swap! a assoc :foo \"bar\")\n;;=> will print the following:\n;; old: {}\n;; new: {:foo \"bar\"}\n\n(remove-watch a :logger)\n\n(swap! a assoc :foo 3)\n;;=> nothing will be printed...\n```"}],
                                     :full-name "cljs.core/remove-watch",
                                     :clj-symbol "clojure.core/remove-watch",
                                     :docstring "Removes a watch (set by add-watch) from a reference"},
           "cljs.core/m3-hash-unencoded-chars" {:return-type number,
                                                :ns "cljs.core",
                                                :name "m3-hash-unencoded-chars",
                                                :signature ["[in]"],
                                                :history [["+"
                                                           "0.0-2261"]],
                                                :type "function",
                                                :full-name-encode "cljs.core/m3-hash-unencoded-chars",
                                                :source {:code "(defn ^number m3-hash-unencoded-chars [in]\n  (let [h1 (loop [i 1 h1 m3-seed]\n             (if (< i (alength in))\n               (recur (+ i 2)\n                 (m3-mix-H1 h1\n                   (m3-mix-K1\n                     (bit-or (.charCodeAt in (dec i))\n                       (bit-shift-left (.charCodeAt in i) 16)))))\n               h1))\n        h1 (if (== (bit-and (alength in) 1) 1)\n             (bit-xor h1 (m3-mix-K1 (.charCodeAt in (dec (alength in)))))\n             h1)]\n    (m3-fmix h1 (imul 2 (alength in)))))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1.7.228",
                                                         :filename "src/main/cljs/cljs/core.cljs",
                                                         :lines [822
                                                                 834]},
                                                :full-name "cljs.core/m3-hash-unencoded-chars"},
           "cljs.core/es6-iterator-seq" {:ns "cljs.core",
                                         :name "es6-iterator-seq",
                                         :signature ["[iter]"],
                                         :history [["+" "0.0-2411"]],
                                         :type "function",
                                         :full-name-encode "cljs.core/es6-iterator-seq",
                                         :source {:code "(defn es6-iterator-seq\n  [iter]\n  (let [v (.next iter)]\n    (if (.-done v)\n      ()\n      (ES6IteratorSeq. (.-value v) iter nil))))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.7.228",
                                                  :filename "src/main/cljs/cljs/core.cljs",
                                                  :lines [1171 1177]},
                                         :full-name "cljs.core/es6-iterator-seq",
                                         :docstring "EXPERIMENTAL: Given an ES2015 compatible iterator return a seq."},
           "cljs.js/*eval-fn*" {:ns "cljs.js",
                                :name "*eval-fn*",
                                :docstring "Each runtime environment provides various ways to eval JavaScript\nsource. Whatever function *eval-fn* is bound to will be passed a map\ncontaining the following keys:\n\n:source - the source of the library (string)\n:name   - used to unique identify the script (symbol)\n:cache  - if the source was originally ClojureScript, will be given the\n          analysis cache.\n\nThe result of evaluation should be the return value.",
                                :type "dynamic var",
                                :source {:code "(defonce\n  ^{:doc \"Each runtime environment provides various ways to eval JavaScript\n  source. Whatever function *eval-fn* is bound to will be passed a map\n  containing the following keys:\n\n  :source - the source of the library (string)\n  :name   - used to unique identify the script (symbol)\n  :cache  - if the source was originally ClojureScript, will be given the\n            analysis cache.\n\n  The result of evaluation should be the return value.\"\n    :dynamic true}\n  *eval-fn*\n  (fn [js-source]\n    (throw (js/Error. \"No *eval-fn* set\"))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/js.cljs",
                                         :lines [79 93]},
                                :full-name "cljs.js/*eval-fn*",
                                :full-name-encode "cljs.js/STAReval-fnSTAR",
                                :history [["+" "1.7.10"]]},
           "cljs.core/IMultiFn" {:ns "cljs.core",
                                 :name "IMultiFn",
                                 :type "protocol",
                                 :full-name-encode "cljs.core/IMultiFn",
                                 :source {:code "(defprotocol IMultiFn\n  (-reset [mf])\n  (-add-method [mf dispatch-val method])\n  (-remove-method [mf dispatch-val])\n  (-prefer-method [mf dispatch-val dispatch-val-y])\n  (-get-method [mf dispatch-val])\n  (-methods [mf])\n  (-prefers [mf])\n  (-default-dispatch-val [mf])\n  (-dispatch-fn [mf]))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [9599 9608]},
                                 :methods [{:name "-reset",
                                            :signature ["[mf]"],
                                            :docstring nil}
                                           {:name "-add-method",
                                            :signature ["[mf dispatch-val method]"],
                                            :docstring nil}
                                           {:name "-remove-method",
                                            :signature ["[mf dispatch-val]"],
                                            :docstring nil}
                                           {:name "-prefer-method",
                                            :signature ["[mf dispatch-val dispatch-val-y]"],
                                            :docstring nil}
                                           {:name "-get-method",
                                            :signature ["[mf dispatch-val]"],
                                            :docstring nil}
                                           {:name "-methods",
                                            :signature ["[mf]"],
                                            :docstring nil}
                                           {:name "-prefers",
                                            :signature ["[mf]"],
                                            :docstring nil}
                                           {:name "-default-dispatch-val",
                                            :signature ["[mf]"],
                                            :docstring nil}
                                           {:name "-dispatch-fn",
                                            :signature ["[mf]"],
                                            :docstring nil}],
                                 :full-name "cljs.core/IMultiFn",
                                 :history [["+" "0.0-927"]]},
           "clojure.browser.event/IEventType" {:ns "clojure.browser.event",
                                               :name "IEventType",
                                               :type "protocol",
                                               :full-name-encode "clojure.browser.event/IEventType",
                                               :source {:code "(defprotocol IEventType\n  (event-types [this]))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.7.228",
                                                        :filename "src/main/cljs/clojure/browser/event.cljs",
                                                        :lines [16 17]},
                                               :methods [{:name "event-types",
                                                          :signature ["[this]"],
                                                          :docstring nil}],
                                               :full-name "clojure.browser.event/IEventType",
                                               :history [["+"
                                                          "0.0-2301"]]},
           "cljs.core/HashSetIter" {:ns "cljs.core",
                                    :name "HashSetIter",
                                    :type "type",
                                    :signature ["[iter]"],
                                    :source {:code "(deftype HashSetIter [iter]\n  Object\n  (hasNext [_]\n    (.hasNext iter))\n  (next [_]\n    (if ^boolean (.hasNext iter)\n      (aget (.-tail (.next iter)) 0)\n      (throw (js/Error. \"No such element\"))))\n  (remove [_] (js/Error. \"Unsupported operation\")))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [7966 7974]},
                                    :full-name "cljs.core/HashSetIter",
                                    :full-name-encode "cljs.core/HashSetIter",
                                    :history [["+" "1.7.28"]]},
           "clojure.zip/end?" {:ns "clojure.zip",
                               :name "end?",
                               :signature ["[loc]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip/endQMARK",
                               :source {:code "(defn end?\n  [loc]\n    (= :end (loc 1)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/clojure/zip.cljs",
                                        :lines [232 235]},
                               :full-name "clojure.zip/end?",
                               :clj-symbol "clojure.zip/end?",
                               :docstring "Returns true if loc represents the end of a depth-first walk"},
           "clojure.string/starts-with?" {:return-type boolean,
                                          :ns "clojure.string",
                                          :name "starts-with?",
                                          :signature ["[s substr]"],
                                          :history [["+" "1.7.145"]],
                                          :type "function",
                                          :full-name-encode "clojure.string/starts-withQMARK",
                                          :source {:code "(defn ^boolean starts-with?\n  [s substr]\n  (gstring/startsWith s substr))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/cljs/clojure/string.cljs",
                                                   :lines [245 248]},
                                          :full-name "clojure.string/starts-with?",
                                          :docstring "True if s starts with substr."},
           "cljs.test/clear-env!" {:ns "cljs.test",
                                   :name "clear-env!",
                                   :type "function",
                                   :signature ["[]"],
                                   :source {:code "(defn clear-env! []\n  (set! *current-env* nil))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/cljs/test.cljs",
                                            :lines [280 281]},
                                   :full-name "cljs.test/clear-env!",
                                   :full-name-encode "cljs.test/clear-envBANG",
                                   :history [["+" "0.0-2496"]]},
           "cljs.analyzer.api/ns-resolve" {:ns "cljs.analyzer.api",
                                           :name "ns-resolve",
                                           :signature ["[ns sym]"
                                                       "[state ns sym]"],
                                           :history [["+" "0.0-2496"]],
                                           :type "function",
                                           :full-name-encode "cljs.analyzer.api/ns-resolve",
                                           :source {:code "(defn ns-resolve\n  ([ns sym]\n   (ns-resolve env/*compiler* ns sym))\n  ([state ns sym]\n   {:pre [(symbol? ns) (symbol? sym)]}\n   (get-in @state [::ana/namespaces ns :defs sym])))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.7.228",
                                                    :filename "src/main/clojure/cljs/analyzer/api.clj",
                                                    :lines [193 200]},
                                           :full-name "cljs.analyzer.api/ns-resolve",
                                           :clj-symbol "clojure.core/ns-resolve",
                                           :docstring "Given a namespace and a symbol return the corresponding var analysis map.\nAnalagous to clojure.core/ns-resolve but returns var analysis map not Var."},
           "special/try" {:description "The expressions (`expr*`) are evaluated and, if no exceptions occur, the value\nof the last is returned.\n\nIf an exception occurs and catch clauses (`catch-clause*`) are provided, each is\nexamined in turn and the first for which the thrown exception is an instance of\nthe named class is considered a matching catch clause. If there is a matching\ncatch clause, its expressions are evaluated in a context in which name is bound\nto the thrown exception, and the value of the last is the return value of the\nfunction.\n\nIf there is no matching catch clause, the exception propagates out of the\nfunction. Before returning, normally or abnormally, any `finally-clause?`\nexpressions will be evaluated for their side effects.\n\n`try` is one of ClojureScript's [special forms](http://clojure.org/special_forms).",
                          :ns "special",
                          :name "try",
                          :signature ["[expr* catch-clause* finally-clause?]"],
                          :history [["+" "0.0-1933"]],
                          :type "special form",
                          :related ["special/catch"
                                    "special/finally"
                                    "special/throw"],
                          :full-name-encode "special/try",
                          :source {:code "(defmethod parse 'try\n  [op env [_ & body :as form] name _]\n  (let [catchenv (update-in env [:context] #(if (= :expr %) :return %))\n        catch? (every-pred seq? #(= (first %) 'catch))\n        default? (every-pred catch? #(= (second %) :default))\n        finally? (every-pred seq? #(= (first %) 'finally))\n\n        {:keys [body cblocks dblock fblock]}\n        (loop [parser {:state :start :forms body\n                       :body [] :cblocks [] :dblock nil :fblock nil}]\n          (if (seq? (:forms parser))\n            (let [[form & forms*] (:forms parser)\n                  parser* (assoc parser :forms forms*)]\n              (case (:state parser)\n                :start (cond\n                         (catch? form) (recur (assoc parser :state :catches))\n                         (finally? form) (recur (assoc parser :state :finally))\n                         :else (recur (update-in parser* [:body] conj form)))\n                :catches (cond\n                           (default? form) (recur (assoc parser* :dblock form :state :finally))\n                           (catch? form) (recur (update-in parser* [:cblocks] conj form))\n                           (finally? form) (recur (assoc parser :state :finally))\n                           :else (throw (error env \"Invalid try form\")))\n                :finally (recur (assoc parser* :fblock form :state :done))\n                :done (throw (error env \"Unexpected form after finally\"))))\n            parser))\n\n        finally (when (seq fblock)\n                  (analyze (assoc env :context :statement) `(do ~@(rest fblock))))\n        e (when (or (seq cblocks) dblock) (gensym \"e\"))\n        default (if-let [[_ _ name & cb] dblock]\n                  `(cljs.core/let [~name ~e] ~@cb)\n                  `(throw ~e))\n        cblock (if (seq cblocks)\n                 `(cljs.core/cond\n                   ~@(mapcat\n                      (fn [[_ type name & cb]]\n                        (when name (assert (not (namespace name)) \"Can't qualify symbol in catch\"))\n                        `[(cljs.core/instance? ~type ~e)\n                          (cljs.core/let [~name ~e] ~@cb)])\n                      cblocks)\n                   :else ~default)\n                 default)\n        locals (:locals catchenv)\n        locals (if e\n                 (assoc locals e\n                        {:name e\n                         :line (get-line e env)\n                         :column (get-col e env)})\n                 locals)\n        catch (when cblock\n                (analyze (assoc catchenv :locals locals) cblock))\n        try (analyze (if (or e finally) catchenv env) `(do ~@body))]\n\n    {:env env :op :try :form form\n     :try try\n     :finally finally\n     :name e\n     :catch catch\n     :children [try catch finally]}))",
                                   :title "Parser code",
                                   :repo "clojurescript",
                                   :tag "r1.7.228",
                                   :filename "src/main/clojure/cljs/analyzer.cljc",
                                   :lines [1008 1067]},
                          :full-name "special/try",
                          :clj-symbol "clojure.core/try",
                          :docstring "catch-clause => (catch classname name expr*)\nfinally-clause => (finally expr*)\nCatches and handles JavaScript exceptions."},
           "cljs.repl/update-require-spec" {:ns "cljs.repl",
                                            :name "update-require-spec",
                                            :signature ["[specs & additions]"],
                                            :history [["+" "0.0-2629"]
                                                      ["-" "0.0-2655"]],
                                            :type "function",
                                            :full-name-encode "cljs.repl/update-require-spec",
                                            :source {:code "(defn update-require-spec\n  [specs & additions]\n  (let [[before [requires & other-specs]]\n        (split-with\n          (fn [[x _]] (not= :require x))\n          specs)\n        requires'\n        `(:require\n           ~@(reduce\n               (fn [requires spec]\n                 (merge-require requires spec))\n               (rest requires)\n               additions))]\n    (concat before [requires'] other-specs)))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2644",
                                                     :filename "src/clj/cljs/repl.clj",
                                                     :lines [226 241]},
                                            :full-name "cljs.repl/update-require-spec",
                                            :docstring "Given the specification portion of a ns form and require spec additions\nreturn an updated specification.",
                                            :removed {:in "0.0-2655",
                                                      :last-seen "0.0-2644"}},
           "cljs.test/test-all-vars-block" {:ns "cljs.test",
                                            :name "test-all-vars-block",
                                            :type "macro",
                                            :signature ["[[quote ns]]"],
                                            :source {:code "(defmacro test-all-vars-block\n  ([[quote ns]]\n   `(let [env# (cljs.test/get-current-env)]\n      (concat\n       [(fn []\n          (when (nil? env#)\n            (cljs.test/set-env! (cljs.test/empty-env)))\n          ~(when (ana-api/ns-resolve ns 'cljs-test-once-fixtures)\n             `(cljs.test/update-current-env! [:once-fixtures] assoc '~ns\n                                             ~(symbol (name ns) \"cljs-test-once-fixtures\")))\n          ~(when (ana-api/ns-resolve ns 'cljs-test-each-fixtures)\n             `(cljs.test/update-current-env! [:each-fixtures] assoc '~ns\n                                             ~(symbol (name ns) \"cljs-test-each-fixtures\"))))]\n       (cljs.test/test-vars-block\n        [~@(->> (ana-api/ns-interns ns)\n                (filter (fn [[_ v]] (:test v)))\n                (sort-by (fn [[_ v]] (:line v)))\n                (map (fn [[k _]]\n                       `(var ~(symbol (name ns) (name k))))))])\n       [(fn []\n          (when (nil? env#)\n            (cljs.test/clear-env!)))]))))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.7.228",
                                                     :filename "src/main/cljs/cljs/test.clj",
                                                     :lines [311 332]},
                                            :full-name "cljs.test/test-all-vars-block",
                                            :full-name-encode "cljs.test/test-all-vars-block",
                                            :history [["+" "0.0-2814"]]},
           "clojure.set/superset?" {:description "Returns true if `a` is a superset of `b`, false otherwise.\n\nIn other words, returns true if `a` contains all the elements of `b`.",
                                    :ns "clojure.set",
                                    :name "superset?",
                                    :signature ["[a b]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :related ["cljs.core/set"
                                              "cljs.core/set?"
                                              "clojure.set/subset?"],
                                    :full-name-encode "clojure.set/supersetQMARK",
                                    :source {:code "(defn superset? \n  [set1 set2]\n  (and (>= (count set1) (count set2))\n       (every? #(contains? set1 %) set2)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/clojure/set.cljs",
                                             :lines [137 141]},
                                    :full-name "clojure.set/superset?",
                                    :clj-symbol "clojure.set/superset?",
                                    :docstring "Is set1 a superset of set2?"},
           "cljs.repl/repl" {:ns "cljs.repl",
                             :name "repl",
                             :signature ["[repl-env & opts]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.repl/repl",
                             :source {:code "(defn repl\n  [repl-env & opts]\n  (assert (even? (count opts))\n    \"Arguments after repl-env must be interleaved key value pairs\")\n  (repl* repl-env (apply hash-map opts)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/clojure/cljs/repl.cljc",
                                      :lines [913 983]},
                             :full-name "cljs.repl/repl",
                             :docstring "Generic, reusable, read-eval-print loop. By default, reads from *in* using\na c.t.r.reader-types/source-logging-push-back-reader,\nwrites to *out*, and prints exception summaries to *err*. If you use the\ndefault :read hook, *in* must either be an instance of\nc.t.r.reader-types/PushbackReader or duplicate its behavior of both supporting\nunread and collapsing CR, LF, and CRLF into a single \\newline. Options\nare sequential keyword-value pairs. The first argument is the JavaScript\nevaluation environment, the second argument is an extended version of the\nstandard ClojureScript compiler options. In addition to ClojureScript compiler\nbuild options it also take a set of options similar to clojure.main/repl with\nadjustments for ClojureScript evalution and compilation model:\n\nAvailable clojure.main/repl style options and their defaults:\n\n   - :init, function of no arguments, initialization hook called with\n     bindings for set!-able vars in place.\n     default: #()\n\n   - :need-prompt, function of no arguments, called before each\n     read-eval-print except the first, the user will be prompted if it\n     returns true.\n     default: #(if (c.t.r.readers-types/indexing-reader? *in*)\n                 (== (c.t.r.reader-types/get-column-number *in*) 1)\n                 (identity true))\n\n   - :prompt, function of no arguments, prompts for more input.\n     default: repl-prompt\n\n   - :flush, function of no arguments, flushes output\n     default: flush\n\n   - :read, function of two arguments, reads from *in*:\n       - returns its first argument to request a fresh prompt\n         - depending on need-prompt, this may cause the repl to prompt\n           before reading again\n       - returns its second argument to request an exit from the repl\n       - else returns the next object read from the input stream\n     default: repl-read\n\n   - :eval, function of one argument, returns the evaluation of its\n     argument. The eval function must take repl-env, the JavaScript evaluation\n     environment, env, the ClojureScript analysis environment, the form\n     and opts, the standard ClojureScript REPL/compiler options.\n     default: eval\n\n   - :print, function of one argument, prints its argument to the output\n     default: println\n\n   - :caught, function of three arguments, a throwable, called when\n     read, eval, or print throws an exception or error default. The second\n     argument is the JavaScript evaluation environment this permits context\n     sensitive handling if necessary. The third argument is opts, the standard\n     ClojureScript REPL/compiler options. In the case of errors or exception\n     in the JavaScript target, these will be thrown as\n     clojure.lang.IExceptionInfo instances.\n     default: repl-caught\n\n   - :reader, the c.t.r reader to use.\n     default: c.t.r.reader-types/source-logging-push-back-reader\n\n   - :print-no-newline, print without a newline.\n     default: print\n\n   - :source-map-inline, whether inline source maps should be enabled. Most\n     useful in browser context. Implies using a fresh reader for each form.\n     default: true"},
           "clojure.browser.net/IConnection" {:ns "clojure.browser.net",
                                              :name "IConnection",
                                              :type "protocol",
                                              :full-name-encode "clojure.browser.net/IConnection",
                                              :source {:code "(defprotocol IConnection\n  (connect\n    [this]\n    [this opt1]\n    [this opt1 opt2]\n    [this opt1 opt2 opt3])\n  (transmit\n    [this opt]\n    [this opt opt2]\n    [this opt opt2 opt3]\n    [this opt opt2 opt3 opt4]\n    [this opt opt2 opt3 opt4 opt5])\n  (close [this]))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.7.228",
                                                       :filename "src/main/cljs/clojure/browser/net.cljs",
                                                       :lines [30 42]},
                                              :methods [{:name "connect",
                                                         :signature ["[this]"
                                                                     "[this opt1]"
                                                                     "[this opt1 opt2]"
                                                                     "[this opt1 opt2 opt3]"],
                                                         :docstring nil}
                                                        {:name "transmit",
                                                         :signature ["[this opt]"
                                                                     "[this opt opt2]"
                                                                     "[this opt opt2 opt3]"
                                                                     "[this opt opt2 opt3 opt4]"
                                                                     "[this opt opt2 opt3 opt4 opt5]"],
                                                         :docstring nil}
                                                        {:name "close",
                                                         :signature ["[this]"],
                                                         :docstring nil}],
                                              :full-name "clojure.browser.net/IConnection",
                                              :history [["+"
                                                         "0.0-927"]]},
           "cljs.core/let" {:description "Binds expressions to symbols and makes those symbols available only within\n`body`.\n\n`bindings` should be a vector with an even number of forms, ie: `[a1 b1, a2 b2,\na3 b3]`. The first item in a pair (the `a`s) should be a symbol that is assigned\nthe evaluation of the second item (the `b`s). These symbols (the `a`s) are then\navailable within `body` (and not outside of `body`).\n\nAnother way to think about this is that the binding symbols in `let` are like\nlocal `def`s that are only available within `let`'s scope.\n\nIn addition to direct symbol binding, `let` supports a destructuring syntax to\n\"break apart\" collections into multiple symbols. This destructuring syntax is\nlike it's own [mini-language] and allows for succinct code.\n\n`let` is a wrapper over one of ClojureScript's [special forms] and is a\nfundamental building block of the language. Many macros rely on `let`s binding\nsyntax and scope rules.\n\n[mini-language]:http://blog.jayfields.com/2010/07/clojure-destructuring.html\n[special forms]:http://clojure.org/special_forms",
                            :ns "cljs.core",
                            :name "let",
                            :signature ["[bindings & body]"],
                            :history [["+" "0.0-927"]],
                            :type "macro",
                            :related ["cljs.core/letfn"
                                      "cljs.core/if-let"],
                            :full-name-encode "cljs.core/let",
                            :source {:code "(core/defmacro let\n  [bindings & body]\n  (assert-args let\n     (vector? bindings) \"a vector for its binding\"\n     (even? (count bindings)) \"an even number of forms in binding vector\")\n  `(let* ~(destructure bindings) ~@body))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.7.228",
                                     :filename "src/main/clojure/cljs/core.cljc",
                                     :lines [720 730]},
                            :full-name "cljs.core/let",
                            :clj-symbol "clojure.core/let",
                            :docstring "binding => binding-form init-expr\n\nEvaluates the exprs in a lexical context in which the symbols in\nthe binding-forms are bound to their respective init-exprs or parts\ntherein."},
           "cljs.core/unchecked-divide-int" {:return-type number,
                                             :ns "cljs.core",
                                             :name "unchecked-divide-int",
                                             :signature ["[x]"
                                                         "[x y]"
                                                         "[x y & more]"],
                                             :history [["+"
                                                        "0.0-1798"]],
                                             :type "function/macro",
                                             :full-name-encode "cljs.core/unchecked-divide-int",
                                             :source {:code "(defn ^number unchecked-divide-int\n  ([x] (unchecked-divide-int 1 x))\n  ([x y] (cljs.core/divide x y)) ;; FIXME: waiting on cljs.core//\n  ([x y & more] (reduce unchecked-divide-int (unchecked-divide-int x y) more)))",
                                                      :title "Function code",
                                                      :repo "clojurescript",
                                                      :tag "r1.7.228",
                                                      :filename "src/main/cljs/cljs/core.cljs",
                                                      :lines [2400
                                                              2405]},
                                             :extra-sources [{:code "(core/defmacro ^::ana/numeric unchecked-divide-int\n  ([& xs] `(/ ~@xs)))",
                                                              :title "Macro code",
                                                              :repo "clojurescript",
                                                              :tag "r1.7.228",
                                                              :filename "src/main/clojure/cljs/core.cljc",
                                                              :lines [986
                                                                      987]}],
                                             :full-name "cljs.core/unchecked-divide-int",
                                             :clj-symbol "clojure.core/unchecked-divide-int",
                                             :docstring "If no denominators are supplied, returns 1/numerator,\nelse returns numerator divided by all of the denominators."},
           "cljs.repl.nashorn/create-engine" {:ns "cljs.repl.nashorn",
                                              :name "create-engine",
                                              :type "function",
                                              :signature ["[]"
                                                          "[{:keys [code-cache], :or {code-cache true}}]"],
                                              :source {:code "    (defn create-engine\n      ([] (create-engine nil))\n      ([{:keys [code-cache] :or {code-cache true}}]\n       (let [args (when code-cache [\"-pcc\"])\n             factories (.getEngineFactories (ScriptEngineManager.))\n             factory (get (zipmap (map #(.getEngineName %) factories) factories) \"Oracle Nashorn\")]\n         (if-let [engine (if-not (empty? args)\n                           (.getScriptEngine ^ScriptEngineFactory factory (into-array args))\n                           (.getScriptEngine ^ScriptEngineFactory factory))]\n           (let [context (.getContext engine)]\n             (.setWriter context *out*)\n             (.setErrorWriter context *err*)\n             engine)\n           (throw (IllegalArgumentException.\n                    \"Cannot find the Nashorn script engine, use a JDK version 8 or higher.\"))))))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.7.228",
                                                       :filename "src/main/clojure/cljs/repl/nashorn.clj",
                                                       :lines [29 43]},
                                              :full-name "cljs.repl.nashorn/create-engine",
                                              :full-name-encode "cljs.repl.nashorn/create-engine",
                                              :history [["+"
                                                         "0.0-2814"]]},
           "cljs.core/dorun" {:description "Forces evaluation of a lazy sequence. Often used to see the effects of a\nsequence produced via functions that have side effects.\n\n`dorun` walks through the successive `next`s of the sequence and returns nil.",
                              :ns "cljs.core",
                              :name "dorun",
                              :signature ["[coll]" "[n coll]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/doall"],
                              :full-name-encode "cljs.core/dorun",
                              :source {:code "(defn dorun\n  ([coll]\n   (when (seq coll)\n     (recur (next coll))))\n  ([n coll]\n   (when (and (seq coll) (pos? n))\n     (recur (dec n) (next coll)))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [8664 8675]},
                              :full-name "cljs.core/dorun",
                              :clj-symbol "clojure.core/dorun",
                              :docstring "When lazy sequences are produced via functions that have side\neffects, any effects other than those needed to produce the first\nelement in the seq do not occur until the seq is consumed. dorun can\nbe used to force any effects. Walks through the successive nexts of\nthe seq, does not retain the head and returns nil."},
           "cljs.core/with-redefs" {:ns "cljs.core",
                                    :name "with-redefs",
                                    :signature ["[bindings & body]"],
                                    :history [["+" "0.0-1806"]],
                                    :type "macro",
                                    :full-name-encode "cljs.core/with-redefs",
                                    :source {:code "(core/defmacro with-redefs\n  [bindings & body]\n  (core/let [names (take-nth 2 bindings)\n             vals (take-nth 2 (drop 1 bindings))\n             tempnames (map (comp gensym name) names)\n             binds (map core/vector names vals)\n             resets (reverse (map core/vector names tempnames))\n             bind-value (core/fn [[k v]] (core/list 'set! k v))]\n    `(let [~@(interleave tempnames names)]\n       ~@(map bind-value binds)\n       (try\n         ~@body\n         (finally\n           ~@(map bind-value resets))))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/clojure/cljs/core.cljc",
                                             :lines [1993 2013]},
                                    :full-name "cljs.core/with-redefs",
                                    :clj-symbol "clojure.core/with-redefs",
                                    :docstring "binding => var-symbol temp-value-expr\n\nTemporarily redefines vars while executing the body.  The\ntemp-value-exprs will be evaluated and each resulting value will\nreplace in parallel the root value of its var.  After the body is\nexecuted, the root values of all the vars will be set back to their\nold values. Useful for mocking out functions during testing."},
           "cljs.core/SeqIter" {:ns "cljs.core",
                                :name "SeqIter",
                                :signature ["[_seq _next]"],
                                :history [["+" "0.0-2301"]],
                                :type "type",
                                :full-name-encode "cljs.core/SeqIter",
                                :source {:code "(deftype SeqIter [^:mutable _seq ^:mutable _next]\n  Object\n  (hasNext [_]\n    (if (identical? _seq INIT)\n      (do\n        (set! _seq START)\n        (set! _next (seq _next)))\n      (if (identical? _seq _next)\n        (set! _next (next _seq))))\n    (not (nil? _next)))\n  (next [this]\n    (if-not (.hasNext this)\n      (throw (js/Error. \"No such element\"))\n      (do\n        (set! _seq _next)\n        (first _next))))\n  (remove [_] (js/Error. \"Unsupported operation\")))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [3555 3571]},
                                :full-name "cljs.core/SeqIter",
                                :clj-symbol "clojure.lang/SeqIterator"},
           "cljs.core/munge" {:ns "cljs.core",
                              :name "munge",
                              :type "function",
                              :signature ["[name]"],
                              :source {:code "(defn munge [name]\n  (let [name' (munge-str (str name))\n        name' (cond\n                (identical? name' \"..\") \"_DOT__DOT_\"\n                (js-reserved? name') (str name' \"$\")\n                :else name')]\n    (if (symbol? name)\n      (symbol name')\n      (str name'))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [10071 10079]},
                              :full-name "cljs.core/munge",
                              :full-name-encode "cljs.core/munge",
                              :history [["+" "1.7.10"]]},
           "cljs.core/unsigned-bit-shift-right" {:description "Bitwise shift right with zero fill",
                                                 :ns "cljs.core",
                                                 :name "unsigned-bit-shift-right",
                                                 :signature ["[x n]"],
                                                 :history [["+"
                                                            "0.0-2080"]],
                                                 :type "function/macro",
                                                 :related ["cljs.core/bit-shift-right"],
                                                 :full-name-encode "cljs.core/unsigned-bit-shift-right",
                                                 :source {:code "(defn unsigned-bit-shift-right\n  [x n] (cljs.core/unsigned-bit-shift-right x n))",
                                                          :title "Function code",
                                                          :repo "clojurescript",
                                                          :tag "r1.7.228",
                                                          :filename "src/main/cljs/cljs/core.cljs",
                                                          :lines [2568
                                                                  2570]},
                                                 :extra-sources [{:code "(core/defmacro ^::ana/numeric unsigned-bit-shift-right [x n]\n  (core/list 'js* \"(~{} >>> ~{})\" x n))",
                                                                  :title "Macro code",
                                                                  :repo "clojurescript",
                                                                  :tag "r1.7.228",
                                                                  :filename "src/main/clojure/cljs/core.cljc",
                                                                  :lines [1137
                                                                          1138]}],
                                                 :full-name "cljs.core/unsigned-bit-shift-right",
                                                 :clj-symbol "clojure.core/unsigned-bit-shift-right",
                                                 :docstring "Bitwise shift right with zero fill"},
           "cljs.core/iterable?" {:return-type boolean,
                                  :ns "cljs.core",
                                  :name "iterable?",
                                  :signature ["[x]"],
                                  :history [["+" "0.0-2356"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/iterableQMARK",
                                  :source {:code "(defn ^boolean iterable?\n  [x]\n  (satisfies? IIterable x))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [1055 1058]},
                                  :full-name "cljs.core/iterable?",
                                  :docstring "Return true if x implements IIterable protocol."},
           "cljs.core/pr-str" {:ns "cljs.core",
                               :name "pr-str",
                               :signature ["[& objs]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/pr-str",
                               :source {:code "(defn pr-str\n  [& objs]\n  (pr-str-with-opts objs (pr-opts)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [8931 8934]},
                               :full-name "cljs.core/pr-str",
                               :clj-symbol "clojure.core/pr-str",
                               :docstring "pr to a string, returning it. Fundamental entrypoint to IPrintWithWriter."},
           "cljs.core/IPrintable" {:ns "cljs.core",
                                   :name "IPrintable",
                                   :history [["+" "0.0-927"]
                                             ["-" "0.0-1798"]],
                                   :type "protocol",
                                   :full-name-encode "cljs.core/IPrintable",
                                   :source {:code "(defprotocol ^:deprecated IPrintable\n  \"Do not use this.  It is kept for backwards compatibility with existing\n   user code that depends on it, but it has been superceded by IPrintWithWriter\n   User code that depends on this should be changed to use -pr-writer instead.\"\n  (-pr-seq [o opts]))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1586",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [253 257]},
                                   :methods [{:name "-pr-seq",
                                              :signature ["[o opts]"],
                                              :docstring nil}],
                                   :full-name "cljs.core/IPrintable",
                                   :docstring "Do not use this.  It is kept for backwards compatibility with existing\n   user code that depends on it, but it has been superceded by IPrintWithWriter\n   User code that depends on this should be changed to use -pr-writer instead.",
                                   :removed {:in "0.0-1798",
                                             :last-seen "0.0-1586"}},
           "cljs.build.api/src-file->target-file" {:return-type File,
                                                   :ns "cljs.build.api",
                                                   :name "src-file->target-file",
                                                   :signature ["[src]"
                                                               "[src opts]"
                                                               "[state src opts]"],
                                                   :history [["+"
                                                              "0.0-2629"]],
                                                   :type "function",
                                                   :full-name-encode "cljs.build.api/src-file-GTtarget-file",
                                                   :source {:code "(defn ^File src-file->target-file\n  ([src] (src-file->target-file src nil))\n  ([src opts]\n   (src-file->target-file\n     (if-not (nil? env/*compiler*)\n       env/*compiler*\n       (env/default-compiler-env opts))\n     src opts))\n  ([state src opts]\n   (env/with-compiler-env state\n     (binding [ana/*cljs-warning-handlers* (:warning-handlers opts ana/*cljs-warning-handlers*)]\n       (closure/src-file->target-file src opts)))))",
                                                            :title "Source code",
                                                            :repo "clojurescript",
                                                            :tag "r1.7.228",
                                                            :filename "src/main/clojure/cljs/build/api.clj",
                                                            :lines [80
                                                                    93]},
                                                   :full-name "cljs.build.api/src-file->target-file",
                                                   :docstring "Given a ClojureScript source file return the target file. May optionally\nprovide build options with :output-dir specified."},
           "cljs.core/defprotocol" {:ns "cljs.core",
                                    :name "defprotocol",
                                    :signature ["[psym & doc+methods]"],
                                    :history [["+" "0.0-927"]],
                                    :type "macro",
                                    :full-name-encode "cljs.core/defprotocol",
                                    :source {:code "(core/defmacro defprotocol\n  [psym & doc+methods]\n  (core/let [p (:name (cljs.analyzer/resolve-var (dissoc &env :locals) psym))\n             [doc methods] (if (core/string? (first doc+methods))\n                             [(first doc+methods) (next doc+methods)]\n                             [nil doc+methods])\n             psym (vary-meta psym assoc\n                    :doc doc\n                    :protocol-symbol true)\n             ns-name (core/-> &env :ns :name)\n             fqn (core/fn [n] (symbol (core/str ns-name \".\" n)))\n             prefix (protocol-prefix p)\n             _ (core/doseq [[mname & arities] methods]\n                 (core/when (some #{0} (map count (filter vector? arities)))\n                   (throw\n                     #?(:clj (Exception.\n                               (core/str \"Invalid protocol, \" psym\n                                 \" defines method \" mname \" with arity 0\"))\n                        :cljs (js/Error.\n                                (core/str \"Invalid protocol, \" psym\n                                  \" defines method \" mname \" with arity 0\"))))))\n             expand-sig (core/fn [fname slot sig]\n                          `(~sig\n                             (if (and (not (nil? ~(first sig)))\n                                      (not (nil? (. ~(first sig) ~(symbol (core/str \"-\" slot)))))) ;; Property access needed here.\n                               (. ~(first sig) ~slot ~@sig)\n                               (let [x# (if (nil? ~(first sig)) nil ~(first sig))\n                                     m# (aget ~(fqn fname) (goog/typeOf x#))]\n                                 (if-not (nil? m#)\n                                   (m# ~@sig)\n                                   (let [m# (aget ~(fqn fname) \"_\")]\n                                     (if-not (nil? m#)\n                                       (m# ~@sig)\n                                       (throw\n                                         (missing-protocol\n                                           ~(core/str psym \".\" fname) ~(first sig))))))))))\n             psym (core/-> psym\n                    (vary-meta update-in [:jsdoc] conj\n                      \"@interface\")\n                    (vary-meta assoc-in [:protocol-info :methods]\n                      (into {}\n                        (map\n                          (core/fn [[fname & sigs]]\n                            (core/let [doc (core/as-> (last sigs) doc\n                                             (core/when (core/string? doc) doc))\n                                       sigs (take-while vector? sigs)]\n                              [(vary-meta fname assoc :doc doc)\n                               (vec sigs)]))\n                          methods))))\n             method (core/fn [[fname & sigs]]\n                      (core/let [doc (core/as-> (last sigs) doc\n                                       (core/when (core/string? doc) doc))\n                                 sigs (take-while vector? sigs)\n                                 amp (core/when (some #{'&} (apply concat sigs))\n                                       (cljs.analyzer/warning\n                                        :protocol-with-variadic-method\n                                        &env {:protocol psym :name fname}))\n                                 slot (symbol (core/str prefix (name fname)))\n                                 fname (vary-meta fname assoc\n                                         :protocol p\n                                         :doc doc)]\n                        `(defn ~fname\n                           ~@(map (core/fn [sig]\n                                    (expand-sig fname\n                                      (symbol (core/str slot \"$arity$\" (count sig)))\n                                      sig))\n                               sigs))))]\n    `(do\n       (set! ~'*unchecked-if* true)\n       (def ~psym (~'js* \"function(){}\"))\n       ~@(map method methods)\n       (set! ~'*unchecked-if* false))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/clojure/cljs/core.cljc",
                                             :lines [1809 1919]},
                                    :full-name "cljs.core/defprotocol",
                                    :clj-symbol "clojure.core/defprotocol",
                                    :docstring "A protocol is a named set of named methods and their signatures:\n\n(defprotocol AProtocolName\n  ;optional doc string\n  \"A doc string for AProtocol abstraction\"\n\n;method signatures\n  (bar [this a b] \"bar docs\")\n  (baz [this a] [this a b] [this a b c] \"baz docs\"))\n\nNo implementations are provided. Docs can be specified for the\nprotocol overall and for each method. The above yields a set of\npolymorphic functions and a protocol object. All are\nnamespace-qualified by the ns enclosing the definition The resulting\nfunctions dispatch on the type of their first argument, which is\nrequired and corresponds to the implicit target object ('this' in\nJavaScript parlance). defprotocol is dynamic, has no special compile-time\neffect, and defines no new types.\n\n(defprotocol P\n  (foo [this])\n  (bar-me [this] [this y]))\n\n(deftype Foo [a b c]\n  P\n  (foo [this] a)\n  (bar-me [this] b)\n  (bar-me [this y] (+ c y)))\n\n(bar-me (Foo. 1 2 3) 42)\n=> 45\n\n(foo\n  (let [x 42]\n    (reify P\n      (foo [this] 17)\n      (bar-me [this] x)\n      (bar-me [this y] x))))\n=> 17"},
           "cljs.core/ints" {:ns "cljs.core",
                             :name "ints",
                             :signature ["[x]"],
                             :history [["+" "0.0-1798"]],
                             :type "function",
                             :full-name-encode "cljs.core/ints",
                             :source {:code "(defn ints [x] x)",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [2481]},
                             :full-name "cljs.core/ints",
                             :clj-symbol "clojure.core/ints"},
           "cljs.core/assert" {:description "Evaluates expression `expr` and throws an exception if it does not evaluate to\nlogical true.  Exception will include `message` if given.\n\nReturns `nil`.",
                               :ns "cljs.core",
                               :name "assert",
                               :signature ["[expr]" "[expr message]"],
                               :history [["+" "0.0-927"]],
                               :type "macro",
                               :full-name-encode "cljs.core/assert",
                               :source {:code "(core/defmacro assert\n  ([x]\n     (core/when *assert*\n       `(when-not ~x\n          (throw (js/Error.\n                  (cljs.core/str \"Assert failed: \" (cljs.core/pr-str '~x)))))))\n  ([x message]\n     (core/when *assert*\n       `(when-not ~x\n          (throw (js/Error.\n                  (cljs.core/str \"Assert failed: \" ~message \"\\n\" (cljs.core/pr-str '~x))))))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/clojure/cljs/core.cljc",
                                        :lines [2163 2175]},
                               :examples [{:id "1dc16f",
                                           :content "```clj\n(assert true)\n;;=> nil\n\n(assert false)\n;;=> Uncaught Error: Assert failed: false\n\n(assert (= 1 2) \"1 is not 2\")\n;;=> Uncaught Error: Assert failed: 1 is not 2\n;;   (= 1 2)\n```"}],
                               :full-name "cljs.core/assert",
                               :clj-symbol "clojure.core/assert",
                               :docstring "Evaluates expr and throws an exception if it does not evaluate to\nlogical true."},
           "cljs.core/declare" {:description "Uses `def` to establish symbols of `names` with no bindings.\n\nUseful for making forward declarations.",
                                :ns "cljs.core",
                                :name "declare",
                                :signature ["[& names]"],
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :related ["special/def"],
                                :full-name-encode "cljs.core/declare",
                                :source {:code "(defmacro declare\n  [& names] `(do ~@(map #(list 'def (vary-meta % assoc :declared true)) names)))",
                                         :title "Source code",
                                         :repo "clojure",
                                         :tag "clojure-1.7.0",
                                         :filename "src/clj/clojure/core.clj",
                                         :lines [2645 2648]},
                                :examples [{:id "5a2dc2",
                                            :content "```clj\na\n;; WARNING: Use of undeclared Var\n\n(declare a)\na\n;;=> nil\n```"}],
                                :full-name "cljs.core/declare",
                                :clj-symbol "clojure.core/declare",
                                :docstring "defs the supplied var names with no bindings, useful for making forward declarations."},
           "cljs.core/PersistentTreeMap.EMPTY" {:ns "cljs.core",
                                                :name "PersistentTreeMap.EMPTY",
                                                :history [["+"
                                                           "0.0-1211"]],
                                                :parent-type "PersistentTreeMap",
                                                :type "var",
                                                :full-name-encode "cljs.core/PersistentTreeMapDOTEMPTY",
                                                :source {:code "(set! (.-EMPTY PersistentTreeMap) (PersistentTreeMap. compare nil 0 nil empty-unordered-hash))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1.7.228",
                                                         :filename "src/main/cljs/cljs/core.cljs",
                                                         :lines [7734]},
                                                :full-name "cljs.core/PersistentTreeMap.EMPTY",
                                                :clj-symbol "clojure.lang/PersistentTreeMap.EMPTY"},
           "cljs.core/fn?" {:description "Returns true if `f` is a function, false otherwise.",
                            :return-type boolean,
                            :ns "cljs.core",
                            :name "fn?",
                            :signature ["[f]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/ifn?"],
                            :full-name-encode "cljs.core/fnQMARK",
                            :source {:code "(defn ^boolean fn?\n  [f]\n  (or ^boolean (goog/isFunction f) (satisfies? Fn f)))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.7.228",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [1780 1783]},
                            :full-name "cljs.core/fn?",
                            :clj-symbol "clojure.core/fn?",
                            :docstring "Return true if f is a JavaScript function or satisfies the Fn protocol."},
           "cljs.compiler.api/with-core-cljs" {:ns "cljs.compiler.api",
                                               :name "with-core-cljs",
                                               :signature ["[]"
                                                           "[opts]"
                                                           "[opts body]"
                                                           "[state opts body]"],
                                               :history [["+"
                                                          "0.0-3255"]],
                                               :type "function",
                                               :full-name-encode "cljs.compiler.api/with-core-cljs",
                                               :source {:code "(defn with-core-cljs\n  ([] (comp/with-core-cljs nil))\n  ([opts] (with-core-cljs opts (fn [])))\n  ([opts body]\n   (with-core-cljs\n     (if-not (nil? env/*compiler*)\n       env/*compiler*\n       (env/default-compiler-env opts))\n     opts body))\n  ([state opts body]\n   (env/with-compiler-env state\n     (binding [ana/*cljs-warning-handlers* (:warning-handlers opts ana/*cljs-warning-handlers*)]\n       (comp/with-core-cljs opts body)))))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.7.228",
                                                        :filename "src/main/clojure/cljs/compiler/api.clj",
                                                        :lines [33 46]},
                                               :full-name "cljs.compiler.api/with-core-cljs",
                                               :docstring "Ensure that core.cljs has been loaded."},
           "cljs.core/associative?" {:description "Returns true if `coll` implements the `IAssociative` protocol, false otherwise.\n\nMaps and vectors are associative.",
                                     :return-type boolean,
                                     :ns "cljs.core",
                                     :name "associative?",
                                     :signature ["[coll]"],
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "cljs.core/associativeQMARK",
                                     :source {:code "(defn ^boolean associative?\n  [x] (satisfies? IAssociative x))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/cljs/cljs/core.cljs",
                                              :lines [1903 1905]},
                                     :examples [{:id "29a37f",
                                                 :content "```clj\n(associative? [1 2 3])\n;;=> true\n\n(associative? {:a 1 :b 2})\n;;=> true\n\n(associative? #{1 2 3})\n;;=> false\n\n(associative? '(1 2 3))\n;;=> false\n```"}],
                                     :full-name "cljs.core/associative?",
                                     :clj-symbol "clojure.core/associative?",
                                     :docstring "Returns true if coll implements Associative"},
           "cljs.repl/canonicalize-specs" {:ns "cljs.repl",
                                           :name "canonicalize-specs",
                                           :type "function",
                                           :signature ["[specs]"],
                                           :source {:code "(defn canonicalize-specs [specs]\n  (letfn [(canonicalize [quoted-spec-or-kw]\n            (if (keyword? quoted-spec-or-kw)\n              quoted-spec-or-kw\n              (as-> (second quoted-spec-or-kw) spec\n                (if (vector? spec) spec [spec]))))]\n    (map canonicalize specs)))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.7.228",
                                                    :filename "src/main/clojure/cljs/repl.cljc",
                                                    :lines [570 576]},
                                           :full-name "cljs.repl/canonicalize-specs",
                                           :full-name-encode "cljs.repl/canonicalize-specs",
                                           :history [["+" "0.0-3148"]]},
           "cljs.repl.rhino/load-javascript" {:ns "cljs.repl.rhino",
                                              :name "load-javascript",
                                              :type "function",
                                              :signature ["[repl-env ns url]"],
                                              :source {:code "(defn load-javascript [repl-env ns url]\n  (try\n    (with-open [reader (io/reader url)]\n      (-eval reader repl-env (.toString url) 1))\n    ;; TODO: don't show errors for goog/base.js line number 105\n    (catch Throwable ex (println (.getMessage ex)))))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.7.228",
                                                       :filename "src/main/clojure/cljs/repl/rhino.clj",
                                                       :lines [97 102]},
                                              :full-name "cljs.repl.rhino/load-javascript",
                                              :full-name-encode "cljs.repl.rhino/load-javascript",
                                              :history [["+"
                                                         "0.0-927"]]},
           "cljs.core/IList" {:ns "cljs.core",
                              :name "IList",
                              :history [["+" "0.0-1211"]],
                              :type "protocol",
                              :full-name-encode "cljs.core/IList",
                              :source {:code "(defprotocol IList\n  \"Marker interface indicating a persistent list\")",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [608 609]},
                              :full-name "cljs.core/IList",
                              :clj-symbol "clojure.lang/IPersistentList",
                              :docstring "Marker interface indicating a persistent list"},
           "cljs.core/list*" {:description "Creates a new list containing the items prepended to the rest, the last of which\nwill be treated as a sequence.",
                              :ns "cljs.core",
                              :name "list*",
                              :signature ["[args]"
                                          "[a args]"
                                          "[a b args]"
                                          "[a b c args]"
                                          "[a b c d & more]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/list"],
                              :full-name-encode "cljs.core/listSTAR",
                              :source {:code "(defn list*\n  ([args] (seq args))\n  ([a args] (cons a args))\n  ([a b args] (cons a (cons b args)))\n  ([a b c args] (cons a (cons b (cons c args))))\n  ([a b c d & more]\n     (cons a (cons b (cons c (cons d (spread more)))))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [3362 3370]},
                              :full-name "cljs.core/list*",
                              :clj-symbol "clojure.core/list*",
                              :docstring "Creates a new list containing the items prepended to the rest, the\nlast of which will be treated as a sequence."},
           "cljs.core/PersistentArrayMap.fromArray" {:ns "cljs.core",
                                                     :name "PersistentArrayMap.fromArray",
                                                     :signature ["[arr no-clone no-check]"],
                                                     :history [["+"
                                                                "0.0-1798"]],
                                                     :parent-type "PersistentArrayMap",
                                                     :type "function",
                                                     :full-name-encode "cljs.core/PersistentArrayMapDOTfromArray",
                                                     :source {:code "(set! (.-fromArray PersistentArrayMap)\n  (fn [arr ^boolean no-clone ^boolean no-check]\n    (as-> (if no-clone arr (aclone arr)) arr\n      (if no-check\n        arr\n        (let [ret (array)]\n          (loop [i 0]\n            (when (< i (alength arr))\n              (let [k (aget arr i)\n                    v (aget arr (inc i))\n                    idx (array-index-of ret k)]\n                (when (== idx -1)\n                  (.push ret k)\n                  (.push ret v)))\n              (recur (+ i 2))))\n          ret))\n      (let [cnt (/ (alength arr) 2)]\n        (PersistentArrayMap. nil cnt arr nil)))))",
                                                              :title "Source code",
                                                              :repo "clojurescript",
                                                              :tag "r1.7.228",
                                                              :filename "src/main/cljs/cljs/core.cljs",
                                                              :lines [6009
                                                                      6026]},
                                                     :full-name "cljs.core/PersistentArrayMap.fromArray"},
           "cljs.core/js-comment" {:ns "cljs.core",
                                   :name "js-comment",
                                   :signature ["[comment]"],
                                   :history [["+" "1.7.107"]],
                                   :type "macro",
                                   :full-name-encode "cljs.core/js-comment",
                                   :source {:code "(core/defmacro js-comment\n  [comment]\n  (core/let [[x & ys] (string/split comment #\"\\n\")]\n    (core/list 'js*\n      (core/str\n        \"\\n/**\\n\"\n        (core/str \" * \" x \"\\n\")\n        (core/->> ys\n          (map #(core/str \" * \" (string/replace % #\"^   \" \"\") \"\\n\"))\n          (reduce core/str \"\"))\n        \" */\\n\"))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/clojure/cljs/core.cljc",
                                            :lines [873 885]},
                                   :full-name "cljs.core/js-comment",
                                   :docstring "Emit a top-level JavaScript multi-line comment. New lines will create a\nnew comment line. Comment block will be preceded and followed by a newline"},
           "cljs.core/reduce" {:description "`f` should be a function of 2 arguments. If `val` is not supplied, returns the\nresult of applying `f` to the first 2 items in `coll`, then applying `f` to that\nresult and the 3rd item, etc.\n\nIf `coll` contains no items, `f` must accept no arguments as well, and `reduce`\nreturns the result of calling `f` with no arguments.\n\nIf `coll` has only 1 item, it is returned and `f` is not called.\n\nIf `val` is supplied, returns the result of applying `f` to `val` and the first\nitem in `coll`, then applying `f` to that result and the 2nd item, etc.\n\nIf `coll` contains no items, returns `val` and `f` is not called.",
                               :ns "cljs.core",
                               :name "reduce",
                               :signature ["[f coll]" "[f val coll]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/reductions"
                                         "cljs.core/apply"
                                         "cljs.core/frequencies"],
                               :full-name-encode "cljs.core/reduce",
                               :source {:code "(defn reduce\n  ([f coll]\n     (cond\n       (implements? IReduce coll)\n       (-reduce ^not-native coll f)\n\n       (array? coll)\n       (array-reduce coll f)\n\n       (string? coll)\n       (array-reduce coll f)\n\n       (native-satisfies? IReduce coll)\n       (-reduce coll f)\n\n       :else\n       (seq-reduce f coll)))\n  ([f val coll]\n     (cond\n       (implements? IReduce coll)\n       (-reduce ^not-native coll f val)\n\n       (array? coll)\n       (array-reduce coll f val)\n      \n       (string? coll)\n       (array-reduce coll f val)\n\n       (native-satisfies? IReduce coll)\n       (-reduce coll f val)\n\n       :else\n       (seq-reduce f val coll))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [2171 2212]},
                               :full-name "cljs.core/reduce",
                               :clj-symbol "clojure.core/reduce",
                               :docstring "f should be a function of 2 arguments. If val is not supplied,\nreturns the result of applying f to the first 2 items in coll, then\napplying f to that result and the 3rd item, etc. If coll contains no\nitems, f must accept no arguments as well, and reduce returns the\nresult of calling f with no arguments.  If coll has only 1 item, it\nis returned and f is not called.  If val is supplied, returns the\nresult of applying f to val and the first item in coll, then\napplying f to that result and the 2nd item, etc. If coll contains no\nitems, returns val and f is not called."},
           "cljs.repl/merge-require" {:ns "cljs.repl",
                                      :name "merge-require",
                                      :signature ["[requires [lib :as spec]]"],
                                      :history [["+" "0.0-2629"]
                                                ["-" "0.0-2655"]],
                                      :type "function",
                                      :full-name-encode "cljs.repl/merge-require",
                                      :source {:code "(defn merge-require [requires [lib :as spec]]\n  (let [[before [match & after]]\n        (split-with\n          (fn [[lib' & _]]\n            (not= lib lib'))\n          requires)]\n    (if (nil? match)\n      ;; no match, append to end\n      (concat requires [spec])\n      (if (= match spec)\n        ;; dupe\n        requires\n        ;; merge\n        (concat before [(merge-spec match spec)] after)))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2644",
                                               :filename "src/clj/cljs/repl.clj",
                                               :lines [211 224]},
                                      :full-name "cljs.repl/merge-require",
                                      :removed {:in "0.0-2655",
                                                :last-seen "0.0-2644"}},
           "cljs.analyzer.api/ns-publics" {:ns "cljs.analyzer.api",
                                           :name "ns-publics",
                                           :signature ["[ns]"
                                                       "[state ns]"],
                                           :history [["+" "0.0-2985"]],
                                           :type "function",
                                           :full-name-encode "cljs.analyzer.api/ns-publics",
                                           :source {:code "(defn ns-publics\n  ([ns]\n   (ns-publics env/*compiler* ns))\n  ([state ns]\n   {:pre [(symbol? ns)]}\n   (->> (merge\n          (get-in @state [::ana/namespaces ns :macros])\n          (get-in @state [::ana/namespaces ns :defs]))\n        (remove (fn [[k v]] (:private v)))\n        (into {}))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.7.228",
                                                    :filename "src/main/clojure/cljs/analyzer/api.clj",
                                                    :lines [180 191]},
                                           :full-name "cljs.analyzer.api/ns-publics",
                                           :clj-symbol "clojure.core/ns-publics",
                                           :docstring "Given a namespace return all the public var analysis maps. Analagous to\nclojure.core/ns-publics but returns var analysis maps not vars."},
           "clojure.browser.event/has-listener" {:ns "clojure.browser.event",
                                                 :name "has-listener",
                                                 :type "function",
                                                 :signature ["[obj opt_type opt_capture]"],
                                                 :source {:code "(defn has-listener [obj opt_type opt_capture])",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r1.7.228",
                                                          :filename "src/main/cljs/clojure/browser/event.cljs",
                                                          :lines [96]},
                                                 :full-name "clojure.browser.event/has-listener",
                                                 :full-name-encode "clojure.browser.event/has-listener",
                                                 :history [["+"
                                                            "0.0-927"]]},
           "cljs.core/unchecked-dec-int" {:ns "cljs.core",
                                          :name "unchecked-dec-int",
                                          :signature ["[x]"],
                                          :history [["+" "0.0-1798"]],
                                          :type "function/macro",
                                          :full-name-encode "cljs.core/unchecked-dec-int",
                                          :source {:code "(defn unchecked-dec-int\n  [x]\n  (cljs.core/unchecked-dec-int x))",
                                                   :title "Function code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/cljs/cljs/core.cljs",
                                                   :lines [2395 2398]},
                                          :extra-sources [{:code "(core/defmacro ^::ana/numeric unchecked-dec-int\n  ([x] `(dec ~x)))",
                                                           :title "Macro code",
                                                           :repo "clojurescript",
                                                           :tag "r1.7.228",
                                                           :filename "src/main/clojure/cljs/core.cljc",
                                                           :lines [983
                                                                   984]}],
                                          :full-name "cljs.core/unchecked-dec-int",
                                          :clj-symbol "clojure.core/unchecked-dec-int",
                                          :docstring "Returns a number one less than x, an int."},
           "cljs.core/PersistentHashMap.EMPTY" {:ns "cljs.core",
                                                :name "PersistentHashMap.EMPTY",
                                                :history [["+"
                                                           "0.0-1211"]],
                                                :parent-type "PersistentHashMap",
                                                :type "var",
                                                :full-name-encode "cljs.core/PersistentHashMapDOTEMPTY",
                                                :source {:code "(set! (.-EMPTY PersistentHashMap) (PersistentHashMap. nil 0 nil false nil empty-unordered-hash))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1.7.228",
                                                         :filename "src/main/cljs/cljs/core.cljs",
                                                         :lines [6941]},
                                                :full-name "cljs.core/PersistentHashMap.EMPTY",
                                                :clj-symbol "clojure.lang/PersistentHashMap.EMPTY"},
           "cljs.pprint/*print-base*" {:ns "cljs.pprint",
                                       :name "*print-base*",
                                       :history [["+" "0.0-3255"]],
                                       :type "dynamic var",
                                       :full-name-encode "cljs.pprint/STARprint-baseSTAR",
                                       :source {:code "(def ^:dynamic\n^{:doc \"The base to use for printing integers and rationals.\"\n  :added \"1.2\"}\n*print-base* 10)",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/cljs/pprint.cljs",
                                                :lines [672 675]},
                                       :full-name "cljs.pprint/*print-base*",
                                       :clj-symbol "clojure.pprint/*print-base*",
                                       :docstring "The base to use for printing integers and rationals."},
           "cljs.core/compare" {:description "Comparator.\n\nReturns a negative number, zero, or a positive number when `x` is logically\n\"less than\", \"equal to\", or \"greater than\" `y`.\n\nUses `IComparable` if available and `google.array.defaultCompare` for objects of\nthe same type. nil is treated as a special case and is always less than any\nother object.",
                                :return-type number,
                                :ns "cljs.core",
                                :name "compare",
                                :signature ["[x y]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/sort-by"
                                          "cljs.core/sorted-set-by"
                                          "cljs.core/sorted-map-by"],
                                :full-name-encode "cljs.core/compare",
                                :source {:code "(defn ^number compare\n  [x y]\n  (cond\n   (identical? x y) 0\n\n   (nil? x) -1\n\n   (nil? y) 1\n\n   (number? x) (if (number? y)\n                 (garray/defaultCompare x y)\n                 (throw (js/Error. (str \"Cannot compare \" x \" to \" y))))\n\n   (satisfies? IComparable x)\n   (-compare x y)\n\n   :else\n   (if (and (or (string? x) (array? x) (true? x) (false? x))\n            (identical? (type x) (type y)))\n     (garray/defaultCompare x y)\n     (throw (js/Error. (str \"Cannot compare \" x \" to \" y))))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [2065 2089]},
                                :examples [{:id "e13fa0",
                                            :content "```clj\n(compare 10 12)\n;;=> -1\n\n(compare 12 10)\n;;=> 1\n\n(compare 10 10)\n;;=> 0\n\n(compare 10 nil)\n;;=>  1\n\n(compare 10 (list 1 2 3))\n;; Error: compare on non-nil objects of different types\n```"}],
                                :full-name "cljs.core/compare",
                                :clj-symbol "clojure.core/compare",
                                :docstring "Comparator. Returns a negative number, zero, or a positive number\n when x is logically 'less than', 'equal to', or 'greater than'\n y. Uses IComparable if available and google.array.defaultCompare for objects\nof the same type and special-cases nil to be less than any other object."},
           "cljs.core/contains?" {:description "Returns true if the `coll` contains the lookup key `k`, otherwise returns false.\n\nNote that for numerically indexed collections like vectors and arrays, this\ntests if the numeric key is within the range of indexes.\n\n`contains?` operates in constant or logarithmic time, using `get` to perform\nthe lookup. It will not perform a linear search for a value.  `some` is\nused for this purpose:\n\n```clj\n(some #{value} coll)\n```",
                                  :return-type boolean,
                                  :ns "cljs.core",
                                  :name "contains?",
                                  :signature ["[coll k]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/some"
                                            "cljs.core/get"],
                                  :full-name-encode "cljs.core/containsQMARK",
                                  :source {:code "(defn ^boolean contains?\n  [coll v]\n  (if (identical? (get coll v lookup-sentinel) lookup-sentinel)\n    false\n    true))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [2028 2037]},
                                  :examples [{:id "2991f0",
                                              :content "Sets and Maps provide key lookups, so `contains?` works as expected:\n\n```clj\n(contains? #{:a :b} :a)\n;;=> true\n\n(contains? {:a 1, :b 2} :a)\n;;=> true\n\n(contains? {:a 1, :b 2} 1)\n;;=> false\n```\n\nVectors provide integer index lookups, so `contains?` works appropriately:\n\n```clj\n(contains? [:a :b] :b)\n;;=> false\n\n(contains? [:a :b] 1)\n;;=> true\n```\n\nLists and Sequences do not provide lookups, so `contains?` will not work:\n\n```clj\n(contains? '(:a :b) :a)\n;;=> false\n\n(contains? '(:a :b) 1)\n;;=> false\n\n(contains? (range 3) 1)\n;;=> false\n```"}],
                                  :full-name "cljs.core/contains?",
                                  :clj-symbol "clojure.core/contains?",
                                  :docstring "Returns true if key is present in the given collection, otherwise\nreturns false.  Note that for numerically indexed collections like\nvectors and arrays, this tests if the numeric key is within the\nrange of indexes. 'contains?' operates constant or logarithmic time;\nit will not perform a linear search for a value.  See also 'some'."},
           "cljs.core/Stepper" {:ns "cljs.core",
                                :name "Stepper",
                                :type "type",
                                :signature ["[xform iter]"],
                                :source {:code "(deftype Stepper [xform iter]\n  Object\n  (step [this lt]\n    (loop []\n      (if (and (not (nil? (.-stepper lt)))\n               (.hasNext iter))\n        (if (reduced? (xform lt (.next iter)))\n          (when-not (nil? (.-rest lt))\n            (set! (.. lt -rest -stepper) nil))\n          (recur))))\n    (when-not (nil? (.-stepper lt))\n      (xform lt))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [3590 3601]},
                                :full-name "cljs.core/Stepper",
                                :full-name-encode "cljs.core/Stepper",
                                :history [["+" "0.0-2301"]]},
           "cljs.core/prefer-method" {:ns "cljs.core",
                                      :name "prefer-method",
                                      :signature ["[multifn dispatch-val-x dispatch-val-y]"],
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "cljs.core/prefer-method",
                                      :source {:code "(defn prefer-method\n  [multifn dispatch-val-x dispatch-val-y]\n  (-prefer-method multifn dispatch-val-x dispatch-val-y))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [9810 9814]},
                                      :full-name "cljs.core/prefer-method",
                                      :clj-symbol "clojure.core/prefer-method",
                                      :docstring "Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y\nwhen there is a conflict"},
           "cljs.core/array-seq" {:description "Creates a `seq` from a JavaScript array, starting at index `i` if given.",
                                  :ns "cljs.core",
                                  :name "array-seq",
                                  :signature ["[array]" "[array i]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/array-seq",
                                  :source {:code "(defn array-seq\n  ([array]\n     (prim-seq array 0))\n  ([array i]\n     (prim-seq array i)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [1466 1471]},
                                  :examples [{:id "9ef6de",
                                              :content "```clj\n(array-seq #js [1 2 3])\n;;=> (1 2 3)\n\n(array-seq #js [1 2 3] 1)\n;;=> (2 3)\n```"}],
                                  :full-name "cljs.core/array-seq",
                                  :docstring "Create a seq from a JavaScript array."},
           "cljs.core/to-array-2d" {:description "Returns a (potentially-ragged) 2-dimensional JavaScript array containing the\ncontents of `coll`.",
                                    :ns "cljs.core",
                                    :name "to-array-2d",
                                    :signature ["[coll]"],
                                    :history [["+" "0.0-1211"]],
                                    :type "function",
                                    :related ["cljs.core/to-array"],
                                    :full-name-encode "cljs.core/to-array-2d",
                                    :source {:code "(defn to-array-2d\n  [coll]\n    (let [ret (make-array (count coll))]\n      (loop [i 0 xs (seq coll)]\n        (when xs\n          (aset ret i (to-array (first xs)))\n          (recur (inc i) (next xs))))\n      ret))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [3222 3231]},
                                    :full-name "cljs.core/to-array-2d",
                                    :clj-symbol "clojure.core/to-array-2d",
                                    :docstring "Returns a (potentially-ragged) 2-dimensional array\ncontaining the contents of coll."},
           "cljs.repl.nashorn/load-ns" {:ns "cljs.repl.nashorn",
                                        :name "load-ns",
                                        :type "function",
                                        :signature ["[engine ns]"],
                                        :source {:code "(defn load-ns [engine ns]\n      (eval-str engine\n        (format \"goog.require(\\\"%s\\\");\" (comp/munge (first ns)))))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/clojure/cljs/repl/nashorn.clj",
                                                 :lines [96 98]},
                                        :full-name "cljs.repl.nashorn/load-ns",
                                        :full-name-encode "cljs.repl.nashorn/load-ns",
                                        :history [["+" "0.0-2814"]]},
           "cljs.core/find-macros-ns" {:ns "cljs.core",
                                       :name "find-macros-ns",
                                       :type "function",
                                       :signature ["[ns]"],
                                       :source {:code "(defn find-macros-ns [ns]\n  (when (nil? NS_CACHE)\n    (set! NS_CACHE (atom {})))\n  (let [the-ns (get @NS_CACHE ns)]\n    (if-not (nil? the-ns)\n      the-ns\n      (let [ns-str (str ns)\n           ns (if (not ^boolean (gstring/contains ns-str \"$macros\"))\n                (symbol (str ns-str \"$macros\"))\n                ns)\n           ns-obj (find-ns-obj ns)]\n       (when-not (nil? ns-obj)\n         (let [new-ns (create-ns ns ns-obj)]\n           (swap! NS_CACHE assoc ns new-ns)\n           new-ns))))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/cljs/core.cljs",
                                                :lines [10185 10199]},
                                       :full-name "cljs.core/find-macros-ns",
                                       :full-name-encode "cljs.core/find-macros-ns",
                                       :history [["+" "1.7.10"]]},
           "cljs.core/ICloneable" {:ns "cljs.core",
                                   :name "ICloneable",
                                   :history [["+" "0.0-2134"]],
                                   :type "protocol",
                                   :full-name-encode "cljs.core/ICloneable",
                                   :source {:code "(defprotocol ICloneable\n  \"Protocol for cloning a value.\"\n  (^clj -clone [value]\n    \"Creates a clone of value.\"))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [455 458]},
                                   :methods [{:name "-clone",
                                              :signature ["[value]"],
                                              :docstring "Creates a clone of value."}],
                                   :full-name "cljs.core/ICloneable",
                                   :docstring "Protocol for cloning a value."},
           "cljs.repl.browser/create-client-js-file" {:ns "cljs.repl.browser",
                                                      :name "create-client-js-file",
                                                      :type "function",
                                                      :signature ["[opts file-path]"],
                                                      :source {:code "(defn create-client-js-file [opts file-path]\n  (let [file (io/file file-path)]\n    (when (not (.exists file))\n      (spit file (compile-client-js opts)))\n    file))",
                                                               :title "Source code",
                                                               :repo "clojurescript",
                                                               :tag "r1.7.228",
                                                               :filename "src/main/clojure/cljs/repl/browser.clj",
                                                               :lines [232
                                                                       236]},
                                                      :full-name "cljs.repl.browser/create-client-js-file",
                                                      :full-name-encode "cljs.repl.browser/create-client-js-file",
                                                      :history [["+"
                                                                 "0.0-927"]]},
           "cljs.core/*print-length*" {:ns "cljs.core",
                                       :name "*print-length*",
                                       :history [["+" "0.0-2060"]],
                                       :type "dynamic var",
                                       :full-name-encode "cljs.core/STARprint-lengthSTAR",
                                       :source {:code "(def\n  ^{:dynamic true\n    :doc \"*print-length* controls how many items of each collection the\n  printer will print. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  number of items of each collection to print. If a collection contains\n  more items, the printer will print items up to the limit followed by\n  '...' to represent the remaining items. The root binding is nil\n  indicating no limit.\"\n    :jsdoc [\"@type {null|number}\"]}\n  *print-length* nil)",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/cljs/core.cljs",
                                                :lines [105 115]},
                                       :full-name "cljs.core/*print-length*",
                                       :clj-symbol "clojure.core/*print-length*",
                                       :docstring "*print-length* controls how many items of each collection the\nprinter will print. If it is bound to logical false, there is no\nlimit. Otherwise, it must be bound to an integer indicating the maximum\nnumber of items of each collection to print. If a collection contains\nmore items, the printer will print items up to the limit followed by\n'...' to represent the remaining items. The root binding is nil\nindicating no limit."},
           "cljs.repl/*cljs-verbose*" {:ns "cljs.repl",
                                       :name "*cljs-verbose*",
                                       :type "dynamic var",
                                       :source {:code "(def ^:dynamic *cljs-verbose* false)",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/clojure/cljs/repl.cljc",
                                                :lines [35]},
                                       :full-name "cljs.repl/*cljs-verbose*",
                                       :full-name-encode "cljs.repl/STARcljs-verboseSTAR",
                                       :history [["+" "0.0-927"]]},
           "cljs.core/PersistentQueue" {:ns "cljs.core",
                                        :name "PersistentQueue",
                                        :signature ["[meta count front rear __hash]"],
                                        :history [["+" "0.0-927"]],
                                        :type "type",
                                        :full-name-encode "cljs.core/PersistentQueue",
                                        :source {:code "(deftype PersistentQueue [meta count front rear ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  ICloneable\n  (-clone [coll] (PersistentQueue. meta count front rear __hash))\n\n  IIterable\n  (-iterator [coll]\n    (PersistentQueueIter. front (-iterator rear)))\n\n  IWithMeta\n  (-with-meta [coll meta] (PersistentQueue. meta count front rear __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] (first front))\n  (-rest [coll] (rest (seq coll)))\n\n  IStack\n  (-peek [coll] (first front))\n  (-pop [coll]\n    (if front\n      (if-let [f1 (next front)]\n        (PersistentQueue. meta (dec count) f1 rear nil)\n        (PersistentQueue. meta (dec count) (seq rear) [] nil))\n      coll))\n\n  ICollection\n  (-conj [coll o]\n    (if front\n      (PersistentQueue. meta (inc count) front (conj (or rear []) o) nil)\n      (PersistentQueue. meta (inc count) (conj front o) [] nil)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY PersistentQueue) meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (let [rear (seq rear)]\n      (if (or front rear)\n        (PersistentQueueSeq. nil front (seq rear) nil))))\n\n  ICounted\n  (-count [coll] count))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/cljs/cljs/core.cljs",
                                                 :lines [5418 5474]},
                                        :full-name "cljs.core/PersistentQueue",
                                        :clj-symbol "clojure.lang/PersistentQueue"},
           "cljs.repl.server/read-post" {:ns "cljs.repl.server",
                                         :name "read-post",
                                         :type "function",
                                         :signature ["[line rdr]"],
                                         :source {:code "(defn read-post [line rdr]\n  (let [[_ path _] (str/split line #\" \")\n        headers (parse-headers (read-headers rdr))\n        content-length (Integer/parseInt (:content-length headers))\n        content (char-array content-length)]\n    (io! (.read rdr content 0 content-length)\n      {:method :post\n       :path path\n       :headers headers\n       :content (String. content)})))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.7.228",
                                                  :filename "src/main/clojure/cljs/repl/server.clj",
                                                  :lines [74 83]},
                                         :full-name "cljs.repl.server/read-post",
                                         :full-name-encode "cljs.repl.server/read-post",
                                         :history [["+" "0.0-1503"]]},
           "cljs.core/drop-last" {:description "Return a lazy sequence of all but the last `n` items in `s`.\n\n`n` defaults to 1.",
                                  :ns "cljs.core",
                                  :name "drop-last",
                                  :signature ["[s]" "[n s]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/drop"
                                            "cljs.core/drop-while"],
                                  :full-name-encode "cljs.core/drop-last",
                                  :source {:code "(defn drop-last\n  ([s] (drop-last 1 s))\n  ([n s] (map (fn [x _] x) s (drop n s))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [4295 4298]},
                                  :full-name "cljs.core/drop-last",
                                  :clj-symbol "clojure.core/drop-last",
                                  :docstring "Return a lazy sequence of all but the last n (default 1) items in coll"},
           "cljs.core/array?" {:description "Returns true if `x` is a JavaScript array, false otherwise.",
                               :return-type boolean,
                               :ns "cljs.core",
                               :name "array?",
                               :signature ["[x]"],
                               :history [["+" "0.0-1798"]],
                               :type "function",
                               :related ["cljs.core/object?"],
                               :full-name-encode "cljs.core/arrayQMARK",
                               :source {:code "(defn ^boolean array?\n  [x]\n  (if (identical? *target* \"nodejs\")\n    (.isArray js/Array x)\n    (instance? js/Array x)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [191 196]},
                               :examples [{:id "39913c",
                                           :content "```clj\n(array? #js [1 2 3])\n;;=> true\n\n(array? [1 2 3])\n;;=> false\n\n(array? \"hi\")\n;;=> false\n```"}],
                               :full-name "cljs.core/array?",
                               :docstring "Returns true if x is a JavaScript array."},
           "cljs.core/PersistentVector.fromArray" {:ns "cljs.core",
                                                   :name "PersistentVector.fromArray",
                                                   :signature ["[xs no-clone]"],
                                                   :history [["+"
                                                              "0.0-1006"]],
                                                   :parent-type "PersistentVector",
                                                   :type "function",
                                                   :full-name-encode "cljs.core/PersistentVectorDOTfromArray",
                                                   :source {:code "(set! (.-fromArray PersistentVector)\n  (fn [xs ^boolean no-clone]\n    (let [l (alength xs)\n          xs (if no-clone xs (aclone xs))]\n      (if (< l 32)\n        (PersistentVector. nil l 5 (.-EMPTY-NODE PersistentVector) xs nil)\n        (let [node (.slice xs 0 32)\n              v (PersistentVector. nil 32 5 (.-EMPTY-NODE PersistentVector) node nil)]\n          (loop [i 32 out (-as-transient v)]\n            (if (< i l)\n              (recur (inc i) (conj! out (aget xs i)))\n              (persistent! out))))))))",
                                                            :title "Source code",
                                                            :repo "clojurescript",
                                                            :tag "r1.7.228",
                                                            :filename "src/main/cljs/cljs/core.cljs",
                                                            :lines [4928
                                                                    4939]},
                                                   :full-name "cljs.core/PersistentVector.fromArray"},
           "cljs.core/filterv" {:description "Returns a vector of the items in `coll` for which `(pred item)` returns true.\n\n`pred` must be free of side-effects.",
                                :ns "cljs.core",
                                :name "filterv",
                                :signature ["[pred coll]"],
                                :history [["+" "0.0-1211"]],
                                :type "function",
                                :full-name-encode "cljs.core/filterv",
                                :source {:code "(defn filterv\n  [pred coll]\n  (-> (reduce (fn [v o] (if (pred o) (conj! v o) v))\n              (transient [])\n              coll)\n      persistent!))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [4516 4523]},
                                :full-name "cljs.core/filterv",
                                :clj-symbol "clojure.core/filterv",
                                :docstring "Returns a vector of the items in coll for which\n(pred item) returns true. pred must be free of side-effects."},
           "cljs.core/IComparable" {:ns "cljs.core",
                                    :name "IComparable",
                                    :history [["+" "0.0-1424"]],
                                    :type "protocol",
                                    :full-name-encode "cljs.core/IComparable",
                                    :source {:code "(defprotocol IComparable\n  \"Protocol for values that can be compared.\"\n  (^number -compare [x y]\n    \"Returns a negative number, zero, or a positive number when x is logically\n     'less than', 'equal to', or 'greater than' y.\"))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [702 706]},
                                    :methods [{:name "-compare",
                                               :signature ["[x y]"],
                                               :docstring "Returns a negative number, zero, or a positive number when x is logically\n     'less than', 'equal to', or 'greater than' y."}],
                                    :full-name "cljs.core/IComparable",
                                    :docstring "Protocol for values that can be compared."},
           "cljs.reader/read-string" {:ns "cljs.reader",
                                      :name "read-string",
                                      :signature ["[s]"],
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "cljs.reader/read-string",
                                      :source {:code "(defn read-string\n  [s]\n  (when-not (string? s)\n    (throw (js/Error. \"Cannot read from non-string object.\")))\n  (let [r (push-back-reader s)]\n    (read r false nil false)))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/cljs/cljs/reader.cljs",
                                               :lines [460 466]},
                                      :full-name "cljs.reader/read-string",
                                      :clj-symbol "clojure.core/read-string",
                                      :docstring "Reads one object from the string s"},
           "cljs.reader/unicode-2-pattern" {:ns "cljs.reader",
                                            :name "unicode-2-pattern",
                                            :type "var",
                                            :source {:code "(def unicode-2-pattern (re-pattern \"^[0-9A-Fa-f]{2}$\"))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.7.228",
                                                     :filename "src/main/cljs/cljs/reader.cljs",
                                                     :lines [181]},
                                            :full-name "cljs.reader/unicode-2-pattern",
                                            :full-name-encode "cljs.reader/unicode-2-pattern",
                                            :history [["+" "0.0-1424"]]},
           "cljs.repl/IGetError" {:ns "cljs.repl",
                                  :name "IGetError",
                                  :type "protocol",
                                  :full-name-encode "cljs.repl/IGetError",
                                  :source {:code "(defprotocol IGetError\n  (-get-error [repl-env name env build-options]\n    \"Given a symbol representing a var holding an error, an analysis\n     environment, and the REPL/compiler options return the canonical error\n     representation:\n\n     {:value <string>\n      :stacktrace <string>}\n\n    :value should be the host environment JavaScript error message string.\n    :stacktrace should be the host JavaScript environment stacktrace string.\"))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/clojure/cljs/repl.cljc",
                                           :lines [123 133]},
                                  :methods [{:name "-get-error",
                                             :signature ["[repl-env name env build-options]"],
                                             :docstring "Given a symbol representing a var holding an error, an analysis\n     environment, and the REPL/compiler options return the canonical error\n     representation:\n\n     {:value <string>\n      :stacktrace <string>}\n\n    :value should be the host environment JavaScript error message string.\n    :stacktrace should be the host JavaScript environment stacktrace string."}],
                                  :full-name "cljs.repl/IGetError",
                                  :history [["+" "0.0-2985"]]},
           "cljs.core/CHAR_MAP" {:ns "cljs.core",
                                 :name "CHAR_MAP",
                                 :type "var",
                                 :source {:code "(def ^{:jsdoc [\"@enum {string}\"]}\n  CHAR_MAP\n  #js {\"-\"    \"_\"\n       \":\"    \"_COLON_\"\n       \"+\"    \"_PLUS_\"\n       \">\"    \"_GT_\"\n       \"<\"    \"_LT_\"\n       \"=\"    \"_EQ_\"\n       \"~\"    \"_TILDE_\"\n       \"!\"    \"_BANG_\"\n       \"@\"    \"_CIRCA_\"\n       \"#\"    \"_SHARP_\"\n       \"'\"    \"_SINGLEQUOTE_\"\n       \"\\\\\\\"\" \"_DOUBLEQUOTE_\"\n       \"%\"    \"_PERCENT_\"\n       \"^\"    \"_CARET_\"\n       \"&\"    \"_AMPERSAND_\"\n       \"*\"    \"_STAR_\"\n       \"|\"    \"_BAR_\"\n       \"{\"    \"_LBRACE_\"\n       \"}\"    \"_RBRACE_\"\n       \"[\"    \"_LBRACK_\"\n       \"]\"    \"_RBRACK_\"\n       \"/\"    \"_SLASH_\"\n       \"\\\\\\\\\" \"_BSLASH_\"\n       \"?\"    \"_QMARK_\"})",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [283 308]},
                                 :full-name "cljs.core/CHAR_MAP",
                                 :full-name-encode "cljs.core/CHAR_MAP",
                                 :history [["+" "1.7.10"]]},
           "cljs.core/Volatile" {:ns "cljs.core",
                                 :name "Volatile",
                                 :signature ["[state]"],
                                 :history [["+" "0.0-2496"]],
                                 :type "type",
                                 :related ["cljs.core/volatile!"
                                           "cljs.core/volatile?"],
                                 :full-name-encode "cljs.core/Volatile",
                                 :source {:code "(deftype Volatile [^:mutable state]\n  IVolatile\n  (-vreset! [_ new-state]\n    (set! state new-state))\n\n  IDeref\n  (-deref [_] state))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [4060 4066]},
                                 :full-name "cljs.core/Volatile",
                                 :clj-symbol "clojure.lang/Volatile"},
           "cljs.core/check-string-hash-cache" {:ns "cljs.core",
                                                :name "check-string-hash-cache",
                                                :signature ["[k]"],
                                                :history [["+"
                                                           "0.0-1424"]
                                                          ["-"
                                                           "0.0-2261"]],
                                                :type "function",
                                                :full-name-encode "cljs.core/check-string-hash-cache",
                                                :source {:code "(defn check-string-hash-cache [k]\n  (when (> string-hash-cache-count 255)\n    (set! string-hash-cache (js-obj))\n    (set! string-hash-cache-count 0))\n  (let [h (aget string-hash-cache k)]\n    (if (number? h)\n      h\n      (add-to-string-hash-cache k))))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r2234",
                                                         :filename "src/cljs/cljs/core.cljs",
                                                         :lines [1147
                                                                 1154]},
                                                :full-name "cljs.core/check-string-hash-cache",
                                                :removed {:in "0.0-2261",
                                                          :last-seen "0.0-2234"}},
           "cljs.core/vector?" {:description "Returns true if `x` is a vector, false otherwise.",
                                :return-type boolean,
                                :ns "cljs.core",
                                :name "vector?",
                                :signature ["[x]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/vector"
                                          "cljs.core/vec"],
                                :full-name-encode "cljs.core/vectorQMARK",
                                :source {:code "(defn ^boolean vector?\n  [x] (satisfies? IVector x))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [1931 1933]},
                                :full-name "cljs.core/vector?",
                                :clj-symbol "clojure.core/vector?",
                                :docstring "Return true if x satisfies IVector"},
           "cljs.core/defmulti" {:ns "cljs.core",
                                 :name "defmulti",
                                 :signature ["[mm-name & options]"],
                                 :history [["+" "0.0-927"]],
                                 :type "macro",
                                 :full-name-encode "cljs.core/defmulti",
                                 :source {:code "(core/defmacro defmulti\n  [mm-name & options]\n  (core/let [docstring   (if (core/string? (first options))\n                           (first options)\n                           nil)\n             options     (if (core/string? (first options))\n                           (next options)\n                           options)\n             m           (if (map? (first options))\n                           (first options)\n                           {})\n             options     (if (map? (first options))\n                           (next options)\n                           options)\n             dispatch-fn (first options)\n             options     (next options)\n             m           (if docstring\n                           (assoc m :doc docstring)\n                           m)\n             m           (if (meta mm-name)\n                           (conj (meta mm-name) m)\n                           m)\n             mm-ns (core/-> &env :ns :name core/str)]\n    (core/when (= (count options) 1)\n      (throw\n        #?(:clj (Exception. \"The syntax for defmulti has changed. Example: (defmulti name dispatch-fn :default dispatch-value)\")\n           :cljs (js/Error. \"The syntax for defmulti has changed. Example: (defmulti name dispatch-fn :default dispatch-value)\"))))\n    (core/let [options (apply core/hash-map options)\n               default (core/get options :default :default)]\n      (check-valid-options options :default :hierarchy)\n      `(defonce ~(with-meta mm-name m)\n         (let [method-table# (atom {})\n               prefer-table# (atom {})\n               method-cache# (atom {})\n               cached-hierarchy# (atom {})\n               hierarchy# (get ~options :hierarchy (cljs.core/get-global-hierarchy))]\n           (cljs.core/MultiFn. (cljs.core/symbol ~mm-ns ~(name mm-name)) ~dispatch-fn ~default hierarchy#\n             method-table# prefer-table# method-cache# cached-hierarchy#))))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/clojure/cljs/core.cljc",
                                          :lines [2471 2515]},
                                 :full-name "cljs.core/defmulti",
                                 :clj-symbol "clojure.core/defmulti",
                                 :docstring "Creates a new multimethod with the associated dispatch function.\nThe docstring and attribute-map are optional.\n\nOptions are key-value pairs and may be one of:\n  :default    the default dispatch value, defaults to :default\n  :hierarchy  the isa? hierarchy to use for dispatching\n              defaults to the global hierarchy"},
           "syntax/rest" {:description "A concept for binding the rest of the values of some sequence to a name.  See\n[doc:syntax/destructure-vector] or [doc:cljs.core/fn] for exact usage details in their\nrespective contexts.",
                          :ns "syntax",
                          :name "rest",
                          :history [["+" "0.0-927"]],
                          :type "special character",
                          :full-name-encode "syntax/rest",
                          :usage ["[... & foo]"],
                          :examples [{:id "ebd356",
                                      :content "Binding `c` to the rest of the function arguments:\n\n```clj\n(defn foo\n  [a b & c]\n  c)\n(foo 1 2 3 4)\n;;=> (3 4)\n```\n\nBinding `c` to the rest of the destructured values:\n\n```clj\n(let [[a b & c]\n      [1 2 3 4]]\n  c)\n;;=> (3 4)\n```"}],
                          :full-name "syntax/rest",
                          :display "& rest",
                          :clj-doc "http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/&"},
           "cljs.core/Keyword" {:ns "cljs.core",
                                :name "Keyword",
                                :signature ["[ns name fqn _hash]"],
                                :history [["+" "0.0-1424"]],
                                :type "type",
                                :full-name-encode "cljs.core/Keyword",
                                :source {:code "(deftype Keyword [ns name fqn ^:mutable _hash]\n  Object\n  (toString [_] (str \":\" fqn))\n  (equiv [this other]\n    (-equiv this other))\n  \n  IEquiv\n  (-equiv [_ other]\n    (if (instance? Keyword other)\n      (identical? fqn (.-fqn other))\n      false))\n  IFn\n  (-invoke [kw coll]\n    (get coll kw))\n  (-invoke [kw coll not-found]\n    (get coll kw not-found))\n\n  IHash\n  (-hash [this]\n    (caching-hash this hash-keyword _hash))\n\n  INamed\n  (-name [_] name)\n  (-namespace [_] ns)\n\n  IPrintWithWriter\n  (-pr-writer [o writer _] (-write writer (str \":\" fqn))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [2930 2956]},
                                :full-name "cljs.core/Keyword",
                                :clj-symbol "clojure.lang/Keyword"},
           "cljs.core/List.EMPTY" {:ns "cljs.core",
                                   :name "List.EMPTY",
                                   :history [["+" "0.0-927"]],
                                   :parent-type "List",
                                   :type "var",
                                   :full-name-encode "cljs.core/ListDOTEMPTY",
                                   :source {:code "(set! (.-EMPTY List) (EmptyList. nil))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [2819]},
                                   :full-name "cljs.core/List.EMPTY",
                                   :clj-symbol "clojure.lang/PersistentList.EMPTY"},
           "clojure.browser.event/dispatch-event" {:ns "clojure.browser.event",
                                                   :name "dispatch-event",
                                                   :type "function",
                                                   :signature ["[src event]"],
                                                   :source {:code "(defn dispatch-event\n  [src event]\n  (events/dispatchEvent src event))",
                                                            :title "Source code",
                                                            :repo "clojurescript",
                                                            :tag "r1.7.228",
                                                            :filename "src/main/cljs/clojure/browser/event.cljs",
                                                            :lines [77
                                                                    79]},
                                                   :full-name "clojure.browser.event/dispatch-event",
                                                   :full-name-encode "clojure.browser.event/dispatch-event",
                                                   :history [["+"
                                                              "0.0-927"]]},
           "cljs.core/ns-interns" {:ns "cljs.core",
                                   :name "ns-interns",
                                   :signature ["[[quote ns]]"],
                                   :history [["+" "0.0-2496"]],
                                   :type "macro",
                                   :full-name-encode "cljs.core/ns-interns",
                                   :source {:code "(core/defmacro ns-interns\n  [[quote ns]]\n  (core/assert (core/and (= quote 'quote) (core/symbol? ns))\n    \"Argument to ns-interns must be a quoted symbol\")\n  `(into {}\n     [~@(map\n          (core/fn [[sym _]]\n            `[(symbol ~(name sym)) (var ~(symbol (name ns) (name sym)))])\n          (get-in @env/*compiler* [:cljs.analyzer/namespaces ns :defs]))]))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/clojure/cljs/core.cljc",
                                            :lines [2606 2615]},
                                   :full-name "cljs.core/ns-interns",
                                   :clj-symbol "clojure.core/ns-interns",
                                   :docstring "Returns a map of the intern mappings for the namespace."},
           "clojure.string/split-lines" {:description "Splits `s` on `\\n` or `\\r\\n`.",
                                         :ns "clojure.string",
                                         :name "split-lines",
                                         :signature ["[s]"],
                                         :history [["+" "0.0-927"]],
                                         :type "function",
                                         :related ["clojure.string/split"],
                                         :full-name-encode "clojure.string/split-lines",
                                         :source {:code "(defn split-lines\n  [s]\n  (split s #\"\\n|\\r\\n\"))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.7.228",
                                                  :filename "src/main/cljs/clojure/string.cljs",
                                                  :lines [160 163]},
                                         :full-name "clojure.string/split-lines",
                                         :clj-symbol "clojure.string/split-lines",
                                         :docstring "Splits s on \n or \r\n."},
           "cljs.test/mapped-line-and-column" {:ns "cljs.test",
                                               :name "mapped-line-and-column",
                                               :type "function",
                                               :signature ["[filename line column]"],
                                               :source {:code "(defn mapped-line-and-column [filename line column]\n  (let [default [filename line column]]\n    (if-let [source-map (:source-map (get-current-env))]\n      ;; source maps are 0 indexed for lines\n      (if-let [columns (get-in source-map [filename (dec line)])]\n        (vec\n          (map\n            ;; source maps are 0 indexed for columns\n            ;; multiple segments may exist at column\n            ;; just take first\n            (first\n              (if-let [mapping (get columns (dec column))]\n                mapping\n                (second (first columns))))\n            [:source :line :col]))\n        default)\n      default)))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.7.228",
                                                        :filename "src/main/cljs/cljs/test.cljs",
                                                        :lines [375
                                                                391]},
                                               :full-name "cljs.test/mapped-line-and-column",
                                               :full-name-encode "cljs.test/mapped-line-and-column",
                                               :history [["+"
                                                          "0.0-2496"]]},
           "cljs.js/valid-opts?" {:ns "cljs.js",
                                  :name "valid-opts?",
                                  :signature ["[x]"],
                                  :history [["+" "1.7.10"]
                                            ["-" "1.7.48"]],
                                  :type "function",
                                  :full-name-encode "cljs.js/valid-optsQMARK",
                                  :source {:code "(defn valid-opts? [x]\n  (or (nil? x) (map? x)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.28",
                                           :filename "src/main/cljs/cljs/js.cljs",
                                           :lines [47 48]},
                                  :full-name "cljs.js/valid-opts?",
                                  :removed {:in "1.7.48",
                                            :last-seen "1.7.28"}},
           "cljs.core/*ns*" {:ns "cljs.core",
                             :name "*ns*",
                             :history [["+" "1.7.10"]],
                             :type "dynamic var",
                             :full-name-encode "cljs.core/STARnsSTAR",
                             :source {:code "(def\n  ^{:dynamic true\n    :doc \"Var bound to the current namespace. Only used for bootstrapping.\"\n    :jsdoc [\"@type {*}\"]}\n  *ns* nil)",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [28 32]},
                             :full-name "cljs.core/*ns*",
                             :clj-symbol "clojure.core/*ns*",
                             :docstring "Var bound to the current namespace. Only used for bootstrapping."},
           "cljs.repl.browser/loaded-libs" {:ns "cljs.repl.browser",
                                            :name "loaded-libs",
                                            :type "var",
                                            :source {:code "(def loaded-libs (atom #{}))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r3058",
                                                     :filename "src/clj/cljs/repl/browser.clj",
                                                     :lines [26]},
                                            :full-name "cljs.repl.browser/loaded-libs",
                                            :full-name-encode "cljs.repl.browser/loaded-libs",
                                            :history [["+" "0.0-927"]
                                                      ["-" "0.0-3115"]],
                                            :removed {:in "0.0-3115",
                                                      :last-seen "0.0-3058"}},
           "cljs.core/areduce" {:description "For quickly reducing an expression `expr` across a JavaScript array `a`.  The\nexpression can use `ret` as the current result, which is initialized to `init`.\nIt can also use `idx` to get the current index.",
                                :ns "cljs.core",
                                :name "areduce",
                                :signature ["[a idx ret init expr]"],
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :related ["cljs.core/reduce"],
                                :full-name-encode "cljs.core/areduce",
                                :source {:code "(core/defmacro areduce\n  [a idx ret init expr]\n  `(let [a# ~a]\n     (loop  [~idx 0 ~ret ~init]\n       (if (< ~idx  (alength a#))\n         (recur (inc ~idx) ~expr)\n         ~ret))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/clojure/cljs/core.cljc",
                                         :lines [2436 2445]},
                                :examples [{:id "20a389",
                                            :content "```clj\n(def a #js [1 2 3])\n(areduce a i ret 0 (+ ret (aget a i)))\n;;=> 6\n```"}],
                                :full-name "cljs.core/areduce",
                                :clj-symbol "clojure.core/areduce",
                                :docstring "Reduces an expression across an array a, using an index named idx,\nand return value named ret, initialized to init, setting ret to the\nevaluation of expr at each step, returning ret."},
           "cljs.core/disj" {:description "disj(oin). Returns a new set of the same (hashed/sorted) type, that does not\ncontain key(s).",
                             :ns "cljs.core",
                             :name "disj",
                             :signature ["[coll]"
                                         "[coll k]"
                                         "[coll k & ks]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/dissoc"
                                       "cljs.core/disj!"
                                       "clojure.set/difference"],
                             :full-name-encode "cljs.core/disj",
                             :source {:code "(defn disj\n  ([coll] coll)\n  ([coll k]\n    (when-not (nil? coll)\n      (-disjoin coll k)))\n  ([coll k & ks]\n    (when-not (nil? coll)\n      (let [ret (disj coll k)]\n        (if ks\n          (recur ret (first ks) (next ks))\n          ret)))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [1869 1881]},
                             :full-name "cljs.core/disj",
                             :clj-symbol "clojure.core/disj",
                             :docstring "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\ndoes not contain key(s)."},
           "cljs.js/*load-fn*" {:ns "cljs.js",
                                :name "*load-fn*",
                                :docstring "Each runtime environment provides a different way to load a library.\nWhatever function *load-fn* is bound to will be passed two arguments - a\nmap and a callback function: The map will have the following keys:\n\n:name   - the name of the library (a symbol)\n:macros - modifier signaling a macros namespace load\n:path   - munged relative library path (a string)\n\nIt is up to the implementor to correctly resolve the corresponding .cljs,\n.cljc, or .js resource (the order must be respected). If :macros is true\nresolution should only consider .clj or .cljc resources (the order must be\nrespected). Upon resolution the callback should be invoked with a map\ncontaining the following keys:\n\n:lang       - the language, :clj or :js\n:source     - the source of the library (a string)\n:cache      - optional, if a :clj namespace has been precompiled to :js, can\n              give an analysis cache for faster loads.\n:source-map - optional, if a :clj namespace has been precompiled to :js, can\n              give a V3 source map JSON\n\nIf the resource could not be resolved, the callback should be invoked with\nnil.",
                                :type "dynamic var",
                                :source {:code "(defonce\n  ^{:doc \"Each runtime environment provides a different way to load a library.\n  Whatever function *load-fn* is bound to will be passed two arguments - a\n  map and a callback function: The map will have the following keys:\n\n  :name   - the name of the library (a symbol)\n  :macros - modifier signaling a macros namespace load\n  :path   - munged relative library path (a string)\n\n  It is up to the implementor to correctly resolve the corresponding .cljs,\n  .cljc, or .js resource (the order must be respected). If :macros is true\n  resolution should only consider .clj or .cljc resources (the order must be\n  respected). Upon resolution the callback should be invoked with a map\n  containing the following keys:\n\n  :lang       - the language, :clj or :js\n  :source     - the source of the library (a string)\n  :cache      - optional, if a :clj namespace has been precompiled to :js, can\n                give an analysis cache for faster loads.\n  :source-map - optional, if a :clj namespace has been precompiled to :js, can\n                give a V3 source map JSON\n\n  If the resource could not be resolved, the callback should be invoked with\n  nil.\"\n    :dynamic true}\n  *load-fn*\n  (fn [name cb]\n    (throw (js/Error. \"No *load-fn* set\"))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/js.cljs",
                                         :lines [50 77]},
                                :full-name "cljs.js/*load-fn*",
                                :full-name-encode "cljs.js/STARload-fnSTAR",
                                :history [["+" "1.7.10"]]},
           "cljs.core/IEditableCollection" {:ns "cljs.core",
                                            :name "IEditableCollection",
                                            :history [["+" "0.0-1211"]],
                                            :type "protocol",
                                            :full-name-encode "cljs.core/IEditableCollection",
                                            :source {:code "(defprotocol IEditableCollection\n  \"Protocol for collections which can transformed to transients.\"\n  (^clj -as-transient [coll]\n    \"Returns a new, transient version of the collection, in constant time.\"))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.7.228",
                                                     :filename "src/main/cljs/cljs/core.cljs",
                                                     :lines [667 670]},
                                            :methods [{:name "-as-transient",
                                                       :signature ["[coll]"],
                                                       :docstring "Returns a new, transient version of the collection, in constant time."}],
                                            :full-name "cljs.core/IEditableCollection",
                                            :clj-symbol "clojure.lang/IEditableCollection",
                                            :docstring "Protocol for collections which can transformed to transients."},
           "cljs.core/unchecked-char" {:return-type number,
                                       :ns "cljs.core",
                                       :name "unchecked-char",
                                       :signature ["[x]"],
                                       :history [["+" "0.0-1798"]],
                                       :type "function/macro",
                                       :full-name-encode "cljs.core/unchecked-char",
                                       :source {:code "(defn ^number unchecked-char [x] x)",
                                                :title "Function code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/cljs/core.cljs",
                                                :lines [2371]},
                                       :extra-sources [{:code "(core/defmacro unchecked-char [x] x)",
                                                        :title "Macro code",
                                                        :repo "clojurescript",
                                                        :tag "r1.7.228",
                                                        :filename "src/main/clojure/cljs/core.cljc",
                                                        :lines [969]}],
                                       :full-name "cljs.core/unchecked-char",
                                       :clj-symbol "clojure.core/unchecked-char"},
           "cljs.core/keyword-identical?" {:return-type boolean,
                                           :ns "cljs.core",
                                           :name "keyword-identical?",
                                           :signature ["[x y]"],
                                           :history [["+" "0.0-1877"]],
                                           :type "function",
                                           :full-name-encode "cljs.core/keyword-identicalQMARK",
                                           :source {:code "(defn ^boolean keyword-identical?\n  [x y]\n  (if (identical? x y)\n    true\n    (if (and (keyword? x) (keyword? y))\n      (identical? (.-fqn x) (.-fqn y))\n      false)))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.7.228",
                                                    :filename "src/main/cljs/cljs/core.cljs",
                                                    :lines [2963 2970]},
                                           :full-name "cljs.core/keyword-identical?",
                                           :docstring "Efficient test to determine that two keywords are identical."},
           "clojure.browser.net/event-types" {:ns "clojure.browser.net",
                                              :name "event-types",
                                              :type "var",
                                              :source {:code "(def event-types\n  (into {}\n        (map\n         (fn [[k v]]\n           [(keyword (.toLowerCase k))\n            v])\n         (merge\n          (js->clj EventType)))))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.7.228",
                                                       :filename "src/main/cljs/clojure/browser/net.cljs",
                                                       :lines [21 28]},
                                              :full-name "clojure.browser.net/event-types",
                                              :full-name-encode "clojure.browser.net/event-types",
                                              :history [["+"
                                                         "0.0-927"]]},
           "clojure.string/lower-case" {:description "Converts string to all lower-case.",
                                        :ns "clojure.string",
                                        :name "lower-case",
                                        :signature ["[s]"],
                                        :history [["+" "0.0-927"]],
                                        :type "function",
                                        :full-name-encode "clojure.string/lower-case",
                                        :source {:code "(defn lower-case\n  [s]\n  (.toLowerCase s))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/cljs/clojure/string.cljs",
                                                 :lines [90 93]},
                                        :full-name "clojure.string/lower-case",
                                        :clj-symbol "clojure.string/lower-case",
                                        :docstring "Converts string to all lower-case."},
           "cljs.core/*print-fn*" {:ns "cljs.core",
                                   :name "*print-fn*",
                                   :docstring "Each runtime environment provides a different way to print output.\nWhatever function *print-fn* is bound to will be passed any\nStrings which should be printed.",
                                   :type "dynamic var",
                                   :source {:code "(defonce\n  ^{:doc \"Each runtime environment provides a different way to print output.\n  Whatever function *print-fn* is bound to will be passed any\n  Strings which should be printed.\" :dynamic true}\n  *print-fn*\n  (fn [_]\n    (throw (js/Error. \"No *print-fn* fn set for evaluation environment\"))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [43 49]},
                                   :full-name "cljs.core/*print-fn*",
                                   :full-name-encode "cljs.core/STARprint-fnSTAR",
                                   :history [["+" "0.0-927"]]},
           "cljs.core/str" {:description "`(str)` and `(str nil)` return the empty string.\n\n`(str x)` returns `x.toString()`.\n\nWith more than one argument, returns the concatenation of the `str` values of\nthe arguments.",
                            :ns "cljs.core",
                            :name "str",
                            :signature ["[]" "[x]" "[x & ys]"],
                            :history [["+" "0.0-927"]],
                            :type "function/macro",
                            :full-name-encode "cljs.core/str",
                            :source {:code "(defn str\n  ([] \"\")\n  ([x] (if (nil? x)\n         \"\"\n         (.join #js [x] \"\")))\n  ([x & ys]\n    (loop [sb (StringBuffer. (str x)) more ys]\n      (if more\n        (recur (. sb  (append (str (first more)))) (next more))\n        (.toString sb)))))",
                                     :title "Function code",
                                     :repo "clojurescript",
                                     :tag "r1.7.228",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [2617 2629]},
                            :extra-sources [{:code "(core/defmacro str [& xs]\n  (core/let [strs (core/->> (repeat (count xs) \"cljs.core.str(~{})\")\n                    (interpose \",\")\n                    (apply core/str))]\n    (list* 'js* (core/str \"[\" strs \"].join('')\") xs)))",
                                             :title "Macro code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/clojure/cljs/core.cljc",
                                             :lines [781 785]}],
                            :full-name "cljs.core/str",
                            :clj-symbol "clojure.core/str",
                            :docstring "With no args, returns the empty string. With one arg x, returns\nx.toString().  (str nil) returns the empty string. With more than\none arg, returns the concatenation of the str values of the args."},
           "cljs.core/ISequential" {:ns "cljs.core",
                                    :name "ISequential",
                                    :history [["+" "0.0-927"]],
                                    :type "protocol",
                                    :full-name-encode "cljs.core/ISequential",
                                    :source {:code "(defprotocol ISequential\n  \"Marker interface indicating a persistent collection of sequential items\")",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [605 606]},
                                    :full-name "cljs.core/ISequential",
                                    :clj-symbol "clojure.lang/Sequential",
                                    :docstring "Marker interface indicating a persistent collection of sequential items"},
           "cljs.pprint/pprint-newline" {:ns "cljs.pprint",
                                         :name "pprint-newline",
                                         :signature ["[kind]"],
                                         :history [["+" "0.0-3255"]],
                                         :type "function",
                                         :full-name-encode "cljs.pprint/pprint-newline",
                                         :source {:code "(defn pprint-newline\n  [kind]\n  (check-enumerated-arg kind #{:linear :miser :fill :mandatory})\n  (nl *out* kind))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.7.228",
                                                  :filename "src/main/cljs/cljs/pprint.cljs",
                                                  :lines [841 850]},
                                         :full-name "cljs.pprint/pprint-newline",
                                         :clj-symbol "clojure.pprint/pprint-newline",
                                         :docstring "Print a conditional newline to a pretty printing stream. kind specifies if the\nnewline is :linear, :miser, :fill, or :mandatory.\n\nThis function is intended for use when writing custom dispatch functions.\n\nOutput is sent to *out* which must be a pretty printing writer."},
           "cljs.core/key-test" {:return-type boolean,
                                 :ns "cljs.core",
                                 :name "key-test",
                                 :signature ["[key other]"],
                                 :history [["+" "0.0-1424"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/key-test",
                                 :source {:code "(defn ^boolean key-test [key other]\n  (cond\n    (identical? key other) true\n    (keyword-identical? key other) true\n    :else (= key other)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [6115 6119]},
                                 :full-name "cljs.core/key-test"},
           "cljs.core/set" {:description "Returns a set of the distinct elements of `coll`.",
                            :ns "cljs.core",
                            :name "set",
                            :signature ["[coll]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/hash-set"
                                      "cljs.core/sorted-set"
                                      "cljs.core/conj"
                                      "cljs.core/disj"
                                      "cljs.core/distinct"
                                      "clojure.set/join"
                                      "clojure.set/select"
                                      "clojure.set/difference"
                                      "clojure.set/intersection"
                                      "clojure.set/union"
                                      "clojure.set/index"
                                      "clojure.set/project"
                                      "clojure.set/rename"
                                      "clojure.set/rename-keys"
                                      "clojure.set/map-invert"],
                            :full-name-encode "cljs.core/set",
                            :source {:code "(defn set\n  [coll]\n  (let [in (seq coll)]\n    (cond\n      (nil? in) #{}\n\n      (and (instance? IndexedSeq in) (zero? (.-i in)))\n      (set-from-indexed-seq in)\n\n      :else\n      (loop [^not-native in in\n             ^not-native out (-as-transient #{})]\n        (if-not (nil? in)\n          (recur (next in) (-conj! out (-first in)))\n          (persistent! out))))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.7.228",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [8211 8226]},
                            :full-name "cljs.core/set",
                            :clj-symbol "clojure.core/set",
                            :docstring "Returns a set of the distinct elements of coll."},
           "cljs.analyzer.api/default-warning-handler" {:ns "cljs.analyzer.api",
                                                        :name "default-warning-handler",
                                                        :signature ["[warning-type env extra]"],
                                                        :history [["+"
                                                                   "1.7.10"]],
                                                        :type "function",
                                                        :full-name-encode "cljs.analyzer.api/default-warning-handler",
                                                        :source {:code "(defn default-warning-handler\n  [warning-type env extra]\n  (ana/default-warning-handler warning-type env extra))",
                                                                 :title "Source code",
                                                                 :repo "clojurescript",
                                                                 :tag "r1.7.228",
                                                                 :filename "src/main/clojure/cljs/analyzer/api.clj",
                                                                 :lines [48
                                                                         53]},
                                                        :full-name "cljs.analyzer.api/default-warning-handler",
                                                        :docstring "The default warning handler.\n\nOutputs the warning messages to *err*."},
           "cljs.repl.nashorn/load-js-file" {:ns "cljs.repl.nashorn",
                                             :name "load-js-file",
                                             :type "function",
                                             :signature ["[engine file]"],
                                             :source {:code "(defn load-js-file [engine file]\n      (eval-str engine (format \"nashorn_load(\\\"%s\\\");\" file)))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.7.228",
                                                      :filename "src/main/clojure/cljs/repl/nashorn.clj",
                                                      :lines [75 76]},
                                             :full-name "cljs.repl.nashorn/load-js-file",
                                             :full-name-encode "cljs.repl.nashorn/load-js-file",
                                             :history [["+"
                                                        "0.0-2814"]]},
           "cljs.core/obj-map" {:ns "cljs.core",
                                :name "obj-map",
                                :signature ["[& keyvals]"],
                                :history [["+" "0.0-1443"]],
                                :type "function",
                                :full-name-encode "cljs.core/obj-map",
                                :source {:code "(defn obj-map\n  [& keyvals]\n  (let [ks  (array)\n        obj (js-obj)]\n    (loop [kvs (seq keyvals)]\n      (if kvs\n        (do (.push ks (first kvs))\n            (aset obj (first kvs) (second kvs))\n            (recur (nnext kvs)))\n        (.fromObject ObjMap ks obj)))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [7756 7767]},
                                :full-name "cljs.core/obj-map",
                                :docstring "keyval => key val\nReturns a new object map with supplied mappings."},
           "special/def" {:description "Creates a global variable with the name of `symbol` and a namespace of the\ncurrent namespace.\n\nIf `init` is supplied, it is evaluated and the result is assigned to `symbol`.\n\n`doc-string` is an optional documentation string.\n\n`def` is one of ClojureScript's [special forms](http://clojure.org/special_forms)\nand is used by many macros to define common elements (ie: `defn`, `defmacro`,\netc).\n\nSupported metadata:\n\n- `^:private boolean` - make non-accessible from other namespaces\n- `^:dynamic boolean` - make [dynamically bindable][doc:cljs.core/binding] (usually named with [doc:syntax/earmuffs])\n- `^:const boolean` - prevents redef and allows it to be used in [doc:cljs.core/case].\n- `^:jsdoc [\"\"]` - vector of JSDoc Tags for [Google Closure][closure-jsdoc] or [standard][other-jsdoc].\n- `^:test (fn [] (assert ...))` - allows function to be tested with [doc:cljs.core/test].\n- `^:doc \"\"` - doc-string (prefer the use of the `(def symbol doc-string init)`)\n\n[closure-jsdoc]:https://developers.google.com/closure/compiler/docs/js-for-compiler?hl=en#tags\n[other-jsdoc]:http://usejsdoc.org/#block-tags\n\nCompiler will also add metadata:\n\n- `:ns`\n- `:name`\n- `:file`\n- `:line`, `:end-line`\n- `:column`, `:end-column`\n- `:source`\n- `:arglists`",
                          :ns "special",
                          :name "def",
                          :signature ["[symbol]"
                                      "[symbol init]"
                                      "[symbol doc-string init]"],
                          :history [["+" "0.0-927"]],
                          :type "special form",
                          :related ["cljs.core/defn"
                                    "cljs.core/fn"
                                    "cljs.core/defmacro"
                                    "cljs.core/defmulti"],
                          :full-name-encode "special/def",
                          :source {:code "(defmethod parse 'def\n  [op env form name _]\n  (let [pfn (fn\n              ([_ sym] {:sym sym})\n              ([_ sym init] {:sym sym :init init})\n              ([_ sym doc init] {:sym sym :doc doc :init init}))\n        args (apply pfn form)\n        sym (:sym args)\n        sym-meta (meta sym)\n        tag (-> sym meta :tag)\n        protocol (-> sym meta :protocol)\n        dynamic (-> sym meta :dynamic)\n        ns-name (-> env :ns :name)\n        locals (:locals env)\n        clash-ns (symbol (str ns-name \".\" sym))]\n    (when (get-in @env/*compiler* [::namespaces clash-ns])\n      (warning :ns-var-clash env\n        {:ns (symbol (str ns-name \".\" sym))\n         :var (symbol (str ns-name) (str sym))}))\n    (when (namespace sym)\n      (throw (error env \"Can't def ns-qualified name\")))\n    (when (:const (resolve-var (dissoc env :locals) sym))\n      (throw (error env \"Can't redefine a constant\")))\n    (when-let [doc (:doc args)]\n      (when-not (string? doc)\n        (throw (error env \"Too many arguments to def\"))))\n    (when-let [v (get-in @env/*compiler* [::namespaces ns-name :defs sym])]\n      (when (and (not *allow-redef*)\n                 (not (:declared v))\n                 (not (:declared sym-meta))\n                 *file-defs*\n                 (get @*file-defs* sym))\n        (warning :redef-in-file env {:sym sym :line (:line v)})))\n    (when *file-defs*\n      (swap! *file-defs* conj sym))\n    (let [env (if (or (and (not= ns-name 'cljs.core)\n                           (core-name? env sym))\n                      (get-in @env/*compiler* [::namespaces ns-name :uses sym]))\n                (let [ev (resolve-existing-var (dissoc env :locals) sym)]\n                  (warning :redef env {:sym sym :ns (:ns ev) :ns-name ns-name})\n                  (swap! env/*compiler* update-in [::namespaces ns-name :excludes] conj sym)\n                  (update-in env [:ns :excludes] conj sym))\n                env)\n          var-name (:name (resolve-var (dissoc env :locals) sym))\n          init-expr (when (contains? args :init)\n                      (swap! env/*compiler* assoc-in [::namespaces ns-name :defs sym]\n                        (merge\n                          {:name var-name}\n                          sym-meta\n                          (when dynamic {:dynamic true})\n                          (source-info var-name env)))\n                      (disallowing-recur\n                        (analyze (assoc env :context :expr) (:init args) sym)))\n          fn-var? (and init-expr (= (:op init-expr) :fn))\n          tag (if fn-var?\n                (or (:ret-tag init-expr) tag)\n                tag)\n          export-as (when-let [export-val (-> sym meta :export)]\n                      (if (= true export-val) var-name export-val))\n          doc (or (:doc args) (-> sym meta :doc))]\n      (when-let [v (get-in @env/*compiler* [::namespaces ns-name :defs sym])]\n        (when (and (not (-> sym meta :declared))\n                   (and (:fn-var v) (not fn-var?)))\n          (warning :fn-var env {:ns-name ns-name :sym sym})))\n      (swap! env/*compiler* assoc-in [::namespaces ns-name :defs sym]\n        (merge\n          {:name var-name}\n          ;; remove actual test metadata, as it includes non-valid EDN and\n          ;; cannot be present in analysis cached to disk - David\n          (cond-> sym-meta\n            (:test sym-meta) (assoc :test true))\n          {:meta (-> sym-meta\n                   (dissoc :test)\n                   (update-in [:file]\n                     (fn [f]\n                       (if (= (-> env :ns :name) 'cljs.core)\n                         \"cljs/core.cljs\"\n                         f))))}\n          (when doc {:doc doc})\n          (when dynamic {:dynamic true})\n          (source-info var-name env)\n          ;; the protocol a protocol fn belongs to\n          (when protocol\n            {:protocol protocol})\n          ;; symbol for reified protocol\n          (when-let [protocol-symbol (-> sym meta :protocol-symbol)]\n            {:protocol-symbol protocol-symbol\n             :info (-> protocol-symbol meta :protocol-info)\n             :impls #{}})\n          (when fn-var?\n            (let [params (map #(vec (map :name (:params %))) (:methods init-expr))]\n              (merge\n                {:fn-var true\n                 ;; protocol implementation context\n                 :protocol-impl (:protocol-impl init-expr)\n                 ;; inline protocol implementation context\n                 :protocol-inline (:protocol-inline init-expr)}\n                (if-let [top-fn-meta (:top-fn sym-meta)]\n                  top-fn-meta\n                  {:variadic (:variadic init-expr)\n                   :max-fixed-arity (:max-fixed-arity init-expr)\n                   :method-params params\n                   :arglists (:arglists sym-meta)\n                   :arglists-meta (doall (map meta (:arglists sym-meta)))}))) )\n          (when (and fn-var? tag)\n            {:ret-tag tag})))\n      (merge\n        {:env env\n         :op :def\n         :form form\n         :name var-name\n         :var (assoc\n                (analyze\n                  (-> env (dissoc :locals)\n                    (assoc :context :expr)\n                    (assoc :def-var true))\n                  sym)\n                :op :var)\n         :doc doc\n         :jsdoc (:jsdoc sym-meta)\n         :init init-expr}\n        (when (:def-emits-var env)\n          {:var-ast (var-ast env sym)})\n        (when-let [test (:test sym-meta)]\n          {:test (analyze (assoc env :context :expr) test)})\n        (when tag\n          (if fn-var?\n            {:ret-tag tag}\n            {:tag tag}))\n        (when dynamic {:dynamic true})\n        (when export-as {:export export-as})\n        (when init-expr {:children [init-expr]})))))",
                                   :title "Parser code",
                                   :repo "clojurescript",
                                   :tag "r1.7.228",
                                   :filename "src/main/clojure/cljs/analyzer.cljc",
                                   :lines [1069 1200]},
                          :examples [{:id "a5f898",
                                      :content "```clj\n(def a)\na\n;;=> nil\n\n(def b 42)\nb\n;;=> 42\n\n(def c \"an optional docstring\" 42)\nc\n;;=> 42\n```"}],
                          :known-as "define",
                          :full-name "special/def",
                          :clj-symbol "clojure.core/def",
                          :docstring "Creates and interns a global var with the name\nof symbol in the current namespace (*ns*) or locates such a var if\nit already exists.  If init is supplied, it is evaluated, and the\nroot binding of the var is set to the resulting value.  If init is\nnot supplied, the root binding of the var is unaffected."},
           "clojure.browser.repl/load-queue" {:ns "clojure.browser.repl",
                                              :name "load-queue",
                                              :type "var",
                                              :source {:code "(def load-queue nil)",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.7.228",
                                                       :filename "src/main/cljs/clojure/browser/repl.cljs",
                                                       :lines [123]},
                                              :full-name "clojure.browser.repl/load-queue",
                                              :full-name-encode "clojure.browser.repl/load-queue",
                                              :history [["+"
                                                         "0.0-3115"]]},
           "cljs.core/print" {:ns "cljs.core",
                              :name "print",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/print",
                              :source {:code "(def ^{:doc\n  \"Prints the object(s) using string-print.\n  print and println produce output for human consumption.\"}\n  print\n  (fn cljs-core-print [& objs]\n    (pr-with-opts objs (assoc (pr-opts) :readably false))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [8949 8954]},
                              :full-name "cljs.core/print",
                              :clj-symbol "clojure.core/print",
                              :docstring "Prints the object(s) using string-print.\nprint and println produce output for human consumption."},
           "cljs.core/ArrayNode" {:ns "cljs.core",
                                  :name "ArrayNode",
                                  :signature ["[edit cnt arr]"],
                                  :history [["+" "0.0-1211"]],
                                  :type "type",
                                  :full-name-encode "cljs.core/ArrayNode",
                                  :source {:code "(deftype ArrayNode [edit ^:mutable cnt ^:mutable arr]\n  Object\n  (inode-assoc [inode shift hash key val added-leaf?]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if (nil? node)\n        (ArrayNode. nil (inc cnt) (clone-and-set arr idx (.inode-assoc (.-EMPTY BitmapIndexedNode) (+ shift 5) hash key val added-leaf?)))\n        (let [n (.inode-assoc node (+ shift 5) hash key val added-leaf?)]\n          (if (identical? n node)\n            inode\n            (ArrayNode. nil cnt (clone-and-set arr idx n)))))))\n\n  (inode-without [inode shift hash key]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if-not (nil? node)\n        (let [n (.inode-without node (+ shift 5) hash key)]\n          (cond\n            (identical? n node)\n            inode\n\n            (nil? n)\n            (if (<= cnt 8)\n              (pack-array-node inode nil idx)\n              (ArrayNode. nil (dec cnt) (clone-and-set arr idx n)))\n\n            :else\n            (ArrayNode. nil cnt (clone-and-set arr idx n))))\n        inode)))\n\n  (inode-lookup [inode shift hash key not-found]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if-not (nil? node)\n        (.inode-lookup node (+ shift 5) hash key not-found)\n        not-found)))\n\n  (inode-find [inode shift hash key not-found]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if-not (nil? node)\n        (.inode-find node (+ shift 5) hash key not-found)\n        not-found)))\n\n  (inode-seq [inode]\n    (create-array-node-seq arr))\n\n  (ensure-editable [inode e]\n    (if (identical? e edit)\n      inode\n      (ArrayNode. e cnt (aclone arr))))\n\n  (inode-assoc! [inode edit shift hash key val added-leaf?]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if (nil? node)\n        (let [editable (edit-and-set inode edit idx (.inode-assoc! (.-EMPTY BitmapIndexedNode) edit (+ shift 5) hash key val added-leaf?))]\n          (set! (.-cnt editable) (inc (.-cnt editable)))\n          editable)\n        (let [n (.inode-assoc! node edit (+ shift 5) hash key val added-leaf?)]\n          (if (identical? n node)\n            inode\n            (edit-and-set inode edit idx n))))))\n\n  (inode-without! [inode edit shift hash key removed-leaf?]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if (nil? node)\n        inode\n        (let [n (.inode-without! node edit (+ shift 5) hash key removed-leaf?)]\n          (cond\n            (identical? n node)\n            inode\n\n            (nil? n)\n            (if (<= cnt 8)\n              (pack-array-node inode edit idx)\n              (let [editable (edit-and-set inode edit idx n)]\n                (set! (.-cnt editable) (dec (.-cnt editable)))\n                editable))\n\n            :else\n            (edit-and-set inode edit idx n))))))\n\n  (kv-reduce [inode f init]\n    (let [len (alength arr)]           ; actually 32\n      (loop [i 0 init init]\n        (if (< i len)\n          (let [node (aget arr i)]\n            (if-not (nil? node)\n              (let [init (.kv-reduce node f init)]\n                (if (reduced? init)\n                  @init\n                  (recur (inc i) init)))\n              (recur (inc i) init)))\n          init))))\n\n IIterable\n (-iterator [coll]\n    (ArrayNodeIterator. arr 0 nil)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [6447 6546]},
                                  :full-name "cljs.core/ArrayNode",
                                  :clj-symbol "clojure.lang/ArrayNode"},
           "cljs.core/type" {:ns "cljs.core",
                             :name "type",
                             :signature ["[x]"],
                             :history [["+" "0.0-971"]],
                             :type "function",
                             :full-name-encode "cljs.core/type",
                             :source {:code "(defn type\n  [x]\n  (when-not (nil? x)\n    (.-constructor x)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [253 257]},
                             :full-name "cljs.core/type",
                             :clj-symbol "clojure.core/type",
                             :docstring "Return x's constructor."},
           "clojure.string/blank?" {:description "True if `s` is nil, empty, or contains only whitespace.",
                                    :return-type boolean,
                                    :ns "clojure.string",
                                    :name "blank?",
                                    :signature ["[s]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "clojure.string/blankQMARK",
                                    :source {:code "(defn ^boolean blank?\n  [s]\n  (gstring/isEmptySafe s))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/clojure/string.cljs",
                                             :lines [193 196]},
                                    :full-name "clojure.string/blank?",
                                    :clj-symbol "clojure.string/blank?",
                                    :docstring "True is s is nil, empty, or contains only whitespace."},
           "syntax/keyword" {:description "A keyword is a string-like datatype that evaluates to itself.  Keywords are often used\nas enums or keys for maps.  Keywords should not start with a number.\n\nKeywords can have an optional namespace. For example, `:foo/bar`. This is useful\nfor functions in a namespace to prevent key collisions on a globally accessible\nmap.",
                             :ns "syntax",
                             :name "keyword",
                             :history [["+" "0.0-927"]],
                             :type "syntax",
                             :related ["syntax/keyword-qualify"
                                       "cljs.core/keyword"
                                       "cljs.core/keyword?"],
                             :full-name-encode "syntax/keyword",
                             :extra-sources ({:code "(defn- read-keyword\n  [reader initch opts pending-forms]\n  (let [ch (read-char reader)]\n    (if-not (whitespace? ch)\n      (let [token (read-token reader ch)\n            s (parse-symbol token)]\n        (if s\n          (let [^String ns (s 0)\n                ^String name (s 1)]\n            (if (identical? \\: (nth token 0))\n              (if ns\n                (let [ns (resolve-ns (symbol (subs ns 1)))]\n                  (if ns\n                    (keyword (str ns) name)\n                    (reader-error reader \"Invalid token: :\" token)))\n                (keyword (str *ns*) (subs name 1)))\n              (keyword ns name)))\n          (reader-error reader \"Invalid token: :\" token)))\n      (reader-error reader \"Invalid token: :\"))))",
                                              :title "Reader code",
                                              :repo "tools.reader",
                                              :tag "tools.reader-1.0.0-alpha1",
                                              :filename "src/main/clojure/clojure/tools/reader.clj",
                                              :lines [343 361]}
                                             {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                              :title "Reader table",
                                              :repo "tools.reader",
                                              :tag "tools.reader-1.0.0-alpha1",
                                              :filename "src/main/clojure/clojure/tools/reader.clj",
                                              :lines [743 762]}),
                             :usage [":foo" ":foo/bar"],
                             :examples [{:id "e5fdbe",
                                         :content "```clj\n:foo\n;;=> :foo\n\n:a/foo\n;;=> :a/foo\n```"}
                                        {:id "9765fe",
                                         :content "A keyword is also callable for retrieving values from a map:\n\n```clj\n(def m {:foo 1})\n(:foo m)\n;;=> 1\n\n(def things [{:foo 1 :bar 2}\n             {:foo 3 :bar 4}\n             {:foo 5 :bar 6}])\n(map :foo things)\n;;=> (1 3 5)\n```"}],
                             :edn-doc "https://github.com/edn-format/edn#keywords",
                             :full-name "syntax/keyword",
                             :display ": keyword",
                             :clj-doc "http://clojure.org/reader#toc1"},
           "cljs.reader/maybe-read-tagged-type" {:ns "cljs.reader",
                                                 :name "maybe-read-tagged-type",
                                                 :type "function",
                                                 :signature ["[rdr initch]"],
                                                 :source {:code "(defn maybe-read-tagged-type\n  [rdr initch]\n  (let [tag (read-symbol rdr initch)\n        pfn (get @*tag-table* (str tag))\n        dfn @*default-data-reader-fn*]\n    (cond\n     pfn (pfn (read rdr true nil false))\n     dfn (dfn tag (read rdr true nil false))\n     :else (reader-error rdr\n                         \"Could not find tag parser for \" (str tag)\n                         \" in \" (pr-str (keys @*tag-table*))))))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r1.7.228",
                                                          :filename "src/main/cljs/cljs/reader.cljs",
                                                          :lines [594
                                                                  604]},
                                                 :full-name "cljs.reader/maybe-read-tagged-type",
                                                 :full-name-encode "cljs.reader/maybe-read-tagged-type",
                                                 :history [["+"
                                                            "0.0-1236"]]},
           "cljs.core/js-inline-comment" {:ns "cljs.core",
                                          :name "js-inline-comment",
                                          :signature ["[comment]"],
                                          :history [["+" "1.7.107"]],
                                          :type "macro",
                                          :full-name-encode "cljs.core/js-inline-comment",
                                          :source {:code "(core/defmacro js-inline-comment\n  [comment]\n  (core/list 'js* (core/str \"/**\" comment \"*/\")))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/clojure/cljs/core.cljc",
                                                   :lines [893 896]},
                                          :full-name "cljs.core/js-inline-comment",
                                          :docstring "Emit an inline JavaScript comment."},
           "cljs.core/IChunkedSeq" {:ns "cljs.core",
                                    :name "IChunkedSeq",
                                    :history [["+" "0.0-1424"]],
                                    :type "protocol",
                                    :full-name-encode "cljs.core/IChunkedSeq",
                                    :source {:code "(defprotocol IChunkedSeq\n  \"Protocol for accessing a collection as sequential chunks.\"\n  (-chunked-first [coll]\n    \"Returns the first chunk in coll.\")\n  (-chunked-rest [coll]\n    \"Return a new collection of coll with the first chunk removed.\"))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [713 718]},
                                    :methods [{:name "-chunked-first",
                                               :signature ["[coll]"],
                                               :docstring "Returns the first chunk in coll."}
                                              {:name "-chunked-rest",
                                               :signature ["[coll]"],
                                               :docstring "Return a new collection of coll with the first chunk removed."}],
                                    :full-name "cljs.core/IChunkedSeq",
                                    :clj-symbol "clojure.lang/IChunkedSeq",
                                    :docstring "Protocol for accessing a collection as sequential chunks."},
           "clojure.browser.dom/append" {:ns "clojure.browser.dom",
                                         :name "append",
                                         :type "function",
                                         :signature ["[parent & children]"],
                                         :source {:code "(defn append [parent & children]\n  (apply gdom/append parent children)\n  parent)",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.7.228",
                                                  :filename "src/main/cljs/clojure/browser/dom.cljs",
                                                  :lines [13 15]},
                                         :full-name "clojure.browser.dom/append",
                                         :full-name-encode "clojure.browser.dom/append",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/take-last" {:description "Returns a sequence of the last `n` items in `coll`.\n\nDepending on the type of collection, `take-last` may be no faster than linear\ntime. For vectors, please use `subvec`.",
                                  :ns "cljs.core",
                                  :name "take-last",
                                  :signature ["[n coll]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/last"
                                            "cljs.core/butlast"
                                            "cljs.core/drop-last"],
                                  :full-name-encode "cljs.core/take-last",
                                  :source {:code "(defn take-last\n  [n coll]\n  (loop [s (seq coll), lead (seq (drop n coll))]\n    (if lead\n      (recur (next s) (next lead))\n      s)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [4300 4307]},
                                  :full-name "cljs.core/take-last",
                                  :clj-symbol "clojure.core/take-last",
                                  :docstring "Returns a seq of the last n items in coll.  Depending on the type\nof coll may be no better than linear time.  For vectors, see also subvec."},
           "cljs.core/key->js" {:ns "cljs.core",
                                :name "key->js",
                                :type "function",
                                :signature ["[k]"],
                                :source {:code "(defn key->js [k]\n  (if (satisfies? IEncodeJS k)\n    (-clj->js k)\n    (if (or (string? k)\n            (number? k)\n            (keyword? k)\n            (symbol? k))\n      (clj->js k)\n      (pr-str k))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [9306 9314]},
                                :full-name "cljs.core/key->js",
                                :full-name-encode "cljs.core/key-GTjs",
                                :history [["+" "0.0-1798"]]},
           "cljs.repl.browser/setup" {:ns "cljs.repl.browser",
                                      :name "setup",
                                      :type "function",
                                      :signature ["[{:keys [working-dir], :as repl-env} opts]"],
                                      :source {:code "(defn setup [{:keys [working-dir] :as repl-env} opts]\n  (binding [browser-state (:browser-state repl-env)\n            ordering (:ordering repl-env)\n            es (:es repl-env)\n            server/state (:server-state repl-env)]\n    (repl/err-out (println \"Compiling client js ...\"))\n    (swap! browser-state\n      (fn [old]\n        (assoc old :client-js\n          (create-client-js-file\n            repl-env (io/file working-dir \"client.js\")))))\n    (repl/err-out (println \"Waiting for browser to connect ...\"))\n    opts\n    (server/start repl-env)))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/clojure/cljs/repl/browser.clj",
                                               :lines [238 251]},
                                      :full-name "cljs.repl.browser/setup",
                                      :full-name-encode "cljs.repl.browser/setup",
                                      :history [["+" "0.0-2665"]]},
           "cljs.core/TransientHashMap" {:ns "cljs.core",
                                         :name "TransientHashMap",
                                         :signature ["[edit root count has-nil? nil-val]"],
                                         :history [["+" "0.0-1211"]],
                                         :type "type",
                                         :full-name-encode "cljs.core/TransientHashMap",
                                         :source {:code "(deftype TransientHashMap [^:mutable ^boolean edit\n                           ^:mutable root\n                           ^:mutable count\n                           ^:mutable ^boolean has-nil?\n                           ^:mutable nil-val]\n  Object\n  (conj! [tcoll o]\n    (if edit\n      (if (satisfies? IMapEntry o)\n        (.assoc! tcoll (key o) (val o))\n        (loop [es (seq o) tcoll tcoll]\n          (if-let [e (first es)]\n            (recur (next es)\n                   (.assoc! tcoll (key e) (val e)))\n            tcoll)))\n      (throw (js/Error. \"conj! after persistent\"))))\n\n  (assoc! [tcoll k v]\n    (if edit\n      (if (nil? k)\n        (do (if (identical? nil-val v)\n              nil\n              (set! nil-val v))\n            (if has-nil?\n              nil\n              (do (set! count (inc count))\n                  (set! has-nil? true)))\n            tcoll)\n        (let [added-leaf? (Box. false)\n              node        (-> (if (nil? root)\n                                (.-EMPTY BitmapIndexedNode)\n                                root)\n                              (.inode-assoc! edit 0 (hash k) k v added-leaf?))]\n          (if (identical? node root)\n            nil\n            (set! root node))\n          (if ^boolean (.-val added-leaf?)\n            (set! count (inc count)))\n          tcoll))\n      (throw (js/Error. \"assoc! after persistent!\"))))\n\n  (without! [tcoll k]\n    (if edit\n      (if (nil? k)\n        (if has-nil?\n          (do (set! has-nil? false)\n              (set! nil-val nil)\n              (set! count (dec count))\n              tcoll)\n          tcoll)\n        (if (nil? root)\n          tcoll\n          (let [removed-leaf? (Box. false)\n                node (.inode-without! root edit 0 (hash k) k removed-leaf?)]\n            (if (identical? node root)\n              nil\n              (set! root node))\n            (if (aget removed-leaf? 0)\n              (set! count (dec count)))\n            tcoll)))\n      (throw (js/Error. \"dissoc! after persistent!\"))))\n\n  (persistent! [tcoll]\n    (if edit\n      (do (set! edit nil)\n          (PersistentHashMap. nil count root has-nil? nil-val nil))\n      (throw (js/Error. \"persistent! called twice\"))))\n\n  ICounted\n  (-count [coll]\n    (if edit\n      count\n      (throw (js/Error. \"count after persistent!\"))))\n\n  ILookup\n  (-lookup [tcoll k]\n    (if (nil? k)\n      (if has-nil?\n        nil-val)\n      (if (nil? root)\n        nil\n        (.inode-lookup root 0 (hash k) k))))\n\n  (-lookup [tcoll k not-found]\n    (if (nil? k)\n      (if has-nil?\n        nil-val\n        not-found)\n      (if (nil? root)\n        not-found\n        (.inode-lookup root 0 (hash k) k not-found))))\n\n  ITransientCollection\n  (-conj! [tcoll val] (.conj! tcoll val))\n\n  (-persistent! [tcoll] (.persistent! tcoll))\n\n  ITransientAssociative\n  (-assoc! [tcoll key val] (.assoc! tcoll key val))\n\n  ITransientMap\n  (-dissoc! [tcoll key] (.without! tcoll key)))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.7.228",
                                                  :filename "src/main/cljs/cljs/core.cljs",
                                                  :lines [6963 7064]},
                                         :full-name "cljs.core/TransientHashMap",
                                         :clj-symbol "clojure.lang/TransientHashMap"},
           "clojure.set/intersection" {:description "Return a set that is the intersection of the input sets.",
                                       :ns "clojure.set",
                                       :name "intersection",
                                       :signature ["[s1]"
                                                   "[s1 s2]"
                                                   "[s1 s2 & sets]"],
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :related ["clojure.set/union"
                                                 "clojure.set/difference"
                                                 "clojure.set/superset?"
                                                 "clojure.set/project"],
                                       :full-name-encode "clojure.set/intersection",
                                       :source {:code "(defn intersection\n  ([s1] s1)\n  ([s1 s2]\n     (if (< (count s2) (count s1))\n       (recur s2 s1)\n       (reduce (fn [result item]\n                   (if (contains? s2 item)\n\t\t     result\n                     (disj result item)))\n\t       s1 s1)))\n  ([s1 s2 & sets] \n     (let [bubbled-sets (bubble-max-key #(- (count %)) (conj sets s2 s1))]\n       (reduce intersection (first bubbled-sets) (rest bubbled-sets)))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/clojure/set.cljs",
                                                :lines [31 44]},
                                       :full-name "clojure.set/intersection",
                                       :clj-symbol "clojure.set/intersection",
                                       :docstring "Return a set that is the intersection of the input sets"},
           "cljs.js/atom?" {:ns "cljs.js",
                            :name "atom?",
                            :signature ["[x]"],
                            :history [["+" "1.7.10"] ["-" "1.7.48"]],
                            :type "function",
                            :full-name-encode "cljs.js/atomQMARK",
                            :source {:code "(defn atom? [x]\n  (instance? Atom x))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.7.28",
                                     :filename "src/main/cljs/cljs/js.cljs",
                                     :lines [41 42]},
                            :full-name "cljs.js/atom?",
                            :removed {:in "1.7.48",
                                      :last-seen "1.7.28"}},
           "cljs.test/async?" {:ns "cljs.test",
                               :name "async?",
                               :signature ["[x]"],
                               :history [["+" "0.0-2814"]],
                               :type "function",
                               :full-name-encode "cljs.test/asyncQMARK",
                               :source {:code "(defn async?\n  [x]\n  (satisfies? IAsyncTest x))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/test.cljs",
                                        :lines [421 424]},
                               :full-name "cljs.test/async?",
                               :docstring "Returns whether x implements IAsyncTest."},
           "cljs.core/fnext" {:description "Same as `(first (next coll))`",
                              :ns "cljs.core",
                              :name "fnext",
                              :signature ["[coll]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/ffirst"
                                        "cljs.core/second"],
                              :full-name-encode "cljs.core/fnext",
                              :source {:code "(defn fnext\n  [coll]\n  (first (next coll)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [1545 1548]},
                              :examples [{:id "92383f",
                                          :content "```clj\n(fnext [1 2 3])\n;;=> 2\n\n(fnext [1 2])\n;;=> 2\n\n(fnext [1])\n;;=> nil\n\n(fnext [])\n;;=> nil\n```"}],
                              :full-name "cljs.core/fnext",
                              :clj-symbol "clojure.core/fnext",
                              :docstring "Same as (first (next x))"},
           "cljs.core/apply" {:description "Applies function `f` to the argument list formed by prepending intervening\narguments to `args`.",
                              :ns "cljs.core",
                              :name "apply",
                              :signature ["[f args]"
                                          "[f x args]"
                                          "[f x y args]"
                                          "[f x y z args]"
                                          "[f a b c d & args]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/map"],
                              :full-name-encode "cljs.core/apply",
                              :source {:code "(defn apply\n  ([f args]\n     (let [fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (let [bc (bounded-count args (inc fixed-arity))]\n          (if (<= bc fixed-arity)\n            (apply-to f bc args)\n            (.cljs$lang$applyTo f args)))\n         (.apply f f (to-array args)))))\n  ([f x args]\n     (let [arglist (list* x args)\n           fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (let [bc (bounded-count arglist (inc fixed-arity))]\n          (if (<= bc fixed-arity)\n            (apply-to f bc arglist)\n            (.cljs$lang$applyTo f arglist)))\n         (.apply f f (to-array arglist)))))\n  ([f x y args]\n     (let [arglist (list* x y args)\n           fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (let [bc (bounded-count arglist (inc fixed-arity))]\n          (if (<= bc fixed-arity)\n            (apply-to f bc arglist)\n            (.cljs$lang$applyTo f arglist)))\n         (.apply f f (to-array arglist)))))\n  ([f x y z args]\n     (let [arglist (list* x y z args)\n           fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (let [bc (bounded-count arglist (inc fixed-arity))]\n          (if (<= bc fixed-arity)\n            (apply-to f bc arglist)\n            (.cljs$lang$applyTo f arglist)))\n         (.apply f f (to-array arglist)))))\n  ([f a b c d & args]\n     (let [arglist (cons a (cons b (cons c (cons d (spread args)))))\n           fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (let [bc (bounded-count arglist (inc fixed-arity))]\n          (if (<= bc fixed-arity)\n            (apply-to f bc arglist)\n            (.cljs$lang$applyTo f arglist)))\n         (.apply f f (to-array arglist))))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [3446 3491]},
                              :examples [{:id "174052",
                                          :content "```clj\n(max 1 2 3)\n;;=> 3\n\n(apply max [1 2 3])\n;;=> 3\n\n(apply max 1 [2 3])\n;;=> 3\n```"}],
                              :full-name "cljs.core/apply",
                              :clj-symbol "clojure.core/apply",
                              :docstring "Applies fn f to the argument list formed by prepending intervening arguments to args."},
           "clojure.walk/prewalk" {:ns "clojure.walk",
                                   :name "prewalk",
                                   :signature ["[f form]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "clojure.walk/prewalk",
                                   :source {:code "(defn prewalk\n  [f form]\n  (walk (partial prewalk f) identity (f form)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/clojure/walk.cljs",
                                            :lines [60 64]},
                                   :full-name "clojure.walk/prewalk",
                                   :clj-symbol "clojure.walk/prewalk",
                                   :docstring "Like postwalk, but does pre-order traversal."},
           "cljs.core/flatten" {:description "Takes any nested combination of sequential things (lists, vectors, etc.) and\nreturns their contents as a single, flat sequence.\n\n`(flatten nil)` returns nil.",
                                :ns "cljs.core",
                                :name "flatten",
                                :signature ["[x]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/flatten",
                                :source {:code "(defn flatten\n  [x]\n  (filter #(not (sequential? %))\n          (rest (tree-seq sequential? seq x))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [4478 4484]},
                                :full-name "cljs.core/flatten",
                                :clj-symbol "clojure.core/flatten",
                                :docstring "Takes any nested combination of sequential things (lists, vectors,\netc.) and returns their contents as a single, flat sequence.\n(flatten nil) returns nil."},
           "cljs.js/valid-name?" {:ns "cljs.js",
                                  :name "valid-name?",
                                  :signature ["[x]"],
                                  :history [["+" "1.7.10"]
                                            ["-" "1.7.48"]],
                                  :type "function",
                                  :full-name-encode "cljs.js/valid-nameQMARK",
                                  :source {:code "(defn valid-name? [x]\n  (or (nil? x) (symbol? x) (string? x)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.28",
                                           :filename "src/main/cljs/cljs/js.cljs",
                                           :lines [44 45]},
                                  :full-name "cljs.js/valid-name?",
                                  :removed {:in "1.7.48",
                                            :last-seen "1.7.28"}},
           "cljs.core/get" {:description "Returns the value mapped to key `k`.\n\nReturns `not-found` or nil if `k` is not present in `o`.",
                            :ns "cljs.core",
                            :name "get",
                            :signature ["[o k]" "[o k not-found]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/get-in"],
                            :full-name-encode "cljs.core/get",
                            :source {:code "(defn get\n  ([o k]\n    (when-not (nil? o)\n      (cond\n        (implements? ILookup o)\n        (-lookup ^not-native o k)\n\n        (array? o)\n        (when (< k (.-length o))\n          (aget o (int k)))\n        \n        (string? o)\n        (when (< k (.-length o))\n          (aget o (int k)))\n\n        (native-satisfies? ILookup o)\n        (-lookup o k)\n        \n        :else nil)))\n  ([o k not-found]\n    (if-not (nil? o)\n      (cond\n        (implements? ILookup o)\n        (-lookup ^not-native o k not-found)\n\n        (array? o)\n        (if (< k (.-length o))\n          (aget o k)\n          not-found)\n        \n        (string? o)\n        (if (< k (.-length o))\n          (aget o k)\n          not-found)\n\n        (native-satisfies? ILookup o)\n        (-lookup o k not-found)\n\n        :else not-found)\n      not-found)))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.7.228",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [1707 1747]},
                            :full-name "cljs.core/get",
                            :clj-symbol "clojure.core/get",
                            :docstring "Returns the value mapped to key, not-found or nil if key not present."},
           "cljs.repl/skip-whitespace" {:ns "cljs.repl",
                                        :name "skip-whitespace",
                                        :signature ["[s]"],
                                        :history [["+" "0.0-2719"]],
                                        :type "function",
                                        :full-name-encode "cljs.repl/skip-whitespace",
                                        :source {:code "(defn skip-whitespace\n  [s]\n  (loop [c (readers/read-char s)]\n    (case c\n      \\newline :line-start\n      nil :stream-end\n      \\; (do (readers/read-line s) :line-start)\n      (if (or (Character/isWhitespace c) (identical? c \\,))\n        (recur (readers/read-char s))\n        (do (readers/unread s c) :body)))))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/clojure/cljs/repl.cljc",
                                                 :lines [59 76]},
                                        :full-name "cljs.repl/skip-whitespace",
                                        :docstring "Skips whitespace characters on stream s. Returns :line-start, :stream-end,\nor :body to indicate the relative location of the next character on s.\nInterprets comma as whitespace and semicolon as comment to end of line.\nDoes not interpret #! as comment to end of line because only one\ncharacter of lookahead is available. The stream must either be an\ninstance of LineNumberingPushbackReader or duplicate its behavior of both\nsupporting .unread and collapsing all of CR, LF, and CRLF to a single\n\\newline."},
           "cljs.core/char" {:description "Converts a number `x` to a character using `String.fromCharCode(x)` from\nJavaScript.",
                             :ns "cljs.core",
                             :name "char",
                             :signature ["[x]"],
                             :history [["+" "0.0-1798"]],
                             :type "function",
                             :full-name-encode "cljs.core/char",
                             :source {:code "(defn char\n  [x]\n  (cond\n    (number? x) (.fromCharCode js/String x)\n    (and (string? x) (== (.-length x) 1)) x\n    :else (throw (js/Error. \"Argument to char must be a character or number\"))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [2358 2364]},
                             :examples [{:id "4e1a56",
                                         :content "```clj\n(char 81)\n;;=> \"Q\"\n\n(char \"Q\")\n;;=> \"Q\"\n\n(char \"foo\")\n;; Error: Argument to char must be a character or number\n```"}],
                             :full-name "cljs.core/char",
                             :clj-symbol "clojure.core/char",
                             :docstring "Coerce to char"},
           "cljs.core/tagged-literal" {:description "Internal use only.  Create tagged literals with their [syntax form][doc:syntax/tagged-literal] instead.",
                                       :ns "cljs.core",
                                       :name "tagged-literal",
                                       :signature ["[tag form]"],
                                       :history [["+" "0.0-3255"]],
                                       :type "function",
                                       :full-name-encode "cljs.core/tagged-literal",
                                       :source {:code "(defn tagged-literal\n  [tag form]\n  {:pre [(symbol? tag)]}\n  (TaggedLiteral. tag form))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/cljs/core.cljs",
                                                :lines [10007 10012]},
                                       :full-name "cljs.core/tagged-literal",
                                       :clj-symbol "clojure.core/tagged-literal",
                                       :docstring "Construct a data representation of a tagged literal from a\ntag symbol and a form."},
           "cljs.core/.." {:description "For interop, the `..` macro allows method/property chaining on the given JavaScript object `o`.\n\nIt essentially combines the thread-first `->` macro with the `.` operator.",
                           :ns "cljs.core",
                           :name "..",
                           :signature ["[o form]" "[o form & more]"],
                           :history [["+" "0.0-927"]],
                           :type "macro",
                           :related ["special/."
                                     "cljs.core/->"
                                     "cljs.core/doto"],
                           :full-name-encode "cljs.core/DOTDOT",
                           :source {:code "(defmacro ..\n  ([x form] `(. ~x ~form))\n  ([x form & more] `(.. (. ~x ~form) ~@more)))",
                                    :title "Source code",
                                    :repo "clojure",
                                    :tag "clojure-1.7.0",
                                    :filename "src/clj/clojure/core.clj",
                                    :lines [1546 1562]},
                           :examples [{:id "500658",
                                       :content "```js\n// JavaScript\n\"a b c d\".toUpperCase().replace(\"A\", \"X\")\n//=> \"X B C D\"\n```\n\n```clj\n;; ClojureScript\n(.. \"a b c d\"\n    toUpperCase\n    (replace \"A\" \"X\"))\n;;=> \"X B C D\"\n```\n\nThis is expanded to:\n\n```clj\n(. (. \"a b c d\" toUpperCase) (replace \"A\" \"X\"))\n```\n\n\nwhich is equivalent to:\n\n```clj\n(.replace (.toUpperCase \"a b c d\") \"A\" \"X\")\n;;=> \"X B C D\"\n```\n\nCompare to the equivalent form using the thread-first `->` macro:\n\n```clj\n(-> \"a b c d\"\n    .toUpperCase\n    (.replace \"A\" \"X\"))\n;;=> \"X B C D\"\n```"}],
                           :full-name "cljs.core/..",
                           :clj-symbol "clojure.core/..",
                           :docstring "form => fieldName-symbol or (instanceMethodName-symbol args*)\n\nExpands into a member access (.) of the first member on the first\nargument, followed by the next member on the result, etc. For\ninstance:\n\n(.. System (getProperties) (get \"os.name\"))\n\nexpands to:\n\n(. (. System (getProperties)) (get \"os.name\"))\n\nbut is easier to write, read, and understand."},
           "cljs.core/floats" {:ns "cljs.core",
                               :name "floats",
                               :signature ["[x]"],
                               :history [["+" "0.0-1798"]],
                               :type "function",
                               :full-name-encode "cljs.core/floats",
                               :source {:code "(defn floats [x] x)",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [2482]},
                               :full-name "cljs.core/floats",
                               :clj-symbol "clojure.core/floats"},
           "specialrepl/require-macros" {:description "Only usable from a REPL.\n\nThis is a way for ClojureScript to load macros from Clojure files.\nThe usage is similar to the `require` form.\n\nThere is a nicer alternative if the Clojure macros file has the same name as a\nClojureScript file in the same directory, which is a common pattern.  In this\ncase, you can just use the `:include-macros` or `:refer-macros` flag of the\n`require` form.",
                                         :ns "specialrepl",
                                         :name "require-macros",
                                         :signature ["[& args]"],
                                         :history [["+" "0.0-2657"]],
                                         :type "special form (repl)",
                                         :related ["specialrepl/require"],
                                         :full-name-encode "specialrepl/require-macros",
                                         :source {:code "(def default-special-fns\n  (let [load-file-fn\n        (fn self\n          ([repl-env env form]\n            (self repl-env env form nil))\n          ([repl-env env [_ file :as form] opts]\n            (load-file repl-env file opts)))\n        in-ns-fn\n        (fn self\n          ([repl-env env form]\n           (self repl-env env form nil))\n          ([repl-env env [_ [quote ns-name] :as form] _]\n            ;; guard against craziness like '5 which wreaks havoc\n           (when-not (and (= quote 'quote) (symbol? ns-name))\n             (throw (IllegalArgumentException. \"Argument to in-ns must be a symbol.\")))\n           (when-not (ana/get-namespace ns-name)\n             (swap! env/*compiler* assoc-in [::ana/namespaces ns-name] {:name ns-name})\n             (-evaluate repl-env \"<cljs repl>\" 1\n               (str \"goog.provide('\" (comp/munge ns-name) \"');\")))\n           (set! ana/*cljs-ns* ns-name)))]\n    (wrap-special-fns wrap-self\n     {'in-ns in-ns-fn\n      'clojure.core/in-ns in-ns-fn\n      'require\n      (fn self\n        ([repl-env env form]\n         (self repl-env env form nil))\n        ([repl-env env [_ & specs :as form] opts]\n         (let [is-self-require? (self-require? specs)\n               [target-ns restore-ns]\n               (if-not is-self-require?\n                 [ana/*cljs-ns* nil]\n                 ['cljs.user ana/*cljs-ns*])]\n           (evaluate-form repl-env env \"<cljs repl>\"\n                          (with-meta\n                            `(~'ns ~target-ns\n                               (:require ~@(-> specs canonicalize-specs decorate-specs)))\n                            {:merge true :line 1 :column 1})\n                          identity opts)\n           (when is-self-require?\n             (set! ana/*cljs-ns* restore-ns)))))\n      'require-macros\n      (fn self\n        ([repl-env env form]\n         (self repl-env env form nil))\n        ([repl-env env [_ & specs :as form] opts]\n         (evaluate-form repl-env env \"<cljs repl>\"\n                        (with-meta\n                          `(~'ns ~ana/*cljs-ns*\n                             (:require-macros ~@(-> specs canonicalize-specs decorate-specs)))\n                          {:merge true :line 1 :column 1})\n                        identity opts)))\n      'import\n      (fn self\n        ([repl-env env form]\n         (self repl-env env form nil))\n        ([repl-env env [_ & specs :as form] opts]\n         (evaluate-form repl-env env \"<cljs repl>\"\n                        (with-meta\n                          `(~'ns ~ana/*cljs-ns*\n                             (:import\n                              ~@(map\n                                 (fn [quoted-spec-or-kw]\n                                   (if (keyword? quoted-spec-or-kw)\n                                     quoted-spec-or-kw\n                                     (second quoted-spec-or-kw)))\n                                 specs)))\n                          {:merge true :line 1 :column 1})\n                        identity opts)))\n      'load-file load-file-fn\n      'clojure.core/load-file load-file-fn\n      'load-namespace\n      (fn self\n        ([repl-env env form]\n         (self env repl-env form nil))\n        ([repl-env env [_ ns :as form] opts]\n         (load-namespace repl-env ns opts)))})))",
                                                  :title "repl specials table",
                                                  :repo "clojurescript",
                                                  :tag "r1.7.228",
                                                  :filename "src/main/clojure/cljs/repl.cljc",
                                                  :lines [642 718]},
                                         :examples [{:id "e34cf4",
                                                     :content "```clj\n(require-macros '[cljs.core.async.macros :refer [go]])\n```"}],
                                         :full-name "specialrepl/require-macros",
                                         :docstring "Similar to the require REPL special function but\n only for macros."},
           "cljs.core/Range" {:ns "cljs.core",
                              :name "Range",
                              :signature ["[meta start end step __hash]"],
                              :history [["+" "0.0-927"]],
                              :type "type",
                              :full-name-encode "cljs.core/Range",
                              :source {:code "(deftype Range [meta start end step ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  ICloneable\n  (-clone [_] (Range. meta start end step __hash))\n\n  IWithMeta\n  (-with-meta [rng meta] (Range. meta start end step __hash))\n\n  IMeta\n  (-meta [rng] meta)\n\n  ISeqable\n  (-seq [rng]\n    (cond\n      (pos? step) (when (< start end) rng)\n      (neg? step) (when (> start end) rng)\n      :else       (when-not (== start end) rng)))\n\n  ISeq\n  (-first [rng]\n    (when-not (nil? (-seq rng)) start))\n  (-rest [rng]\n    (if-not (nil? (-seq rng))\n      (Range. meta (+ start step) end step nil)\n      ()))\n\n  IIterable\n  (-iterator [_]\n    (RangeIterator. start end step))\n\n  INext\n  (-next [rng]\n    (if (pos? step)\n      (when (< (+ start step) end)\n        (Range. meta (+ start step) end step nil))\n      (when (> (+ start step) end)\n        (Range. meta (+ start step) end step nil))))\n\n  ICollection\n  (-conj [rng o] (cons o rng))\n\n  IEmptyableCollection\n  (-empty [rng] (with-meta (.-EMPTY List) meta))\n\n  ISequential\n  IEquiv\n  (-equiv [rng other] (equiv-sequential rng other))\n\n  IHash\n  (-hash [rng] (caching-hash rng hash-ordered-coll __hash))\n\n  ICounted\n  (-count [rng]\n    (if-not (-seq rng)\n      0\n      (Math/ceil (/ (- end start) step))))\n\n  IIndexed\n  (-nth [rng n]\n    (if (< n (-count rng))\n      (+ start (* n step))\n      (if (and (> start end) (zero? step))\n        start\n        (throw (js/Error. \"Index out of bounds\")))))\n  (-nth [rng n not-found]\n    (if (< n (-count rng))\n      (+ start (* n step))\n      (if (and (> start end) (zero? step))\n        start\n        not-found)))\n\n  IReduce\n  (-reduce [rng f] (ci-reduce rng f))\n  (-reduce [rng f init]\n    (loop [i start ret init]\n      (if (if (pos? step) (< i end) (> i end))\n        (let [ret (f ret i)]\n          (if (reduced? ret)\n            @ret\n            (recur (+ i step) ret)))\n        ret))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [8440 8525]},
                              :full-name "cljs.core/Range",
                              :clj-symbol "clojure.lang/Range"},
           "cljs.core/zero?" {:description "Returns true if `n` is 0, false otherwise.",
                              :return-type boolean,
                              :ns "cljs.core",
                              :name "zero?",
                              :signature ["[n]"],
                              :history [["+" "0.0-927"]],
                              :type "function/macro",
                              :related ["cljs.core/pos?"
                                        "cljs.core/neg?"],
                              :full-name-encode "cljs.core/zeroQMARK",
                              :source {:code "(defn ^boolean zero?\n  [n]\n  (cljs.core/zero? n))",
                                       :title "Function code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [2596 2599]},
                              :extra-sources [{:code "(core/defmacro ^::ana/numeric zero? [x]\n  `(== ~x 0))",
                                               :title "Macro code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/clojure/cljs/core.cljc",
                                               :lines [1068 1069]}],
                              :full-name "cljs.core/zero?",
                              :clj-symbol "clojure.core/zero?",
                              :docstring "Returns true if num is zero, else false"},
           "cljs.core/identity" {:description "Returns its argument.",
                                 :ns "cljs.core",
                                 :name "identity",
                                 :signature ["[x]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :related ["cljs.core/nil?"],
                                 :full-name-encode "cljs.core/identity",
                                 :source {:code "(defn identity\n  [x] x)",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [2226 2228]},
                                 :full-name "cljs.core/identity",
                                 :clj-symbol "clojure.core/identity",
                                 :docstring "Returns its argument."},
           "cljs.repl.browser/parse-file" {:ns "cljs.repl.browser",
                                           :name "parse-file",
                                           :signature ["[{:keys [host host-port port], :as repl-env} file {:keys [asset-path], :as opts}]"],
                                           :history [["+" "0.0-3053"]
                                                     ["-" "1.7.10"]],
                                           :type "function",
                                           :full-name-encode "cljs.repl.browser/parse-file",
                                           :source {:code "(defn parse-file [{:keys [host host-port port] :as repl-env} file {:keys [asset-path] :as opts}]\n  (let [base-url-pattern (Pattern/compile (str \"http://\" host \":\" (or host-port port) \"/\"))]\n    (if (re-find base-url-pattern file)\n      (-> file\n        (string/replace base-url-pattern \"\")\n        (string/replace\n          (Pattern/compile\n            (str \"^\" (or asset-path (util/output-directory opts)) \"/\")) \"\"))\n      (if-let [asset-root (:asset-root opts)]\n        (string/replace file asset-root \"\")\n        (throw\n          (ex-info (str \"Could not relativize URL \" file)\n            {:type :parse-stacktrace\n             :reason :relativize-url}))))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r3308",
                                                    :filename "src/main/clojure/cljs/repl/browser.clj",
                                                    :lines [230 243]},
                                           :full-name "cljs.repl.browser/parse-file",
                                           :removed {:in "1.7.10",
                                                     :last-seen "0.0-3308"}},
           "cljs.core/first" {:description "Returns the first item in `coll` and calls `seq` on its argument.\n\nReturns nil when `coll` is nil.",
                              :ns "cljs.core",
                              :name "first",
                              :signature ["[coll]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/rest"
                                        "cljs.core/next"
                                        "cljs.core/nth"
                                        "cljs.core/second"
                                        "cljs.core/take"
                                        "cljs.core/ffirst"],
                              :full-name-encode "cljs.core/first",
                              :source {:code "(defn first\n  [coll]\n  (when-not (nil? coll)\n    (if (implements? ISeq coll)\n      (-first ^not-native coll)\n      (let [s (seq coll)]\n        (when-not (nil? s)\n          (-first s))))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [1093 1102]},
                              :examples [{:id "40e413",
                                          :content "```clj\n(first [1 2 3])\n;;=> 1\n\n(first [])\n;;=> nil\n```"}],
                              :full-name "cljs.core/first",
                              :clj-symbol "clojure.core/first",
                              :docstring "Returns the first item in the collection. Calls seq on its\nargument. If coll is nil, returns nil."},
           "cljs.reader/ratio-pattern" {:ns "cljs.reader",
                                        :name "ratio-pattern",
                                        :type "var",
                                        :source {:code "(def ratio-pattern (re-pattern \"^([-+]?[0-9]+)/([0-9]+)$\"))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/cljs/cljs/reader.cljs",
                                                 :lines [99]},
                                        :full-name "cljs.reader/ratio-pattern",
                                        :full-name-encode "cljs.reader/ratio-pattern",
                                        :history [["+" "0.0-927"]]},
           "cljs.core/println-str" {:ns "cljs.core",
                                    :name "println-str",
                                    :signature ["[& objs]"],
                                    :history [["+" "0.0-1011"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/println-str",
                                    :source {:code "(defn println-str\n  [& objs]\n  (prn-str-with-opts objs (assoc (pr-opts) :readably false)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [8968 8971]},
                                    :full-name "cljs.core/println-str",
                                    :clj-symbol "clojure.core/println-str",
                                    :docstring "println to a string, returning it"},
           "cljs.core/>" {:description "Returns true if each successive number argument is less than the previous\none, false otherwise.",
                          :return-type boolean,
                          :ns "cljs.core",
                          :name ">",
                          :signature ["[x]" "[x y]" "[x y & more]"],
                          :history [["+" "0.0-927"]],
                          :type "function/macro",
                          :related ["cljs.core/>="],
                          :full-name-encode "cljs.core/GT",
                          :source {:code "(defn ^boolean >\n  ([x] true)\n  ([x y] (cljs.core/> x y))\n  ([x y & more]\n   (if (cljs.core/> x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (cljs.core/> y (first more)))\n     false)))",
                                   :title "Function code",
                                   :repo "clojurescript",
                                   :tag "r1.7.228",
                                   :filename "src/main/cljs/cljs/core.cljs",
                                   :lines [2314 2324]},
                          :extra-sources [{:code "(core/defmacro ^::ana/numeric >\n  ([x] true)\n  ([x y] (bool-expr (core/list 'js* \"(~{} > ~{})\" x y)))\n  ([x y & more] `(and (> ~x ~y) (> ~y ~@more))))",
                                           :title "Macro code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/clojure/cljs/core.cljc",
                                           :lines [1047 1050]}],
                          :examples [{:id "67180c",
                                      :content "```clj\n(> 1 2)\n;;=> false\n\n(> 2 1)\n;;=> true\n\n(> 2 2)\n;;=> false\n\n(> 6 5 4 3 2)\n;;=> true\n```"}],
                          :full-name "cljs.core/>",
                          :clj-symbol "clojure.core/>",
                          :docstring "Returns non-nil if nums are in monotonically decreasing order,\notherwise false."},
           "cljs.repl/IPrintStacktrace" {:ns "cljs.repl",
                                         :name "IPrintStacktrace",
                                         :type "protocol",
                                         :full-name-encode "cljs.repl/IPrintStacktrace",
                                         :source {:code "(defprotocol IPrintStacktrace\n  (-print-stacktrace [repl-env stacktrace error build-options]\n    \"Implementing REPL evaluation environments are given the opportunity to\n     print the mapped stacktrace themselves. This permits further processing.\"))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.7.228",
                                                  :filename "src/main/clojure/cljs/repl.cljc",
                                                  :lines [150 153]},
                                         :methods [{:name "-print-stacktrace",
                                                    :signature ["[repl-env stacktrace error build-options]"],
                                                    :docstring "Implementing REPL evaluation environments are given the opportunity to\n     print the mapped stacktrace themselves. This permits further processing."}],
                                         :full-name "cljs.repl/IPrintStacktrace",
                                         :history [["+" "0.0-2843"]]},
           "cljs.core/juxt" {:description "Takes a set of functions and returns a function that is the juxtaposition of\nthose functions.\n\nThe returned function takes a variable number of arguments, and returns a vector\ncontaining the result of applying each function to the arguments (left-to-\nright).\n\n`((juxt a b c) x)` => `[(a x) (b x) (c x)]`",
                             :ns "cljs.core",
                             :name "juxt",
                             :signature ["[f]"
                                         "[f g]"
                                         "[f g h]"
                                         "[f g h & fs]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/partial"
                                       "cljs.core/comp"],
                             :full-name-encode "cljs.core/juxt",
                             :source {:code "(defn juxt\n  ([f]\n     (fn\n       ([] (vector (f)))\n       ([x] (vector (f x)))\n       ([x y] (vector (f x y)))\n       ([x y z] (vector (f x y z)))\n       ([x y z & args] (vector (apply f x y z args)))))\n  ([f g]\n     (fn\n       ([] (vector (f) (g)))\n       ([x] (vector (f x) (g x)))\n       ([x y] (vector (f x y) (g x y)))\n       ([x y z] (vector (f x y z) (g x y z)))\n       ([x y z & args] (vector (apply f x y z args) (apply g x y z args)))))\n  ([f g h]\n     (fn\n       ([] (vector (f) (g) (h)))\n       ([x] (vector (f x) (g x) (h x)))\n       ([x y] (vector (f x y) (g x y) (h x y)))\n       ([x y z] (vector (f x y z) (g x y z) (h x y z)))\n       ([x y z & args] (vector (apply f x y z args) (apply g x y z args) (apply h x y z args)))))\n  ([f g h & fs]\n     (let [fs (list* f g h fs)]\n       (fn\n         ([] (reduce #(conj %1 (%2)) [] fs))\n         ([x] (reduce #(conj %1 (%2 x)) [] fs))\n         ([x y] (reduce #(conj %1 (%2 x y)) [] fs))\n         ([x y z] (reduce #(conj %1 (%2 x y z)) [] fs))\n         ([x y z & args] (reduce #(conj %1 (apply %2 x y z args)) [] fs))))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [8628 8662]},
                             :full-name "cljs.core/juxt",
                             :clj-symbol "clojure.core/juxt",
                             :docstring "Takes a set of functions and returns a fn that is the juxtaposition\nof those fns.  The returned fn takes a variable number of args, and\nreturns a vector containing the result of applying each fn to the\nargs (left-to-right).\n((juxt a b c) x) => [(a x) (b x) (c x)]"},
           "cljs.pprint/*print-suppress-namespaces*" {:ns "cljs.pprint",
                                                      :name "*print-suppress-namespaces*",
                                                      :history [["+"
                                                                 "0.0-3255"]],
                                                      :type "dynamic var",
                                                      :full-name-encode "cljs.pprint/STARprint-suppress-namespacesSTAR",
                                                      :source {:code "(def ^:dynamic\n^{:doc \"Don't print namespaces with symbols. This is particularly useful when\npretty printing the results of macro expansions\"\n  :added \"1.2\"}\n*print-suppress-namespaces* nil)",
                                                               :title "Source code",
                                                               :repo "clojurescript",
                                                               :tag "r1.7.228",
                                                               :filename "src/main/cljs/cljs/pprint.cljs",
                                                               :lines [657
                                                                       661]},
                                                      :full-name "cljs.pprint/*print-suppress-namespaces*",
                                                      :clj-symbol "clojure.pprint/*print-suppress-namespaces*",
                                                      :docstring "Don't print namespaces with symbols. This is particularly useful when\npretty printing the results of macro expansions"},
           "cljs.core/max" {:description "Returns the greatest number argument.",
                            :return-type number,
                            :ns "cljs.core",
                            :name "max",
                            :signature ["[x]" "[x y]" "[x y & more]"],
                            :history [["+" "0.0-927"]],
                            :type "function/macro",
                            :related ["cljs.core/min"
                                      "cljs.core/max-key"],
                            :full-name-encode "cljs.core/max",
                            :source {:code "(defn ^number max\n  ([x] x)\n  ([x y] (cljs.core/max x y))\n  ([x y & more]\n   (reduce max (cljs.core/max x y) more)))",
                                     :title "Function code",
                                     :repo "clojurescript",
                                     :tag "r1.7.228",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [2342 2347]},
                            :extra-sources [{:code "(core/defmacro ^::ana/numeric max\n  ([x] x)\n  ([x y] `(let [x# ~x, y# ~y]\n            (~'js* \"((~{} > ~{}) ? ~{} : ~{})\" x# y# x# y#)))\n  ([x y & more] `(max (max ~x ~y) ~@more)))",
                                             :title "Macro code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/clojure/cljs/core.cljc",
                                             :lines [1077 1081]}],
                            :full-name "cljs.core/max",
                            :clj-symbol "clojure.core/max",
                            :docstring "Returns the greatest of the nums."},
           "cljs.core/completing" {:ns "cljs.core",
                                   :name "completing",
                                   :signature ["[f]" "[f cf]"],
                                   :history [["+" "0.0-2341"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/completing",
                                   :source {:code "(defn completing\n  ([f] (completing f identity))\n  ([f cf]\n    (fn\n      ([] (f))\n      ([x] (cf x))\n      ([x y] (f x y)))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [2230 2239]},
                                   :full-name "cljs.core/completing",
                                   :clj-symbol "clojure.core/completing",
                                   :docstring "Takes a reducing function f of 2 args and returns a fn suitable for\ntransduce by adding an arity-1 signature that calls cf (default -\nidentity) on the result argument."},
           "cljs.core/transduce" {:ns "cljs.core",
                                  :name "transduce",
                                  :signature ["[xform f coll]"
                                              "[xform f init coll]"],
                                  :history [["+" "0.0-2301"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/transduce",
                                  :source {:code "(defn transduce\n  ([xform f coll] (transduce xform f (f) coll))\n  ([xform f init coll]\n     (let [f (xform f)\n           ret (reduce f init coll)]\n       (f ret))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [2241 2254]},
                                  :full-name "cljs.core/transduce",
                                  :clj-symbol "clojure.core/transduce",
                                  :docstring "reduce with a transformation of f (xf). If init is not\nsupplied, (f) will be called to produce it. f should be a reducing\nstep function that accepts both 1 and 2 arguments, if it accepts\nonly 2 you can add the arity-1 with 'completing'. Returns the result\nof applying (the transformed) xf to init and the first item in coll,\nthen applying xf to that result and the 2nd item, etc. If coll\ncontains no items, returns init and f is not called. Note that\ncertain transforms may inject or skip items."},
           "cljs.pprint/set-pprint-dispatch" {:ns "cljs.pprint",
                                              :name "set-pprint-dispatch",
                                              :signature ["[function]"],
                                              :history [["+"
                                                         "0.0-3255"]],
                                              :type "function",
                                              :full-name-encode "cljs.pprint/set-pprint-dispatch",
                                              :source {:code "(defn set-pprint-dispatch\n  [function]\n  (set! *print-pprint-dispatch* function)\n  nil)",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.7.228",
                                                       :filename "src/main/cljs/cljs/pprint.cljs",
                                                       :lines [824
                                                               827]},
                                              :full-name "cljs.pprint/set-pprint-dispatch",
                                              :clj-symbol "clojure.pprint/set-pprint-dispatch"},
           "cljs.test/test-var" {:ns "cljs.test",
                                 :name "test-var",
                                 :signature ["[v]"],
                                 :history [["+" "0.0-2496"]],
                                 :type "function",
                                 :full-name-encode "cljs.test/test-var",
                                 :source {:code "(defn test-var\n  [v]\n  (run-block (test-var-block v)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/test.cljs",
                                          :lines [483 487]},
                                 :full-name "cljs.test/test-var",
                                 :clj-symbol "clojure.test/test-var",
                                 :docstring "If v has a function in its :test metadata, calls that function,\nadd v to :testing-vars property of env."},
           "cljs.core/with-out-str" {:ns "cljs.core",
                                     :name "with-out-str",
                                     :signature ["[& body]"],
                                     :history [["+" "0.0-1535"]],
                                     :type "macro",
                                     :full-name-encode "cljs.core/with-out-str",
                                     :source {:code "(core/defmacro with-out-str\n  [& body]\n  `(let [sb# (js/goog.string.StringBuffer.)]\n     (binding [cljs.core/*print-newline* true\n               cljs.core/*print-fn* (fn [x#] (.append sb# x#))]\n       ~@body)\n     (cljs.core/str sb#)))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/clojure/cljs/core.cljc",
                                              :lines [2577 2586]},
                                     :full-name "cljs.core/with-out-str",
                                     :clj-symbol "clojure.core/with-out-str",
                                     :docstring "Evaluates exprs in a context in which *print-fn* is bound to .append\non a fresh StringBuffer.  Returns the string created by any nested\nprinting calls."},
           "cljs.core/*3" {:description "Only usable from a REPL.\n\nHolds the result of the third to last expression.",
                           :ns "cljs.core",
                           :name "*3",
                           :history [["+" "0.0-927"]],
                           :type "var",
                           :related ["cljs.core/*1"
                                     "cljs.core/*2"
                                     "cljs.core/*e"],
                           :full-name-encode "cljs.core/STAR3",
                           :source {:code "(def\n  ^{:doc \"bound in a repl thread to the third most recent value printed\"}\n  *3)",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r1.7.228",
                                    :filename "src/main/cljs/cljs/core.cljs",
                                    :lines [164 166]},
                           :examples [{:id "d7a6e9",
                                       :content "```clj\n(+ 1 2 3 4)\n;;=> 10\n\n(+ 4 8)\n;;=> 12\n\n(+ 1 2)\n;;=> 3\n\n*3\n;;=> 10\n\n(inc *3)\n;;=> 11\n```\n\nNote that a standalone evaluation of `*1`, `*2`, `*3`, or `*e` is not a part of\nremembered history:\n\n```clj\n:first\n;;=> :first\n\n:second\n;;=> :second\n\n:third\n;;=> :third\n\n*3\n;;=> :first\n\n*2\n;;=> :second\n\n*1\n;;=> :third\n```"}],
                           :full-name "cljs.core/*3",
                           :clj-symbol "clojure.core/*3",
                           :docstring "bound in a repl thread to the third most recent value printed"},
           "cljs.core/memfn" {:ns "cljs.core",
                              :name "memfn",
                              :signature ["[name & args]"],
                              :history [["+" "0.0-1443"]],
                              :type "macro",
                              :full-name-encode "cljs.core/memfn",
                              :source {:code "(defmacro memfn\n  [name & args]\n  (let [t (with-meta (gensym \"target\")\n            (meta name))]\n    `(fn [~t ~@args]\n       (. ~t (~name ~@args)))))",
                                       :title "Source code",
                                       :repo "clojure",
                                       :tag "clojure-1.7.0",
                                       :filename "src/clj/clojure/core.clj",
                                       :lines [3717 3728]},
                              :full-name "cljs.core/memfn",
                              :clj-symbol "clojure.core/memfn",
                              :docstring "Expands into code that creates a fn that expects to be passed an\nobject and any args and calls the named instance method on the\nobject passing the args. Use when you want to treat a Java method as\na first-class fn. name may be type-hinted with the method receiver's\ntype in order to avoid reflective calls."},
           "cljs.core/IEncodeClojure" {:ns "cljs.core",
                                       :name "IEncodeClojure",
                                       :type "protocol",
                                       :full-name-encode "cljs.core/IEncodeClojure",
                                       :source {:code "(defprotocol IEncodeClojure\n  (-js->clj [x options] \"Transforms JavaScript values to Clojure\"))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/cljs/core.cljs",
                                                :lines [9337 9338]},
                                       :methods [{:name "-js->clj",
                                                  :signature ["[x options]"],
                                                  :docstring "Transforms JavaScript values to Clojure"}],
                                       :full-name "cljs.core/IEncodeClojure",
                                       :history [["+" "0.0-1552"]]},
           "cljs.js/eval-str*" {:ns "cljs.js",
                                :name "eval-str*",
                                :signature ["[bound-vars source name opts cb]"],
                                :history [["+" "1.7.10"]
                                          ["-" "1.7.28"]],
                                :type "function",
                                :full-name-encode "cljs.js/eval-strSTAR",
                                :source {:code "(defn eval-str* [bound-vars source name opts cb]\n  (let [rdr        (rt/indexing-push-back-reader source 1 name)\n        eof        (js-obj)\n        aenv       (ana/empty-env)\n        sb         (StringBuffer.)\n        the-ns     (or (:ns opts) 'cljs.user)\n        bound-vars (cond-> (merge bound-vars {:*cljs-ns* the-ns})\n                     (:source-map opts) (assoc :*sm-data* (sm-data)))]\n    (when (:verbose opts) (debug-prn \"Evaluating\" name))\n    ((fn compile-loop [ns]\n       (binding [env/*compiler*         (:*compiler* bound-vars)\n                 *eval-fn*              (:*eval-fn* bound-vars)\n                 ana/*cljs-ns*          ns\n                 *ns*                   (create-ns ns)\n                 r/*data-readers*       (:*data-readers* bound-vars)\n                 comp/*source-map-data* (:*sm-data* bound-vars)]\n         (let [res (try\n                     {:value (r/read {:eof eof :read-cond :allow :features #{:cljs}} rdr)}\n                     (catch :default cause\n                       (wrap-error\n                         (ana/error aenv\n                           (str \"Could not eval \" name) cause))))]\n           (if (:error res)\n             (cb res)\n             (let [form (:value res)]\n               (if-not (identical? eof form)\n                 (let [aenv (cond-> (assoc aenv :ns (ana/get-namespace ns))\n                              (:context opts) (assoc :context (:context opts))\n                              (:def-emits-var opts) (assoc :def-emits-var true))\n                       res  (try\n                              {:value (ana/analyze aenv form nil opts)}\n                              (catch :default cause\n                                (wrap-error\n                                  (ana/error aenv\n                                    (str \"Could not eval \" name) cause))))]\n                   (if (:error res)\n                     (cb res)\n                     (let [ast (:value res)\n                           ns' ana/*cljs-ns*]\n                      (if (= :ns (:op ast))\n                        (do\n                          (.append sb\n                            (str \"goog.provide(\\\"\" (munge (:name ast)) \"\\\");\\n\"))\n                          (ns-side-effects true bound-vars aenv ast opts\n                            (fn [res]\n                              (if (:error res)\n                                (cb res)\n                                (compile-loop ns')))))\n                        (do\n                          (.append sb (with-out-str (comp/emit ast)))\n                          (recur ns'))))))\n                 (do\n                   (when (:source-map opts)\n                     (append-source-map env/*compiler*\n                       name source sb @comp/*source-map-data* opts))\n                   (let [js-source (.toString sb)\n                         evalm     {:lang   :clj\n                                    :name   name\n                                    :path   (ns->relpath name)\n                                    :source js-source\n                                    :cache  (get-in env/*compiler* [::ana/namespaces name])}\n                         complete  (fn [res]\n                                     (if (:error res)\n                                       (cb res)\n                                       (do\n                                         (when (:verbose opts)\n                                           (debug-prn js-source))\n                                         (let [res (try\n                                                     {:ns ns :value (*eval-fn* evalm)}\n                                                     (catch :default cause\n                                                       (wrap-error (ana/error aenv \"ERROR\" cause))))]\n                                           (cb res)))))]\n                     (if-let [f (:cache-source opts)]\n                       (f evalm complete)\n                       (complete {:value nil}))))))))))\n      (:*cljs-ns* bound-vars))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.10",
                                         :filename "src/main/cljs/cljs/js.cljs",
                                         :lines [623 698]},
                                :full-name "cljs.js/eval-str*",
                                :removed {:in "1.7.28",
                                          :last-seen "1.7.10"}},
           "cljs.core/TransientArrayMap" {:ns "cljs.core",
                                          :name "TransientArrayMap",
                                          :signature ["[editable? len arr]"],
                                          :history [["+" "0.0-1211"]],
                                          :type "type",
                                          :full-name-encode "cljs.core/TransientArrayMap",
                                          :source {:code "(deftype TransientArrayMap [^:mutable editable?\n                            ^:mutable len\n                            arr]\n  ICounted\n  (-count [tcoll]\n    (if editable?\n      (quot len 2)\n      (throw (js/Error. \"count after persistent!\"))))\n\n  ILookup\n  (-lookup [tcoll k]\n    (-lookup tcoll k nil))\n\n  (-lookup [tcoll k not-found]\n    (if editable?\n      (let [idx (array-map-index-of tcoll k)]\n        (if (== idx -1)\n          not-found\n          (aget arr (inc idx))))\n      (throw (js/Error. \"lookup after persistent!\"))))\n\n  ITransientCollection\n  (-conj! [tcoll o]\n    (if editable?\n      (if (satisfies? IMapEntry o)\n        (-assoc! tcoll (key o) (val o))\n        (loop [es (seq o) tcoll tcoll]\n          (if-let [e (first es)]\n            (recur (next es)\n                   (-assoc! tcoll (key e) (val e)))\n            tcoll)))\n      (throw (js/Error. \"conj! after persistent!\"))))\n\n  (-persistent! [tcoll]\n    (if editable?\n      (do (set! editable? false)\n          (PersistentArrayMap. nil (quot len 2) arr nil))\n      (throw (js/Error. \"persistent! called twice\"))))\n\n  ITransientAssociative\n  (-assoc! [tcoll key val]\n    (if editable?\n      (let [idx (array-map-index-of tcoll key)]\n        (if (== idx -1)\n          (if (<= (+ len 2) (* 2 (.-HASHMAP-THRESHOLD PersistentArrayMap)))\n            (do (set! len (+ len 2))\n                (.push arr key)\n                (.push arr val)\n                tcoll)\n            (assoc! (array->transient-hash-map len arr) key val))\n          (if (identical? val (aget arr (inc idx)))\n            tcoll\n            (do (aset arr (inc idx) val)\n                tcoll))))\n      (throw (js/Error. \"assoc! after persistent!\"))))\n\n  ITransientMap\n  (-dissoc! [tcoll key]\n    (if editable?\n      (let [idx (array-map-index-of tcoll key)]\n        (when (>= idx 0)\n          (aset arr idx (aget arr (- len 2)))\n          (aset arr (inc idx) (aget arr (dec len)))\n          (doto arr .pop .pop)\n          (set! len (- len 2)))\n        tcoll)\n      (throw (js/Error. \"dissoc! after persistent!\")))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/cljs/cljs/core.cljs",
                                                   :lines [6032 6098]},
                                          :full-name "cljs.core/TransientArrayMap",
                                          :clj-symbol "clojure.lang/TransientArrayMap"},
           "cljs.core/cond->>" {:description "Takes an expression and a set of test/form pairs. Threads `expr` (via `->>`)\nthrough each form for which the corresponding test expression is true.\n\nNote that, unlike `cond` branching, `cond->>` threading does not short circuit\nafter the first true test expression.",
                                :ns "cljs.core",
                                :name "cond->>",
                                :signature ["[expr & clauses]"],
                                :history [["+" "0.0-1798"]],
                                :type "macro",
                                :related ["cljs.core/->"
                                          "cljs.core/->>"
                                          "cljs.core/cond->"
                                          "cljs.core/cond"],
                                :full-name-encode "cljs.core/cond-GTGT",
                                :source {:code "(defmacro cond->>\n  [expr & clauses]\n  (assert (even? (count clauses)))\n  (let [g (gensym)\n        pstep (fn [[test step]] `(if ~test (->> ~g ~step) ~g))]\n    `(let [~g ~expr\n           ~@(interleave (repeat g) (map pstep (partition 2 clauses)))]\n       ~g)))",
                                         :title "Source code",
                                         :repo "clojure",
                                         :tag "clojure-1.7.0",
                                         :filename "src/clj/clojure/core.clj",
                                         :lines [7247 7259]},
                                :examples [{:id "e07a05",
                                            :content "```clj\n(def filter? true)\n(def sum? true)\n\n(cond->> [1 2 3 4]\n  filter? (filter even?)\n  sum?    (reduce +))\n;;=> 6\n```"}],
                                :full-name "cljs.core/cond->>",
                                :clj-symbol "clojure.core/cond->>",
                                :docstring "Takes an expression and a set of test/form pairs. Threads expr (via ->>)\nthrough each form for which the corresponding test expression\nis true.  Note that, unlike cond branching, cond->> threading does not short circuit\nafter the first true test expression."},
           "cljs.core/number?" {:description "Returns true if `n` is a number, false otherwise.",
                                :return-type boolean,
                                :ns "cljs.core",
                                :name "number?",
                                :signature ["[n]"],
                                :history [["+" "0.0-927"]],
                                :type "function/macro",
                                :related ["cljs.core/integer?"],
                                :full-name-encode "cljs.core/numberQMARK",
                                :source {:code "(defn ^boolean number?\n  [x]\n  (cljs.core/number? x))",
                                         :title "Function code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [198 201]},
                                :extra-sources [{:code "(core/defmacro number? [x]\n  (bool-expr (core/list 'js* \"typeof ~{} === 'number'\" x)))",
                                                 :title "Macro code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/clojure/cljs/core.cljc",
                                                 :lines [933 934]}],
                                :full-name "cljs.core/number?",
                                :clj-symbol "clojure.core/number?",
                                :docstring "Returns true if x is a JavaScript number."},
           "cljs.core/array" {:description "Creates a JavaScript array containing `args`.\n\nThe tagged literal `#js [1 2 3]` is equivalent to `(array 1 2 3)`",
                              :return-type array,
                              :ns "cljs.core",
                              :name "array",
                              :signature ["[& args]"],
                              :history [["+" "0.0-927"]],
                              :type "function/macro",
                              :related ["cljs.core/aclone"
                                        "cljs.core/make-array"
                                        "cljs.core/clj->js"],
                              :full-name-encode "cljs.core/array",
                              :source {:code "(defn ^array array\n  [var-args]            ;; [& items]\n  (let [a (js/Array. (alength (cljs.core/js-arguments)))]\n    (loop [i 0]\n      (if (< i (alength a))\n        (do\n          (aset a i (aget (cljs.core/js-arguments) i))\n          (recur (inc i)))\n        a))))",
                                       :title "Function code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [373 383]},
                              :extra-sources [{:code "(core/defmacro array [& rest]\n  (core/let [xs-str (core/->> (repeat \"~{}\")\n                      (take (count rest))\n                      (interpose \",\")\n                      (apply core/str))]\n    (vary-meta\n      (list* 'js* (core/str \"[\" xs-str \"]\") rest)\n      assoc :tag 'array)))",
                                               :title "Macro code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/clojure/cljs/core.cljc",
                                               :lines [2320 2327]}],
                              :examples [{:id "3a546d",
                                          :content "```clj\n(array 1 2 3)\n;;=> #js [1 2 3]\n\n(apply array [1 2 3])\n;;=> #js [1 2 3]\n\n#js [1 2 3]\n;;=> #js [1 2 3]\n```"}
                                         {:id "cca945",
                                          :content "When creating nested JavaScript arrays, you can opt to use `clj->js` instead:\n\n```clj\n(array 1 2 (array 3 4))\n;;=> #js [1 2 #js [3 4]]\n\n(clj->js [1 2 [3 4]])\n;;=> #js [1 2 #js [3 4]]\n```"}],
                              :full-name "cljs.core/array",
                              :docstring "Creates a new javascript array.\n@param {...*} var_args"},
           "cljs.core/nthnext" {:description "Returns the `n`th `next` of `coll`.\n\nReturns `(seq coll)` when `n` is 0.",
                                :ns "cljs.core",
                                :name "nthnext",
                                :signature ["[coll n]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/nth"
                                          "cljs.core/drop"
                                          "cljs.core/nthrest"],
                                :full-name-encode "cljs.core/nthnext",
                                :source {:code "(defn nthnext\n  [coll n]\n  (loop [n n xs (seq coll)]\n    (if (and xs (pos? n))\n      (recur (dec n) (next xs))\n      xs)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [2607 2613]},
                                :full-name "cljs.core/nthnext",
                                :clj-symbol "clojure.core/nthnext",
                                :docstring "Returns the nth next of coll, (seq coll) when n is 0."},
           "cljs.core/re-pattern" {:description "Returns an instance of RegExp which has compiled the provided string.",
                                   :ns "cljs.core",
                                   :name "re-pattern",
                                   :signature ["[s]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/re-pattern",
                                   :source {:code "(defn re-pattern\n  [s]\n  (if (instance? js/RegExp s)\n    s\n    (let [[prefix flags] (re-find #\"^\\(\\?([idmsux]*)\\)\" s)\n          pattern (subs s (count prefix))]\n      (js/RegExp. pattern (or flags \"\")))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [8733 8740]},
                                   :full-name "cljs.core/re-pattern",
                                   :clj-symbol "clojure.core/re-pattern",
                                   :docstring "Returns an instance of RegExp which has compiled the provided string."},
           "cljs.core/missing-protocol" {:ns "cljs.core",
                                         :name "missing-protocol",
                                         :type "function",
                                         :signature ["[proto obj]"],
                                         :source {:code "(defn missing-protocol [proto obj]\n  (let [ty (type obj)\n        ty (if (and ty (.-cljs$lang$type ty))\n             (.-cljs$lang$ctorStr ty)\n             (goog/typeOf obj))]\n   (js/Error.\n     (.join (array \"No protocol method \" proto\n                   \" defined for type \" ty \": \" obj) \"\"))))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.7.228",
                                                  :filename "src/main/cljs/cljs/core.cljs",
                                                  :lines [259 266]},
                                         :full-name "cljs.core/missing-protocol",
                                         :full-name-encode "cljs.core/missing-protocol",
                                         :history [["+" "0.0-927"]]},
           "clojure.browser.dom/set-text" {:ns "clojure.browser.dom",
                                           :name "set-text",
                                           :signature ["[e s]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "clojure.browser.dom/set-text",
                                           :source {:code "(defn set-text\n  [e s]\n  (gdom/setTextContent (ensure-element e) s))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.7.228",
                                                    :filename "src/main/cljs/clojure/browser/dom.cljs",
                                                    :lines [124 129]},
                                           :full-name "clojure.browser.dom/set-text",
                                           :docstring "Set the text content for the passed element returning the\nelement. If a keyword is passed in the place of e, the element with\nthat id will be used and returned."},
           "cljs.test/js-line-and-column" {:ns "cljs.test",
                                           :name "js-line-and-column",
                                           :type "function",
                                           :signature ["[stack-element]"],
                                           :source {:code "(defn js-line-and-column [stack-element]\n  (let [parts (.split stack-element \":\")\n        cnt   (count parts)]\n    [(js/parseInt (nth parts (- cnt 2)) 10)\n     (js/parseInt (nth parts (dec cnt)) 10)]))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.7.228",
                                                    :filename "src/main/cljs/cljs/test.cljs",
                                                    :lines [366 370]},
                                           :full-name "cljs.test/js-line-and-column",
                                           :full-name-encode "cljs.test/js-line-and-column",
                                           :history [["+" "0.0-2496"]]},
           "cljs.core/copy-arguments" {:ns "cljs.core",
                                       :name "copy-arguments",
                                       :type "macro",
                                       :signature ["[dest]"],
                                       :source {:code "(core/defmacro copy-arguments [dest]\n  `(let [len# (alength (js-arguments))]\n     (loop [i# 0]\n       (when (< i# len#)\n         (.push ~dest (aget (js-arguments) i#))\n         (recur (inc i#))))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/clojure/cljs/core.cljc",
                                                :lines [2699 2704]},
                                       :full-name "cljs.core/copy-arguments",
                                       :full-name-encode "cljs.core/copy-arguments",
                                       :history [["+" "1.7.10"]]},
           "clojure.zip/up" {:ns "clojure.zip",
                             :name "up",
                             :signature ["[loc]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "clojure.zip/up",
                             :source {:code "(defn up\n  [loc]\n    (let [[node {l :l, ppath :ppath, pnodes :pnodes r :r, changed? :changed?, :as path}] loc]\n      (when pnodes\n        (let [pnode (peek pnodes)]\n          (with-meta (if changed?\n                       [(make-node loc pnode (concat l (cons node r))) \n                        (and ppath (assoc ppath :changed? true))]\n                       [pnode ppath])\n                     (meta loc))))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/clojure/zip.cljs",
                                      :lines [111 122]},
                             :full-name "clojure.zip/up",
                             :clj-symbol "clojure.zip/up",
                             :docstring "Returns the loc of the parent of the node at this loc, or nil if at\nthe top"},
           "cljs.analyzer.api/parse-ns" {:ns "cljs.analyzer.api",
                                         :name "parse-ns",
                                         :signature ["[src]"
                                                     "[src opts]"
                                                     "[src dest opts]"
                                                     "[state src dest opts]"],
                                         :history [["+" "0.0-3208"]],
                                         :type "function",
                                         :full-name-encode "cljs.analyzer.api/parse-ns",
                                         :source {:code "(defn parse-ns\n  ([src] (parse-ns src nil nil))\n  ([src opts] (parse-ns src nil opts))\n  ([src dest opts]\n   (parse-ns\n     (if-not (nil? env/*compiler*)\n       env/*compiler*\n       (env/default-compiler-env opts))\n     src dest opts))\n  ([state src dest opts]\n   (env/with-compiler-env state\n     (binding [ana/*cljs-warning-handlers* (:warning-handlers opts ana/*cljs-warning-handlers*)]\n       (ana/parse-ns src dest opts)))))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.7.228",
                                                  :filename "src/main/clojure/cljs/analyzer/api.clj",
                                                  :lines [94 115]},
                                         :full-name "cljs.analyzer.api/parse-ns",
                                         :docstring "Helper for parsing only the essential namespace information from a\nClojureScript source file and returning a cljs.closure/IJavaScript compatible\nmap _not_ a namespace AST node.\n\nBy default does not load macros or perform any analysis of dependencies. If\nopts parameter provided :analyze-deps and :load-macros keys their values will\nbe used for *analyze-deps* and *load-macros* bindings respectively. This\nfunction does _not_ side-effect the ambient compilation environment unless\nrequested via opts where :restore is false."},
           "cljs.core/IWithMeta" {:ns "cljs.core",
                                  :name "IWithMeta",
                                  :history [["+" "0.0-927"]],
                                  :type "protocol",
                                  :full-name-encode "cljs.core/IWithMeta",
                                  :source {:code "(defprotocol IWithMeta\n  \"Protocol for adding metadata to an object.\"\n  (^clj -with-meta [o meta]\n    \"Returns a new object with value of o and metadata meta added to it.\"))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [570 573]},
                                  :methods [{:name "-with-meta",
                                             :signature ["[o meta]"],
                                             :docstring "Returns a new object with value of o and metadata meta added to it."}],
                                  :full-name "cljs.core/IWithMeta",
                                  :docstring "Protocol for adding metadata to an object."},
           "cljs.core/bit-and-not" {:description "Bitwise \"and\" `x` with bitwise \"not\" `y`.  Same as `x & ~y` in JavaScript.",
                                    :ns "cljs.core",
                                    :name "bit-and-not",
                                    :signature ["[x y]"
                                                "[x y & more]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function/macro",
                                    :related ["cljs.core/bit-and"
                                              "cljs.core/bit-not"],
                                    :full-name-encode "cljs.core/bit-and-not",
                                    :source {:code "(defn bit-and-not\n  ([x y] (cljs.core/bit-and-not x y))\n  ([x y & more]\n     (reduce bit-and-not (cljs.core/bit-and-not x y) more)))",
                                             :title "Function code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [2526 2530]},
                                    :extra-sources [{:code "(core/defmacro ^::ana/numeric bit-and-not\n  ([x y] (core/list 'js* \"(~{} & ~~{})\" x y))\n  ([x y & more] `(bit-and-not (bit-and-not ~x ~y) ~@more)))",
                                                     :title "Macro code",
                                                     :repo "clojurescript",
                                                     :tag "r1.7.228",
                                                     :filename "src/main/clojure/cljs/core.cljc",
                                                     :lines [1115
                                                             1117]}],
                                    :examples [{:id "16f35d",
                                                :content "Bits can be entered using radix notation:\n\n```clj\n(bit-and-not 2r1100 2r1010)\n;;=> 4\n;; 4 = 2r0100\n```\n\nSame numbers in decimal:\n\n```clj\n(bit-and-not 12 10)\n;;=> 4\n```\n\nSame result using `bit-and` and `bit-not`:\n\n```clj\n(bit-and 12 (bit-not 10))\n;;=> 4\n```"}],
                                    :full-name "cljs.core/bit-and-not",
                                    :clj-symbol "clojure.core/bit-and-not",
                                    :docstring "Bitwise and"},
           "clojure.string/triml" {:description "Removes whitespace from the left side of string.",
                                   :ns "clojure.string",
                                   :name "triml",
                                   :signature ["[s]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "clojure.string/triml",
                                   :source {:code "(defn triml\n  [s]\n  (gstring/trimLeft s))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/clojure/string.cljs",
                                            :lines [170 173]},
                                   :full-name "clojure.string/triml",
                                   :clj-symbol "clojure.string/triml",
                                   :docstring "Removes whitespace from the left side of string."},
           "cljs.core/chunk-append" {:ns "cljs.core",
                                     :name "chunk-append",
                                     :type "function",
                                     :signature ["[b x]"],
                                     :source {:code "(defn chunk-append [b x]\n  (.add b x))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/cljs/cljs/core.cljs",
                                              :lines [3193 3194]},
                                     :full-name "cljs.core/chunk-append",
                                     :full-name-encode "cljs.core/chunk-append",
                                     :history [["+" "0.0-1424"]]},
           "clojure.string/ends-with?" {:return-type boolean,
                                        :ns "clojure.string",
                                        :name "ends-with?",
                                        :signature ["[s substr]"],
                                        :history [["+" "1.7.145"]],
                                        :type "function",
                                        :full-name-encode "clojure.string/ends-withQMARK",
                                        :source {:code "(defn ^boolean ends-with?\n  [s substr]\n  (gstring/endsWith s substr))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/cljs/clojure/string.cljs",
                                                 :lines [250 253]},
                                        :full-name "clojure.string/ends-with?",
                                        :docstring "True if s ends with substr."},
           "syntax/character" {:description "A single character string.  Carried over from Clojure for\ncompatibility.  They are represented as single character JavaScript strings.\n\n`\\c` = `\"c\"`\n\n| unicode characters  | constraints                                   |\n|---------------------|-----------------------------------------------|\n| `\\uXXXX`            | XXXX must have 4 digits outside 0xD7FF-0xE000 |\n| `\\oXXX`             | XXX is octal between 0 and 0377               |\n\n| special characters  | result   |\n|---------------------|----------|\n| `\\newline`          | `\"\\n\"`   |\n| `\\space`            | `\" \"`    |\n| `\\tab`              | `\"\\t\"`   |\n| `\\formfeed`         | `\"\\f\"`   |\n| `\\backspace`        | `\"\\b\"`   |\n| `\\return`           | `\"\\r\"`   |",
                               :ns "syntax",
                               :name "character",
                               :history [["+" "0.0-927"]],
                               :type "syntax",
                               :related ["syntax/string"
                                         "cljs.core/str"],
                               :full-name-encode "syntax/character",
                               :extra-sources ({:code "(defn- read-char*\n  [rdr backslash opts pending-forms]\n  (let [ch (read-char rdr)]\n    (if-not (nil? ch)\n      (let [token (if (or (macro-terminating? ch)\n                          (whitespace? ch))\n                    (str ch)\n                    (read-token rdr ch))\n            token-len (count token)]\n        (cond\n\n         (== 1 token-len)  (Character/valueOf (nth token 0))\n\n         (= token \"newline\") \\newline\n         (= token \"space\") \\space\n         (= token \"tab\") \\tab\n         (= token \"backspace\") \\backspace\n         (= token \"formfeed\") \\formfeed\n         (= token \"return\") \\return\n\n         (.startsWith token \"u\")\n         (let [c (read-unicode-char token 1 4 16)\n               ic (int c)]\n           (if (and (> ic upper-limit)\n                    (< ic lower-limit))\n             (reader-error rdr \"Invalid character constant: \\\\u\" (Integer/toString ic 16))\n             c))\n\n         (.startsWith token \"o\")\n         (let [len (dec token-len)]\n           (if (> len 3)\n             (reader-error rdr \"Invalid octal escape sequence length: \" len)\n             (let [uc (read-unicode-char token 1 len 8)]\n               (if (> (int uc) 0377)\n                 (reader-error rdr \"Octal escape sequence must be in range [0, 377]\")\n                 uc))))\n\n         :else (reader-error rdr \"Unsupported character: \\\\\" token)))\n      (reader-error rdr \"EOF while reading character\"))))",
                                                :title "Reader code",
                                                :repo "tools.reader",
                                                :tag "tools.reader-1.0.0-alpha1",
                                                :filename "src/main/clojure/clojure/tools/reader.clj",
                                                :lines [135 174]}
                                               {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                                :title "Reader table",
                                                :repo "tools.reader",
                                                :tag "tools.reader-1.0.0-alpha1",
                                                :filename "src/main/clojure/clojure/tools/reader.clj",
                                                :lines [743 762]}),
                               :examples [{:id "495a47",
                                           :content "```clj\n\\c\n;;=> \"c\"\n\n\\A\n;;=> \"A\"\n\n\\newline\n;;=> \"\\n\"\n\n\\u00a1\n;;=> \"¡\"\n\n\\o256\n;;=> \"®\"\n```"}],
                               :edn-doc "https://github.com/edn-format/edn#characters",
                               :full-name "syntax/character",
                               :display "\\ character",
                               :clj-doc "http://clojure.org/reader#toc1"},
           "cljs.core/print-meta?" {:return-type boolean,
                                    :ns "cljs.core",
                                    :name "print-meta?",
                                    :signature ["[opts obj]"],
                                    :history [["+" "1.7.10"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/print-metaQMARK",
                                    :source {:code "(defn ^boolean print-meta? [opts obj]\n  (and (boolean (get opts :meta))\n       (implements? IMeta obj)\n       (not (nil? (meta obj)))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [8797 8800]},
                                    :full-name "cljs.core/print-meta?"},
           "syntax/unreadable" {:description "A proper definition for something that cannot be read.\n\nWhen certain values cannot be printed to a REPL using some literal syntax form,\nit wraps a description of its value in a form defined as unreadable, `#<>`.  A\nreader error will be thrown if this value is fed back into the REPL.\n\nFor example, `(atom 42)` will print `#<Atom: 42>` when evaluated in a REPL.\nThis communicates a human-readable form that is not intended to be reproduce\nits value.\n\nOftentimes, evaluating JavaScript objects in a REPL will print the result\nof its `.toString` method inside the unreadable form `#<>`.",
                                :ns "syntax",
                                :name "unreadable",
                                :history [["+" "0.0-927"]],
                                :type "syntax",
                                :full-name-encode "syntax/unreadable",
                                :extra-sources ({:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    \\? read-cond\n    nil))",
                                                 :title "Reader table",
                                                 :repo "tools.reader",
                                                 :tag "tools.reader-1.0.0-alpha1",
                                                 :filename "src/main/clojure/clojure/tools/reader.clj",
                                                 :lines [764 776]}),
                                :usage ["#<...>"],
                                :examples [{:id "e0a6cd",
                                            :content "Unreadable forms will throw an exception when read:\n\n```clj\n#<foo>\n;; clojure.lang.ExceptionInfo: Unreadable form\n```\n\nYou can create an unreadable form for a custom type:\n\n```clj\n(deftype Foo [])\n(Foo.)\n;;=> #<[object Object]>\n\n(deftype Foo [x]\n  Object\n  (toString [_]\n    (str \"Foo: \" x)))\n(Foo. 1)\n;;=> #<Foo: 1>\n```\n\nSome examples of unreadable JavaScript values:\n\n```clj\nMath/sin\n;;=> #<function sin() { [native code] }>\n\njs/console\n;;=> #<[object Object]>\n```"}],
                                :full-name "syntax/unreadable",
                                :display "#<> unreadable",
                                :clj-doc "https://github.com/clojure/clojure/blob/clojure-1.7.0-RC1/src/jvm/clojure/lang/LispReader.java#L115"},
           "cljs.core/regexp?" {:return-type boolean,
                                :ns "cljs.core",
                                :name "regexp?",
                                :signature ["[x]"],
                                :history [["+" "0.0-1424"]],
                                :type "function",
                                :full-name-encode "cljs.core/regexpQMARK",
                                :source {:code "(defn ^boolean regexp?\n  [x]\n  (instance? js/RegExp x))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [8693 8696]},
                                :full-name "cljs.core/regexp?",
                                :docstring "Returns true if x is a JavaScript RegExp instance."},
           "clojure.string/split" {:description "Splits string on a regular expression. Optional argument limit is the maximum\nnumber of splits. Not lazy. Returns vector of the splits.",
                                   :ns "clojure.string",
                                   :name "split",
                                   :signature ["[s re]"
                                               "[s re limit]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/subs"
                                             "clojure.string/replace"
                                             "clojure.string/split-lines"],
                                   :full-name-encode "clojure.string/split",
                                   :source {:code "(defn split\n  ([s re]\n     (split s re 0))\n    ([s re limit]\n     (discard-trailing-if-needed limit\n       (if (identical? \"/(?:)/\" (str re))\n         (split-with-empty-regex s limit)\n         (if (< limit 1)\n           (vec (.split (str s) re))\n           (loop [s s\n                  limit limit\n                  parts []]\n             (if (== 1 limit)\n               (conj parts s)\n               (let [m (re-find re s)]\n                 (if-not (nil? m)\n                   (let [index (.indexOf s m)]\n                     (recur (.substring s (+ index (count m)))\n                       (dec limit)\n                       (conj parts (.substring s 0 index))))\n                   (conj parts s))))))))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/clojure/string.cljs",
                                            :lines [136 158]},
                                   :full-name "clojure.string/split",
                                   :clj-symbol "clojure.string/split",
                                   :docstring "Splits string on a regular expression. Optional argument limit is\nthe maximum number of splits. Not lazy. Returns vector of the splits."},
           "cljs.reader/read-4-chars" {:ns "cljs.reader",
                                       :name "read-4-chars",
                                       :type "function",
                                       :signature ["[reader]"],
                                       :source {:code "(defn read-4-chars [reader]\n  (.toString\n    (StringBuffer.\n      (read-char reader)\n      (read-char reader)\n      (read-char reader)\n      (read-char reader))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/cljs/reader.cljs",
                                                :lines [173 179]},
                                       :full-name "cljs.reader/read-4-chars",
                                       :full-name-encode "cljs.reader/read-4-chars",
                                       :history [["+" "0.0-1424"]]},
           "cljs.pprint/with-pprint-dispatch" {:ns "cljs.pprint",
                                               :name "with-pprint-dispatch",
                                               :signature ["[function & body]"],
                                               :history [["+"
                                                          "0.0-3255"]],
                                               :type "macro",
                                               :full-name-encode "cljs.pprint/with-pprint-dispatch",
                                               :source {:code "(defmacro with-pprint-dispatch\n  [function & body]\n  `(cljs.core/binding [cljs.pprint/*print-pprint-dispatch* ~function]\n     ~@body))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.7.228",
                                                        :filename "src/main/cljs/cljs/pprint.clj",
                                                        :lines [147
                                                                151]},
                                               :full-name "cljs.pprint/with-pprint-dispatch",
                                               :clj-symbol "clojure.pprint/with-pprint-dispatch",
                                               :docstring "Execute body with the pretty print dispatch function bound to function."},
           "cljs.core/iteration" {:ns "cljs.core",
                                  :name "iteration",
                                  :signature ["[xform coll]"],
                                  :history [["+" "0.0-2301"]
                                            ["-" "0.0-2371"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/iteration",
                                  :source {:code "(defn iteration\n  [xform coll]\n  (Iteration. xform coll))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2356",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [8205 8210]},
                                  :full-name "cljs.core/iteration",
                                  :docstring "Returns an iterable/seqable/reducible sequence of applications of\nthe transducer to the items in coll. Note that these applications\nwill be performed every time iterator/seq/reduce is called.",
                                  :removed {:in "0.0-2371",
                                            :last-seen "0.0-2356"}},
           "cljs.core/hash-map" {:description "Returns a new hash map with supplied mappings.\n\n`keyvals` must be an even number of forms.",
                                 :ns "cljs.core",
                                 :name "hash-map",
                                 :signature ["[& keyvals]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function/macro",
                                 :related ["cljs.core/array-map"
                                           "cljs.core/sorted-map"],
                                 :full-name-encode "cljs.core/hash-map",
                                 :source {:code "(defn hash-map\n  [& keyvals]\n  (loop [in (seq keyvals), out (transient (.-EMPTY PersistentHashMap))]\n    (if in\n      (recur (nnext in) (assoc! out (first in) (second in)))\n      (persistent! out))))",
                                          :title "Function code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [7738 7745]},
                                 :extra-sources [{:code "(core/defmacro hash-map\n  ([] `(.-EMPTY cljs.core/PersistentHashMap))\n  ([& kvs]\n   (core/let [pairs (partition 2 kvs)\n              ks    (map first pairs)\n              vs    (map second pairs)]\n     (vary-meta\n       `(.fromArrays cljs.core/PersistentHashMap (array ~@ks) (array ~@vs))\n       assoc :tag 'cljs.core/PersistentHashMap))))",
                                                  :title "Macro code",
                                                  :repo "clojurescript",
                                                  :tag "r1.7.228",
                                                  :filename "src/main/clojure/cljs/core.cljc",
                                                  :lines [2363 2371]}],
                                 :full-name "cljs.core/hash-map",
                                 :clj-symbol "clojure.core/hash-map",
                                 :docstring "keyval => key val\nReturns a new hash map with supplied mappings."},
           "cljs.core/mapv" {:description "Returns a vector consisting of the result of applying `f` to the set of first\nitems of each coll, followed by applying `f` to the set of second items in each\ncoll, until any one of the colls is exhausted. Any remaining items in other\ncolls are ignored.\n\nFunction `f` should accept number-of-colls arguments.",
                             :ns "cljs.core",
                             :name "mapv",
                             :signature ["[f coll]"
                                         "[f c1 c2]"
                                         "[f c1 c2 c3]"
                                         "[f c1 c2 c3 & colls]"],
                             :history [["+" "0.0-1211"]],
                             :type "function",
                             :related ["cljs.core/map"],
                             :full-name-encode "cljs.core/mapv",
                             :source {:code "(defn mapv\n  ([f coll]\n     (-> (reduce (fn [v o] (conj! v (f o))) (transient []) coll)\n         persistent!))\n  ([f c1 c2]\n     (into [] (map f c1 c2)))\n  ([f c1 c2 c3]\n     (into [] (map f c1 c2 c3)))\n  ([f c1 c2 c3 & colls]\n     (into [] (apply map f c1 c2 c3 colls))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [4500 4514]},
                             :full-name "cljs.core/mapv",
                             :clj-symbol "clojure.core/mapv",
                             :docstring "Returns a vector consisting of the result of applying f to the\nset of first items of each coll, followed by applying f to the set\nof second items in each coll, until any one of the colls is\nexhausted.  Any remaining items in other colls are ignored. Function\nf should accept number-of-colls arguments."},
           "cljs.core/rem" {:description "Returns the remainder of dividing numerator `n` by denominator `d`.\n\nReturns `NaN` when `d` is 0 (divide by 0 error).",
                            :ns "cljs.core",
                            :name "rem",
                            :signature ["[n d]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/quot"
                                      "cljs.core/mod"],
                            :full-name-encode "cljs.core/rem",
                            :source {:code "(defn rem\n  [n d]\n  (let [q (quot n d)]\n    (- n (* d q))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.7.228",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [2502 2506]},
                            :full-name "cljs.core/rem",
                            :clj-symbol "clojure.core/rem",
                            :docstring "remainder of dividing numerator by denominator."},
           "cljs.core/IRecord" {:ns "cljs.core",
                                :name "IRecord",
                                :history [["+" "0.0-927"]],
                                :type "protocol",
                                :full-name-encode "cljs.core/IRecord",
                                :source {:code "(defprotocol IRecord\n  \"Marker interface indicating a record object\")",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [611 612]},
                                :full-name "cljs.core/IRecord",
                                :clj-symbol "clojure.lang/IRecord",
                                :docstring "Marker interface indicating a record object"},
           "cljs.core/unsafe-cast" {:ns "cljs.core",
                                    :name "unsafe-cast",
                                    :signature ["[t x]"],
                                    :history [["+" "1.7.107"]],
                                    :type "macro",
                                    :full-name-encode "cljs.core/unsafe-cast",
                                    :source {:code "(core/defmacro unsafe-cast\n  [t x]\n  (core/let [cast-expr (core/str \"~{} = /** @type {\" t \"} */ (~{})\")]\n    (core/list 'js* cast-expr x x)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/clojure/cljs/core.cljc",
                                             :lines [887 891]},
                                    :full-name "cljs.core/unsafe-cast",
                                    :docstring "EXPERIMENTAL: Subject to change. Unsafely cast a value to a different type."},
           "cljs.core/RangedIterator" {:ns "cljs.core",
                                       :name "RangedIterator",
                                       :type "type",
                                       :signature ["[i base arr v start end]"],
                                       :source {:code "(deftype RangedIterator [^:mutable i ^:mutable base ^:mutable arr v start end]\n  Object\n  (hasNext [this]\n    (< i end))\n  (next [this]\n    (when (== (- i base) 32)\n      (set! arr (unchecked-array-for v i))\n      (set! base (+ base 32)))\n    (let [ret (aget arr (bit-and i 0x01f))]\n      (set! i (inc i))\n      ret)))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/cljs/core.cljs",
                                                :lines [4719 4729]},
                                       :full-name "cljs.core/RangedIterator",
                                       :full-name-encode "cljs.core/RangedIterator",
                                       :history [["+" "0.0-2371"]]},
           "cljs.core/volatile!" {:ns "cljs.core",
                                  :name "volatile!",
                                  :signature ["[val]"],
                                  :history [["+" "0.0-2496"]],
                                  :type "function",
                                  :related ["cljs.core/volatile?"
                                            "cljs.core/vswap!"
                                            "cljs.core/vreset!"
                                            "cljs.core/Volatile"],
                                  :full-name-encode "cljs.core/volatileBANG",
                                  :source {:code "(defn volatile!\n  [val]\n  (Volatile. val))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [4068 4071]},
                                  :full-name "cljs.core/volatile!",
                                  :clj-symbol "clojure.core/volatile!",
                                  :docstring "Creates and returns a Volatile with an initial value of val."},
           "cljs.core/constantly" {:description "Returns a function that takes any number of arguments and always returns `x`.",
                                   :ns "cljs.core",
                                   :name "constantly",
                                   :signature ["[x]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/repeatedly"],
                                   :full-name-encode "cljs.core/constantly",
                                   :source {:code "(defn constantly\n  [x] (fn [& args] x))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [3802 3804]},
                                   :examples [{:id "9d5c25",
                                               :content "```clj\n(def ten (constantly 10))\n\n(ten \"hi\")\n;;=> 10\n\n(ten 123)\n;;=> 10\n\n(ten :whatever)\n;;=> 10\n```"}],
                                   :full-name "cljs.core/constantly",
                                   :clj-symbol "clojure.core/constantly",
                                   :docstring "Returns a function that takes any number of arguments and returns x."},
           "cljs.test/*current-env*" {:ns "cljs.test",
                                      :name "*current-env*",
                                      :type "dynamic var",
                                      :source {:code "(def ^:dynamic *current-env* nil)",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/cljs/cljs/test.cljs",
                                               :lines [269]},
                                      :full-name "cljs.test/*current-env*",
                                      :full-name-encode "cljs.test/STARcurrent-envSTAR",
                                      :history [["+" "0.0-2496"]]},
           "clojure.browser.dom/get-element" {:ns "clojure.browser.dom",
                                              :name "get-element",
                                              :type "function",
                                              :signature ["[id]"],
                                              :source {:code "(defn get-element [id]\n  (gdom/getElement (name id)))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.7.228",
                                                       :filename "src/main/cljs/clojure/browser/dom.cljs",
                                                       :lines [98 99]},
                                              :full-name "clojure.browser.dom/get-element",
                                              :full-name-encode "clojure.browser.dom/get-element",
                                              :history [["+"
                                                         "0.0-927"]]},
           "cljs.core/PersistentQueueIter" {:ns "cljs.core",
                                            :name "PersistentQueueIter",
                                            :type "type",
                                            :signature ["[fseq riter]"],
                                            :source {:code "(deftype PersistentQueueIter [^:mutable fseq riter]\n  Object\n  (hasNext [_]\n    (or (and (some? fseq) (seq fseq)) (and (some? riter) (.hasNext riter))))\n  (next [_]\n    (cond\n      (some? fseq)\n      (let [ret (first fseq)]\n        (set! fseq (next fseq))\n        ret)\n      (and (some? riter) ^boolean (.hasNext riter))\n      (.next riter)\n      :else (throw (js/Error. \"No such element\"))))\n  (remove [_] (js/Error. \"Unsupported operation\")))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.7.228",
                                                     :filename "src/main/cljs/cljs/core.cljs",
                                                     :lines [5363
                                                             5376]},
                                            :full-name "cljs.core/PersistentQueueIter",
                                            :full-name-encode "cljs.core/PersistentQueueIter",
                                            :history [["+" "1.7.28"]]},
           "cljs.core/UUID" {:description "A type representing a universally unique identifier ([UUID]).\n\nUse [doc:cljs.core/uuid] or [doc:syntax/uuid-literal] to create one.\n\n[UUID]:https://en.wikipedia.org/wiki/Universally_unique_identifier",
                             :ns "cljs.core",
                             :name "UUID",
                             :signature ["[uuid __hash]"],
                             :history [["+" "0.0-1424"]],
                             :type "type",
                             :related ["syntax/uuid-literal"
                                       "cljs.core/random-uuid"
                                       "cljs.core/uuid"],
                             :full-name-encode "cljs.core/UUID",
                             :source {:code "(deftype UUID [uuid ^:mutable __hash]\n  Object\n  (toString [_] uuid)\n  (equiv [this other]\n    (-equiv this other))\n\n  IEquiv\n  (-equiv [_ other]\n    (and (instance? UUID other) (identical? uuid (.-uuid other))))\n\n  IPrintWithWriter\n  (-pr-writer [_ writer _]\n    (-write writer (str \"#uuid \\\"\" uuid \"\\\"\")))\n\n  IHash\n  (-hash [this]\n    (when (nil? __hash)\n      (set! __hash (hash uuid)))\n    __hash)\n\n  IComparable\n  (-compare [_ other]\n    (garray/defaultCompare uuid (.-uuid other))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [9839 9861]},
                             :full-name "cljs.core/UUID"},
           "clojure.core.reducers/reduce" {:ns "clojure.core.reducers",
                                           :name "reduce",
                                           :signature ["[f coll]"
                                                       "[f init coll]"],
                                           :history [["+" "0.0-1236"]],
                                           :type "function",
                                           :full-name-encode "clojure.core.reducers/reduce",
                                           :source {:code "(defn reduce\n  ([f coll] (reduce f (f) coll))\n  ([f init coll]\n     (if (map? coll)\n       (-kv-reduce coll f init)\n       (cond\n         (nil? coll) init\n         (array? coll) (array-reduce coll f init)\n         :else (-reduce coll f init)))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.7.228",
                                                    :filename "src/main/cljs/clojure/core/reducers.cljs",
                                                    :lines [33 44]},
                                           :full-name "clojure.core.reducers/reduce",
                                           :clj-symbol "clojure.core.reducers/reduce",
                                           :docstring "Like core/reduce except:\n  When init is not provided, (f) is used.\n  Maps are reduced with reduce-kv"},
           "cljs.core/and" {:description "Evaluates arguments one at a time from left to right. If an argument returns\nlogical false (nil or false), `and` returns that value and doesn't evaluate any\nof the other arguments, otherwise it returns the value of the last argument.\n\n`(and)` returns true.",
                            :ns "cljs.core",
                            :name "and",
                            :signature ["[]" "[x]" "[x & next]"],
                            :history [["+" "0.0-927"]],
                            :type "macro",
                            :related ["cljs.core/or" "special/if"],
                            :full-name-encode "cljs.core/and",
                            :source {:code "(core/defmacro and\n  ([] true)\n  ([x] x)\n  ([x & next]\n   (core/let [forms (concat [x] next)]\n     (if (every? #(simple-test-expr? &env %)\n           (map #(cljs.analyzer/analyze &env %) forms))\n       (core/let [and-str (core/->> (repeat (count forms) \"(~{})\")\n                            (interpose \" && \")\n                            (apply core/str))]\n         (bool-expr `(~'js* ~and-str ~@forms)))\n       `(let [and# ~x]\n          (if and# (and ~@next) and#))))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.7.228",
                                     :filename "src/main/clojure/cljs/core.cljc",
                                     :lines [795 811]},
                            :examples [{:id "a39a73",
                                        :content "```clj\n(and)\n;;=> true\n\n(and false)\n;;=> false\n\n(and true)\n;;=> true\n\n(and true true)\n;;=> true\n\n(and true false)\n;;=> false\n\n(and false false)\n;;=> false\n```"}
                                       {:id "766638",
                                        :content "`nil` and `false` are the only falsy values and everything else is truthy:\n\n```clj\n(and \"foo\" \"bar\")\n;;=> \"bar\"\n\n(and \"foo\" nil)\n;;=> nil\n\n(and \"foo\" false)\n;;=> false\n\n(and nil \"foo\")\n;;=> nil\n\n(and false \"foo\")\n;;=> false\n```"}],
                            :full-name "cljs.core/and",
                            :clj-symbol "clojure.core/and",
                            :docstring "Evaluates exprs one at a time, from left to right. If a form\nreturns logical false (nil or false), and returns that value and\ndoesn't evaluate any of the other expressions, otherwise it returns\nthe value of the last expr. (and) returns true."},
           "cljs.js/js-eval" {:ns "cljs.js",
                              :name "js-eval",
                              :signature ["[{:keys [source], :as resource}]"],
                              :history [["+" "1.7.10"]],
                              :type "function",
                              :full-name-encode "cljs.js/js-eval",
                              :source {:code "(defn js-eval\n  [{:keys [source] :as resource}]\n  (js/eval source))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/js.cljs",
                                       :lines [95 98]},
                              :full-name "cljs.js/js-eval",
                              :docstring "A default JavaScript evaluation function."},
           "clojure.browser.repl/wrap-message" {:ns "clojure.browser.repl",
                                                :name "wrap-message",
                                                :type "function",
                                                :signature ["[t data]"],
                                                :source {:code "(defn wrap-message [t data]\n  (pr-str {:type t :content data :order (swap! order inc)}))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1.7.228",
                                                         :filename "src/main/cljs/clojure/browser/repl.cljs",
                                                         :lines [90
                                                                 91]},
                                                :full-name "clojure.browser.repl/wrap-message",
                                                :full-name-encode "clojure.browser.repl/wrap-message",
                                                :history [["+"
                                                           "0.0-927"]]},
           "cljs.reader/deregister-tag-parser!" {:ns "cljs.reader",
                                                 :name "deregister-tag-parser!",
                                                 :type "function",
                                                 :signature ["[tag]"],
                                                 :source {:code "(defn deregister-tag-parser!\n  [tag]\n  (let [tag (str tag)\n        old-parser (get @*tag-table* tag)]\n    (swap! *tag-table* dissoc tag)\n    old-parser))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r1.7.228",
                                                          :filename "src/main/cljs/cljs/reader.cljs",
                                                          :lines [613
                                                                  618]},
                                                 :full-name "cljs.reader/deregister-tag-parser!",
                                                 :full-name-encode "cljs.reader/deregister-tag-parserBANG",
                                                 :history [["+"
                                                            "0.0-1424"]]},
           "clojure.reflect/print-doc" {:ns "clojure.reflect",
                                        :name "print-doc",
                                        :type "function",
                                        :signature ["[{:keys [name method-params doc]}]"],
                                        :source {:code "(defn print-doc [{:keys [name method-params doc]}]\n  (when-not (empty? name)\n    (println name)\n    (println method-params)\n    (println doc)))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/cljs/clojure/reflect.cljs",
                                                 :lines [39 43]},
                                        :full-name "clojure.reflect/print-doc",
                                        :full-name-encode "clojure.reflect/print-doc",
                                        :history [["+" "0.0-1503"]]},
           "clojure.browser.event/unlisten-by-key" {:ns "clojure.browser.event",
                                                    :name "unlisten-by-key",
                                                    :type "function",
                                                    :signature ["[key]"],
                                                    :source {:code "(defn unlisten-by-key\n  [key]\n  (events/unlistenByKey key))",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r1.7.228",
                                                             :filename "src/main/cljs/clojure/browser/event.cljs",
                                                             :lines [73
                                                                     75]},
                                                    :full-name "clojure.browser.event/unlisten-by-key",
                                                    :full-name-encode "clojure.browser.event/unlisten-by-key",
                                                    :history [["+"
                                                               "0.0-927"]]},
           "cljs.core/try" {:moved "special/try",
                            :ns "cljs.core",
                            :name "try",
                            :signature ["[& forms]"],
                            :history [["+" "0.0-927"]
                                      ["-" "0.0-1933"]],
                            :type "macro",
                            :full-name-encode "cljs.core/try",
                            :source {:code "(defmacro try\n  [& forms]\n  (let [catch? #(and (seq? %) (= (first %) 'catch))\n        [body catches] (split-with (complement catch?) forms)\n        [catches fin] (split-with catch? catches)\n        e (gensym \"e\")]\n    (assert (every? #(clojure.core/> (count %) 2) catches) \"catch block must specify a prototype and a name\")\n    (if (seq catches)\n      `(~'try*\n        ~@body\n        (catch ~e\n            (cond\n             ~@(mapcat\n                (fn [[_ type name & cb]]\n                  `[(instance? ~type ~e) (let [~name ~e] ~@cb)])\n                catches)\n             :else (throw ~e)))\n        ~@fin)\n      `(~'try*\n        ~@body\n        ~@fin))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1913",
                                     :filename "src/clj/cljs/core.clj",
                                     :lines [1004 1032]},
                            :full-name "cljs.core/try",
                            :clj-symbol "clojure.core/try",
                            :docstring "(try expr* catch-clause* finally-clause?)\n\n Special Form\n\n catch-clause => (catch protoname name expr*)\n finally-clause => (finally expr*)\n\nCatches and handles JavaScript exceptions.",
                            :removed {:in "0.0-1933",
                                      :last-seen "0.0-1913"}},
           "cljs.repl.nashorn/init-engine" {:ns "cljs.repl.nashorn",
                                            :name "init-engine",
                                            :type "function",
                                            :signature ["[engine output-dir debug]"],
                                            :source {:code "(defn init-engine [engine output-dir debug]\n      (eval-resource engine \"goog/base.js\" debug)\n      (eval-resource engine \"goog/deps.js\" debug)\n      (eval-str engine \"var global = this\") ; required by React\n      (eval-str engine\n        (format\n          (str \"var nashorn_load = function(path) {\"\n            \"  var outputPath = \\\"%s\\\" + \\\"/\\\" + path;\"\n            (when debug \"  print(\\\"loading: \\\" + outputPath) ; \")\n            \"  load(outputPath);\"\n            \"};\")\n          output-dir))\n      (eval-str engine\n        (str \"goog.global.CLOSURE_IMPORT_SCRIPT = function(path) {\"\n          \" nashorn_load(\\\"goog/\\\" + path);\"\n          \" return true;\"\n          \"};\"))\n      (eval-str engine \"goog.global.isProvided_ = function(name) { return false; };\")\n      engine)",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.7.228",
                                                     :filename "src/main/clojure/cljs/repl/nashorn.clj",
                                                     :lines [55 73]},
                                            :full-name "cljs.repl.nashorn/init-engine",
                                            :full-name-encode "cljs.repl.nashorn/init-engine",
                                            :history [["+" "0.0-2814"]]},
           "cljs.build.api/goog-dep-string" {:ns "cljs.build.api",
                                             :name "goog-dep-string",
                                             :signature ["[opts ijs]"],
                                             :history [["+"
                                                        "0.0-3291"]],
                                             :type "function",
                                             :full-name-encode "cljs.build.api/goog-dep-string",
                                             :source {:code "(defn goog-dep-string\n  [opts ijs]\n  (closure/add-dep-string opts ijs))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.7.228",
                                                      :filename "src/main/clojure/cljs/build/api.clj",
                                                      :lines [113 117]},
                                             :full-name "cljs.build.api/goog-dep-string",
                                             :docstring "Given compiler options and a IJavaScript instance return the corresponding\ngoog.addDependency string"},
           "cljs.core/iterate" {:description "Returns a lazy sequence of `x`, `(f x)`, `(f (f x))` etc.\n\n`f` must be free of side-effects.",
                                :ns "cljs.core",
                                :name "iterate",
                                :signature ["[f x]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/cycle"
                                          "cljs.core/repeatedly"
                                          "cljs.core/repeat"],
                                :full-name-encode "cljs.core/iterate",
                                :source {:code "(defn iterate\n  [f x] (cons x (lazy-seq (iterate f (f x)))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [4361 4364]},
                                :full-name "cljs.core/iterate",
                                :clj-symbol "clojure.core/iterate",
                                :docstring "Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects"},
           "cljs.core/lazy-seq" {:description "Returns a new lazy sequence.",
                                 :ns "cljs.core",
                                 :name "lazy-seq",
                                 :signature ["[& body]"],
                                 :history [["+" "0.0-927"]],
                                 :type "macro",
                                 :related ["cljs.core/lazy-cat"
                                           "cljs.core/realized?"
                                           "cljs.core/doall"
                                           "cljs.core/iterate"],
                                 :full-name-encode "cljs.core/lazy-seq",
                                 :source {:code "(core/defmacro lazy-seq\n  [& body]\n  `(new cljs.core/LazySeq nil (fn [] ~@body) nil nil))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/clojure/cljs/core.cljc",
                                          :lines [1977 1983]},
                                 :full-name "cljs.core/lazy-seq",
                                 :clj-symbol "clojure.core/lazy-seq",
                                 :docstring "Takes a body of expressions that returns an ISeq or nil, and yields\na ISeqable object that will invoke the body only the first time seq\nis called, and will cache the result and return it on all subsequent\nseq calls."},
           "cljs.test/update-current-env!" {:ns "cljs.test",
                                            :name "update-current-env!",
                                            :type "function",
                                            :signature ["[ks f & args]"],
                                            :source {:code "(defn update-current-env! [ks f & args]\n  (set! *current-env* (apply update-in (get-current-env) ks f args)))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.7.228",
                                                     :filename "src/main/cljs/cljs/test.cljs",
                                                     :lines [274 275]},
                                            :full-name "cljs.test/update-current-env!",
                                            :full-name-encode "cljs.test/update-current-envBANG",
                                            :history [["+" "0.0-2496"]]},
           "specialrepl/load-file" {:description "Only usable from a REPL.\n\nLoad file at `filename`, then compiles and evaluates its code.",
                                    :ns "specialrepl",
                                    :name "load-file",
                                    :signature ["[filename]"],
                                    :history [["+" "0.0-927"]],
                                    :type "special form (repl)",
                                    :full-name-encode "specialrepl/load-file",
                                    :source {:code "(def default-special-fns\n  (let [load-file-fn\n        (fn self\n          ([repl-env env form]\n            (self repl-env env form nil))\n          ([repl-env env [_ file :as form] opts]\n            (load-file repl-env file opts)))\n        in-ns-fn\n        (fn self\n          ([repl-env env form]\n           (self repl-env env form nil))\n          ([repl-env env [_ [quote ns-name] :as form] _]\n            ;; guard against craziness like '5 which wreaks havoc\n           (when-not (and (= quote 'quote) (symbol? ns-name))\n             (throw (IllegalArgumentException. \"Argument to in-ns must be a symbol.\")))\n           (when-not (ana/get-namespace ns-name)\n             (swap! env/*compiler* assoc-in [::ana/namespaces ns-name] {:name ns-name})\n             (-evaluate repl-env \"<cljs repl>\" 1\n               (str \"goog.provide('\" (comp/munge ns-name) \"');\")))\n           (set! ana/*cljs-ns* ns-name)))]\n    (wrap-special-fns wrap-self\n     {'in-ns in-ns-fn\n      'clojure.core/in-ns in-ns-fn\n      'require\n      (fn self\n        ([repl-env env form]\n         (self repl-env env form nil))\n        ([repl-env env [_ & specs :as form] opts]\n         (let [is-self-require? (self-require? specs)\n               [target-ns restore-ns]\n               (if-not is-self-require?\n                 [ana/*cljs-ns* nil]\n                 ['cljs.user ana/*cljs-ns*])]\n           (evaluate-form repl-env env \"<cljs repl>\"\n                          (with-meta\n                            `(~'ns ~target-ns\n                               (:require ~@(-> specs canonicalize-specs decorate-specs)))\n                            {:merge true :line 1 :column 1})\n                          identity opts)\n           (when is-self-require?\n             (set! ana/*cljs-ns* restore-ns)))))\n      'require-macros\n      (fn self\n        ([repl-env env form]\n         (self repl-env env form nil))\n        ([repl-env env [_ & specs :as form] opts]\n         (evaluate-form repl-env env \"<cljs repl>\"\n                        (with-meta\n                          `(~'ns ~ana/*cljs-ns*\n                             (:require-macros ~@(-> specs canonicalize-specs decorate-specs)))\n                          {:merge true :line 1 :column 1})\n                        identity opts)))\n      'import\n      (fn self\n        ([repl-env env form]\n         (self repl-env env form nil))\n        ([repl-env env [_ & specs :as form] opts]\n         (evaluate-form repl-env env \"<cljs repl>\"\n                        (with-meta\n                          `(~'ns ~ana/*cljs-ns*\n                             (:import\n                              ~@(map\n                                 (fn [quoted-spec-or-kw]\n                                   (if (keyword? quoted-spec-or-kw)\n                                     quoted-spec-or-kw\n                                     (second quoted-spec-or-kw)))\n                                 specs)))\n                          {:merge true :line 1 :column 1})\n                        identity opts)))\n      'load-file load-file-fn\n      'clojure.core/load-file load-file-fn\n      'load-namespace\n      (fn self\n        ([repl-env env form]\n         (self env repl-env form nil))\n        ([repl-env env [_ ns :as form] opts]\n         (load-namespace repl-env ns opts)))})))",
                                             :title "repl specials table",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/clojure/cljs/repl.cljc",
                                             :lines [642 718]},
                                    :examples [{:id "0903c5",
                                                :content "```clj\n(load-file \"path/to/foo.cljs\")\n```"}],
                                    :full-name "specialrepl/load-file",
                                    :clj-symbol "clojure.core/load-file",
                                    :docstring "Sequentially read and evaluate the set of forms contained in the file."},
           "cljs.core/IndexedSeq" {:ns "cljs.core",
                                   :name "IndexedSeq",
                                   :signature ["[arr i]"],
                                   :history [["+" "0.0-927"]],
                                   :type "type",
                                   :full-name-encode "cljs.core/IndexedSeq",
                                   :source {:code "(deftype IndexedSeq [arr i]\n  Object\n  (toString [coll]\n   (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  ICloneable\n  (-clone [_] (IndexedSeq. arr i))\n\n  ISeqable\n  (-seq [this]\n    (when (< i (alength arr))\n      this))\n\n  ASeq\n  ISeq\n  (-first [_] (aget arr i))\n  (-rest [_] (if (< (inc i) (alength arr))\n               (IndexedSeq. arr (inc i))\n               (list)))\n\n  INext\n  (-next [_] (if (< (inc i) (alength arr))\n               (IndexedSeq. arr (inc i))\n               nil))\n\n  ICounted\n  (-count [_]\n    (max 0 (- (alength arr) i)))\n\n  IIndexed\n  (-nth [coll n]\n    (let [i (+ n i)]\n      (when (< i (alength arr))\n        (aget arr i))))\n  (-nth [coll n not-found]\n    (let [i (+ n i)]\n      (if (< i (alength arr))\n        (aget arr i)\n        not-found)))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IIterable\n  (-iterator [coll]\n    (IndexedSeqIterator. arr i))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (.-EMPTY List))\n\n  IReduce\n  (-reduce [coll f]\n    (array-reduce arr f (aget arr i) (inc i)))\n  (-reduce [coll f start]\n    (array-reduce arr f start i))\n\n  IHash\n  (-hash [coll] (hash-ordered-coll coll))\n\n  IReversible\n  (-rseq [coll]\n    (let [c (-count coll)]\n      (if (pos? c)\n        (RSeq. coll (dec c) nil)))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [1385 1454]},
                                   :full-name "cljs.core/IndexedSeq",
                                   :clj-symbol "clojure.lang/IndexedSeq"},
           "cljs.repl.server/parse-headers" {:ns "cljs.repl.server",
                                             :name "parse-headers",
                                             :signature ["[header-lines]"],
                                             :history [["+"
                                                        "0.0-1503"]],
                                             :type "function",
                                             :full-name-encode "cljs.repl.server/parse-headers",
                                             :source {:code "(defn parse-headers\n  [header-lines]\n  (apply hash-map\n    (mapcat\n      (fn [line]\n        (let [[k v] (str/split line #\":\" 2)]\n          [(keyword (str/lower-case k)) (str/triml v)]))\n      header-lines)))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.7.228",
                                                      :filename "src/main/clojure/cljs/repl/server.clj",
                                                      :lines [56 64]},
                                             :full-name "cljs.repl.server/parse-headers",
                                             :docstring "Parse the headers of an HTTP POST request."},
           "cljs.core/KeySeq" {:ns "cljs.core",
                               :name "KeySeq",
                               :signature ["[mseq _meta]"],
                               :history [["+" "0.0-1820"]],
                               :type "type",
                               :full-name-encode "cljs.core/KeySeq",
                               :source {:code "(deftype KeySeq [^not-native mseq _meta]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  IMeta\n  (-meta [coll] _meta)\n\n  IWithMeta\n  (-with-meta [coll new-meta] (KeySeq. mseq new-meta))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ICollection\n  (-conj [coll o]\n    (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY List) _meta))\n\n  IHash\n  (-hash [coll] (hash-ordered-coll coll))\n  \n  ISeq\n  (-first [coll]\n    (let [^not-native me (-first mseq)]\n      (-key me)))\n\n  (-rest [coll]\n    (let [nseq (if (satisfies? INext mseq)\n                 (-next mseq)\n                 (next mseq))]\n      (if-not (nil? nseq)\n        (KeySeq. nseq _meta)\n        ())))\n\n  INext\n  (-next [coll]\n    (let [nseq (if (satisfies? INext mseq)\n                 (-next mseq)\n                 (next mseq))]\n      (when-not (nil? nseq)\n        (KeySeq. nseq _meta))))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [7788 7841]},
                               :full-name "cljs.core/KeySeq",
                               :clj-symbol "clojure.lang/KeySeq"},
           "cljs.core/next" {:description "Returns a sequence of the items after the first and calls `seq` on its argument.\n\nReturns nil if `coll` is empty.",
                             :return-type seq,
                             :ns "cljs.core",
                             :name "next",
                             :signature ["[coll]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/rest"
                                       "cljs.core/first"
                                       "cljs.core/fnext"],
                             :full-name-encode "cljs.core/next",
                             :source {:code "(defn ^seq next\n  [coll]\n  (when-not (nil? coll)\n    (if (implements? INext coll)\n      (-next ^not-native coll)\n      (seq (rest coll)))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [1117 1124]},
                             :examples [{:id "7db59a",
                                         :content "```clj\n(next [1 2 3])\n;;=> (2 3)\n\n(next [1 2])\n;;=> (2)\n\n(next [1])\n;;=> nil\n\n(next [])\n;;=> nil\n```"}],
                             :full-name "cljs.core/next",
                             :clj-symbol "clojure.core/next",
                             :docstring "Returns a seq of the items after the first. Calls seq on its\nargument.  If there are no more items, returns nil"},
           "cljs.core/*print-readably*" {:ns "cljs.core",
                                         :name "*print-readably*",
                                         :history [["+" "0.0-927"]],
                                         :type "dynamic var",
                                         :full-name-encode "cljs.core/STARprint-readablySTAR",
                                         :source {:code "(def\n  ^{:dynamic true\n    :doc \"When set to logical false, strings and characters will be printed with\n  non-alphanumeric characters converted to the appropriate escape sequences.\n\n  Defaults to true\"}\n  *print-readably* true)",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.7.228",
                                                  :filename "src/main/cljs/cljs/core.cljs",
                                                  :lines [81 87]},
                                         :full-name "cljs.core/*print-readably*",
                                         :clj-symbol "clojure.core/*print-readably*",
                                         :docstring "When set to logical false, strings and characters will be printed with\nnon-alphanumeric characters converted to the appropriate escape sequences.\n\nDefaults to true"},
           "cljs.repl.node/read-response" {:ns "cljs.repl.node",
                                           :name "read-response",
                                           :type "function",
                                           :signature ["[in]"],
                                           :source {:code "(defn read-response [^BufferedReader in]\n  (let [sb (StringBuilder.)]\n    (loop [sb sb c (.read in)]\n      (cond\n       (= c 1) (let [ret (str sb)]\n                 (print ret)\n                 (recur (StringBuilder.) (.read in)))\n       (= c 0) (str sb)\n       :else (do\n               (.append sb (char c))\n               (recur sb (.read in)))))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.7.228",
                                                    :filename "src/main/clojure/cljs/repl/node.clj",
                                                    :lines [40 50]},
                                           :full-name "cljs.repl.node/read-response",
                                           :full-name-encode "cljs.repl.node/read-response",
                                           :history [["+" "0.0-2629"]]},
           "cljs.repl.browser/repl-client-js" {:ns "cljs.repl.browser",
                                               :name "repl-client-js",
                                               :type "function",
                                               :signature ["[]"],
                                               :source {:code "(defn repl-client-js []\n  (slurp (:client-js @browser-state)))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.7.228",
                                                        :filename "src/main/clojure/cljs/repl/browser.clj",
                                                        :lines [76 77]},
                                               :full-name "cljs.repl.browser/repl-client-js",
                                               :full-name-encode "cljs.repl.browser/repl-client-js",
                                               :history [["+"
                                                          "0.0-927"]]},
           "cljs.core/booleans" {:ns "cljs.core",
                                 :name "booleans",
                                 :signature ["[x]"],
                                 :history [["+" "0.0-1798"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/booleans",
                                 :source {:code "(defn booleans [x] x)",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [2477]},
                                 :full-name "cljs.core/booleans",
                                 :clj-symbol "clojure.core/booleans"},
           "cljs.core/not-native" {:ns "cljs.core",
                                   :name "not-native",
                                   :type "var",
                                   :source {:code "(def not-native nil)",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [177]},
                                   :full-name "cljs.core/not-native",
                                   :full-name-encode "cljs.core/not-native",
                                   :history [["+" "0.0-1798"]]},
           "cljs.repl.browser/parse-headers" {:moved "cljs.repl.server/parse-headers",
                                              :ns "cljs.repl.browser",
                                              :name "parse-headers",
                                              :signature ["[header-lines]"],
                                              :history [["+"
                                                         "0.0-927"]
                                                        ["-"
                                                         "0.0-1503"]],
                                              :type "function",
                                              :full-name-encode "cljs.repl.browser/parse-headers",
                                              :source {:code "(defn parse-headers\n  [header-lines]\n  (apply hash-map\n   (mapcat\n    (fn [line]\n      (let [[k v] (str/split line #\":\" 2)]\n        [(keyword (str/lower-case k)) (str/triml v)]))\n    header-lines)))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1450",
                                                       :filename "src/clj/cljs/repl/browser.clj",
                                                       :lines [116
                                                               124]},
                                              :full-name "cljs.repl.browser/parse-headers",
                                              :docstring "Parse the headers of an HTTP POST request.",
                                              :removed {:in "0.0-1503",
                                                        :last-seen "0.0-1450"}},
           "cljs.core/last" {:description "Returns the last item in `coll` in linear time.\n\n`peek` is much faster than `last` for a vector.",
                             :ns "cljs.core",
                             :name "last",
                             :signature ["[coll]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/first"
                                       "cljs.core/next"
                                       "cljs.core/rest"
                                       "cljs.core/butlast"
                                       "cljs.core/take-last"],
                             :full-name-encode "cljs.core/last",
                             :source {:code "(defn last\n  [s]\n  (let [sn (next s)]\n    (if-not (nil? sn)\n      (recur sn)\n      (first s))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [1555 1561]},
                             :examples [{:id "eb0836",
                                         :content "```clj\n(last [1 2 3])\n;;=> 3\n\n(last [1 2])\n;;=> 2\n\n(last [1])\n;;=> 1\n\n(last [])\n;;=> nil\n```"}],
                             :full-name "cljs.core/last",
                             :clj-symbol "clojure.core/last",
                             :docstring "Return the last item in coll, in linear time"},
           "cljs.core/pr-str*" {:ns "cljs.core",
                                :name "pr-str*",
                                :signature ["[obj]"],
                                :history [["+" "0.0-1806"]],
                                :type "function",
                                :full-name-encode "cljs.core/pr-strSTAR",
                                :source {:code "(defn pr-str*\n  [^not-native obj]\n  (let [sb (StringBuffer.)\n        writer (StringBufferWriter. sb)]\n    (-pr-writer obj writer (pr-opts))\n    (-flush writer)\n    (str sb)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [763 771]},
                                :full-name "cljs.core/pr-str*",
                                :docstring "Support so that collections can implement toString without\nloading all the printing machinery."},
           "cljs.core/random-uuid" {:ns "cljs.core",
                                    :name "random-uuid",
                                    :type "function",
                                    :signature ["[]"],
                                    :source {:code "(defn random-uuid []\n  (letfn [(hex [] (.toString (rand-int 16) 16))]\n    (let [rhex (.toString (bit-or 0x8 (bit-and 0x3 (rand-int 16))) 16)]\n      (uuid\n        (str (hex) (hex) (hex) (hex)\n             (hex) (hex) (hex) (hex) \"-\"\n             (hex) (hex) (hex) (hex) \"-\"\n             \"4\"   (hex) (hex) (hex) \"-\"\n             rhex  (hex) (hex) (hex) \"-\"\n             (hex) (hex) (hex) (hex)\n             (hex) (hex) (hex) (hex)\n             (hex) (hex) (hex) (hex))))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [9866 9877]},
                                    :full-name "cljs.core/random-uuid",
                                    :full-name-encode "cljs.core/random-uuid",
                                    :history [["+" "0.0-3308"]]},
           "cljs.core/bit-shift-left" {:description "Bitwise shift left `n` bits.  Same as `x << n` in JavaScript.",
                                       :ns "cljs.core",
                                       :name "bit-shift-left",
                                       :signature ["[x n]"],
                                       :history [["+" "0.0-927"]],
                                       :type "function/macro",
                                       :related ["cljs.core/bit-shift-right"],
                                       :full-name-encode "cljs.core/bit-shift-left",
                                       :source {:code "(defn bit-shift-left\n  [x n] (cljs.core/bit-shift-left x n))",
                                                :title "Function code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/cljs/core.cljs",
                                                :lines [2556 2558]},
                                       :extra-sources [{:code "(core/defmacro ^::ana/numeric bit-shift-left [x n]\n  (core/list 'js* \"(~{} << ~{})\" x n))",
                                                        :title "Macro code",
                                                        :repo "clojurescript",
                                                        :tag "r1.7.228",
                                                        :filename "src/main/clojure/cljs/core.cljc",
                                                        :lines [1128
                                                                1129]}],
                                       :examples [{:id "67c34a",
                                                   :content "Bits can be entered using radix notation:\n\n```clj\n(bit-shift-left 2r0101 1)\n;;=> 10\n;; 10 = 2r1010\n```\n\nSame numbers in decimal:\n\n```clj\n(bit-shift-left 5 1)\n;;=> 10\n```"}],
                                       :full-name "cljs.core/bit-shift-left",
                                       :clj-symbol "clojure.core/bit-shift-left",
                                       :docstring "Bitwise shift left"},
           "clojure.string/reverse" {:description "Returns `s` with its characters reversed.",
                                     :ns "clojure.string",
                                     :name "reverse",
                                     :signature ["[s]"],
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "clojure.string/reverse",
                                     :source {:code "(defn reverse\n  [s]\n  (-> (.replace s re-surrogate-pair \"$2$1\")\n      (.. (split \"\") (reverse) (join \"\"))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/cljs/clojure/string.cljs",
                                              :lines [21 25]},
                                     :full-name "clojure.string/reverse",
                                     :clj-symbol "clojure.string/reverse",
                                     :docstring "Returns s with its characters reversed."},
           "cljs.core/min" {:description "Returns the least number argument.",
                            :return-type number,
                            :ns "cljs.core",
                            :name "min",
                            :signature ["[x]" "[x y]" "[x y & more]"],
                            :history [["+" "0.0-927"]],
                            :type "function/macro",
                            :related ["cljs.core/max"
                                      "cljs.core/min-key"],
                            :full-name-encode "cljs.core/min",
                            :source {:code "(defn ^number min\n  ([x] x)\n  ([x y] (cljs.core/min x y))\n  ([x y & more]\n   (reduce min (cljs.core/min x y) more)))",
                                     :title "Function code",
                                     :repo "clojurescript",
                                     :tag "r1.7.228",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [2349 2354]},
                            :extra-sources [{:code "(core/defmacro ^::ana/numeric min\n  ([x] x)\n  ([x y] `(let [x# ~x, y# ~y]\n            (~'js* \"((~{} < ~{}) ? ~{} : ~{})\" x# y# x# y#)))\n  ([x y & more] `(min (min ~x ~y) ~@more)))",
                                             :title "Macro code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/clojure/cljs/core.cljc",
                                             :lines [1083 1087]}],
                            :examples [{:id "ab2de5",
                                        :content "```clj\n(min 1 2 3 4)\n;; => 1\n```\n\nApply it to a collection:\n\n```clj\n(apply min [1 2 3 4])\n;; => 1\n```"}],
                            :full-name "cljs.core/min",
                            :clj-symbol "clojure.core/min",
                            :docstring "Returns the least of the nums."},
           "cljs.reader/escape-char" {:ns "cljs.reader",
                                      :name "escape-char",
                                      :type "function",
                                      :signature ["[buffer reader]"],
                                      :source {:code "(defn escape-char\n  [buffer reader]\n  (let [ch (read-char reader)\n        mapresult (escape-char-map ch)]\n    (if mapresult\n      mapresult\n      (cond\n        (identical? ch \\x)\n        (->> (read-2-chars reader)\n          (validate-unicode-escape unicode-2-pattern reader ch)\n          (make-unicode-char))\n\n        (identical? ch \\u)\n        (->> (read-4-chars reader)\n          (validate-unicode-escape unicode-4-pattern reader ch)\n          (make-unicode-char))\n\n        (numeric? ch)\n        (.fromCharCode js/String ch)\n\n        :else\n        (reader-error reader \"Unexpected unicode escape \\\\\" ch )))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/cljs/cljs/reader.cljs",
                                               :lines [193 214]},
                                      :full-name "cljs.reader/escape-char",
                                      :full-name-encode "cljs.reader/escape-char",
                                      :history [["+" "0.0-927"]]},
           "cljs.reader/read-raw-string*" {:ns "cljs.reader",
                                           :name "read-raw-string*",
                                           :type "function",
                                           :signature ["[reader _]"],
                                           :source {:code "(defn read-raw-string*\n  [reader _]\n  (loop [buffer (gstring/StringBuffer.)\n         ch (read-char reader)]\n    (cond\n      (nil? ch) (reader-error reader \"EOF while reading\")\n      (identical? \"\\\\\" ch) (do (.append buffer ch)\n                             (let [nch (read-char reader)]\n                               (if (nil? nch)\n                                 (reader-error reader \"EOF while reading\")\n                                 (recur (doto buffer (.append nch))\n                                        (read-char reader)))))\n      (identical? \"\\\"\" ch) (.toString buffer)\n      :else (recur (doto buffer (.append ch)) (read-char reader)))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.7.228",
                                                    :filename "src/main/cljs/cljs/reader.cljs",
                                                    :lines [304 317]},
                                           :full-name "cljs.reader/read-raw-string*",
                                           :full-name-encode "cljs.reader/read-raw-stringSTAR",
                                           :history [["+" "0.0-2261"]]},
           "cljs.core/INext" {:ns "cljs.core",
                              :name "INext",
                              :history [["+" "0.0-1424"]],
                              :type "protocol",
                              :full-name-encode "cljs.core/INext",
                              :source {:code "(defprotocol INext\n  \"Protocol for accessing the next items of a collection.\"\n  (^clj-or-nil -next [coll]\n    \"Returns a new collection of coll without the first item. In contrast to\n     rest, it should return nil if there are no more items, e.g.\n     (next []) => nil\n     (next nil) => nil\"))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [501 507]},
                              :methods [{:name "-next",
                                         :signature ["[coll]"],
                                         :docstring "Returns a new collection of coll without the first item. In contrast to\n     rest, it should return nil if there are no more items, e.g.\n     (next []) => nil\n     (next nil) => nil"}],
                              :full-name "cljs.core/INext",
                              :docstring "Protocol for accessing the next items of a collection."},
           "syntax/auto-gensym" {:description "(Only intended for use in a [doc:syntax/syntax-quote].)\n\n``foo#` => `foo__135__auto__`\n\nAuto-generates a unique symbol with the given prefix, particularly one that\nwill not shadow any existing symbol in its resulting scope.  This is intended\nas a convenience for creating hygienic macros without calling\n[doc:cljs.core/gensym] directly.\n\nEvery symbol matching a unique `foo#` symbol within a syntax quoted form will\nbe replaced with the same generated symbol.\n\n``(foo# foo#)` => `(foo__138__auto__ foo__138__auto__)`\n\nNamespace-qualified symbols `foo/bar#` are not replaced.",
                                 :ns "syntax",
                                 :name "auto-gensym",
                                 :history [["+" "0.0-927"]],
                                 :type "special character",
                                 :related ["cljs.core/gensym"
                                           "syntax/syntax-quote"],
                                 :full-name-encode "syntax/auto-gensym",
                                 :usage ["foo#"],
                                 :examples [{:id "432cda",
                                             :content "```clj\n`foo#\n;;=> foo__142__auto__\n```\n\nNamespace-qualified symbols are left alone.\n\n```clj\n`foo/bar#\n;;=> foo/bar#\n```"}
                                            {:id "cd51e7",
                                             :content "Create safe local bindings:\n\n```clj\n`(let [x# 1]\n   (+ x# 2))\n;;=> (cljs.user/let [x__146__auto__ 1] (cljs.user/+ x__146__auto__ 2))\n```"}],
                                 :full-name "syntax/auto-gensym",
                                 :display "# auto-gensym",
                                 :clj-doc "http://clojure.org/reader#syntax-quote"},
           "cljs.reader/read-map" {:ns "cljs.reader",
                                   :name "read-map",
                                   :type "function",
                                   :signature ["[rdr _]"],
                                   :source {:code "(defn read-map\n  [rdr _]\n  (let [l (read-delimited-list \"}\" rdr true)]\n    (when (odd? (count l))\n      (reader-error rdr \"Map literal must contain an even number of forms\"))\n    (apply hash-map l)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/cljs/reader.cljs",
                                            :lines [274 279]},
                                   :full-name "cljs.reader/read-map",
                                   :full-name-encode "cljs.reader/read-map",
                                   :history [["+" "0.0-927"]]},
           "cljs.core/seq" {:description "Returns a sequence on the collection. If the collection is empty, returns nil.\n\n`(seq nil)` returns nil.\n\n`seq` also works on strings.",
                            :return-type seq,
                            :ns "cljs.core",
                            :name "seq",
                            :signature ["[coll]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/seq?"
                                      "cljs.core/empty?"],
                            :full-name-encode "cljs.core/seq",
                            :source {:code "(defn ^seq seq\n  [coll]\n  (when-not (nil? coll)\n    (cond\n      (implements? ISeqable coll)\n      (-seq ^not-native coll)\n\n      (array? coll)\n      (when-not (zero? (alength coll))\n        (IndexedSeq. coll 0))\n\n      (string? coll)\n      (when-not (zero? (alength coll))\n        (IndexedSeq. coll 0))\n\n      (native-satisfies? ISeqable coll)\n      (-seq coll)\n\n      :else (throw (js/Error. (str coll \" is not ISeqable\"))))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.7.228",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [1070 1091]},
                            :full-name "cljs.core/seq",
                            :clj-symbol "clojure.core/seq",
                            :docstring "Returns a seq on the collection. If the collection is\nempty, returns nil.  (seq nil) returns nil. seq also works on\nStrings."},
           "cljs.core/*print-newline*" {:ns "cljs.core",
                                        :name "*print-newline*",
                                        :docstring "When set to logical false will drop newlines from printing calls.\nThis is to work around the implicit newlines emitted by standard JavaScript\nconsole objects.",
                                        :type "dynamic var",
                                        :source {:code "(def\n  ^{:dynamic true\n    :doc \"When set to logical false will drop newlines from printing calls.\n  This is to work around the implicit newlines emitted by standard JavaScript\n  console objects.\"}\n  *print-newline* true)",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/cljs/cljs/core.cljs",
                                                 :lines [74 79]},
                                        :full-name "cljs.core/*print-newline*",
                                        :full-name-encode "cljs.core/STARprint-newlineSTAR",
                                        :history [["+" "0.0-2060"]]},
           "cljs.core/long" {:ns "cljs.core",
                             :name "long",
                             :signature ["[x]"],
                             :history [["+" "0.0-1211"]],
                             :type "function",
                             :full-name-encode "cljs.core/long",
                             :source {:code "(defn long\n  [x]\n  (fix x))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [2467 2470]},
                             :full-name "cljs.core/long",
                             :clj-symbol "clojure.core/long",
                             :docstring "Coerce to long by stripping decimal places. Identical to `int'."},
           "cljs.core/es6-iterator" {:ns "cljs.core",
                                     :name "es6-iterator",
                                     :signature ["[coll]"],
                                     :history [["+" "0.0-2371"]],
                                     :type "function",
                                     :full-name-encode "cljs.core/es6-iterator",
                                     :source {:code "(defn es6-iterator\n  [coll]\n  (ES6Iterator. (seq coll)))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/cljs/cljs/core.cljs",
                                              :lines [1154 1157]},
                                     :full-name "cljs.core/es6-iterator",
                                     :docstring "EXPERIMENTAL: Return a ES2015 compatible iterator for coll."},
           "cljs.core/not-empty" {:description "Returns nil if `coll` is empty, else returns `coll`.",
                                  :ns "cljs.core",
                                  :name "not-empty",
                                  :signature ["[coll]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/empty"],
                                  :full-name-encode "cljs.core/not-empty",
                                  :source {:code "(defn not-empty\n  [coll] (when (seq coll) coll))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [3517 3519]},
                                  :full-name "cljs.core/not-empty",
                                  :clj-symbol "clojure.core/not-empty",
                                  :docstring "If coll is empty, returns nil, else coll"},
           "cljs.core/println" {:ns "cljs.core",
                                :name "println",
                                :signature ["[& objs]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/println",
                                :source {:code "(defn println\n  [& objs]\n  (pr-with-opts objs (assoc (pr-opts) :readably false))\n  (when *print-newline*\n    (newline (pr-opts))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [8961 8966]},
                                :full-name "cljs.core/println",
                                :clj-symbol "clojure.core/println",
                                :docstring "Same as print followed by (newline)"},
           "cljs.core/NS_CACHE" {:ns "cljs.core",
                                 :name "NS_CACHE",
                                 :type "var",
                                 :source {:code "(def\n  ^{:jsdoc [\"@type {*}\"]}\n  NS_CACHE nil)",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [10128 10130]},
                                 :full-name "cljs.core/NS_CACHE",
                                 :full-name-encode "cljs.core/NS_CACHE",
                                 :history [["+" "1.7.10"]]},
           "clojure.browser.repl/connect" {:ns "clojure.browser.repl",
                                           :name "connect",
                                           :signature ["[repl-server-url]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "clojure.browser.repl/connect",
                                           :source {:code "(defn connect\n  [repl-server-url]\n  (let [repl-connection\n        (net/xpc-connection\n          {:peer_uri repl-server-url})]\n    (swap! xpc-connection (constantly repl-connection))\n    (net/register-service repl-connection\n      :evaluate-javascript\n      (fn [js]\n        (net/transmit\n          repl-connection\n          :send-result\n          (evaluate-javascript repl-connection js))))\n    (net/connect repl-connection\n      (constantly nil)\n      (fn [iframe]\n        (set! (.-display (.-style iframe))\n          \"none\")))\n    (bootstrap)\n    repl-connection))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.7.228",
                                                    :filename "src/main/cljs/clojure/browser/repl.cljs",
                                                    :lines [184 206]},
                                           :full-name "clojure.browser.repl/connect",
                                           :docstring "Connects to a REPL server from an HTML document. After the\nconnection is made, the REPL will evaluate forms in the context of\nthe document that called this function."},
           "cljs.core/bytes" {:ns "cljs.core",
                              :name "bytes",
                              :signature ["[x]"],
                              :history [["+" "0.0-1798"]],
                              :type "function",
                              :full-name-encode "cljs.core/bytes",
                              :source {:code "(defn bytes [x] x)",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [2478]},
                              :full-name "cljs.core/bytes",
                              :clj-symbol "clojure.core/bytes"},
           "cljs.core/unchecked-byte" {:return-type number,
                                       :ns "cljs.core",
                                       :name "unchecked-byte",
                                       :signature ["[x]"],
                                       :history [["+" "0.0-1798"]],
                                       :type "function/macro",
                                       :full-name-encode "cljs.core/unchecked-byte",
                                       :source {:code "(defn ^number unchecked-byte [x] x)",
                                                :title "Function code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/cljs/core.cljs",
                                                :lines [2370]},
                                       :extra-sources [{:code "(core/defmacro unchecked-byte [x] x)",
                                                        :title "Macro code",
                                                        :repo "clojurescript",
                                                        :tag "r1.7.228",
                                                        :filename "src/main/clojure/cljs/core.cljc",
                                                        :lines [968]}],
                                       :full-name "cljs.core/unchecked-byte",
                                       :clj-symbol "clojure.core/unchecked-byte"},
           "clojure.browser.dom/insert-at" {:ns "clojure.browser.dom",
                                            :name "insert-at",
                                            :type "function",
                                            :signature ["[parent child index]"],
                                            :source {:code "(defn insert-at [parent child index]\n  (gdom/insertChildAt parent child index))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.7.228",
                                                     :filename "src/main/cljs/clojure/browser/dom.cljs",
                                                     :lines [104 105]},
                                            :full-name "clojure.browser.dom/insert-at",
                                            :full-name-encode "clojure.browser.dom/insert-at",
                                            :history [["+" "0.0-927"]]},
           "cljs.core/quot" {:description "Returns the quotient of dividing numerator `n` by denominator `d`.\n\nReturns `NaN` when `d` is 0 (divide by 0 error).",
                             :ns "cljs.core",
                             :name "quot",
                             :signature ["[n d]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/rem"
                                       "cljs.core/mod"],
                             :full-name-encode "cljs.core/quot",
                             :source {:code "(defn quot\n  [n d]\n  (let [rem (js-mod n d)]\n    (fix (/ (- n rem) d))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [2496 2500]},
                             :full-name "cljs.core/quot",
                             :clj-symbol "clojure.core/quot",
                             :docstring "quot[ient] of dividing numerator by denominator."},
           "cljs.repl.reflect/handle-reflect-query" {:ns "cljs.repl.reflect",
                                                     :name "handle-reflect-query",
                                                     :signature ["[[param _] & _]"],
                                                     :history [["+"
                                                                "0.0-1503"]],
                                                     :type "multimethod",
                                                     :full-name-encode "cljs.repl.reflect/handle-reflect-query",
                                                     :source {:code "(defmulti handle-reflect-query (fn [[param _] & _] param))",
                                                              :title "Source code",
                                                              :repo "clojurescript",
                                                              :tag "r1.7.228",
                                                              :filename "src/main/clojure/cljs/repl/reflect.clj",
                                                              :lines [60]},
                                                     :extra-sources ({:code "(defmethod handle-reflect-query \"var\"\n  [[_ sym] req conn opts]\n  (let [sym (read-url-string sym)]\n    (compile-and-return conn (get-meta sym))))",
                                                                      :title "Dispatch method",
                                                                      :repo "clojurescript",
                                                                      :tag "r1.7.228",
                                                                      :filename "src/main/clojure/cljs/repl/reflect.clj",
                                                                      :lines [62
                                                                              65]}
                                                                     {:code "(defmethod handle-reflect-query \"macroform\"\n  [[_ mform] req conn opts]\n  (let [mform (-> mform read-url-string macroexpand)]\n    (server/send-and-close conn 200 (with-out-str (pprint/pprint mform)))))",
                                                                      :title "Dispatch method",
                                                                      :repo "clojurescript",
                                                                      :tag "r1.7.228",
                                                                      :filename "src/main/clojure/cljs/repl/reflect.clj",
                                                                      :lines [67
                                                                              70]}),
                                                     :full-name "cljs.repl.reflect/handle-reflect-query"},
           "clojure.browser.event/get-listener" {:ns "clojure.browser.event",
                                                 :name "get-listener",
                                                 :type "function",
                                                 :signature ["[src type listener opt_capt opt_handler]"],
                                                 :source {:code "(defn get-listener [src type listener opt_capt opt_handler])",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r1.7.228",
                                                          :filename "src/main/cljs/clojure/browser/event.cljs",
                                                          :lines [91]},
                                                 :full-name "clojure.browser.event/get-listener",
                                                 :full-name-encode "clojure.browser.event/get-listener",
                                                 :history [["+"
                                                            "0.0-927"]]},
           "cljs.core/filter" {:description "Returns a lazy sequence of the non-nil results of `(f item)`. Note, this means\nfalse return values will be included.\n\n`f` must be free of side-effects.\n\nReturns a transducer when no collection is provided.",
                               :ns "cljs.core",
                               :name "filter",
                               :signature ["[f]" "[f coll]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/remove"
                                         "cljs.core/keep"],
                               :full-name-encode "cljs.core/filter",
                               :source {:code "(defn filter\n  ([pred]\n    (fn [rf]\n      (fn\n        ([] (rf))\n        ([result] (rf result))\n        ([result input]\n           (if (pred input)\n             (rf result input)\n             result)))))\n  ([pred coll]\n   (lazy-seq\n    (when-let [s (seq coll)]\n      (if (chunked-seq? s)\n        (let [c (chunk-first s)\n              size (count c)\n              b (chunk-buffer size)]\n          (dotimes [i size]\n              (when (pred (-nth c i))\n                (chunk-append b (-nth c i))))\n          (chunk-cons (chunk b) (filter pred (chunk-rest s))))\n        (let [f (first s) r (rest s)]\n          (if (pred f)\n            (cons f (filter pred r))\n            (filter pred r))))))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [4426 4453]},
                               :full-name "cljs.core/filter",
                               :clj-symbol "clojure.core/filter",
                               :docstring "Returns a lazy sequence of the items in coll for which\n(pred item) returns true. pred must be free of side-effects.\nReturns a transducer when no collection is provided."},
           "cljs.core/RSeq" {:ns "cljs.core",
                             :name "RSeq",
                             :signature ["[ci i meta]"],
                             :history [["+" "0.0-1424"]],
                             :type "type",
                             :full-name-encode "cljs.core/RSeq",
                             :source {:code "(deftype RSeq [ci i meta]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  ICloneable\n  (-clone [_] (RSeq. ci i meta))\n\n  IMeta\n  (-meta [coll] meta)\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (RSeq. ci i new-meta))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ISeq\n  (-first [coll]\n    (-nth ci i))\n  (-rest [coll]\n    (if (pos? i)\n      (RSeq. ci (dec i) nil)\n      ()))\n  \n  INext\n  (-next [coll]\n    (when (pos? i)\n      (RSeq. ci (dec i) nil)))\n\n  ICounted\n  (-count [coll] (inc i))\n\n  ICollection\n  (-conj [coll o]\n    (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY List) meta))\n\n  IHash\n  (-hash [coll] (hash-ordered-coll coll))\n\n  IReduce\n  (-reduce [col f] (seq-reduce f col))\n  (-reduce [col f start] (seq-reduce f start col)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [1475 1526]},
                             :full-name "cljs.core/RSeq",
                             :clj-symbol "clojure.lang/RSeq"},
           "clojure.zip/branch?" {:ns "clojure.zip",
                                  :name "branch?",
                                  :signature ["[loc]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.zip/branchQMARK",
                                  :source {:code "(defn branch?\n  [loc]\n    ((:zip/branch? (meta loc)) (node loc)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/clojure/zip.cljs",
                                           :lines [64 67]},
                                  :full-name "clojure.zip/branch?",
                                  :clj-symbol "clojure.zip/branch?",
                                  :docstring "Returns true if the node at loc is a branch"},
           "special/if" {:description "If `test` is not false or nil, `then` is evaluated and returned. Otherwise,\n`else?` is evaluated and returned. `else?` defaults to nil if not provided.\n\n`if` is one of ClojureScript's [special forms](http://clojure.org/special_forms)\nand is a fundamental building block of the language. All other conditionals in\nClojureScript are based on `if`s notion of truthiness (ie: anything other than\nfalse or nil).",
                         :ns "special",
                         :name "if",
                         :signature ["[test then else?]"],
                         :history [["+" "0.0-927"]],
                         :type "special form",
                         :related ["cljs.core/cond"
                                   "cljs.core/when"
                                   "cljs.core/if-let"
                                   "cljs.core/if-not"],
                         :full-name-encode "special/if",
                         :source {:code "(defmethod parse 'if\n  [op env [_ test then else :as form] name _]\n  (when (< (count form) 3)\n    (throw (error env \"Too few arguments to if\")))\n  (when (> (count form) 4)\n   (throw (error env \"Too many arguments to if\")))\n  (let [test-expr (disallowing-recur (analyze (assoc env :context :expr) test))\n        then-expr (allowing-redef (analyze env then))\n        else-expr (allowing-redef (analyze env else))]\n    {:env env :op :if :form form\n     :test test-expr :then then-expr :else else-expr\n     :unchecked #?(:clj  @*unchecked-if*\n                   :cljs *unchecked-if*)\n     :children [test-expr then-expr else-expr]}))",
                                  :title "Parser code",
                                  :repo "clojurescript",
                                  :tag "r1.7.228",
                                  :filename "src/main/clojure/cljs/analyzer.cljc",
                                  :lines [966 979]},
                         :examples [{:id "e591ff",
                                     :content "```clj\n(def v [1 2])\n\n(if (empty? v) \"empty!\" \"filled!\")\n;;=> \"filled!\"\n\n(str \"This vector is \"\n  (if (empty? v) \"empty!\" \"filled!\"))\n;;=> \"This vector is filled!\"\n```"}],
                         :full-name "special/if",
                         :clj-symbol "clojure.core/if",
                         :docstring "Evaluates test. If not the singular values nil or false,\nevaluates and yields then, otherwise, evaluates and yields else. If\nelse is not supplied it defaults to nil."},
           "cljs.pprint/*print-radix*" {:ns "cljs.pprint",
                                        :name "*print-radix*",
                                        :history [["+" "0.0-3255"]],
                                        :type "dynamic var",
                                        :full-name-encode "cljs.pprint/STARprint-radixSTAR",
                                        :source {:code "(def ^:dynamic\n^{:doc \"Print a radix specifier in front of integers and rationals. If *print-base* is 2, 8,\nor 16, then the radix specifier used is #b, #o, or #x, respectively. Otherwise the\nradix specifier is in the form #XXr where XX is the decimal value of *print-base* \"\n  :added \"1.2\"}\n*print-radix* nil)",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/cljs/cljs/pprint.cljs",
                                                 :lines [665 670]},
                                        :full-name "cljs.pprint/*print-radix*",
                                        :clj-symbol "clojure.pprint/*print-radix*",
                                        :docstring "Print a radix specifier in front of integers and rationals. If *print-base* is 2, 8,\nor 16, then the radix specifier used is #b, #o, or #x, respectively. Otherwise the\nradix specifier is in the form #XXr where XX is the decimal value of *print-base* "},
           "cljs.core/ObjMap" {:ns "cljs.core",
                               :name "ObjMap",
                               :type "type",
                               :signature ["[meta keys strobj update-count __hash]"],
                               :source {:code "(deftype ObjMap [meta keys strobj update-count ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  IWithMeta\n  (-with-meta [coll meta] (ObjMap. meta keys strobj update-count __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (reduce -conj\n              coll\n              entry)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY ObjMap) meta))\n\n  IEquiv\n  (-equiv [coll other] (equiv-map coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-unordered-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (when (pos? (alength keys))\n      (map #(vector % (aget strobj %))\n           (.sort keys obj-map-compare-keys))))\n\n  ICounted\n  (-count [coll] (alength keys))\n\n  ILookup\n  (-lookup [coll k] (-lookup coll k nil))\n  (-lookup [coll k not-found]\n    (if (and ^boolean (goog/isString k)\n             (not (nil? (scan-array 1 k keys))))\n      (aget strobj k)\n      not-found))\n\n  IAssociative\n  (-assoc [coll k v]\n    (if ^boolean (goog/isString k)\n        (if (or (> update-count (.-HASHMAP_THRESHOLD ObjMap))\n                (>= (alength keys) (.-HASHMAP_THRESHOLD ObjMap)))\n          (obj-map->hash-map coll k v)\n          (if-not (nil? (scan-array 1 k keys))\n            (let [new-strobj (obj-clone strobj keys)]\n              (aset new-strobj k v)\n              (ObjMap. meta keys new-strobj (inc update-count) nil)) ; overwrite\n            (let [new-strobj (obj-clone strobj keys) ; append\n                  new-keys (aclone keys)]\n              (aset new-strobj k v)\n              (.push new-keys k)\n              (ObjMap. meta new-keys new-strobj (inc update-count) nil))))\n        ;; non-string key. game over.\n        (obj-map->hash-map coll k v)))\n  (-contains-key? [coll k]\n    (if (and ^boolean (goog/isString k)\n             (not (nil? (scan-array 1 k keys))))\n      true\n      false))\n\n  IKVReduce\n  (-kv-reduce [coll f init]\n    (let [len (alength keys)]\n      (loop [keys (.sort keys obj-map-compare-keys)\n             init init]\n        (if (seq keys)\n          (let [k (first keys)\n                init (f init k (aget strobj k))]\n            (if (reduced? init)\n              @init\n              (recur (rest keys) init)))\n          init))))\n\n  IMap\n  (-dissoc [coll k]\n    (if (and ^boolean (goog/isString k)\n             (not (nil? (scan-array 1 k keys))))\n      (let [new-keys (aclone keys)\n            new-strobj (obj-clone strobj keys)]\n        (.splice new-keys (scan-array 1 k new-keys) 1)\n        (js-delete new-strobj k)\n        (ObjMap. meta new-keys new-strobj (inc update-count) nil))\n      coll)) ; key not found, return coll unchanged\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found))\n\n  IEditableCollection\n  (-as-transient [coll]\n    (transient (into (hash-map) coll))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [5549 5651]},
                               :full-name "cljs.core/ObjMap",
                               :full-name-encode "cljs.core/ObjMap",
                               :history [["+" "0.0-927"]]},
           "cljs.core/sequence" {:ns "cljs.core",
                                 :name "sequence",
                                 :signature ["[coll]"
                                             "[xform coll]"
                                             "[xform coll & colls]"],
                                 :history [["+" "0.0-2120"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/sequence",
                                 :source {:code "(defn sequence\n  ([coll]\n     (if (seq? coll)\n       coll\n       (or (seq coll) ())))\n  ([xform coll]\n     (.create LazyTransformer xform coll))\n  ([xform coll & colls]\n     (.createMulti LazyTransformer xform (to-array (cons coll colls)))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [3736 3752]},
                                 :full-name "cljs.core/sequence",
                                 :clj-symbol "clojure.core/sequence",
                                 :docstring "Coerces coll to a (possibly empty) sequence, if it is not already\none. Will not force a lazy seq. (sequence nil) yields (), When a\ntransducer is supplied, returns a lazy sequence of applications of\nthe transform to the items in coll(s), i.e. to the set of first\nitems of each coll, followed by the set of second\nitems in each coll, until any one of the colls is exhausted.  Any\nremaining items in other colls are ignored. The transform should accept\nnumber-of-colls arguments"},
           "cljs.core/zipmap" {:description "Returns a map with `keys` mapped to corresponding `vals`.\n\n<pre>user=> (zipmap [:a :b :c :d] [1 2 3 4])\n{:a 1, :b 2, :c 3, :d 4}</pre>",
                               :ns "cljs.core",
                               :name "zipmap",
                               :signature ["[keys vals]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/interleave"],
                               :full-name-encode "cljs.core/zipmap",
                               :source {:code "(defn zipmap\n  [keys vals]\n    (loop [map (transient {})\n           ks (seq keys)\n           vs (seq vals)]\n      (if (and ks vs)\n        (recur (assoc! map (first ks) (first vs))\n               (next ks)\n               (next vs))\n        (persistent! map))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [8306 8316]},
                               :full-name "cljs.core/zipmap",
                               :clj-symbol "clojure.core/zipmap",
                               :docstring "Returns a map with the keys mapped to the corresponding vals."},
           "cljs.core/char?" {:return-type boolean,
                              :ns "cljs.core",
                              :name "char?",
                              :signature ["[x]"],
                              :history [["+" "1.7.10"]],
                              :type "function",
                              :full-name-encode "cljs.core/charQMARK",
                              :source {:code "(defn ^boolean char?\n  [x]\n  (gstring/isUnicodeChar x))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [227 230]},
                              :full-name "cljs.core/char?",
                              :clj-symbol "clojure.core/char?",
                              :docstring "Returns true if x is a JavaScript char."},
           "cljs.core/hash-combine" {:ns "cljs.core",
                                     :name "hash-combine",
                                     :type "function",
                                     :signature ["[seed hash]"],
                                     :source {:code "(defn hash-combine [seed hash]\n  ; a la boost\n  (bit-xor seed\n    (+ hash 0x9e3779b9\n      (bit-shift-left seed 6)\n      (bit-shift-right seed 2))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/cljs/cljs/core.cljs",
                                              :lines [897 902]},
                                     :full-name "cljs.core/hash-combine",
                                     :full-name-encode "cljs.core/hash-combine",
                                     :history [["+" "0.0-927"]]},
           "cljs.core/reversible?" {:description "Returns true if `coll` implements the `IReversible` protocol, false otherwise.\n\nVectors, sorted maps, and sorted sets implement `IReversible`.",
                                    :return-type boolean,
                                    :ns "cljs.core",
                                    :name "reversible?",
                                    :signature ["[coll]"],
                                    :history [["+" "0.0-1211"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/reversibleQMARK",
                                    :source {:code "(defn ^boolean reversible?\n  [coll]\n  (satisfies? IReversible coll))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [2823 2826]},
                                    :full-name "cljs.core/reversible?",
                                    :clj-symbol "clojure.core/reversible?",
                                    :docstring "Returns true if coll satisfies? IReversible."},
           "syntax/arg" {:description "Special vars for accessing implicit function arguments.\n\nOnly usable inside [doc:syntax/function].\n\n- `%` or `%1` for first argument.\n- `%2`, `%3` and so on for subsequent arguments\n- `%&` for the rest of the arguments after the highest individually referenced argument",
                         :ns "syntax",
                         :name "arg",
                         :history [["+" "0.0-927"]],
                         :type "syntax",
                         :related ["syntax/function"],
                         :full-name-encode "syntax/arg",
                         :extra-sources ({:code "(defn- read-arg\n  [rdr pct opts pending-forms]\n  (if-not (thread-bound? #'arg-env)\n    (read-symbol rdr pct)\n    (let [ch (peek-char rdr)]\n      (cond\n       (or (whitespace? ch)\n           (macro-terminating? ch)\n           (nil? ch))\n       (register-arg 1)\n\n       (identical? ch \\&)\n       (do (read-char rdr)\n           (register-arg -1))\n\n       :else\n       (let [n (read* rdr true nil opts pending-forms)]\n         (if-not (integer? n)\n           (throw (IllegalStateException. \"Arg literal must be %, %& or %integer\"))\n           (register-arg n)))))))",
                                          :title "Reader code",
                                          :repo "tools.reader",
                                          :tag "tools.reader-1.0.0-alpha1",
                                          :filename "src/main/clojure/clojure/tools/reader.clj",
                                          :lines [558 577]}
                                         {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                          :title "Reader table",
                                          :repo "tools.reader",
                                          :tag "tools.reader-1.0.0-alpha1",
                                          :filename "src/main/clojure/clojure/tools/reader.clj",
                                          :lines [743 762]}),
                         :examples [{:id "d17825",
                                     :content "```clj\n(map #(* 2 %) [1 2 3])\n;;=> (2 4 6)\n\n(def f #(println %1 %2 %&))\n(f 1 2 3 4 5)\n;; prints: 1 2 (3 4 5)\n```"}],
                         :full-name "syntax/arg",
                         :display "% arg",
                         :clj-doc "http://clojure.org/reader#toc2"},
           "clojure.core.reducers/flatten" {:ns "clojure.core.reducers",
                                            :name "flatten",
                                            :signature ["[]" "[coll]"],
                                            :history [["+" "0.0-1236"]],
                                            :type "function",
                                            :full-name-encode "clojure.core.reducers/flatten",
                                            :source {:code "(defcurried flatten\n  \"Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat foldable\n  collection.\"\n  {}\n  [coll]\n  (folder coll\n   (fn [f1]\n     (fn\n       ([] (f1))\n       ([ret v]\n          (if (sequential? v)\n            (-reduce (flatten v) f1 ret)\n            (f1 ret v)))))))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.7.228",
                                                     :filename "src/main/cljs/clojure/core/reducers.cljs",
                                                     :lines [130 143]},
                                            :full-name "clojure.core.reducers/flatten",
                                            :clj-symbol "clojure.core.reducers/flatten",
                                            :docstring "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat foldable\n  collection."},
           "cljs.core/max-key" {:description "Returns the `x` for which `(k x)` is greatest.\n\n`(k x)` should return a number.",
                                :ns "cljs.core",
                                :name "max-key",
                                :signature ["[k x]"
                                            "[k x y]"
                                            "[k x y & more]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/max"
                                          "cljs.core/min-key"],
                                :full-name-encode "cljs.core/max-key",
                                :source {:code "(defn max-key\n  ([k x] x)\n  ([k x y] (if (> (k x) (k y)) x y))\n  ([k x y & more]\n   (reduce #(max-key k %1 %2) (max-key k x y) more)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [8318 8323]},
                                :full-name "cljs.core/max-key",
                                :clj-symbol "clojure.core/max-key",
                                :docstring "Returns the x for which (k x), a number, is greatest."},
           "clojure.zip/insert-child" {:ns "clojure.zip",
                                       :name "insert-child",
                                       :signature ["[loc item]"],
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "clojure.zip/insert-child",
                                       :source {:code "(defn insert-child\n  [loc item]\n    (replace loc (make-node loc (node loc) (cons item (children loc)))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/clojure/zip.cljs",
                                                :lines [194 198]},
                                       :full-name "clojure.zip/insert-child",
                                       :clj-symbol "clojure.zip/insert-child",
                                       :docstring "Inserts the item as the leftmost child of the node at this loc,\nwithout moving"},
           "cljs.repl.browser/send-404" {:moved "cljs.repl.server/send-404",
                                         :ns "cljs.repl.browser",
                                         :name "send-404",
                                         :signature ["[conn path]"],
                                         :history [["+" "0.0-927"]
                                                   ["-" "0.0-1503"]],
                                         :type "function",
                                         :full-name-encode "cljs.repl.browser/send-404",
                                         :source {:code "(defn send-404 [conn path]\n  (send-and-close conn 404\n                  (str \"<html><body>\"\n                       \"<h2>Page not found</h2>\"\n                       \"No page \" path \" found on this server.\"\n                       \"</body></html>\")\n                  \"text/html\"))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1450",
                                                  :filename "src/clj/cljs/repl/browser.clj",
                                                  :lines [92 98]},
                                         :full-name "cljs.repl.browser/send-404",
                                         :removed {:in "0.0-1503",
                                                   :last-seen "0.0-1450"}},
           "cljs.core/defrecord" {:ns "cljs.core",
                                  :name "defrecord",
                                  :signature ["[rsym fields & impls]"],
                                  :history [["+" "0.0-927"]],
                                  :type "macro",
                                  :full-name-encode "cljs.core/defrecord",
                                  :source {:code "(core/defmacro defrecord\n  [rsym fields & impls]\n  (validate-fields \"defrecord\" rsym fields)\n  (core/let [rsym (vary-meta rsym assoc :internal-ctor true)\n             r    (vary-meta\n                    (:name (cljs.analyzer/resolve-var (dissoc &env :locals) rsym))\n                    assoc :internal-ctor true)]\n    `(let []\n       ~(emit-defrecord &env rsym r fields impls)\n       (set! (.-getBasis ~r) (fn [] '[~@fields]))\n       (set! (.-cljs$lang$type ~r) true)\n       (set! (.-cljs$lang$ctorPrSeq ~r) (fn [this#] (cljs.core/list ~(core/str r))))\n       (set! (.-cljs$lang$ctorPrWriter ~r) (fn [this# writer#] (-write writer# ~(core/str r))))\n       ~(build-positional-factory rsym r fields)\n       ~(build-map-factory rsym r fields)\n       ~r)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/clojure/cljs/core.cljc",
                                           :lines [1740 1807]},
                                  :full-name "cljs.core/defrecord",
                                  :clj-symbol "clojure.core/defrecord",
                                  :docstring "(defrecord name [fields*]  options* specs*)\n\nCurrently there are no options.\n\nEach spec consists of a protocol or interface name followed by zero\nor more method bodies:\n\nprotocol-or-Object\n(methodName [args*] body)*\n\nThe record will have the (immutable) fields named by\nfields, which can have type hints. Protocols and methods\nare optional. The only methods that can be supplied are those\ndeclared in the protocols.  Note that method bodies are\nnot closures, the local environment includes only the named fields,\nand those fields can be accessed directly.\n\nMethod definitions take the form:\n\n(methodname [args*] body)\n\nThe argument and return types can be hinted on the arg and\nmethodname symbols. If not supplied, they will be inferred, so type\nhints should be reserved for disambiguation.\n\nMethods should be supplied for all methods of the desired\nprotocol(s). You can also define overrides for\nmethods of Object. Note that a parameter must be supplied to\ncorrespond to the target object ('this' in JavaScript parlance). Note also\nthat recur calls to the method head should *not* pass the target object, it\nwill be supplied automatically and can not be substituted.\n\nIn the method bodies, the (unqualified) name can be used to name the\nclass (for calls to new, instance? etc).\n\nThe type will have implementations of several ClojureScript\nprotocol generated automatically: IMeta/IWithMeta (metadata support) and\nIMap, etc.\n\nIn addition, defrecord will define type-and-value-based =,\nand will define ClojureScript IHash and IEquiv.\n\nTwo constructors will be defined, one taking the designated fields\nfollowed by a metadata map (nil for none) and an extension field\nmap (nil for none), and one taking only the fields (using nil for\nmeta and extension fields). Note that the field names __meta\nand __extmap are currently reserved and should not be used when\ndefining your own records.\n\nGiven (defrecord TypeName ...), two factory functions will be\ndefined: ->TypeName, taking positional parameters for the fields,\nand map->TypeName, taking a map of keywords to field values."},
           "cljs.core/eduction" {:ns "cljs.core",
                                 :name "eduction",
                                 :signature ["[xform* coll]"],
                                 :history [["+" "0.0-2371"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/eduction",
                                 :source {:code "(defn eduction\n  [& xforms]\n  (Eduction. (apply comp (butlast xforms)) (last xforms)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [9283 9290]},
                                 :full-name "cljs.core/eduction",
                                 :clj-symbol "clojure.core/eduction",
                                 :docstring "Returns a reducible/iterable application of the transducers\nto the items in coll. Transducers are applied in order as if\ncombined with comp. Note that these applications will be\nperformed every time reduce/iterator is called."},
           "cljs.core/ex-info" {:ns "cljs.core",
                                :name "ex-info",
                                :signature ["[msg data]"
                                            "[msg data cause]"],
                                :history [["+" "0.0-1576"]],
                                :type "function",
                                :full-name-encode "cljs.core/ex-info",
                                :source {:code "(defn ex-info\n  ([msg data] (ex-info msg data nil))\n  ([msg data cause]\n    (ExceptionInfo. msg data cause)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [9921 9926]},
                                :full-name "cljs.core/ex-info",
                                :clj-symbol "clojure.core/ex-info",
                                :docstring "Create an instance of ExceptionInfo, an Error type that carries a\nmap of additional data."},
           "cljs.js/empty-state" {:ns "cljs.js",
                                  :name "empty-state",
                                  :signature ["[]" "[init]"],
                                  :history [["+" "1.7.10"]],
                                  :type "function",
                                  :full-name-encode "cljs.js/empty-state",
                                  :source {:code "(defn empty-state\n  ([]\n   (doto (env/default-compiler-env)\n     (swap!\n       (fn [state]\n         (-> state\n           (assoc-in [::ana/namespaces 'cljs.core] (dump-core)))))))\n  ([init]\n   (doto (empty-state) (swap! init))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/js.cljs",
                                           :lines [103 113]},
                                  :full-name "cljs.js/empty-state",
                                  :docstring "Construct an empty compiler state. Required to invoke analyze, compile,\neval and eval-str."},
           "cljs.repl.browser/repl-env" {:ns "cljs.repl.browser",
                                         :name "repl-env",
                                         :signature ["[& {:as opts}]"],
                                         :history [["+" "0.0-927"]],
                                         :type "function",
                                         :full-name-encode "cljs.repl.browser/repl-env",
                                         :source {:code "(defn repl-env\n  [& {:as opts}]\n  (repl-env* opts))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.7.228",
                                                  :filename "src/main/clojure/cljs/repl/browser.clj",
                                                  :lines [309 328]},
                                         :full-name "cljs.repl.browser/repl-env",
                                         :docstring "Create a browser-connected REPL environment.\n\nOptions:\n\nport:           The port on which the REPL server will run. Defaults to 9000.\nworking-dir:    The directory where the compiled REPL client JavaScript will\n                be stored. Defaults to \".repl\" with a ClojureScript version\n                suffix, eg. \".repl-0.0-2138\".\nserve-static:   Should the REPL server attempt to serve static content?\n                Defaults to true.\nstatic-dir:     List of directories to search for static content. Defaults to\n                [\".\" \"out/\"].\noptimizations:  The level of optimization to use when compiling the client\n                end of the REPL. Defaults to :simple.\nsrc:            The source directory containing user-defined cljs files. Used to\n                support reflection. Defaults to \"src/\".\n"},
           "cljs.repl.nashorn/bootstrap-repl" {:ns "cljs.repl.nashorn",
                                               :name "bootstrap-repl",
                                               :type "function",
                                               :signature ["[engine output-dir opts]"],
                                               :source {:code "    (defn bootstrap-repl [engine output-dir opts]\n      (env/ensure\n        (let [deps-file \".nashorn_repl_deps.js\"\n              core (io/resource \"cljs/core.cljs\")\n              core-js (closure/compile core\n                        (assoc opts\n                          :output-file (closure/src-file->target-file core)))\n              deps (closure/add-dependencies opts core-js)]\n          ;; output unoptimized code and the deps file\n          ;; for all compiled namespaces\n          (apply closure/output-unoptimized\n            (assoc opts :output-to (.getPath (io/file output-dir deps-file)))\n            deps)\n          ;; load the deps file so we can goog.require cljs.core etc.\n          (load-js-file engine deps-file))))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.7.228",
                                                        :filename "src/main/clojure/cljs/repl/nashorn.clj",
                                                        :lines [80 94]},
                                               :full-name "cljs.repl.nashorn/bootstrap-repl",
                                               :full-name-encode "cljs.repl.nashorn/bootstrap-repl",
                                               :history [["+"
                                                          "0.0-2814"]]},
           "cljs.core/butlast" {:description "Returns a sequence of all but the last item in `s`.\n\n`butlast` runs in linear time.",
                                :ns "cljs.core",
                                :name "butlast",
                                :signature ["[s]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/first"
                                          "cljs.core/rest"
                                          "cljs.core/last"
                                          "cljs.core/next"
                                          "cljs.core/drop-last"
                                          "cljs.core/take-last"],
                                :full-name-encode "cljs.core/butlast",
                                :source {:code "(defn butlast\n  [s]\n  (loop [ret [] s s]\n    (if (next s)\n      (recur (conj ret (first s)) (next s))\n      (seq ret))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [8289 8295]},
                                :examples [{:id "7a4676",
                                            :content "```clj\n(butlast [1 2 3])\n;;=> (1 2)\n\n(butlast [1 2])\n;;=> (1)\n\n(butlast [1])\n;;=> nil\n\n(butlast [])\n;;=> nil\n```"}],
                                :full-name "cljs.core/butlast",
                                :clj-symbol "clojure.core/butlast",
                                :docstring "Return a seq of all but the last item in coll, in linear time"},
           "cljs.core/array-iter" {:ns "cljs.core",
                                   :name "array-iter",
                                   :type "function",
                                   :signature ["[x]"],
                                   :source {:code "(defn array-iter [x]\n  (ArrayIter. x 0))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [3549 3550]},
                                   :full-name "cljs.core/array-iter",
                                   :full-name-encode "cljs.core/array-iter",
                                   :history [["+" "0.0-2301"]]},
           "cljs.core/print-str" {:ns "cljs.core",
                                  :name "print-str",
                                  :signature ["[& objs]"],
                                  :history [["+" "0.0-1011"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/print-str",
                                  :source {:code "(defn print-str\n  [& objs]\n  (pr-str-with-opts objs (assoc (pr-opts) :readably false)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [8956 8959]},
                                  :full-name "cljs.core/print-str",
                                  :clj-symbol "clojure.core/print-str",
                                  :docstring "print to a string, returning it"},
           "cljs.repl.rhino/load-file" {:ns "cljs.repl.rhino",
                                        :name "load-file",
                                        :signature ["[repl-env opts src]"],
                                        :history [["+" "0.0-2985"]],
                                        :type "function",
                                        :full-name-encode "cljs.repl.rhino/load-file",
                                        :source {:code "(defn load-file\n  [repl-env opts src]\n  (let [goog-path (io/file (util/output-directory opts) \"goog\" src)]\n    (rhino-eval repl-env (.getPath goog-path) 1 (io/reader goog-path))))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/clojure/cljs/repl/rhino.clj",
                                                 :lines [89 95]},
                                        :full-name "cljs.repl.rhino/load-file",
                                        :docstring "Load a JavaScript. This is needed to load JavaScript files before the Rhino\nenvironment is bootstrapped. After bootstrapping load-javascript will be\nused."},
           "cljs.core/hash" {:ns "cljs.core",
                             :name "hash",
                             :signature ["[o]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/hash",
                             :source {:code "(defn hash\n  [o]\n  (cond\n    (implements? IHash o)\n    (-hash ^not-native o)\n\n    (number? o)\n    (js-mod (Math/floor o) 2147483647)\n\n    (true? o) 1\n\n    (false? o) 0\n\n    (string? o)\n    (m3-hash-int (hash-string o))\n\n    (instance? js/Date o)\n    (.valueOf o)\n\n    (nil? o) 0\n\n    :else\n    (-hash o)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [871 895]},
                             :full-name "cljs.core/hash",
                             :clj-symbol "clojure.core/hash",
                             :docstring "Returns the hash code of its argument. Note this is the hash code\nconsistent with =."},
           "cljs.core/bit-set" {:description "Set bit at index `n`.  Same as `x | (1 << y)` in JavaScript.",
                                :ns "cljs.core",
                                :name "bit-set",
                                :signature ["[x n]"],
                                :history [["+" "0.0-927"]],
                                :type "function/macro",
                                :related ["cljs.core/bit-clear"],
                                :full-name-encode "cljs.core/bit-set",
                                :source {:code "(defn bit-set\n  [x n]\n  (cljs.core/bit-set x n))",
                                         :title "Function code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [2546 2549]},
                                :extra-sources [{:code "(core/defmacro ^::ana/numeric bit-set [x n]\n  (core/list 'js* \"(~{} | (1 << ~{}))\" x n))",
                                                 :title "Macro code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/clojure/cljs/core.cljc",
                                                 :lines [1140 1141]}],
                                :examples [{:id "6a8a49",
                                            :content "Bits can be entered using radix notation:\n\n```clj\n(bit-set 2r1100 1)\n;;=> 14\n;; 14 = 2r1110\n```\n\nSame number in decimal:\n\n```clj\n(bit-set 12 1)\n;;=> 14\n```"}],
                                :full-name "cljs.core/bit-set",
                                :clj-symbol "clojure.core/bit-set",
                                :docstring "Set bit at index n"},
           "cljs.core/clj->js" {:description "Recursively transforms ClojureScript values to JavaScript.\n\n| ClojureScript |        | JavaScript |         |\n|---------------|--------|------------|---------|\n| Set           | `#{}`  | Array      | `[]`    |\n| Vector        | `[]`   | Array      | `[]`    |\n| List          | `()`   | Array      | `[]`    |\n| Keyword       | `:foo` | String     | `\"foo\"` |\n| Symbol        | `bar`  | String     | `\"bar\"` |\n| Map           | `{}`   | Object     | `{}`    |",
                                :ns "cljs.core",
                                :name "clj->js",
                                :signature ["[x]"],
                                :history [["+" "0.0-1552"]],
                                :type "function",
                                :related ["cljs.core/js->clj"],
                                :full-name-encode "cljs.core/clj-GTjs",
                                :source {:code "(defn clj->js\n   [x]\n   (when-not (nil? x)\n     (if (satisfies? IEncodeJS x)\n       (-clj->js x)\n       (cond\n         (keyword? x) (name x)\n         (symbol? x) (str x)\n         (map? x) (let [m (js-obj)]\n                    (doseq [[k v] x]\n                      (aset m (key->js k) (clj->js v)))\n                    m)\n         (coll? x) (let [arr (array)]\n                     (doseq [x (map clj->js x)]\n                       (.push arr x))\n                     arr)\n         :else x))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [9316 9335]},
                                :examples [{:id "2b1057",
                                            :content "```clj\n(clj->js {:foo 1 :bar 2})\n;;=> #js {:foo 1, :bar 2}\n\n(clj->js [:foo \"bar\" 'baz])\n;;=> #js [\"foo\" \"bar\" \"baz\"]\n\n(clj->js [1 {:foo \"bar\"} 4])\n;;=> #js [1 #js {:foo \"bar\"} 4]\n```"}],
                                :full-name "cljs.core/clj->js",
                                :docstring "Recursively transforms ClojureScript values to JavaScript.\nsets/vectors/lists become Arrays, Keywords and Symbol become Strings,\nMaps become Objects. Arbitrary keys are encoded to by key->js."},
           "cljs.js/load-analysis-cache!" {:ns "cljs.js",
                                           :name "load-analysis-cache!",
                                           :type "function",
                                           :signature ["[state ns cache]"],
                                           :source {:code "(defn load-analysis-cache! [state ns cache]\n  (swap! state assoc-in [::ana/namespaces ns] cache))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.7.228",
                                                    :filename "src/main/cljs/cljs/js.cljs",
                                                    :lines [115 116]},
                                           :full-name "cljs.js/load-analysis-cache!",
                                           :full-name-encode "cljs.js/load-analysis-cacheBANG",
                                           :history [["+" "1.7.10"]]},
           "cljs.core/concat" {:description "Returns a lazy sequence representing the concatenation of the elements in the\nsupplied collections.",
                               :ns "cljs.core",
                               :name "concat",
                               :signature ["[]"
                                           "[x]"
                                           "[x y]"
                                           "[x y & zs]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/conj"
                                         "cljs.core/into"],
                               :full-name-encode "cljs.core/concat",
                               :source {:code "(defn concat\n  ([] (lazy-seq nil))\n  ([x] (lazy-seq x))\n  ([x y]\n    (lazy-seq\n      (let [s (seq x)]\n        (if s\n          (if (chunked-seq? s)\n            (chunk-cons (chunk-first s) (concat (chunk-rest s) y))\n            (cons (first s) (concat (rest s) y)))\n          y))))\n  ([x y & zs]\n     (let [cat (fn cat [xys zs]\n                 (lazy-seq\n                   (let [xys (seq xys)]\n                     (if xys\n                       (if (chunked-seq? xys)\n                         (chunk-cons (chunk-first xys)\n                                     (cat (chunk-rest xys) zs))\n                         (cons (first xys) (cat (rest xys) zs)))\n                       (when zs\n                         (cat (first zs) (next zs)))))))]\n       (cat (concat x y) zs))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [3337 3360]},
                               :examples [{:id "dcc019",
                                           :content "```clj\n(concat (list 1 2 3) (list 4 5 6))\n;;=> (1 2 3 4 5 6)\n\n(concat [1 2 3] (list 4 5 6))\n;; => (1 2 3 4 5 6)\n\n(concat [1] [2] [3])\n;; => (1 2 3)\n```"}],
                               :full-name "cljs.core/concat",
                               :clj-symbol "clojure.core/concat",
                               :docstring "Returns a lazy seq representing the concatenation of the elements in the supplied colls."},
           "cljs.test/IAsyncTest" {:ns "cljs.test",
                                   :name "IAsyncTest",
                                   :type "protocol",
                                   :full-name-encode "cljs.test/IAsyncTest",
                                   :source {:code "(defprotocol IAsyncTest\n  \"Marker protocol denoting CPS function to begin asynchronous\n  testing.\")",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/cljs/test.cljs",
                                            :lines [417 419]},
                                   :full-name "cljs.test/IAsyncTest",
                                   :docstring "Marker protocol denoting CPS function to begin asynchronous\n  testing.",
                                   :history [["+" "0.0-2814"]]},
           "cljs.core/conj" {:description "conj(oin)\n\nReturns a new collection with the `x`s \"added\" to `coll`.\n\nThe \"addition\" may happen at different \"places\" depending on the collection\ntype.\n\n`(conj nil item)` returns `(item)`.",
                             :ns "cljs.core",
                             :name "conj",
                             :signature ["[]"
                                         "[coll]"
                                         "[coll x]"
                                         "[coll x & xs]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/cons"
                                       "cljs.core/into"
                                       "cljs.core/peek"
                                       "cljs.core/pop"],
                             :full-name-encode "cljs.core/conj",
                             :source {:code "(defn conj\n  ([] [])\n  ([coll] coll)\n  ([coll x]\n    (if-not (nil? coll)\n      (-conj coll x)\n      (list x)))\n  ([coll x & xs]\n    (if xs\n      (recur (conj coll x) (first xs) (next xs))\n      (conj coll x))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [1567 1580]},
                             :examples [{:id "8c2a84",
                                         :content "Append a vector:\n\n```clj\n(conj [1 2 3] 4)\n;;=> [1 2 3 4]\n```\n\nPrepend a list:\n\n```clj\n(conj (list 1 2 3) 0)\n;;=> (0 1 2 3)\n```\n\nPrepend a sequence:\n\n```clj\n(def x (range 1 4))\n;;=> (1 2 3)\n\n(conj x 0)\n;;=> (0 1 2 3)\n```\n\nAdd to set:\n\n```clj\n(conj #{\"a\" \"b\" \"c\"} \"d\")\n;;=> #{\"a\" \"b\" \"c\" \"d\"}\n```"}],
                             :known-as "conjoin",
                             :full-name "cljs.core/conj",
                             :clj-symbol "clojure.core/conj",
                             :docstring "conj[oin]. Returns a new collection with the xs\n'added'. (conj nil item) returns (item).  The 'addition' may\nhappen at different 'places' depending on the concrete type."},
           "cljs.core/unchecked-short" {:return-type number,
                                        :ns "cljs.core",
                                        :name "unchecked-short",
                                        :signature ["[x]"],
                                        :history [["+" "0.0-1798"]],
                                        :type "function/macro",
                                        :full-name-encode "cljs.core/unchecked-short",
                                        :source {:code "(defn ^number unchecked-short [x] x)",
                                                 :title "Function code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/cljs/cljs/core.cljs",
                                                 :lines [2372]},
                                        :extra-sources [{:code "(core/defmacro unchecked-short [x] x)",
                                                         :title "Macro code",
                                                         :repo "clojurescript",
                                                         :tag "r1.7.228",
                                                         :filename "src/main/clojure/cljs/core.cljc",
                                                         :lines [970]}],
                                        :full-name "cljs.core/unchecked-short",
                                        :clj-symbol "clojure.core/unchecked-short"},
           "clojure.set/difference" {:description "Return a set that is the first set without elements of the remaining sets.",
                                     :ns "clojure.set",
                                     :name "difference",
                                     :signature ["[s1]"
                                                 "[s1 s2]"
                                                 "[s1 s2 & sets]"],
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :related ["clojure.set/union"
                                               "clojure.set/intersection"
                                               "clojure.set/superset?"
                                               "clojure.set/project"],
                                     :full-name-encode "clojure.set/difference",
                                     :source {:code "(defn difference\n  ([s1] s1)\n  ([s1 s2] \n     (if (< (count s1) (count s2))\n       (reduce (fn [result item] \n                   (if (contains? s2 item) \n                     (disj result item) \n                     result))\n               s1 s1)\n       (reduce disj s1 s2)))\n  ([s1 s2 & sets] \n     (reduce difference s1 (conj sets s2))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/cljs/clojure/set.cljs",
                                              :lines [46 58]},
                                     :full-name "clojure.set/difference",
                                     :clj-symbol "clojure.set/difference",
                                     :docstring "Return a set that is the first set without elements of the remaining sets"},
           "cljs.core/byte" {:return-type number,
                             :ns "cljs.core",
                             :name "byte",
                             :signature ["[x]"],
                             :history [["+" "0.0-1798"]],
                             :type "function/macro",
                             :full-name-encode "cljs.core/byte",
                             :source {:code "(defn ^number byte [x] x)",
                                      :title "Function code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [2356]},
                             :extra-sources [{:code "(core/defmacro byte [x] x)",
                                              :title "Macro code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/clojure/cljs/core.cljc",
                                              :lines [963]}],
                             :full-name "cljs.core/byte",
                             :clj-symbol "clojure.core/byte"},
           "cljs.core/when-first" {:description "With `bindings` as `x`, `xs`, roughly the same as `(when (seq xs) (let [x (first\nxs)] body))` but `xs` is evaluated only once.",
                                   :ns "cljs.core",
                                   :name "when-first",
                                   :signature ["[bindings & body]"],
                                   :history [["+" "0.0-927"]],
                                   :type "macro",
                                   :full-name-encode "cljs.core/when-first",
                                   :source {:code "(defmacro when-first\n  [bindings & body]\n  (assert-args\n     (vector? bindings) \"a vector for its binding\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n  (let [[x xs] bindings]\n    `(when-let [xs# (seq ~xs)]\n       (let [~x (first xs#)]\n           ~@body))))",
                                            :title "Source code",
                                            :repo "clojure",
                                            :tag "clojure-1.7.0",
                                            :filename "src/clj/clojure/core.clj",
                                            :lines [4420 4432]},
                                   :full-name "cljs.core/when-first",
                                   :clj-symbol "clojure.core/when-first",
                                   :docstring "bindings => x xs\n\nRoughly the same as (when (seq xs) (let [x (first xs)] body)) but xs is evaluated only once"},
           "cljs.reader/*tag-table*" {:ns "cljs.reader",
                                      :name "*tag-table*",
                                      :type "dynamic var",
                                      :source {:code "(def ^:dynamic *tag-table*\n  (atom {\"inst\"  read-date\n         \"uuid\"  read-uuid\n         \"queue\" read-queue\n         \"js\"    read-js}))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/cljs/cljs/reader.cljs",
                                               :lines [585 589]},
                                      :full-name "cljs.reader/*tag-table*",
                                      :full-name-encode "cljs.reader/STARtag-tableSTAR",
                                      :history [["+" "0.0-1236"]]},
           "cljs.core/distinct?" {:description "Returns true if no two of the arguments are `=`",
                                  :return-type boolean,
                                  :ns "cljs.core",
                                  :name "distinct?",
                                  :signature ["[x]"
                                              "[x y]"
                                              "[x y & more]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/distinct"],
                                  :full-name-encode "cljs.core/distinctQMARK",
                                  :source {:code "(defn ^boolean distinct?\n  ([x] true)\n  ([x y] (not (= x y)))\n  ([x y & more]\n     (if (not (= x y))\n     (loop [s #{x y} xs more]\n       (let [x (first xs)\n             etc (next xs)]\n         (if xs\n           (if (contains? s x)\n             false\n             (recur (conj s x) etc))\n           true)))\n     false)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [2047 2061]},
                                  :examples [{:id "b32799",
                                              :content "```clj\n(distinct? 1)\n;;=> true\n\n(distinct? 1 2)\n;;=> true\n\n(distinct? 1 1)\n;;=> false\n\n(distinct? 1 2 3)\n;;=> true\n\n(distinct? 1 2 1)\n;;=> false\n```\n\nApply it a collection:\n\n```clj\n(apply distinct? [1 2 3])\n;;=> true\n\n(apply distinct? [1 2 1])\n;;=> false\n```"}],
                                  :full-name "cljs.core/distinct?",
                                  :clj-symbol "clojure.core/distinct?",
                                  :docstring "Returns true if no two of the arguments are ="},
           "cljs.pprint/pprint" {:ns "cljs.pprint",
                                 :name "pprint",
                                 :signature ["[object]"
                                             "[object writer]"],
                                 :history [["+" "0.0-3255"]],
                                 :type "function",
                                 :full-name-encode "cljs.pprint/pprint",
                                 :source {:code "(defn pprint\n  ([object]\n   (let [sb (StringBuffer.)]\n     (binding [*out* (StringBufferWriter. sb)]\n       (pprint object *out*)\n       (*print-fn* (str sb)))))\n  ([object writer]\n   (with-pretty-writer writer\n                       (binding [*print-pretty* true]\n                         (write-out object))\n                       (if (not (= 0 (get-column *out*)))\n                         (-write *out* \\newline)))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/pprint.cljs",
                                          :lines [811 822]},
                                 :full-name "cljs.pprint/pprint",
                                 :clj-symbol "clojure.pprint/pprint"},
           "clojure.core.reducers/filter" {:ns "clojure.core.reducers",
                                           :name "filter",
                                           :signature ["[pred]"
                                                       "[pred coll]"],
                                           :history [["+" "0.0-1236"]],
                                           :type "function",
                                           :full-name-encode "clojure.core.reducers/filter",
                                           :source {:code "(defcurried filter\n  \"Retains values in the reduction of coll for which (pred val)\n  returns logical true. Foldable.\"\n  {}\n  [pred coll]\n  (folder coll\n   (fn [f1]\n     (rfn [f1 k]\n          ([ret k v]\n             (if (pred k v)\n               (f1 ret k v)\n               ret))))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.7.228",
                                                    :filename "src/main/cljs/clojure/core/reducers.cljs",
                                                    :lines [117 128]},
                                           :full-name "clojure.core.reducers/filter",
                                           :clj-symbol "clojure.core.reducers/filter",
                                           :docstring "Retains values in the reduction of coll for which (pred val)\n  returns logical true. Foldable."},
           "cljs.core/INamed" {:ns "cljs.core",
                               :name "INamed",
                               :history [["+" "0.0-1798"]],
                               :type "protocol",
                               :full-name-encode "cljs.core/INamed",
                               :source {:code "(defprotocol INamed\n  \"Protocol for adding a name.\"\n  (^string -name [x]\n    \"Returns the name String of x.\")\n  (^string -namespace [x]\n    \"Returns the namespace String of x.\"))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [725 730]},
                               :methods [{:name "-name",
                                          :signature ["[x]"],
                                          :docstring "Returns the name String of x."}
                                         {:name "-namespace",
                                          :signature ["[x]"],
                                          :docstring "Returns the namespace String of x."}],
                               :full-name "cljs.core/INamed",
                               :clj-symbol "clojure.lang/Named",
                               :docstring "Protocol for adding a name."},
           "cljs.repl/merge-spec" {:ns "cljs.repl",
                                   :name "merge-spec",
                                   :signature ["[[lib & {:as aindex}] [_ & {:as bindex}]]"],
                                   :history [["+" "0.0-2629"]
                                             ["-" "0.0-2655"]],
                                   :type "function",
                                   :full-name-encode "cljs.repl/merge-spec",
                                   :source {:code "(defn merge-spec [[lib & {:as aindex}] [_ & {:as bindex}]]\n  (let [merged-map\n        (merge-with\n          (fn [x y]\n            (if (vector? x)\n              (vec (distinct (into x y)))\n              y))\n          aindex bindex)]\n    (apply vector lib\n      (apply concat\n        (sort\n          (fn [[sa] [sb]]\n            (compare (spec-sort sa) (spec-sort sb)))\n          merged-map)))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2644",
                                            :filename "src/clj/cljs/repl.clj",
                                            :lines [196 209]},
                                   :full-name "cljs.repl/merge-spec",
                                   :removed {:in "0.0-2655",
                                             :last-seen "0.0-2644"}},
           "syntax/set" {:description "Create a literal set.  Values must be unique.",
                         :ns "syntax",
                         :name "set",
                         :history [["+" "0.0-927"]],
                         :type "syntax",
                         :related ["cljs.core/hash-set"
                                   "cljs.core/sorted-set"
                                   "cljs.core/sorted-set-by"],
                         :full-name-encode "syntax/set",
                         :extra-sources ({:code "(defn- read-set\n  [rdr _ opts pending-forms]\n  (let [[start-line start-column] (starting-line-col-info rdr)\n        ;; subtract 1 from start-column so it includes the # in the leading #{\n        start-column (if start-column (int (dec start-column)))\n        the-set (PersistentHashSet/createWithCheck (read-delimited \\} rdr opts pending-forms))\n        [end-line end-column] (ending-line-col-info rdr)]\n    (with-meta the-set\n      (when start-line\n        (merge\n         (when-let [file (get-file-name rdr)]\n           {:file file})\n         {:line start-line\n          :column start-column\n          :end-line end-line\n          :end-column end-column})))))",
                                          :title "Reader code",
                                          :repo "tools.reader",
                                          :tag "tools.reader-1.0.0-alpha1",
                                          :filename "src/main/clojure/clojure/tools/reader.clj",
                                          :lines [387 402]}
                                         {:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    \\? read-cond\n    nil))",
                                          :title "Reader table",
                                          :repo "tools.reader",
                                          :tag "tools.reader-1.0.0-alpha1",
                                          :filename "src/main/clojure/clojure/tools/reader.clj",
                                          :lines [764 776]}),
                         :usage ["#{...}"],
                         :examples [{:id "f11ab6",
                                     :content "```clj\n#{1 2 3}\n;;=> #{1 2 3}\n```\n\nDuplicate values will cause an error:\n\n```clj\n#{1 1 2 3}\n;; Error: Duplicate key: 1\n```"}],
                         :edn-doc "https://github.com/edn-format/edn#sets",
                         :full-name "syntax/set",
                         :display "#{} set",
                         :clj-doc "http://clojure.org/reader#toc1"},
           "cljs.core/add-to-string-hash-cache" {:ns "cljs.core",
                                                 :name "add-to-string-hash-cache",
                                                 :type "function",
                                                 :signature ["[k]"],
                                                 :source {:code "(defn add-to-string-hash-cache [k]\n  (let [h (hash-string* k)]\n    (aset string-hash-cache k h)\n    (set! string-hash-cache-count (inc string-hash-cache-count))\n    h))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r1.7.228",
                                                          :filename "src/main/cljs/cljs/core.cljs",
                                                          :lines [856
                                                                  860]},
                                                 :full-name "cljs.core/add-to-string-hash-cache",
                                                 :full-name-encode "cljs.core/add-to-string-hash-cache",
                                                 :history [["+"
                                                            "0.0-1424"]]},
           "cljs.repl.rhino/repl-env" {:ns "cljs.repl.rhino",
                                       :name "repl-env",
                                       :signature ["[& {:as opts}]"],
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "cljs.repl.rhino/repl-env",
                                       :source {:code "(defn repl-env\n  [& {:as opts}]\n  (repl-env* opts))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/clojure/cljs/repl/rhino.clj",
                                                :lines [212 216]},
                                       :full-name "cljs.repl.rhino/repl-env",
                                       :docstring "Returns a fresh JS environment, suitable for passing to repl.\nHang on to return for use across repl calls."},
           "cljs.core/HashCollisionNode" {:ns "cljs.core",
                                          :name "HashCollisionNode",
                                          :signature ["[edit collision-hash cnt arr]"],
                                          :history [["+" "0.0-1211"]],
                                          :type "type",
                                          :full-name-encode "cljs.core/HashCollisionNode",
                                          :source {:code "(deftype HashCollisionNode [edit\n                            ^:mutable collision-hash\n                            ^:mutable cnt\n                            ^:mutable arr]\n  Object\n  (inode-assoc [inode shift hash key val added-leaf?]\n    (if (== hash collision-hash)\n      (let [idx (hash-collision-node-find-index arr cnt key)]\n        (if (== idx -1)\n          (let [len     (* 2 cnt)\n                new-arr (make-array (+ len 2))]\n            (array-copy arr 0 new-arr 0 len)\n            (aset new-arr len key)\n            (aset new-arr (inc len) val)\n            (set! (.-val added-leaf?) true)\n            (HashCollisionNode. nil collision-hash (inc cnt) new-arr))\n          (if (= (aget arr idx) val)\n            inode\n            (HashCollisionNode. nil collision-hash cnt (clone-and-set arr (inc idx) val)))))\n      (.inode-assoc (BitmapIndexedNode. nil (bitpos collision-hash shift) (array nil inode))\n                    shift hash key val added-leaf?)))\n\n  (inode-without [inode shift hash key]\n    (let [idx (hash-collision-node-find-index arr cnt key)]\n      (cond (== idx -1) inode\n            (== cnt 1)  nil\n            :else (HashCollisionNode. nil collision-hash (dec cnt) (remove-pair arr (quot idx 2))))))\n\n  (inode-lookup [inode shift hash key not-found]\n    (let [idx (hash-collision-node-find-index arr cnt key)]\n      (cond (< idx 0)              not-found\n            (key-test key (aget arr idx)) (aget arr (inc idx))\n            :else                  not-found)))\n\n  (inode-find [inode shift hash key not-found]\n    (let [idx (hash-collision-node-find-index arr cnt key)]\n      (cond (< idx 0)              not-found\n            (key-test key (aget arr idx)) [(aget arr idx) (aget arr (inc idx))]\n            :else                  not-found)))\n\n  (inode-seq [inode]\n    (create-inode-seq arr))\n\n  (ensure-editable [inode e]\n    (if (identical? e edit)\n      inode\n      (let [new-arr (make-array (* 2 (inc cnt)))]\n        (array-copy arr 0 new-arr 0 (* 2 cnt))\n        (HashCollisionNode. e collision-hash cnt new-arr))))\n\n  (ensure-editable-array [inode e count array]\n    (if (identical? e edit)\n      (do (set! arr array)\n          (set! cnt count)\n          inode)\n      (HashCollisionNode. edit collision-hash count array)))\n\n  (inode-assoc! [inode edit shift hash key val added-leaf?]\n    (if (== hash collision-hash)\n      (let [idx (hash-collision-node-find-index arr cnt key)]\n        (if (== idx -1)\n          (if (> (alength arr) (* 2 cnt))\n            (let [editable (edit-and-set inode edit (* 2 cnt) key (inc (* 2 cnt)) val)]\n              (set! (.-val added-leaf?) true)\n              (set! (.-cnt editable) (inc (.-cnt editable)))\n              editable)\n            (let [len     (alength arr)\n                  new-arr (make-array (+ len 2))]\n              (array-copy arr 0 new-arr 0 len)\n              (aset new-arr len key)\n              (aset new-arr (inc len) val)\n              (set! (.-val added-leaf?) true)\n              (.ensure-editable-array inode edit (inc cnt) new-arr)))\n          (if (identical? (aget arr (inc idx)) val)\n            inode\n            (edit-and-set inode edit (inc idx) val))))\n      (.inode-assoc! (BitmapIndexedNode. edit (bitpos collision-hash shift) (array nil inode nil nil))\n                     edit shift hash key val added-leaf?)))\n\n  (inode-without! [inode edit shift hash key removed-leaf?]\n    (let [idx (hash-collision-node-find-index arr cnt key)]\n      (if (== idx -1)\n        inode\n        (do (aset removed-leaf? 0 true)\n            (if (== cnt 1)\n              nil\n              (let [editable (.ensure-editable inode edit)\n                    earr     (.-arr editable)]\n                (aset earr idx (aget earr (- (* 2 cnt) 2)))\n                (aset earr (inc idx) (aget earr (dec (* 2 cnt))))\n                (aset earr (dec (* 2 cnt)) nil)\n                (aset earr (- (* 2 cnt) 2) nil)\n                (set! (.-cnt editable) (dec (.-cnt editable)))\n                editable))))))\n\n  (kv-reduce [inode f init]\n    (inode-kv-reduce arr f init))\n\n  IIterable\n  (-iterator [coll]\n    (NodeIterator. arr 0 nil nil)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/cljs/cljs/core.cljs",
                                                   :lines [6557 6657]},
                                          :full-name "cljs.core/HashCollisionNode",
                                          :clj-symbol "clojure.lang/HashCollisionNode"},
           "cljs.core/m3-mix-K1" {:return-type number,
                                  :ns "cljs.core",
                                  :name "m3-mix-K1",
                                  :signature ["[k1]"],
                                  :history [["+" "0.0-2261"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/m3-mix-K1",
                                  :source {:code "(defn ^number m3-mix-K1 [k1]\n  (-> (int k1) (imul m3-C1) (int-rotate-left 15) (imul m3-C2)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [800 801]},
                                  :full-name "cljs.core/m3-mix-K1"},
           "cljs.core/object?" {:description "Returns true if `x` is a JavaScript object, false otherwise.",
                                :return-type boolean,
                                :ns "cljs.core",
                                :name "object?",
                                :signature ["[x]"],
                                :history [["+" "0.0-2120"]],
                                :type "function",
                                :related ["cljs.core/array?"],
                                :full-name-encode "cljs.core/objectQMARK",
                                :source {:code "(defn ^boolean object?\n  [x]\n  (if-not (nil? x)\n    (identical? (.-constructor x) js/Object)\n    false))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [215 220]},
                                :full-name "cljs.core/object?",
                                :docstring "Returns true if x's constructor is Object"},
           "cljs.core/pos?" {:description "Returns true if `n` is greater than 0, false otherwise.",
                             :return-type boolean,
                             :ns "cljs.core",
                             :name "pos?",
                             :signature ["[n]"],
                             :history [["+" "0.0-927"]],
                             :type "function/macro",
                             :related ["cljs.core/neg?"
                                       "cljs.core/zero?"],
                             :full-name-encode "cljs.core/posQMARK",
                             :source {:code "(defn ^boolean pos?\n  [n] (cljs.core/pos? n))",
                                      :title "Function code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [2592 2594]},
                             :extra-sources [{:code "(core/defmacro ^::ana/numeric pos? [x]\n  `(> ~x 0))",
                                              :title "Macro code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/clojure/cljs/core.cljc",
                                              :lines [1071 1072]}],
                             :full-name "cljs.core/pos?",
                             :clj-symbol "clojure.core/pos?",
                             :docstring "Returns true if num is greater than zero, else false"},
           "cljs.test/block" {:ns "cljs.test",
                              :name "block",
                              :signature ["[fns]"],
                              :history [["+" "0.0-2814"]],
                              :type "function",
                              :full-name-encode "cljs.test/block",
                              :source {:code "(defn block\n  [fns]\n  (some-> fns\n          (vary-meta assoc ::block? true)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/test.cljs",
                                       :lines [445 450]},
                              :full-name "cljs.test/block",
                              :docstring "Tag a seq of fns to be picked up by run-block as injected\ncontinuation.  See run-block."},
           "cljs.core/into-array" {:description "Returns a new JavaScript array from the elements of `aseq`.",
                                   :return-type array,
                                   :ns "cljs.core",
                                   :name "into-array",
                                   :signature ["[aseq]"],
                                   :history [["+" "0.0-1211"]],
                                   :type "function",
                                   :related ["cljs.core/to-array"
                                             "cljs.core/make-array"],
                                   :full-name-encode "cljs.core/into-array",
                                   :source {:code "(defn ^array into-array\n  ([aseq]\n     (into-array nil aseq))\n  ([type aseq]\n     (reduce (fn [a x] (.push a x) a) (array) aseq)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [408 414]},
                                   :full-name "cljs.core/into-array",
                                   :clj-symbol "clojure.core/into-array",
                                   :docstring "Returns an array with components set to the values in aseq. Optional type\nargument accepted for compatibility with Clojure."},
           "syntax/tagged-literal" {:description "A tagged literal is a way to tag another core syntax literal to represent a\nsingle, new literal.\n\n- `#foo []`\n- `#foo {}`\n- `#foo \"bar\"`\n- `#foo 123`\n- ...\n\nIf a [symbol][doc:syntax/symbol] is prefixed by `#`, that symbol is considered a\n__tag__ for the following form.  Together they represent a new value.  Real\nexamples:\n\n- `#js {:foo 1}`, map -> JavaScript object\n- `#inst \"2015-01-12\"` string -> Date\n\nIn these examples, the values `{:foo 1}` and `\"2015-01-12\"` are read normally,\nbut are further interpretted by their registered tag handlers to produce new\nvalues: a JavaScript object and Date, respectively.\n\nThese tagged literals are the \"extensible\" part of extensible data notation\n([edn]), with ClojureScript being a superset of edn.\n\n[edn]:https://github.com/edn-format/edn#tagged-elements\n\nClojureScript supports the following tagged literals:\n\n- [doc:syntax/inst-literal]\n- [doc:syntax/uuid-literal]\n- [doc:syntax/js-literal]\n- [doc:syntax/queue-literal]",
                                    :ns "syntax",
                                    :name "tagged-literal",
                                    :history [["+" "0.0-1211"]],
                                    :type "syntax",
                                    :related ["syntax/dispatch"],
                                    :full-name-encode "syntax/tagged-literal",
                                    :extra-sources [{:code "(defn- read-tagged [rdr initch opts pending-forms]\n  (let [tag (read* rdr true nil opts pending-forms)]\n    (if-not (symbol? tag)\n      (reader-error rdr \"Reader tag must be a symbol\"))\n    (if *suppress-read*\n      (tagged-literal tag (read* rdr true nil opts pending-forms))\n      (if-let [f (or (*data-readers* tag)\n                     (default-data-readers tag))]\n        (f (read* rdr true nil opts pending-forms))\n        (if (.contains (name tag) \".\")\n          (read-ctor rdr tag opts pending-forms)\n          (if-let [f *default-data-reader-fn*]\n            (f tag (read* rdr true nil opts pending-forms))\n            (reader-error rdr \"No reader function for tag \" (name tag))))))))",
                                                     :title "Reader code",
                                                     :repo "tools.reader",
                                                     :tag "tools.reader-1.0.0-alpha1",
                                                     :filename "src/main/clojure/clojure/tools/reader.clj",
                                                     :lines [811 824]}],
                                    :usage ["#foo ..."],
                                    :examples [{:id "e84f6a",
                                                :content "(Tagged literals are printed as themselves, just like core syntax literals.)\n\nliteral JavaScript object:\n\n```clj\n#js {:foo 1}\n;;=> #js {:foo 1}\n\n(def foo 1)\n#js {:foo foo}\n;;=> #js {:foo 1}\n```\n\nliteral queue:\n\n```clj\n#queue [1 2 3]\n;;=> #queue [1 2 3]\n\n(conj #queue [1 2 3] 4)\n;;=> #queue [1 2 3 4]\n```\n\nliteral instant of time (date):\n\n```clj\n#inst \"2014-10-13\"\n;;=> #inst \"2014-10-13T00:00:00.000-00:00\"\n```\n\nliteral UUID:\n\n```clj\n#uuid \"97bda55b-6175-4c39-9e04-7c0205c709dc\"\n;;=> #uuid \"97bda55b-6175-4c39-9e04-7c0205c709dc\"\n```"}],
                                    :edn-doc "https://github.com/edn-format/edn#tagged-elements",
                                    :full-name "syntax/tagged-literal",
                                    :display "# tagged literal",
                                    :clj-doc "http://clojure.org/reader#toc4"},
           "cljs.core/PersistentVector" {:ns "cljs.core",
                                         :name "PersistentVector",
                                         :signature ["[meta cnt shift root tail __hash]"],
                                         :history [["+" "0.0-1006"]],
                                         :type "type",
                                         :full-name-encode "cljs.core/PersistentVector",
                                         :source {:code "(deftype PersistentVector [meta cnt shift root tail ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  ICloneable\n  (-clone [_] (PersistentVector. meta cnt shift root tail __hash))\n\n  IWithMeta\n  (-with-meta [coll meta] (PersistentVector. meta cnt shift root tail __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IStack\n  (-peek [coll]\n    (when (> cnt 0)\n      (-nth coll (dec cnt))))\n  (-pop [coll]\n    (cond\n     (zero? cnt) (throw (js/Error. \"Can't pop empty vector\"))\n     (== 1 cnt) (-with-meta (.-EMPTY PersistentVector) meta)\n     (< 1 (- cnt (tail-off coll)))\n      (PersistentVector. meta (dec cnt) shift root (.slice tail 0 -1) nil)\n      :else (let [new-tail (unchecked-array-for coll (- cnt 2))\n                  nr (pop-tail coll shift root)\n                  new-root (if (nil? nr) (.-EMPTY-NODE PersistentVector) nr)\n                  cnt-1 (dec cnt)]\n              (if (and (< 5 shift) (nil? (pv-aget new-root 1)))\n                (PersistentVector. meta cnt-1 (- shift 5) (pv-aget new-root 0) new-tail nil)\n                (PersistentVector. meta cnt-1 shift new-root new-tail nil)))))\n\n  ICollection\n  (-conj [coll o]\n    (if (< (- cnt (tail-off coll)) 32)\n      (let [len (alength tail)\n            new-tail (make-array (inc len))]\n        (dotimes [i len]\n          (aset new-tail i (aget tail i)))\n        (aset new-tail len o)\n        (PersistentVector. meta (inc cnt) shift root new-tail nil))\n      (let [root-overflow? (> (bit-shift-right-zero-fill cnt 5) (bit-shift-left 1 shift))\n            new-shift (if root-overflow? (+ shift 5) shift)\n            new-root (if root-overflow?\n                       (let [n-r (pv-fresh-node nil)]\n                           (pv-aset n-r 0 root)\n                           (pv-aset n-r 1 (new-path nil shift (VectorNode. nil tail)))\n                           n-r)\n                       (push-tail coll shift root (VectorNode. nil tail)))]\n        (PersistentVector. meta (inc cnt) new-shift new-root (array o) nil))))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY PersistentVector) meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other]\n    (if (instance? PersistentVector other)\n      (if (== cnt (count other))\n        (let [me-iter  (-iterator coll)\n              you-iter (-iterator other)]\n          (loop []\n            (if (.hasNext me-iter)\n              (let [x (.next me-iter)\n                    y (.next you-iter)]\n                (if (= x y)\n                  (recur)\n                  false))\n              true)))\n        false)\n      (equiv-sequential coll other)))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (cond\n      (zero? cnt) nil\n      (<= cnt 32) (IndexedSeq. tail 0)\n      :else (chunked-seq coll (first-array-for-longvec coll) 0 0)))\n\n  ICounted\n  (-count [coll] cnt)\n\n  IIndexed\n  (-nth [coll n]\n    (aget (array-for coll n) (bit-and n 0x01f)))\n  (-nth [coll n not-found]\n    (if (and (<= 0 n) (< n cnt))\n      (aget (unchecked-array-for coll n) (bit-and n 0x01f))\n      not-found))\n\n  ILookup\n  (-lookup [coll k] (-lookup coll k nil))\n  (-lookup [coll k not-found] (if (number? k)\n                                (-nth coll k not-found)\n                                not-found))\n\n  IMapEntry\n  (-key [coll]\n    (-nth coll 0))\n  (-val [coll]\n    (-nth coll 1))\n\n  IAssociative\n  (-assoc [coll k v]\n    (if (number? k)\n      (-assoc-n coll k v)\n      (throw (js/Error. \"Vector's key for assoc must be a number.\"))))\n\n  IVector\n  (-assoc-n [coll n val]\n    (cond\n       (and (<= 0 n) (< n cnt))\n       (if (<= (tail-off coll) n)\n         (let [new-tail (aclone tail)]\n           (aset new-tail (bit-and n 0x01f) val)\n           (PersistentVector. meta cnt shift root new-tail nil))\n         (PersistentVector. meta cnt shift (do-assoc coll shift root n val) tail nil))\n       (== n cnt) (-conj coll val)\n       :else (throw (js/Error. (str \"Index \" n \" out of bounds  [0,\" cnt \"]\")))))\n\n  IReduce\n  (-reduce [v f]\n    (ci-reduce v f))\n  (-reduce [v f init]\n    (loop [i 0 init init]\n      (if (< i cnt)\n        (let [arr  (unchecked-array-for v i)\n              len  (alength arr)\n              init (loop [j 0 init init]\n                     (if (< j len)\n                       (let [init (f init (aget arr j))]\n                         (if (reduced? init)\n                           init\n                           (recur (inc j) init)))\n                       init))]\n          (if (reduced? init)\n            @init\n            (recur (+ i len) init)))\n        init)))\n\n  IKVReduce\n  (-kv-reduce [v f init]\n    (loop [i 0 init init]\n      (if (< i cnt)\n        (let [arr  (unchecked-array-for v i)\n              len  (alength arr)\n              init (loop [j 0 init init]\n                     (if (< j len)\n                       (let [init (f init (+ j i) (aget arr j))]\n                         (if (reduced? init)\n                           init\n                           (recur (inc j) init)))\n                       init))]\n          (if (reduced? init)\n            @init\n            (recur (+ i len) init)))\n        init)))\n\n  IFn\n  (-invoke [coll k]\n    (-nth coll k))\n  (-invoke [coll k not-found]\n    (-nth coll k not-found))\n\n  IEditableCollection\n  (-as-transient [coll]\n    (TransientVector. cnt shift (tv-editable-root root) (tv-editable-tail tail)))\n\n  IReversible\n  (-rseq [coll]\n    (if (pos? cnt)\n      (RSeq. coll (dec cnt) nil)))\n\n  IIterable\n  (-iterator [this]\n    (ranged-iterator this 0 cnt)))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.7.228",
                                                  :filename "src/main/cljs/cljs/core.cljs",
                                                  :lines [4741 4921]},
                                         :full-name "cljs.core/PersistentVector",
                                         :clj-symbol "clojure.lang/PersistentVector"},
           "cljs.core/IHash" {:ns "cljs.core",
                              :name "IHash",
                              :history [["+" "0.0-927"]],
                              :type "protocol",
                              :full-name-encode "cljs.core/IHash",
                              :source {:code "(defprotocol IHash\n  \"Protocol for adding hashing functionality to a type.\"\n  (-hash [o]\n    \"Returns the hash code of o.\"))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [595 598]},
                              :methods [{:name "-hash",
                                         :signature ["[o]"],
                                         :docstring "Returns the hash code of o."}],
                              :full-name "cljs.core/IHash",
                              :docstring "Protocol for adding hashing functionality to a type."},
           "cljs.repl.node/seq->js-array" {:ns "cljs.repl.node",
                                           :name "seq->js-array",
                                           :type "function",
                                           :signature ["[v]"],
                                           :source {:code "(defn seq->js-array [v]\n  (str \"[\" (apply str (interpose \", \" (map pr-str v))) \"]\"))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.7.228",
                                                    :filename "src/main/clojure/cljs/repl/node.clj",
                                                    :lines [75 76]},
                                           :full-name "cljs.repl.node/seq->js-array",
                                           :full-name-encode "cljs.repl.node/seq-GTjs-array",
                                           :history [["+" "0.0-2814"]]},
           "clojure.reflect/doc" {:ns "clojure.reflect",
                                  :name "doc",
                                  :signature ["[sym]"],
                                  :history [["+" "0.0-1503"]],
                                  :type "function",
                                  :full-name-encode "clojure.reflect/doc",
                                  :source {:code "(defn doc\n  [sym]\n  (meta sym print-doc))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/clojure/reflect.cljs",
                                           :lines [45 49]},
                                  :full-name "clojure.reflect/doc",
                                  :docstring "Queries the reflection api with a fully qualified symbol, then prints\ndocumentation information at the repl."},
           "cljs.core/is_proto_" {:ns "cljs.core",
                                  :name "is_proto_",
                                  :type "function",
                                  :signature ["[x]"],
                                  :source {:code "(defn is_proto_\n  [x]\n  (identical? (.-prototype (.-constructor x)) x))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [243 245]},
                                  :full-name "cljs.core/is_proto_",
                                  :full-name-encode "cljs.core/is_proto_",
                                  :history [["+" "0.0-927"]]},
           "cljs.core/shorts" {:ns "cljs.core",
                               :name "shorts",
                               :signature ["[x]"],
                               :history [["+" "0.0-1798"]],
                               :type "function",
                               :full-name-encode "cljs.core/shorts",
                               :source {:code "(defn shorts [x] x)",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [2480]},
                               :full-name "cljs.core/shorts",
                               :clj-symbol "clojure.core/shorts"},
           "cljs.core/TransientVector" {:ns "cljs.core",
                                        :name "TransientVector",
                                        :signature ["[cnt shift root tail]"],
                                        :history [["+" "0.0-1211"]],
                                        :type "type",
                                        :full-name-encode "cljs.core/TransientVector",
                                        :source {:code "(deftype TransientVector [^:mutable cnt\n                          ^:mutable shift\n                          ^:mutable root\n                          ^:mutable tail]\n  ITransientCollection\n  (-conj! [tcoll o]\n    (if ^boolean (.-edit root)\n      (if (< (- cnt (tail-off tcoll)) 32)\n        (do (aset tail (bit-and cnt 0x01f) o)\n            (set! cnt (inc cnt))\n            tcoll)\n        (let [tail-node (VectorNode. (.-edit root) tail)\n              new-tail  (make-array 32)]\n          (aset new-tail 0 o)\n          (set! tail new-tail)\n          (if (> (bit-shift-right-zero-fill cnt 5)\n                 (bit-shift-left 1 shift))\n            (let [new-root-array (make-array 32)\n                  new-shift      (+ shift 5)]\n              (aset new-root-array 0 root)\n              (aset new-root-array 1 (new-path (.-edit root) shift tail-node))\n              (set! root  (VectorNode. (.-edit root) new-root-array))\n              (set! shift new-shift)\n              (set! cnt   (inc cnt))\n              tcoll)\n            (let [new-root (tv-push-tail tcoll shift root tail-node)]\n              (set! root new-root)\n              (set! cnt  (inc cnt))\n              tcoll))))\n      (throw (js/Error. \"conj! after persistent!\"))))\n\n  (-persistent! [tcoll]\n    (if ^boolean (.-edit root)\n      (do (set! (.-edit root) nil)\n          (let [len (- cnt (tail-off tcoll))\n                trimmed-tail (make-array len)]\n            (array-copy tail 0 trimmed-tail 0 len)\n            (PersistentVector. nil cnt shift root trimmed-tail nil)))\n      (throw (js/Error. \"persistent! called twice\"))))\n\n  ITransientAssociative\n  (-assoc! [tcoll key val]\n    (if (number? key)\n      (-assoc-n! tcoll key val)\n      (throw (js/Error. \"TransientVector's key for assoc! must be a number.\"))))\n\n  ITransientVector\n  (-assoc-n! [tcoll n val]\n    (if ^boolean (.-edit root)\n      (cond\n        (and (<= 0 n) (< n cnt))\n        (if (<= (tail-off tcoll) n)\n          (do (aset tail (bit-and n 0x01f) val)\n              tcoll)\n          (let [new-root\n                ((fn go [level node]\n                   (let [node (tv-ensure-editable (.-edit root) node)]\n                     (if (zero? level)\n                       (do (pv-aset node (bit-and n 0x01f) val)\n                           node)\n                       (let [subidx (bit-and (bit-shift-right-zero-fill n level)\n                                             0x01f)]\n                         (pv-aset node subidx\n                                  (go (- level 5) (pv-aget node subidx)))\n                         node))))\n                 shift root)]\n            (set! root new-root)\n            tcoll))\n        (== n cnt) (-conj! tcoll val)\n        :else\n        (throw\n         (js/Error.\n          (str \"Index \" n \" out of bounds for TransientVector of length\" cnt))))\n      (throw (js/Error. \"assoc! after persistent!\"))))\n\n  (-pop! [tcoll]\n    (if ^boolean (.-edit root)\n      (cond\n        (zero? cnt) (throw (js/Error. \"Can't pop empty vector\"))\n        (== 1 cnt)                       (do (set! cnt 0) tcoll)\n        (pos? (bit-and (dec cnt) 0x01f)) (do (set! cnt (dec cnt)) tcoll)\n        :else\n        (let [new-tail (unchecked-editable-array-for tcoll (- cnt 2))\n              new-root (let [nr (tv-pop-tail tcoll shift root)]\n                         (if-not (nil? nr)\n                           nr\n                           (VectorNode. (.-edit root) (make-array 32))))]\n          (if (and (< 5 shift) (nil? (pv-aget new-root 1)))\n            (let [new-root (tv-ensure-editable (.-edit root) (pv-aget new-root 0))]\n              (set! root  new-root)\n              (set! shift (- shift 5))\n              (set! cnt   (dec cnt))\n              (set! tail  new-tail)\n              tcoll)\n            (do (set! root new-root)\n                (set! cnt  (dec cnt))\n                (set! tail new-tail)\n                tcoll))))\n      (throw (js/Error. \"pop! after persistent!\"))))\n\n  ICounted\n  (-count [coll]\n    (if ^boolean (.-edit root)\n      cnt\n      (throw (js/Error. \"count after persistent!\"))))\n\n  IIndexed\n  (-nth [coll n]\n    (if ^boolean (.-edit root)\n      (aget (array-for coll n) (bit-and n 0x01f))\n      (throw (js/Error. \"nth after persistent!\"))))\n\n  (-nth [coll n not-found]\n    (if (and (<= 0 n) (< n cnt))\n      (-nth coll n)\n      not-found))\n\n  ILookup\n  (-lookup [coll k] (-lookup coll k nil))\n\n  (-lookup [coll k not-found] (if (number? k)\n                                (-nth coll k not-found)\n                                not-found))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/cljs/cljs/core.cljs",
                                                 :lines [5230 5359]},
                                        :full-name "cljs.core/TransientVector",
                                        :clj-symbol "clojure.lang/TransientVector"},
           "cljs.core/keep-indexed" {:description "Returns a lazy sequence of the non-nil results of `(f index item)`. Note, this\nmeans false return values will be included.\n\n`f` must be free of side-effects.\n\nReturns a stateful transducer when no collection is provided.",
                                     :ns "cljs.core",
                                     :name "keep-indexed",
                                     :signature ["[f]" "[f coll]"],
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :related ["cljs.core/map-indexed"
                                               "cljs.core/keep"],
                                     :full-name-encode "cljs.core/keep-indexed",
                                     :source {:code "(defn keep-indexed\n  ([f]\n   (fn [rf]\n     (let [ia (volatile! -1)]\n       (fn\n         ([] (rf))\n         ([result] (rf result))\n         ([result input]\n            (let [i (vswap! ia inc)\n                  v (f i input)]\n              (if (nil? v)\n                result\n                (rf result v))))))))\n  ([f coll]\n     (letfn [(keepi [idx coll]\n               (lazy-seq\n                (when-let [s (seq coll)]\n                  (if (chunked-seq? s)\n                    (let [c (chunk-first s)\n                          size (count c)\n                          b (chunk-buffer size)]\n                      (dotimes [i size]\n                        (let [x (f (+ idx i) (-nth c i))]\n                          (when-not (nil? x)\n                            (chunk-append b x))))\n                      (chunk-cons (chunk b) (keepi (+ idx size) (chunk-rest s))))\n                    (let [x (f idx (first s))]\n                      (if (nil? x)\n                        (keepi (inc idx) (rest s))\n                        (cons x (keepi (inc idx) (rest s)))))))))]\n       (keepi 0 coll))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/cljs/cljs/core.cljs",
                                              :lines [4082 4116]},
                                     :full-name "cljs.core/keep-indexed",
                                     :clj-symbol "clojure.core/keep-indexed",
                                     :docstring "Returns a lazy sequence of the non-nil results of (f index item). Note,\nthis means false return values will be included.  f must be free of\nside-effects.  Returns a stateful transducer when no collection is\nprovided."},
           "cljs.core/bit-shift-right" {:description "Bitwise shift right `n` bits.  Same as `x >> n` in JavaScript.",
                                        :ns "cljs.core",
                                        :name "bit-shift-right",
                                        :signature ["[x n]"],
                                        :history [["+" "0.0-927"]],
                                        :type "function/macro",
                                        :related ["cljs.core/bit-shift-left"
                                                  "cljs.core/unsigned-bit-shift-right"],
                                        :full-name-encode "cljs.core/bit-shift-right",
                                        :source {:code "(defn bit-shift-right\n  [x n] (cljs.core/bit-shift-right x n))",
                                                 :title "Function code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/cljs/cljs/core.cljs",
                                                 :lines [2560 2562]},
                                        :extra-sources [{:code "(core/defmacro ^::ana/numeric bit-shift-right [x n]\n  (core/list 'js* \"(~{} >> ~{})\" x n))",
                                                         :title "Macro code",
                                                         :repo "clojurescript",
                                                         :tag "r1.7.228",
                                                         :filename "src/main/clojure/cljs/core.cljc",
                                                         :lines [1131
                                                                 1132]}],
                                        :examples [{:id "5b75af",
                                                    :content "Bits can be entered using radix notation:\n\n```clj\n(bit-shift-right 2r1010 1)\n;;=> 5\n;; 5 = 2r0101\n```\n\nSame numbers in decimal:\n\n```clj\n(bit-shift-right 10 1)\n;;=> 5\n```"}],
                                        :full-name "cljs.core/bit-shift-right",
                                        :clj-symbol "clojure.core/bit-shift-right",
                                        :docstring "Bitwise shift right"},
           "cljs.repl.server/stop" {:ns "cljs.repl.server",
                                    :name "stop",
                                    :type "function",
                                    :signature ["[]"],
                                    :source {:code "(defn stop []\n  (.close (:socket @state)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/clojure/cljs/repl/server.clj",
                                             :lines [180 181]},
                                    :full-name "cljs.repl.server/stop",
                                    :full-name-encode "cljs.repl.server/stop",
                                    :history [["+" "0.0-1503"]]},
           "cljs.core/comparator" {:ns "cljs.core",
                                   :name "comparator",
                                   :signature ["[pred]"],
                                   :history [["+" "0.0-1586"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/comparator",
                                   :source {:code "(defn comparator\n  [pred]\n  (fn [x y]\n    (cond (pred x y) -1 (pred y x) 1 :else 0)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [9950 9954]},
                                   :full-name "cljs.core/comparator",
                                   :clj-symbol "clojure.core/comparator",
                                   :docstring "Returns an JavaScript compatible comparator based upon pred."},
           "cljs.core/ES6Iterator" {:ns "cljs.core",
                                    :name "ES6Iterator",
                                    :type "type",
                                    :signature ["[s]"],
                                    :source {:code "(deftype ES6Iterator [^:mutable s]\n  Object\n  (next [_]\n    (if-not (nil? s)\n      (let [x (first s)]\n        (set! s (next s))\n        #js {:value x :done false})\n      #js {:value nil :done true})))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [1145 1152]},
                                    :full-name "cljs.core/ES6Iterator",
                                    :full-name-encode "cljs.core/ES6Iterator",
                                    :history [["+" "0.0-2371"]]},
           "cljs.pprint/getf" {:ns "cljs.pprint",
                               :name "getf",
                               :signature ["[sym]"],
                               :history [["+" "0.0-3255"]],
                               :type "macro",
                               :full-name-encode "cljs.pprint/getf",
                               :source {:code "(defmacro getf\n  [sym]\n  `(~sym @@~'this))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/pprint.clj",
                                        :lines [27 30]},
                               :full-name "cljs.pprint/getf",
                               :docstring "Get the value of the field a named by the argument (which should be a keyword)."},
           "cljs.repl/dir" {:description "Prints a sorted directory of public vars in a namespace `ns`.",
                            :ns "cljs.repl",
                            :name "dir",
                            :signature ["[ns]"],
                            :history [["+" "0.0-2985"]],
                            :type "macro",
                            :related ["cljs.repl/find-doc"
                                      "cljs.repl/apropos"],
                            :full-name-encode "cljs.repl/dir",
                            :source {:code "(defmacro dir\n  [ns]\n  `(doseq [sym# (quote ~(sort (keys (ana-api/ns-publics ns))))]\n     (println sym#)))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.7.228",
                                     :filename "src/main/clojure/cljs/repl.cljc",
                                     :lines [1268 1272]},
                            :examples [{:id "9bf2b0",
                                        :content "```clj\n(require 'clojure.set)\n\n(dir clojure.set)\n;; Prints:\n;;  difference\n;;  index\n;;  intersection\n;;  join\n;;  map-invert\n;;  project\n;;  rename\n;;  rename-keys\n;;  select\n;;  subset?\n;;  superset?\n;;  union\n;;\n;;=> nil\n```"}],
                            :full-name "cljs.repl/dir",
                            :clj-symbol "clojure.repl/dir",
                            :docstring "Prints a sorted directory of public vars in a namespace"},
           "cljs.core/PersistentTreeSet" {:ns "cljs.core",
                                          :name "PersistentTreeSet",
                                          :signature ["[meta tree-map __hash]"],
                                          :history [["+" "0.0-1211"]],
                                          :type "type",
                                          :full-name-encode "cljs.core/PersistentTreeSet",
                                          :source {:code "(deftype PersistentTreeSet [meta tree-map ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  ;; EXPERIMENTAL: subject to change\n  (keys [coll]\n    (es6-iterator (seq coll)))\n  (entries [coll]\n    (es6-set-entries-iterator (seq coll)))\n  (values [coll]\n    (es6-iterator (seq coll)))\n  (has [coll k]\n    (contains? coll k))\n  (forEach [coll f]\n    (doseq [[k v] coll]\n      (f v k)))\n\n  ICloneable\n  (-clone [_] (PersistentTreeSet. meta tree-map __hash))\n\n  IWithMeta\n  (-with-meta [coll meta] (PersistentTreeSet. meta tree-map __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll o]\n    (PersistentTreeSet. meta (assoc tree-map o nil) nil))\n\n  IEmptyableCollection\n  (-empty [coll] (PersistentTreeSet. meta (-empty tree-map) 0))\n\n  IEquiv\n  (-equiv [coll other]\n    (and\n     (set? other)\n     (== (count coll) (count other))\n     (every? #(contains? coll %)\n             other)))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-unordered-coll __hash))\n\n  ISeqable\n  (-seq [coll] (keys tree-map))\n\n  ISorted\n  (-sorted-seq [coll ascending?]\n    (map key (-sorted-seq tree-map ascending?)))\n\n  (-sorted-seq-from [coll k ascending?]\n    (map key (-sorted-seq-from tree-map k ascending?)))\n\n  (-entry-key [coll entry] entry)\n\n  (-comparator [coll] (-comparator tree-map))\n\n  IReversible\n  (-rseq [coll]\n    (if (pos? (count tree-map))\n      (map key (rseq tree-map))))\n\n  ICounted\n  (-count [coll] (count tree-map))\n\n  ILookup\n  (-lookup [coll v]\n    (-lookup coll v nil))\n  (-lookup [coll v not-found]\n    (let [n (.entry-at tree-map v)]\n      (if-not (nil? n)\n        (.-key n)\n        not-found)))\n\n  ISet\n  (-disjoin [coll v]\n    (PersistentTreeSet. meta (dissoc tree-map v) nil))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/cljs/cljs/core.cljs",
                                                   :lines [8112 8198]},
                                          :full-name "cljs.core/PersistentTreeSet",
                                          :clj-symbol "clojure.lang/PersistentTreeSet"},
           "clojure.zip/insert-right" {:ns "clojure.zip",
                                       :name "insert-right",
                                       :signature ["[loc item]"],
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "clojure.zip/insert-right",
                                       :source {:code "(defn insert-right\n  [loc item]\n    (let [[node {r :r :as path}] loc]\n      (if (nil? path)\n        (throw \"Insert at top\")\n        (with-meta [node (assoc path :r (cons item r) :changed? true)] (meta loc)))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/clojure/zip.cljs",
                                                :lines [174 181]},
                                       :full-name "clojure.zip/insert-right",
                                       :clj-symbol "clojure.zip/insert-right",
                                       :docstring "Inserts the item as the right sibling of the node at this loc,\nwithout moving"},
           "cljs.core/make-hierarchy" {:ns "cljs.core",
                                       :name "make-hierarchy",
                                       :signature ["[]"],
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :related ["cljs.core/ancestors"
                                                 "cljs.core/descendants"
                                                 "cljs.core/isa?"
                                                 "cljs.core/derive"],
                                       :full-name-encode "cljs.core/make-hierarchy",
                                       :source {:code "(defn make-hierarchy\n  [] {:parents {} :descendants {} :ancestors {}})",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/cljs/core.cljs",
                                                :lines [9430 9432]},
                                       :full-name "cljs.core/make-hierarchy",
                                       :clj-symbol "clojure.core/make-hierarchy",
                                       :docstring "Creates a hierarchy object for use with derive, isa? etc."},
           "cljs.core/repeat" {:description "Returns a lazy sequence of `x`s.\n\nThe length of the sequence is infinite, or `n` if provided.",
                               :ns "cljs.core",
                               :name "repeat",
                               :signature ["[x]" "[n x]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/repeatedly"
                                         "cljs.core/cycle"
                                         "cljs.core/constantly"
                                         "cljs.core/dotimes"],
                               :full-name-encode "cljs.core/repeat",
                               :source {:code "(defn repeat\n  ([x] (lazy-seq (cons x (repeat x))))\n  ([n x] (take n (repeat x))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [4345 4348]},
                               :full-name "cljs.core/repeat",
                               :clj-symbol "clojure.core/repeat",
                               :docstring "Returns a lazy (infinite!, or length n if supplied) sequence of xs."},
           "syntax/destructure-map" {:description "A helpful shorthand for binding names to values inside a map.\n\nThe destructure map can be a map from a symbol to a lookup value:\n\n```clj\n(let [ {a :foo}   ;; <-- destructure map\n       {:foo 1} ]\n  a)\n;;=> 1\n```\n\nThe destructure map can bind multiple names:\n\n```clj\n(let [ {a :foo, b :bar}   ;; <-- destructure map\n       {:foo 1, :bar 2} ]\n  (println a b))\n;; 1 2\n```\n\nUse this convenient alternative if names match the keys:\n\n```clj\n(let [ {:keys [foo bar]}   ;; <-- destructure map\n       {:foo 1, :bar 2} ]\n  (println foo bar))\n;; 1 2\n```\n\nDifferent key types are supported using `:keys`, `:strs`, or `:syms`, which\nmap to the manual destructuring forms below:\n\n- `{:keys [foo]}` -> `{foo :foo }`\n- `{:strs [foo]}` -> `{foo \"foo\"}`\n- `{:syms [foo]}` -> `{foo 'foo }`\n\nUse `:as foo` to name the original value:\n\n```clj\n(let [ {:keys [foo bar] :as whole}\n       {:foo 1, :bar 2} ]\n  whole)\n;;=> {:foo 1, :bar 2}\n```\n\nUse `:or {}` to provide default values if missing:\n\n```clj\n(let [ {:keys [foo bar] :or {bar 0} }\n       {:foo 1} ]\n  (println foo bar))\n;; 1 0\n```\n\nUse the special destructuring map in place of any local name binding in the\nfollowing forms:\n\n- `(let [...])`\n- `(fn [...])`\n- `(loop [...])`\n\nDestructure maps can be nested, even in place of names in [destructure\nvectors][doc:syntax/destructure-vector].",
                                     :ns "syntax",
                                     :name "destructure-map",
                                     :history [["+" "0.0-927"]],
                                     :type "binding",
                                     :related ["syntax/destructure-vector"],
                                     :full-name-encode "syntax/destructure-map",
                                     :source {:code "(core/defn destructure [bindings]\n  (core/let [bents (partition 2 bindings)\n             pb (core/fn pb [bvec b v]\n                  (core/let [pvec\n                             (core/fn [bvec b val]\n                               (core/let [gvec (gensym \"vec__\")]\n                                 (core/loop [ret (core/-> bvec (conj gvec) (conj val))\n                                             n 0\n                                             bs b\n                                             seen-rest? false]\n                                   (if (seq bs)\n                                     (core/let [firstb (first bs)]\n                                       (core/cond\n                                         (= firstb '&) (recur (pb ret (second bs) (core/list `nthnext gvec n))\n                                                         n\n                                                         (nnext bs)\n                                                         true)\n                                         (= firstb :as) (pb ret (second bs) gvec)\n                                         :else (if seen-rest?\n                                                 (throw\n                                                   #?(:clj (new Exception \"Unsupported binding form, only :as can follow & parameter\")\n                                                      :cljs (new js/Error \"Unsupported binding form, only :as can follow & parameter\")))\n                                                 (recur (pb ret firstb (core/list `nth gvec n nil))\n                                                   (core/inc n)\n                                                   (next bs)\n                                                   seen-rest?))))\n                                     ret))))\n                             pmap\n                             (core/fn [bvec b v]\n                               (core/let [gmap (gensym \"map__\")\n                                          defaults (:or b)]\n                                 (core/loop [ret (core/-> bvec (conj gmap) (conj v)\n                                                   (conj gmap) (conj `(if (implements? ISeq ~gmap) (apply hash-map ~gmap) ~gmap))\n                                                   ((core/fn [ret]\n                                                      (if (:as b)\n                                                        (conj ret (:as b) gmap)\n                                                        ret))))\n                                             bes (reduce\n                                                   (core/fn [bes entry]\n                                                     (reduce #(assoc %1 %2 ((val entry) %2))\n                                                       (dissoc bes (key entry))\n                                                       ((key entry) bes)))\n                                                   (dissoc b :as :or)\n                                                   {:keys #(if (core/keyword? %) % (keyword (core/str %))),\n                                                    :strs core/str, :syms #(core/list `quote %)})]\n                                   (if (seq bes)\n                                     (core/let [bb (key (first bes))\n                                                bk (val (first bes))\n                                                has-default (contains? defaults bb)]\n                                       (recur (pb ret bb (if has-default\n                                                           (core/list `get gmap bk (defaults bb))\n                                                           (core/list `get gmap bk)))\n                                         (next bes)))\n                                     ret))))]\n                    (core/cond\n                      (core/symbol? b) (core/-> bvec (conj (if (namespace b) (symbol (name b)) b)) (conj v))\n                      (core/keyword? b) (core/-> bvec (conj (symbol (name b))) (conj v))\n                      (vector? b) (pvec bvec b v)\n                      (map? b) (pmap bvec b v)\n                      :else (throw\n                              #?(:clj (new Exception (core/str \"Unsupported binding form: \" b))\n                                 :cljs (new js/Error (core/str \"Unsupported binding form: \" b)))))))\n             process-entry (core/fn [bvec b] (pb bvec (first b) (second b)))]\n    (if (every? core/symbol? (map first bents))\n      bindings\n      (core/if-let [kwbs (seq (filter #(core/keyword? (first %)) bents))]\n        (throw\n          #?(:clj (new Exception (core/str \"Unsupported binding key: \" (ffirst kwbs)))\n             :cljs (new js/Error (core/str \"Unsupported binding key: \" (ffirst kwbs)))))\n        (reduce process-entry [] bents)))))",
                                              :title "Parser code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/clojure/cljs/core.cljc",
                                              :lines [619 688]},
                                     :usage ["{:keys [] :strs [] :syms [] :or {} :as name}"],
                                     :examples [{:id "0d56ee",
                                                 :content "Use in place of function arguments:\n\n```clj\n(defn print-point\n  [{:keys [x y z]}]\n  (println x y z))\n\n(print-point {:x 1, :y 2, :z 3})\n;; 1 2 3\n```"}
                                                {:id "7a51df",
                                                 :content "A non-vector sequence can be destructured as a map:\n\n```clj\n(let [{:keys [a b]} '(:a 1 :b 2)]\n  (println a b))\n;; 1 2\n```"}],
                                     :full-name "syntax/destructure-map",
                                     :display "destructure {}",
                                     :clj-doc "http://clojure.org/special_forms#toc18"},
           "syntax/syntax-quote" {:description "(Only intended for use in Clojure macros, which can be used from but not\nwritten in ClojureScript.)\n\nPrevent evaluation of the following form.\n\nAdds namespace-qualification to any symbols inside the following form by\nresolving them in the current context.\n\nAny non-namespaced symbols ending with `#` are replaced with unique symbols.\nSee [doc:syntax/auto-gensym].",
                                  :ns "syntax",
                                  :name "syntax-quote",
                                  :history [["+" "0.0-927"]],
                                  :type "syntax",
                                  :related ["syntax/auto-gensym"
                                            "syntax/quote"
                                            "syntax/unquote"
                                            "syntax/unquote-splicing"],
                                  :full-name-encode "syntax/syntax-quote",
                                  :extra-sources ({:code "(defn- read-syntax-quote\n  [rdr backquote opts pending-forms]\n  (binding [gensym-env {}]\n    (-> (read* rdr true nil opts pending-forms)\n      syntax-quote*)))",
                                                   :title "Reader code",
                                                   :repo "tools.reader",
                                                   :tag "tools.reader-1.0.0-alpha1",
                                                   :filename "src/main/clojure/clojure/tools/reader.clj",
                                                   :lines [737 741]}
                                                  {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                                   :title "Reader table",
                                                   :repo "tools.reader",
                                                   :tag "tools.reader-1.0.0-alpha1",
                                                   :filename "src/main/clojure/clojure/tools/reader.clj",
                                                   :lines [743 762]}),
                                  :examples [{:id "bffbdf",
                                              :content "```clj\n`foo\n;;=> cljs.user/foo\n\n`foo#\n;;=> foo__20418__auto__\n\n`(def foo 1)\n;;=> (def cljs.user/foo 1)\n```"}],
                                  :full-name "syntax/syntax-quote",
                                  :display "` syntax quote",
                                  :clj-doc "http://clojure.org/reader#toc2"},
           "cljs.core/array-list" {:ns "cljs.core",
                                   :name "array-list",
                                   :type "function",
                                   :signature ["[]"],
                                   :source {:code "(defn array-list []\n  (ArrayList. (array)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [8340 8341]},
                                   :full-name "cljs.core/array-list",
                                   :full-name-encode "cljs.core/array-list",
                                   :history [["+" "0.0-2301"]]},
           "cljs.repl.rhino/goog-require" {:ns "cljs.repl.rhino",
                                           :name "goog-require",
                                           :signature ["[repl-env opts rule]"],
                                           :history [["+" "0.0-927"]
                                                     ["-" "0.0-2985"]],
                                           :type "function",
                                           :full-name-encode "cljs.repl.rhino/goog-require",
                                           :source {:code "(defn goog-require [repl-env opts rule]\n  (let [path        (string/replace (comp/munge rule) \\. File/separatorChar)\n        output-dir  (util/output-directory opts)\n        cljsc-path  (str output-dir File/separator (str path \".js\"))\n        cljs-path   (str path \".cljs\")\n        gpath       (-eval (str \"goog.dependencies_.nameToPath['\" rule \"']\")\n                      repl-env \"<cljs repl>\" 1)\n        js-path     (str \"goog/\" gpath)\n        js-out-path (io/file output-dir \"goog\"\n                      (string/replace gpath \\/ File/separatorChar))]\n    (let [compiled (io/file cljsc-path)]\n      (if (.exists compiled)\n        ;; TODO: only take this path if analysis cache is available\n        ;; - David\n        (do\n          (with-open [reader (io/reader compiled)]\n            (-eval reader repl-env cljsc-path 1)))\n        (if-let [res (io/resource cljs-path)]\n          (binding [ana/*cljs-ns* 'cljs.user]\n            (repl/load-stream repl-env cljs-path res))\n          (if-let [res (io/resource js-path)]\n            (with-open [reader (io/reader res)]\n              (-eval reader repl-env js-path 1))\n            (if (.exists js-out-path)\n              (with-open [reader (io/reader js-out-path)]\n                (-eval reader repl-env js-path 1))\n              (throw\n               (Exception.\n                 (str \"Cannot find \"\n                   cljs-path \" or \"\n                   js-path \" or \"\n                   (.getName js-out-path) \" in classpath\"))))))))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2913",
                                                    :filename "src/clj/cljs/repl/rhino.clj",
                                                    :lines [78 109]},
                                           :full-name "cljs.repl.rhino/goog-require",
                                           :removed {:in "0.0-2985",
                                                     :last-seen "0.0-2913"}},
           "cljs.core/prn-str-with-opts" {:ns "cljs.core",
                                          :name "prn-str-with-opts",
                                          :signature ["[objs opts]"],
                                          :history [["+" "0.0-1011"]],
                                          :type "function",
                                          :full-name-encode "cljs.core/prn-str-with-opts",
                                          :source {:code "(defn prn-str-with-opts\n  [objs opts]\n  (if (empty? objs)\n    \"\\n\"\n    (let [sb (pr-sb-with-opts objs opts)]\n      (.append sb \\newline)\n      (str sb))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/cljs/cljs/core.cljs",
                                                   :lines [8909 8916]},
                                          :full-name "cljs.core/prn-str-with-opts",
                                          :docstring "Same as pr-str-with-opts followed by (newline)"},
           "cljs.core/MultiFn" {:ns "cljs.core",
                                :name "MultiFn",
                                :signature ["[name dispatch-fn default-dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy]"],
                                :history [["+" "0.0-927"]],
                                :type "type",
                                :full-name-encode "cljs.core/MultiFn",
                                :source {:code "(deftype MultiFn [name dispatch-fn default-dispatch-val hierarchy\n                  method-table prefer-table method-cache cached-hierarchy]\n  IFn\n  (-invoke [mf]\n    (let [dispatch-val (dispatch-fn)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn)))\n  (-invoke [mf a]\n    (let [dispatch-val (dispatch-fn a)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a)))\n  (-invoke [mf a b]\n    (let [dispatch-val (dispatch-fn a b)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b)))\n  (-invoke [mf a b c]\n    (let [dispatch-val (dispatch-fn a b c)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c)))\n  (-invoke [mf a b c d]\n    (let [dispatch-val (dispatch-fn a b c d)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d)))\n  (-invoke [mf a b c d e]\n    (let [dispatch-val (dispatch-fn a b c d e)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e)))\n  (-invoke [mf a b c d e f]\n    (let [dispatch-val (dispatch-fn a b c d e f)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f)))\n  (-invoke [mf a b c d e f g]\n    (let [dispatch-val (dispatch-fn a b c d e f g)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g)))\n  (-invoke [mf a b c d e f g h]\n    (let [dispatch-val (dispatch-fn a b c d e f g h)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h)))\n  (-invoke [mf a b c d e f g h i]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i)))\n  (-invoke [mf a b c d e f g h i j]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j)))\n  (-invoke [mf a b c d e f g h i j k]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k)))\n  (-invoke [mf a b c d e f g h i j k l]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l)))\n  (-invoke [mf a b c d e f g h i j k l m]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m)))\n  (-invoke [mf a b c d e f g h i j k l m n]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m n)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m n)))\n  (-invoke [mf a b c d e f g h i j k l m n o]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m n o)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m n o)))\n  (-invoke [mf a b c d e f g h i j k l m n o p]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m n o p)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m n o p)))\n  (-invoke [mf a b c d e f g h i j k l m n o p q]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m n o p q)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m n o p q)))\n  (-invoke [mf a b c d e f g h i j k l m n o p q r]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m n o p q r)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m n o p q r)))\n  (-invoke [mf a b c d e f g h i j k l m n o p q r s]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m n o p q r s)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m n o p q r s)))\n  (-invoke [mf a b c d e f g h i j k l m n o p q r s t]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m n o p q r s t)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m n o p q r s t)))\n  (-invoke [mf a b c d e f g h i j k l m n o p q r s t rest]\n    (let [dispatch-val (apply dispatch-fn a b c d e f g h i j k l m n o p q r s t rest)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (apply target-fn a b c d e f g h i j k l m n o p q r s t rest)))\n    \n  IMultiFn\n  (-reset [mf]\n    (swap! method-table (fn [mf] {}))\n    (swap! method-cache (fn [mf] {}))\n    (swap! prefer-table (fn [mf] {}))\n    (swap! cached-hierarchy (fn [mf] nil))\n    mf)\n\n  (-add-method [mf dispatch-val method]\n    (swap! method-table assoc dispatch-val method)\n    (reset-cache method-cache method-table cached-hierarchy hierarchy)\n    mf)\n\n  (-remove-method [mf dispatch-val]\n    (swap! method-table dissoc dispatch-val)\n    (reset-cache method-cache method-table cached-hierarchy hierarchy)\n    mf)\n\n  (-get-method [mf dispatch-val]\n    (when-not (= @cached-hierarchy @hierarchy)\n      (reset-cache method-cache method-table cached-hierarchy hierarchy))\n    (if-let [target-fn (@method-cache dispatch-val)]\n      target-fn\n      (if-let [target-fn (find-and-cache-best-method name dispatch-val hierarchy method-table\n                                                     prefer-table method-cache cached-hierarchy)]\n        target-fn\n        (@method-table default-dispatch-val))))\n\n  (-prefer-method [mf dispatch-val-x dispatch-val-y]\n    (when (prefers* dispatch-val-x dispatch-val-y prefer-table)\n      (throw (js/Error. (str \"Preference conflict in multimethod '\" name \"': \" dispatch-val-y\n                   \" is already preferred to \" dispatch-val-x))))\n    (swap! prefer-table\n           (fn [old]\n             (assoc old dispatch-val-x\n                    (conj (get old dispatch-val-x #{})\n                          dispatch-val-y))))\n    (reset-cache method-cache method-table cached-hierarchy hierarchy))\n\n  (-methods [mf] @method-table)\n  (-prefers [mf] @prefer-table)\n  (-default-dispatch-val [mf] default-dispatch-val)\n  (-dispatch-fn [mf] dispatch-fn)\n  \n  INamed\n  (-name [this] (-name name))\n  (-namespace [this] (-namespace name))\n\n  IHash\n  (-hash [this] (goog/getUid this)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [9613 9798]},
                                :full-name "cljs.core/MultiFn",
                                :clj-symbol "clojure.lang/MultiFn"},
           "cljs.test/successful?" {:ns "cljs.test",
                                    :name "successful?",
                                    :signature ["[summary]"],
                                    :history [["+" "0.0-2496"]],
                                    :type "function",
                                    :full-name-encode "cljs.test/successfulQMARK",
                                    :source {:code "(defn successful?\n  [summary]\n  (and (zero? (:fail summary 0))\n       (zero? (:error summary 0))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/test.cljs",
                                             :lines [588 593]},
                                    :full-name "cljs.test/successful?",
                                    :clj-symbol "clojure.test/successful?",
                                    :docstring "Returns true if the given test summary indicates all tests\nwere successful, false otherwise."},
           "cljs.core/hash-keyword" {:ns "cljs.core",
                                     :name "hash-keyword",
                                     :type "function",
                                     :signature ["[k]"],
                                     :source {:code "(defn hash-keyword [k]\n  (int (+ (hash-symbol k) 0x9e3779b9)))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/cljs/cljs/core.cljs",
                                              :lines [2915 2916]},
                                     :full-name "cljs.core/hash-keyword",
                                     :full-name-encode "cljs.core/hash-keyword",
                                     :history [["+" "0.0-2261"]]},
           "cljs.test/run-tests-block" {:ns "cljs.test",
                                        :name "run-tests-block",
                                        :signature ["[env-or-ns & namespaces]"],
                                        :history [["+" "0.0-2814"]],
                                        :type "macro",
                                        :full-name-encode "cljs.test/run-tests-block",
                                        :source {:code "(defmacro run-tests-block\n  [env-or-ns & namespaces]\n  (assert (every?\n           (fn [[quote ns]] (and (= quote 'quote) (symbol? ns)))\n           namespaces)\n          \"All arguments to run-tests must be quoted symbols\")\n  (let [is-ns (ns? env-or-ns)\n        env (gensym \"env\")\n        summary (gensym \"summary\")]\n    `(let [~env ~(if is-ns\n                   `(cljs.test/empty-env)\n                   env-or-ns)\n           ~summary (cljs.core/volatile!\n                     {:test 0 :pass 0 :fail 0 :error 0\n                      :type :summary})]\n       (concat ~@(map\n                  (fn [ns]\n                    `(concat (cljs.test/test-ns-block ~env ~ns)\n                             [(fn []\n                                (cljs.core/vswap!\n                                 ~summary\n                                 (partial merge-with +)\n                                 (:report-counters\n                                  (cljs.test/get-and-clear-env!))))]))\n                  (if is-ns\n                    (concat [env-or-ns] namespaces)\n                    namespaces))\n               [(fn []\n                   (cljs.test/set-env! ~env)\n                   (do-report (deref ~summary))\n                   (report (assoc (deref ~summary) :type :end-run-tests))\n                   (cljs.test/clear-env!))]))))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/cljs/cljs/test.clj",
                                                 :lines [248 281]},
                                        :full-name "cljs.test/run-tests-block",
                                        :docstring "Like test-vars, but returns a block for further composition and\nlater execution."},
           "cljs.core/Reduced" {:ns "cljs.core",
                                :name "Reduced",
                                :signature ["[val]"],
                                :history [["+" "0.0-1211"]],
                                :type "type",
                                :full-name-encode "cljs.core/Reduced",
                                :source {:code "(deftype Reduced [val]\n  IDeref\n  (-deref [o] val))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [1268 1270]},
                                :full-name "cljs.core/Reduced",
                                :clj-symbol "clojure.lang/Reduced"},
           "cljs.core/not-any?" {:description "Returns false if `(pred x)` is logical true for any `x` in `coll`, else true.",
                                 :return-type boolean,
                                 :ns "cljs.core",
                                 :name "not-any?",
                                 :signature ["[pred coll]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :related ["cljs.core/every?"
                                           "cljs.core/some"],
                                 :full-name-encode "cljs.core/not-anyQMARK",
                                 :source {:code "(defn ^boolean not-any?\n  [pred coll] (not (some pred coll)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [3777 3780]},
                                 :full-name "cljs.core/not-any?",
                                 :clj-symbol "clojure.core/not-any?",
                                 :docstring "Returns false if (pred x) is logical true for any x in coll,\nelse true."},
           "cljs.reader/read-regex" {:ns "cljs.reader",
                                     :name "read-regex",
                                     :type "function",
                                     :signature ["[rdr ch]"],
                                     :source {:code "(defn read-regex\n  [rdr ch]\n  (-> (read-raw-string* rdr ch) re-pattern))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/cljs/cljs/reader.cljs",
                                              :lines [400 402]},
                                     :full-name "cljs.reader/read-regex",
                                     :full-name-encode "cljs.reader/read-regex",
                                     :history [["+" "0.0-927"]]},
           "cljs.repl/spec-sort" {:ns "cljs.repl",
                                  :name "spec-sort",
                                  :type "var",
                                  :source {:code "(def spec-sort\n  {:as 0\n   :refer 1\n   :refer-macros 2\n   :include-macros 3})",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2644",
                                           :filename "src/clj/cljs/repl.clj",
                                           :lines [190 194]},
                                  :full-name "cljs.repl/spec-sort",
                                  :full-name-encode "cljs.repl/spec-sort",
                                  :history [["+" "0.0-2629"]
                                            ["-" "0.0-2655"]],
                                  :removed {:in "0.0-2655",
                                            :last-seen "0.0-2644"}},
           "clojure.zip/next" {:ns "clojure.zip",
                               :name "next",
                               :signature ["[loc]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip/next",
                               :source {:code "(defn next\n  [loc]\n    (if (= :end (loc 1))\n      loc\n      (or \n       (and (branch? loc) (down loc))\n       (right loc)\n       (loop [p loc]\n         (if (up p)\n           (or (right (up p)) (recur (up p)))\n           [(node p) :end])))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/clojure/zip.cljs",
                                        :lines [206 219]},
                               :full-name "clojure.zip/next",
                               :clj-symbol "clojure.zip/next",
                               :docstring "Moves to the next loc in the hierarchy, depth-first. When reaching\nthe end, returns a distinguished loc detectable via end?. If already\nat the end, stays there."},
           "cljs.analyzer.api/no-warn" {:ns "cljs.analyzer.api",
                                        :name "no-warn",
                                        :signature ["[& body]"],
                                        :history [["+" "0.0-3291"]],
                                        :type "macro",
                                        :full-name-encode "cljs.analyzer.api/no-warn",
                                        :source {:code "(defmacro no-warn\n  [& body]\n  (let [no-warnings (zipmap (keys ana/*cljs-warnings*) (repeat false))]\n    `(binding [ana/*cljs-warnings* ~no-warnings]\n       ~@body)))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/clojure/cljs/analyzer/api.clj",
                                                 :lines [36 41]},
                                        :full-name "cljs.analyzer.api/no-warn",
                                        :docstring "Disable analyzer warnings for any analysis executed in body."},
           "syntax/dispatch" {:description "`#` is a prefix character that is called the dispatch macro, because it allows\nthe behavior of the reader to be dispatched to another table, indexed by the\ncharacter following the `#`.\n\nSyntax forms prefixed with `#` are made to bear some similarity to their\noriginal forms:\n\n| original                           | with `#` prefix                                  | relation               |\n|------------------------------------|--------------------------------------------------|------------------------|\n| [doc:syntax/string]                    | [doc:syntax/regex]                                   | string-related         |\n| [doc:syntax/list]                      | [doc:syntax/function]                                | code-related           |\n| [doc:syntax/map]                       | [doc:syntax/set]                                     | lookup-related         |\n| [doc:syntax/quote]                     | [doc:syntax/var]                                     | quote-related          |\n| [doc:syntax/unused]                    | [doc:syntax/ignore]                                  | ignore-related         |\n| [`foo (symbol)`][doc:syntax/symbol]    | [`#foo (tagged literal)`][doc:syntax/tagged-literal] | name-related           |\n| [doc:syntax/predicate]                 | [doc:syntax/cond]                                    | conditional-related    |",
                              :ns "syntax",
                              :name "dispatch",
                              :history [["+" "0.0-927"]],
                              :type "syntax",
                              :related ["syntax/regex"
                                        "syntax/function"
                                        "syntax/set"
                                        "syntax/var"
                                        "syntax/ignore"
                                        "syntax/tagged-literal"
                                        "syntax/cond"],
                              :full-name-encode "syntax/dispatch",
                              :extra-sources ({:code "(defn- read-dispatch\n  [rdr _ opts pending-forms]\n  (if-let [ch (read-char rdr)]\n    (if-let [dm (dispatch-macros ch)]\n      (dm rdr ch opts pending-forms)\n      (read-tagged (doto rdr (unread ch)) ch opts pending-forms)) ;; ctor reader is implemented as a tagged literal\n    (reader-error rdr \"EOF while reading character\")))",
                                               :title "Reader code",
                                               :repo "tools.reader",
                                               :tag "tools.reader-1.0.0-alpha1",
                                               :filename "src/main/clojure/clojure/tools/reader.clj",
                                               :lines [66 72]}
                                              {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                               :title "Reader table",
                                               :repo "tools.reader",
                                               :tag "tools.reader-1.0.0-alpha1",
                                               :filename "src/main/clojure/clojure/tools/reader.clj",
                                               :lines [743 762]}),
                              :usage ["#..."],
                              :examples [{:id "0a1f4c",
                                          :content "The dispatch macro is not usable on its own.  Rather, it dispatches to other\nsyntax forms.\n\nRegular expression:\n\n```clj\n#\"[a-zA-Z0-9]+\"\n;;=> #\"[a-zA-Z0-9]+\"\n```\n\nSet:\n\n```clj\n#{:foo 1 2}\n;;=> #{:foo 1 2}\n```\n\nFunction:\n\n```clj\n#(foo 1 2)\n;;=> #<function (){\n;;   return cljs.user.foo.call(null,(1),(2));\n;;   }>\n```\n\nVar reference:\n\n```clj\n(def a)\n#'a\n;;=> #'cljs.user/a\n```\n\nIgnore form:\n\n```clj\n#_foo\n;; waits for next form since #_foo was ignored\n\n#_123 456\n;;=> 456\n```\n\nTagged Literals:\n\n```clj\n#queue [1 2 3]\n;;=> #queue [1 2 3]\n\n#js {:foo 1}\n;;=> #js {:foo 1}\n\n#inst \"2010-11-12T18:14:15.666-00:00\"\n;;=> #inst \"2010-11-12T18:14:15.666-00:00\"\n```\n\nReader Conditional:\n\n```clj\n#?(:clj \"Clojure\" :cljs \"ClojureScript\")\n;;=> \"ClojureScript\"\n```"}],
                              :edn-doc "https://github.com/edn-format/edn#-dispatch-character",
                              :full-name "syntax/dispatch",
                              :display "# dispatch",
                              :clj-doc "http://clojure.org/reader#toc2"},
           "cljs.test/async" {:ns "cljs.test",
                              :name "async",
                              :signature ["[done & body]"],
                              :history [["+" "0.0-2814"]],
                              :type "macro",
                              :full-name-encode "cljs.test/async",
                              :source {:code "(defmacro async\n  [done & body]\n  `(reify\n     cljs.test/IAsyncTest\n     cljs.core/IFn\n     (~'-invoke [_# ~done]\n       ~@body)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/test.clj",
                                       :lines [223 240]},
                              :full-name "cljs.test/async",
                              :docstring "Wraps body as a CPS function that can be returned from a test to\ncontinue asynchronously.  Binds done to a function that must be\ninvoked once and from an async context after any assertions.\n\n(deftest example-with-timeout\n  (async done\n    (js/setTimeout (fn []\n                     ;; make assertions in async context...\n                     (done) ;; ...then call done\n                     )\n                   0)))"},
           "cljs.core/find-ns" {:ns "cljs.core",
                                :name "find-ns",
                                :signature ["[ns]"],
                                :history [["+" "1.7.10"]],
                                :type "function",
                                :full-name-encode "cljs.core/find-ns",
                                :source {:code "(defn find-ns [ns]\n  (when (nil? NS_CACHE)\n    (set! NS_CACHE (atom {})))\n  (let [the-ns (get @NS_CACHE ns)]\n    (if-not (nil? the-ns)\n      the-ns\n      (let [ns-obj (find-ns-obj ns)]\n        (when-not (nil? ns-obj)\n          (let [new-ns (create-ns ns ns-obj)]\n            (swap! NS_CACHE assoc ns new-ns)\n            new-ns))))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [10173 10183]},
                                :full-name "cljs.core/find-ns",
                                :clj-symbol "clojure.core/find-ns"},
           "cljs.core/IFn" {:ns "cljs.core",
                            :name "IFn",
                            :history [["+" "0.0-971"]],
                            :type "protocol",
                            :full-name-encode "cljs.core/IFn",
                            :source {:code "(defprotocol IFn\n  \"Protocol for adding the ability to invoke an object as a function.\n  For example, a vector can also be used to look up a value:\n  ([1 2 3 4] 1) => 2\"\n  (-invoke\n    [this]\n    [this a]\n    [this a b]\n    [this a b c]\n    [this a b c d]\n    [this a b c d e]\n    [this a b c d e f]\n    [this a b c d e f g]\n    [this a b c d e f g h]\n    [this a b c d e f g h i]\n    [this a b c d e f g h i j]\n    [this a b c d e f g h i j k]\n    [this a b c d e f g h i j k l]\n    [this a b c d e f g h i j k l m]\n    [this a b c d e f g h i j k l m n]\n    [this a b c d e f g h i j k l m n o]\n    [this a b c d e f g h i j k l m n o p]\n    [this a b c d e f g h i j k l m n o p q]\n    [this a b c d e f g h i j k l m n o p q r]\n    [this a b c d e f g h i j k l m n o p q r s]\n    [this a b c d e f g h i j k l m n o p q r s t]\n    [this a b c d e f g h i j k l m n o p q r s t rest]))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.7.228",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [427 453]},
                            :methods [{:name "-invoke",
                                       :signature ["[this]"
                                                   "[this a]"
                                                   "[this a b]"
                                                   "[this a b c]"
                                                   "[this a b c d]"
                                                   "[this a b c d e]"
                                                   "[this a b c d e f]"
                                                   "[this a b c d e f g]"
                                                   "[this a b c d e f g h]"
                                                   "[this a b c d e f g h i]"
                                                   "[this a b c d e f g h i j]"
                                                   "[this a b c d e f g h i j k]"
                                                   "[this a b c d e f g h i j k l]"
                                                   "[this a b c d e f g h i j k l m]"
                                                   "[this a b c d e f g h i j k l m n]"
                                                   "[this a b c d e f g h i j k l m n o]"
                                                   "[this a b c d e f g h i j k l m n o p]"
                                                   "[this a b c d e f g h i j k l m n o p q]"
                                                   "[this a b c d e f g h i j k l m n o p q r]"
                                                   "[this a b c d e f g h i j k l m n o p q r s]"
                                                   "[this a b c d e f g h i j k l m n o p q r s t]"
                                                   "[this a b c d e f g h i j k l m n o p q r s t rest]"],
                                       :docstring nil}],
                            :full-name "cljs.core/IFn",
                            :clj-symbol "clojure.lang/IFn",
                            :docstring "Protocol for adding the ability to invoke an object as a function.\n  For example, a vector can also be used to look up a value:\n  ([1 2 3 4] 1) => 2"},
           "cljs.core/aget" {:description "Returns the value at index `i` of a JavaScript array.\n\n```clj\n(def a #js [1 2 3])\n(aget a 0)\n;;=> 1\n```\n\nRetrieve nested elements with the additional `idxs` arguments.\n\n```clj\n(def a #js [1 2 #js [3 4]])\n(aget a 2 0)\n;;=> 3\n```\n\nFor JavaScript objects, use [`goog.object/get`] or the multi-arity [`goog.object/getValueByKeys`].\n\n```clj\n(require 'goog.object)\n(def obj #js {:foo #js {:bar 2}})\n\n(goog.object/get obj \"foo\")\n;;=> #js {:bar 2} \n\n(goog.object/getValueByKeys obj \"foo\" \"bar\")\n;;=> 2\n```\n\n[`goog.object/get`]:http://google.github.io/closure-library/api/namespace_goog_object.html#get\n[`goog.object/getValueByKeys`]:http://google.github.io/closure-library/api/namespace_goog_object.html#getValueByKeys",
                             :ns "cljs.core",
                             :name "aget",
                             :signature ["[array i]"
                                         "[array i & idxs]"],
                             :history [["+" "0.0-927"]],
                             :type "function/macro",
                             :related ["cljs.core/.."
                                       "cljs.core/aset"
                                       "cljs.core/get"
                                       "cljs.core/nth"],
                             :full-name-encode "cljs.core/aget",
                             :source {:code "(defn aget\n  ([array i]\n     (cljs.core/aget array i))\n  ([array i & idxs]\n     (apply aget (aget array i) idxs)))",
                                      :title "Function code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [387 392]},
                             :extra-sources [{:code "(core/defmacro aget\n  ([a i]\n   (core/list 'js* \"(~{}[~{}])\" a i))\n  ([a i & idxs]\n   (core/let [astr (apply core/str (repeat (count idxs) \"[~{}]\"))]\n     `(~'js* ~(core/str \"(~{}[~{}]\" astr \")\") ~a ~i ~@idxs))))",
                                              :title "Macro code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/clojure/cljs/core.cljc",
                                              :lines [942 947]}],
                             :full-name "cljs.core/aget",
                             :clj-symbol "clojure.core/aget",
                             :docstring "Returns the value at the index."},
           "cljs.core/if-let" {:description "When `test` is logical true, evaluates `then` with the value of `test` bound to\n`x`. Otherwise, evaluates `else` with no bindings.\n\n`else` defaults to nil.",
                               :ns "cljs.core",
                               :name "if-let",
                               :signature ["[[x test] then]"
                                           "[[x test] then else]"],
                               :history [["+" "0.0-927"]],
                               :type "macro",
                               :related ["cljs.core/when-let"
                                         "special/if"],
                               :full-name-encode "cljs.core/if-let",
                               :source {:code "(defmacro if-let\n  ([bindings then]\n   `(if-let ~bindings ~then nil))\n  ([bindings then else & oldform]\n   (assert-args\n     (vector? bindings) \"a vector for its binding\"\n     (nil? oldform) \"1 or 2 forms after binding vector\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n   (let [form (bindings 0) tst (bindings 1)]\n     `(let [temp# ~tst]\n        (if temp#\n          (let [~form temp#]\n            ~then)\n          ~else)))))",
                                        :title "Source code",
                                        :repo "clojure",
                                        :tag "clojure-1.7.0",
                                        :filename "src/clj/clojure/core.clj",
                                        :lines [1727 1745]},
                               :full-name "cljs.core/if-let",
                               :clj-symbol "clojure.core/if-let",
                               :docstring "bindings => binding-form test\n\nIf test is true, evaluates then with binding-form bound to the value of \ntest, if not, yields else"},
           "cljs.core//" {:description "If no denominators are supplied, returns 1/numerator, else returns numerator\ndivided by all of the denominators.",
                          :return-type number,
                          :ns "cljs.core",
                          :name "/",
                          :signature ["[x]" "[x y]" "[x y & more]"],
                          :history [["+" "0.0-927"]],
                          :type "function/macro",
                          :related ["cljs.core/*" "cljs.core/quot"],
                          :full-name-encode "cljs.core/SLASH",
                          :source {:code "(defn ^number /\n  ([x] (/ 1 x))\n  ([x y] (cljs.core/divide x y)) ;; FIXME: waiting on cljs.core//\n  ([x y & more] (reduce / (/ x y) more)))",
                                   :title "Function code",
                                   :repo "clojurescript",
                                   :tag "r1.7.228",
                                   :filename "src/main/cljs/cljs/core.cljs",
                                   :lines [2283 2288]},
                          :extra-sources [{:code "(core/defmacro ^::ana/numeric /\n  ([x] `(/ 1 ~x))\n  ([x y] (core/list 'js* \"(~{} / ~{})\" x y))\n  ([x y & more] `(/ (/ ~x ~y) ~@more)))",
                                           :title "Macro code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/clojure/cljs/core.cljc",
                                           :lines [1027 1030]}],
                          :examples [{:id "824bb7",
                                      :content "```clj\n(/ 6 3)\n;;=> 2\n\n(/ 6 3 2)\n;;=> 1\n\n(/ 10)\n;;=> 0.1\n\n(/ 1 3)\n;;=> 0.3333333333333333\n```"}],
                          :full-name "cljs.core//",
                          :clj-symbol "clojure.core//",
                          :docstring "If no denominators are supplied, returns 1/numerator,\nelse returns numerator divided by all of the denominators."},
           "cljs.core/unchecked-int" {:ns "cljs.core",
                                      :name "unchecked-int",
                                      :signature ["[x]"],
                                      :history [["+" "0.0-1798"]],
                                      :type "function",
                                      :full-name-encode "cljs.core/unchecked-int",
                                      :source {:code "(defn unchecked-int\n  [x]\n  (fix x))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [2462 2465]},
                                      :full-name "cljs.core/unchecked-int",
                                      :clj-symbol "clojure.core/unchecked-int",
                                      :docstring "Coerce to int by stripping decimal places."},
           "cljs.repl.server/read-get" {:ns "cljs.repl.server",
                                        :name "read-get",
                                        :type "function",
                                        :signature ["[line rdr]"],
                                        :source {:code "(defn read-get [line rdr]\n  (let [[_ path _] (str/split line #\" \")\n        headers (parse-headers (read-headers rdr))]\n    {:method :get\n     :path path\n     :headers headers}))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/clojure/cljs/repl/server.clj",
                                                 :lines [85 90]},
                                        :full-name "cljs.repl.server/read-get",
                                        :full-name-encode "cljs.repl.server/read-get",
                                        :history [["+" "0.0-1503"]]},
           "cljs.core/min-key" {:description "Returns the `x` for which `(k x)` is least.\n\n`(k x)` should return a number.",
                                :ns "cljs.core",
                                :name "min-key",
                                :signature ["[k x]"
                                            "[k x y]"
                                            "[k x y & more]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/min"
                                          "cljs.core/max-key"],
                                :full-name-encode "cljs.core/min-key",
                                :source {:code "(defn min-key\n  ([k x] x)\n  ([k x y] (if (< (k x) (k y)) x y))\n  ([k x y & more]\n     (reduce #(min-key k %1 %2) (min-key k x y) more)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [8325 8330]},
                                :full-name "cljs.core/min-key",
                                :clj-symbol "clojure.core/min-key",
                                :docstring "Returns the x for which (k x), a number, is least."},
           "clojure.zip/root" {:ns "clojure.zip",
                               :name "root",
                               :signature ["[loc]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip/root",
                               :source {:code "(defn root\n  [loc]\n    (if (= :end (loc 1))\n      (node loc)\n      (let [p (up loc)]\n        (if p\n          (recur p)\n          (node loc)))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/clojure/zip.cljs",
                                        :lines [124 133]},
                               :full-name "clojure.zip/root",
                               :clj-symbol "clojure.zip/root",
                               :docstring "zips all the way up and returns the root node, reflecting any\nchanges."},
           "cljs.core/drop-while" {:description "Returns a lazy sequence of the items in `coll` starting from the first item for\nwhich `(pred item)` returns logical false.\n\nReturns a stateful transducer when no collection is provided.",
                                   :ns "cljs.core",
                                   :name "drop-while",
                                   :signature ["[pred]" "[pred coll]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/take-while"
                                             "cljs.core/split-with"],
                                   :full-name-encode "cljs.core/drop-while",
                                   :source {:code "(defn drop-while\n  ([pred]\n     (fn [rf]\n       (let [da (volatile! true)]\n         (fn\n           ([] (rf))\n           ([result] (rf result))\n           ([result input]\n              (let [drop? @da]\n                (if (and drop? (pred input))\n                  result\n                  (do\n                    (vreset! da nil)\n                    (rf result input)))))))))\n  ([pred coll]\n     (let [step (fn [pred coll]\n                  (let [s (seq coll)]\n                    (if (and s (pred (first s)))\n                      (recur pred (rest s))\n                      s)))]\n       (lazy-seq (step pred coll)))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [4309 4332]},
                                   :full-name "cljs.core/drop-while",
                                   :clj-symbol "clojure.core/drop-while",
                                   :docstring "Returns a lazy sequence of the items in coll starting from the\nfirst item for which (pred item) returns logical false.  Returns a\nstateful transducer when no collection is provided."},
           "cljs.repl.browser/send-repl-client-page" {:ns "cljs.repl.browser",
                                                      :name "send-repl-client-page",
                                                      :type "function",
                                                      :signature ["[request conn opts]"],
                                                      :source {:code "(defn send-repl-client-page\n  [request conn opts]\n  (server/send-and-close conn 200\n    (str \"<html><head><meta charset=\\\"UTF-8\\\"></head><body>\n          <script type=\\\"text/javascript\\\">\"\n         (repl-client-js)\n         \"</script>\"\n         \"<script type=\\\"text/javascript\\\">\n          clojure.browser.repl.client.start(\\\"http://\" (-> request :headers :host) \"\\\");\n          </script>\"\n         \"</body></html>\")\n    \"text/html\"))",
                                                               :title "Source code",
                                                               :repo "clojurescript",
                                                               :tag "r1.7.228",
                                                               :filename "src/main/clojure/cljs/repl/browser.clj",
                                                               :lines [79
                                                                       90]},
                                                      :full-name "cljs.repl.browser/send-repl-client-page",
                                                      :full-name-encode "cljs.repl.browser/send-repl-client-page",
                                                      :history [["+"
                                                                 "0.0-927"]]},
           "clojure.browser.repl/evaluate-javascript" {:ns "clojure.browser.repl",
                                                       :name "evaluate-javascript",
                                                       :signature ["[conn block]"],
                                                       :history [["+"
                                                                  "0.0-927"]],
                                                       :type "function",
                                                       :full-name-encode "clojure.browser.repl/evaluate-javascript",
                                                       :source {:code "(defn evaluate-javascript\n  [conn block]\n  (let [result\n        (try\n          {:status :success\n           :value (str (js* \"eval(~{block})\"))}\n          (catch :default e\n            {:status :exception\n             :ua-product (get-ua-product)\n             :value (str e)\n             :stacktrace\n             (if (.hasOwnProperty e \"stack\")\n               (.-stack e)\n               \"No stacktrace available.\")}))]\n    (pr-str result)))",
                                                                :title "Source code",
                                                                :repo "clojurescript",
                                                                :tag "r1.7.228",
                                                                :filename "src/main/cljs/clojure/browser/repl.cljs",
                                                                :lines [54
                                                                        69]},
                                                       :full-name "clojure.browser.repl/evaluate-javascript",
                                                       :docstring "Process a single block of JavaScript received from the server"},
           "cljs.core/set-validator!" {:description "Sets a validator function for atom `a`.\n\n`fn` must be nil or a side-effect-free function of one argument, which will be\npassed the intended new state on any state change. `fn` should return false or\nthrow an Error if the new state is unacceptable.\n\nIf the current value of `a` is unacceptable to `fn` when `set-validator!` is\ncalled, an Error will be thrown and the validator will not be set.\n\n`(set-validator! my-atom nil)` will remove the validator from `my-atom`.",
                                       :ns "cljs.core",
                                       :name "set-validator!",
                                       :signature ["[a fn]"],
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :related ["cljs.core/atom"
                                                 "cljs.core/get-validator"],
                                       :full-name-encode "cljs.core/set-validatorBANG",
                                       :source {:code "(defn set-validator!\n  [iref val]\n  (set! (.-validator iref) val))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/cljs/core.cljs",
                                                :lines [4045 4053]},
                                       :full-name "cljs.core/set-validator!",
                                       :clj-symbol "clojure.core/set-validator!",
                                       :docstring "Sets the validator-fn for an atom. validator-fn must be nil or a\nside-effect-free fn of one argument, which will be passed the intended\nnew state on any state change. If the new state is unacceptable, the\nvalidator-fn should return false or throw an Error. If the current state\nis not acceptable to the new validator, an Error will be thrown and the\nvalidator will not be changed."},
           "syntax/queue-literal" {:description "Create a persistent queue. The form following `#queue` must be a vector.\n\nQueues are the only core collection type that requires a tagged literal to\ncreate, while the other collections have built-in delimiters `()` `[]` `{}` `#{}`.\n\nSee [doc:cljs.core/PersistentQueue] for data structure details.",
                                   :ns "syntax",
                                   :name "queue-literal",
                                   :history [["+" "0.0-1424"]],
                                   :type "tagged literal",
                                   :related ["syntax/list"
                                             "syntax/vector"
                                             "syntax/map"
                                             "syntax/set"],
                                   :full-name-encode "syntax/queue-literal",
                                   :extra-sources ({:code "(defn read-queue\n  [form]\n  (when-not (vector? form)\n    (throw\n      #?(:clj  (RuntimeException.\n                 \"Queue literal expects a vector for its elements.\")\n         :cljs (js/Error.\n                 \"Queue literal expects a vector for its elements.\"))))\n  (list 'cljs.core/into 'cljs.core.PersistentQueue.EMPTY form))",
                                                    :title "Reader code",
                                                    :repo "clojurescript",
                                                    :tag "r1.7.228",
                                                    :filename "src/main/clojure/cljs/tagged_literals.cljc",
                                                    :lines [5 13]}
                                                   {:code "(def ^:dynamic *cljs-data-readers*\n  {'queue read-queue\n   'uuid  read-uuid\n   'inst  read-inst\n   'js    read-js})",
                                                    :title "Reader table",
                                                    :repo "clojurescript",
                                                    :tag "r1.7.228",
                                                    :filename "src/main/clojure/cljs/tagged_literals.cljc",
                                                    :lines [79 83]}),
                                   :usage ["#queue [...]"],
                                   :examples [{:id "f81c50",
                                               :content "```clj\n#queue []\n;;=> #queue []\n\n#queue [1 2 3]\n;;=> #queue [1 2 3]\n```\n\nSome operations:\n\n```clj\n(def q #queue [1 2 3])\n;;=> #queue [1 2 3]\n\n(conj q 4)\n;;=> #queue [1 2 3 4]\n\n(pop q)\n;;=> #queue [2 3]\n\n(peek q)\n;;=> 1\n```"}],
                                   :full-name "syntax/queue-literal",
                                   :display "#queue literal"},
           "cljs.core/<" {:description "Returns true if each successive number argument is greater than the previous\none, false otherwise.",
                          :return-type boolean,
                          :ns "cljs.core",
                          :name "<",
                          :signature ["[x]" "[x y]" "[x y & more]"],
                          :history [["+" "0.0-927"]],
                          :type "function/macro",
                          :related ["cljs.core/<="],
                          :full-name-encode "cljs.core/LT",
                          :source {:code "(defn ^boolean <\n  ([x] true)\n  ([x y] (cljs.core/< x y))\n  ([x y & more]\n     (if (cljs.core/< x y)\n       (if (next more)\n         (recur y (first more) (next more))\n         (cljs.core/< y (first more)))\n       false)))",
                                   :title "Function code",
                                   :repo "clojurescript",
                                   :tag "r1.7.228",
                                   :filename "src/main/cljs/cljs/core.cljs",
                                   :lines [2290 2300]},
                          :extra-sources [{:code "(core/defmacro ^::ana/numeric <\n  ([x] true)\n  ([x y] (bool-expr (core/list 'js* \"(~{} < ~{})\" x y)))\n  ([x y & more] `(and (< ~x ~y) (< ~y ~@more))))",
                                           :title "Macro code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/clojure/cljs/core.cljc",
                                           :lines [1037 1040]}],
                          :examples [{:id "02e6d3",
                                      :content "```clj\n(< 1 2)\n;;=> true\n\n(< 2 1)\n;;=> false\n\n(< 1 1)\n;;=> false\n\n(< 2 3 4 5 6)\n;;=> true\n```"}],
                          :full-name "cljs.core/<",
                          :clj-symbol "clojure.core/<",
                          :docstring "Returns non-nil if nums are in monotonically increasing order,\notherwise false."},
           "syntax/shebang" {:description "Equivalent to [doc:syntax/comment].\n\nThis is intended to allow executable ClojureScript files under Unix by allowing\nthe first line of the file to have a [shebang line](https://en.wikipedia.org/wiki/Shebang_(Unix)).",
                             :ns "syntax",
                             :name "shebang",
                             :history [["+" "0.0-927"]],
                             :type "syntax",
                             :full-name-encode "syntax/shebang",
                             :extra-sources ({:code "(defn read-comment\n  [rdr & _]\n  (skip-line rdr))",
                                              :title "Reader code",
                                              :repo "tools.reader",
                                              :tag "tools.reader-1.0.0-alpha1",
                                              :filename "src/main/clojure/clojure/tools/reader/impl/commons.clj",
                                              :lines [123 125]}
                                             {:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    \\? read-cond\n    nil))",
                                              :title "Reader table",
                                              :repo "tools.reader",
                                              :tag "tools.reader-1.0.0-alpha1",
                                              :filename "src/main/clojure/clojure/tools/reader.clj",
                                              :lines [764 776]}),
                             :examples [{:id "de569a",
                                         :content "```clj\n#!/bin/cljs\n;; waits for another form since #!/bin/cljs was ignored.\n\n123 #! this is ignored\n;;=> 123\n```"}],
                             :full-name "syntax/shebang",
                             :display "#! shebang",
                             :clj-doc "https://github.com/clojure/clojure/blob/clojure-1.7.0-RC1/src/jvm/clojure/lang/LispReader.java#L114"},
           "cljs.repl.reflect/read-url-string" {:ns "cljs.repl.reflect",
                                                :name "read-url-string",
                                                :type "var",
                                                :source {:code "(def read-url-string (comp read-string url-decode))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1.7.228",
                                                         :filename "src/main/clojure/cljs/repl/reflect.clj",
                                                         :lines [42]},
                                                :full-name "cljs.repl.reflect/read-url-string",
                                                :full-name-encode "cljs.repl.reflect/read-url-string",
                                                :history [["+"
                                                           "0.0-1503"]]},
           "cljs.repl/repl-special-doc-map" {:ns "cljs.repl",
                                             :name "repl-special-doc-map",
                                             :type "var",
                                             :source {:code "(def repl-special-doc-map\n  '{in-ns {:arglists ([name])\n           :doc \"Sets *cljs-ns* to the namespace named by the symbol, creating it if needed.\"}\n    require {:arglists ([& args])\n             :doc \"  Loads libs, skipping any that are already loaded. Each argument is\n  either a libspec that identifies a lib or a flag that modifies how all the identified\n  libs are loaded. Use :require in the ns macro in preference to calling this\n  directly.\n\n  Libs\n\n  A 'lib' is a named set of resources in classpath whose contents define a\n  library of ClojureScript code. Lib names are symbols and each lib is associated\n  with a ClojureScript namespace. A lib's name also locates its root directory\n  within classpath using Java's package name to classpath-relative path mapping.\n  All resources in a lib should be contained in the directory structure under its\n  root directory. All definitions a lib makes should be in its associated namespace.\n\n  'require loads a lib by loading its root resource. The root resource path\n  is derived from the lib name in the following manner:\n  Consider a lib named by the symbol 'x.y.z; it has the root directory\n  <classpath>/x/y/, and its root resource is <classpath>/x/y/z.clj. The root\n  resource should contain code to create the lib's namespace (usually by using\n  the ns macro) and load any additional lib resources.\n\n  Libspecs\n\n  A libspec is a lib name or a vector containing a lib name followed by\n  options expressed as sequential keywords and arguments.\n\n  Recognized options:\n  :as takes a symbol as its argument and makes that symbol an alias to the\n    lib's namespace in the current namespace.\n  :refer takes a list of symbols to refer from the namespace..\n  :refer-macros takes a list of macro symbols to refer from the namespace.\n  :include-macros true causes macros from the namespace to be required.\n\n  Flags\n\n  A flag is a keyword.\n  Recognized flags: :reload, :reload-all, :verbose\n  :reload forces loading of all the identified libs even if they are\n    already loaded\n  :reload-all implies :reload and also forces loading of all libs that the\n    identified libs directly or indirectly load via require or use\n  :verbose triggers printing information about each load, alias, and refer\n\n  Example:\n\n  The following would load the library clojure.string :as string.\n\n  (require '[clojure/string :as string])\"}\n    require-macros {:arglists ([& args])\n                    :doc \"Similar to the require REPL special function but\n    only for macros.\"}\n    import {:arglists ([& import-symbols-or-lists])\n            :doc \"import-list => (closure-namespace constructor-name-symbols*)\n\n  For each name in constructor-name-symbols, adds a mapping from name to the\n  constructor named by closure-namespace to the current namespace. Use :import in the ns\n  macro in preference to calling this directly.\"}\n    load-file {:arglists ([name])\n               :doc \"Sequentially read and evaluate the set of forms contained in the file.\"}})",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.7.228",
                                                      :filename "src/main/clojure/cljs/repl.cljc",
                                                      :lines [1080
                                                              1142]},
                                             :full-name "cljs.repl/repl-special-doc-map",
                                             :full-name-encode "cljs.repl/repl-special-doc-map",
                                             :history [["+"
                                                        "0.0-3058"]]},
           "cljs.core/fn" {:description "Defines a function.\n\n`name?` is an optional name of the function to be used inside `body`. This is\nuseful for recursive calls. Note that `name?` in `fn` is not the same as the\n`name` argument to `defn`, which defines a global symbol for the function.\n\n`params*` are the arguments to the function and a binding form for the symbols\nthat the arguments will take inside the body of the function. Functions can have\narity of 0-20 and there is no runtime enforcement of arity when calling a\nfunction (just like in JavaScript).\n\n`prepost-map?` is an optional map with optional keys `:pre` and `:post` that\ncontain collections of [pre or post conditions](http://blog.fogus.me/2009/12/21/clojures-pre-and-post/)\nfor the function.\n\n`body` is a series of expressions that execute when the function is called. The\narguments to the function are mapped to symbols in `params*` and are available\nin `body`. The value of the last expression in `body` is the return value of\ncalling the function.",
                           :ns "cljs.core",
                           :name "fn",
                           :signature ["[name? [params*] prepost-map? body]"
                                       "[name? ([params*] prepost-map? body)+]"],
                           :history [["+" "0.0-927"]],
                           :type "macro",
                           :related ["cljs.core/defn"
                                     "cljs.core/defn-"],
                           :full-name-encode "cljs.core/fn",
                           :source {:code "(defmacro fn\n  [& sigs]\n    (let [name (if (symbol? (first sigs)) (first sigs) nil)\n          sigs (if name (next sigs) sigs)\n          sigs (if (vector? (first sigs)) \n                 (list sigs) \n                 (if (seq? (first sigs))\n                   sigs\n                   ;; Assume single arity syntax\n                   (throw (IllegalArgumentException. \n                            (if (seq sigs)\n                              (str \"Parameter declaration \" \n                                   (first sigs)\n                                   \" should be a vector\")\n                              (str \"Parameter declaration missing\"))))))\n          psig (fn* [sig]\n                 ;; Ensure correct type before destructuring sig\n                 (when (not (seq? sig))\n                   (throw (IllegalArgumentException.\n                            (str \"Invalid signature \" sig\n                                 \" should be a list\"))))\n                 (let [[params & body] sig\n                       _ (when (not (vector? params))\n                           (throw (IllegalArgumentException. \n                                    (if (seq? (first sigs))\n                                      (str \"Parameter declaration \" params\n                                           \" should be a vector\")\n                                      (str \"Invalid signature \" sig\n                                           \" should be a list\")))))\n                       conds (when (and (next body) (map? (first body))) \n                                           (first body))\n                       body (if conds (next body) body)\n                       conds (or conds (meta params))\n                       pre (:pre conds)\n                       post (:post conds)                       \n                       body (if post\n                              `((let [~'% ~(if (< 1 (count body)) \n                                            `(do ~@body) \n                                            (first body))]\n                                 ~@(map (fn* [c] `(assert ~c)) post)\n                                 ~'%))\n                              body)\n                       body (if pre\n                              (concat (map (fn* [c] `(assert ~c)) pre) \n                                      body)\n                              body)]\n                   (maybe-destructured params body)))\n          new-sigs (map psig sigs)]\n      (with-meta\n        (if name\n          (list* 'fn* name new-sigs)\n          (cons 'fn* new-sigs))\n        (meta &form))))",
                                    :title "Source code",
                                    :repo "clojure",
                                    :tag "clojure-1.7.0",
                                    :filename "src/clj/clojure/core.clj",
                                    :lines [4333 4393]},
                           :full-name "cljs.core/fn",
                           :clj-symbol "clojure.core/fn",
                           :docstring "params => positional-params* , or positional-params* & next-param\npositional-param => binding-form\nnext-param => binding-form\nname => symbol\n\nDefines a function"},
           "cljs.core/split-with" {:description "Returns a vector of `[(take-while pred coll) (drop-while pred coll)]`",
                                   :ns "cljs.core",
                                   :name "split-with",
                                   :signature ["[pred coll]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/split-at"
                                             "clojure.string/split"
                                             "cljs.core/take-while"
                                             "cljs.core/drop-while"],
                                   :full-name-encode "cljs.core/split-with",
                                   :source {:code "(defn split-with\n  [pred coll]\n  [(take-while pred coll) (drop-while pred coll)])",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [8559 8562]},
                                   :full-name "cljs.core/split-with",
                                   :clj-symbol "clojure.core/split-with",
                                   :docstring "Returns a vector of [(take-while pred coll) (drop-while pred coll)]"},
           "cljs.pprint/formatter-out" {:ns "cljs.pprint",
                                        :name "formatter-out",
                                        :signature ["[format-in]"],
                                        :history [["+" "0.0-3255"]],
                                        :type "macro",
                                        :full-name-encode "cljs.pprint/formatter-out",
                                        :source {:code "(defmacro formatter-out\n  [format-in]\n  `(let [format-in# ~format-in\n         cf# (if (string? format-in#) (cljs.pprint/cached-compile format-in#) format-in#)]\n     (fn [& args#]\n       (let [navigator# (cljs.pprint/init-navigator args#)]\n         (cljs.pprint/execute-format cf# navigator#)))))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/cljs/cljs/pprint.clj",
                                                 :lines [133 145]},
                                        :full-name "cljs.pprint/formatter-out",
                                        :clj-symbol "clojure.pprint/formatter-out",
                                        :docstring "Makes a function which can directly run format-in. The function is\nfn [& args] ... and returns nil. This version of the formatter macro is\ndesigned to be used with *out* set to an appropriate Writer. In particular,\nthis is meant to be used as part of a pretty printer dispatch method.\n\nformat-in can be either a control string or a previously compiled format."},
           "cljs.js/eval-str" {:ns "cljs.js",
                               :name "eval-str",
                               :signature ["[state source cb]"
                                           "[state source name cb]"
                                           "[state source name opts cb]"],
                               :history [["+" "1.7.10"]],
                               :type "function",
                               :full-name-encode "cljs.js/eval-str",
                               :source {:code "(defn eval-str\n  ([state source cb]\n   (eval-str state source nil cb))\n  ([state source name cb]\n   (eval-str state source name nil cb))\n  ([state source name opts cb]\n   {:pre [(atom? state) (string? source)\n          (valid-name? name) (valid-opts? opts) (fn? cb)]}\n   (eval-str*\n     {:*compiler*     state\n      :*data-readers* tags/*cljs-data-readers*\n      :*analyze-deps* (or (:analyze-deps opts) true)\n      :*load-macros*  (or (:load-macros opts) true)\n      :*load-fn*      (or (:load opts) *load-fn*)\n      :*eval-fn*      (or (:eval opts) *eval-fn*)}\n     source name opts cb)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/js.cljs",
                                        :lines [767 811]},
                               :full-name "cljs.js/eval-str",
                               :docstring "Evalute ClojureScript source given as a string. The parameters:\n\nstate (atom)\n  the compiler state\n\nsource (string)\n  the ClojureScript source\n\nname (symbol)\n  optional, the name of the source\n\nopts (map)\n  compilation options.\n\n  :eval         - eval function to invoke, see *eval-fn*\n  :load         - library resolution function, see *load-fn*\n  :source-map   - set to true to generate inline source map information\n  :cache-source - optional, a function to run side-effects with the\n                  compilation result prior to actual evalution. This function\n                  takes two arguments, the first is the eval map, the source\n                  will be under :source. The second argument is a callback of\n                  one argument. If an error occurs an :error key should be\n                  supplied.\n\ncb (function)\n  callback, will be invoked with a map. If succesful the map will contain\n  a :value key with the result of evaluation and :ns the current namespace.\n  If unsuccessful will contain a :error key with an ex-info instance describing\n  the cause of failure."},
           "cljs.pprint/pp" {:ns "cljs.pprint",
                             :name "pp",
                             :signature ["[]"],
                             :history [["+" "0.0-3255"]],
                             :type "macro",
                             :full-name-encode "cljs.pprint/pp",
                             :source {:code "(defmacro pp\n  [] `(cljs.pprint/pprint *1))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/pprint.clj",
                                      :lines [153 157]},
                             :full-name "cljs.pprint/pp",
                             :clj-symbol "clojure.pprint/pp",
                             :docstring "A convenience macro that pretty prints the last thing output. This is\nexactly equivalent to (pprint *1)."},
           "cljs.core/IWriter" {:ns "cljs.core",
                                :name "IWriter",
                                :history [["+" "0.0-1503"]],
                                :type "protocol",
                                :full-name-encode "cljs.core/IWriter",
                                :source {:code "(defprotocol IWriter\n  \"Protocol for writing. Currently only implemented by StringBufferWriter.\"\n  (-write [writer s]\n    \"Writes s with writer and returns the result.\")\n  (-flush [writer]\n    \"Flush writer.\"))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [636 641]},
                                :methods [{:name "-write",
                                           :signature ["[writer s]"],
                                           :docstring "Writes s with writer and returns the result."}
                                          {:name "-flush",
                                           :signature ["[writer]"],
                                           :docstring "Flush writer."}],
                                :full-name "cljs.core/IWriter",
                                :docstring "Protocol for writing. Currently only implemented by StringBufferWriter."},
           "cljs.repl.browser/preloaded-libs" {:ns "cljs.repl.browser",
                                               :name "preloaded-libs",
                                               :type "var",
                                               :source {:code "(def preloaded-libs (atom #{}))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r3058",
                                                        :filename "src/clj/cljs/repl/browser.clj",
                                                        :lines [28]},
                                               :full-name "cljs.repl.browser/preloaded-libs",
                                               :full-name-encode "cljs.repl.browser/preloaded-libs",
                                               :history [["+"
                                                          "0.0-1424"]
                                                         ["-"
                                                          "0.0-3115"]],
                                               :removed {:in "0.0-3115",
                                                         :last-seen "0.0-3058"}},
           "cljs.core/IReduce" {:ns "cljs.core",
                                :name "IReduce",
                                :history [["+" "0.0-927"]],
                                :type "protocol",
                                :full-name-encode "cljs.core/IReduce",
                                :source {:code "(defprotocol IReduce\n  \"Protocol for seq types that can reduce themselves.\n  Called by cljs.core/reduce.\"\n  (-reduce [coll f] [coll f start]\n    \"f should be a function of 2 arguments. If start is not supplied,\n     returns the result of applying f to the first 2 items in coll, then\n     applying f to that result and the 3rd item, etc.\"))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [575 581]},
                                :methods [{:name "-reduce",
                                           :signature ["[coll f]"
                                                       "[coll f start]"],
                                           :docstring "f should be a function of 2 arguments. If start is not supplied,\n     returns the result of applying f to the first 2 items in coll, then\n     applying f to that result and the 3rd item, etc."}],
                                :full-name "cljs.core/IReduce",
                                :clj-symbol "clojure.lang/IReduce",
                                :docstring "Protocol for seq types that can reduce themselves.\n  Called by cljs.core/reduce."},
           "cljs.reader/symbol-pattern" {:ns "cljs.reader",
                                         :name "symbol-pattern",
                                         :type "var",
                                         :source {:code "(def symbol-pattern (re-pattern \"^[:]?([^0-9/].*/)?([^0-9/][^/]*)$\"))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.7.228",
                                                  :filename "src/main/cljs/cljs/reader.cljs",
                                                  :lines [101]},
                                         :full-name "cljs.reader/symbol-pattern",
                                         :full-name-encode "cljs.reader/symbol-pattern",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/PersistentHashSet.fromArray" {:ns "cljs.core",
                                                    :name "PersistentHashSet.fromArray",
                                                    :signature ["[items no-clone]"],
                                                    :history [["+"
                                                               "0.0-1443"]],
                                                    :parent-type "PersistentHashSet",
                                                    :type "function",
                                                    :full-name-encode "cljs.core/PersistentHashSetDOTfromArray",
                                                    :source {:code "(set! (.-fromArray PersistentHashSet)\n  (fn [items ^boolean no-clone]\n    (let [len (alength items)]\n      (if (<= len (.-HASHMAP-THRESHOLD PersistentArrayMap))\n        (let [arr (if no-clone items (aclone items))]\n          (loop [i 0\n                 out (transient (.-EMPTY PersistentArrayMap))]\n            (if (< i len)\n              (recur (inc i) (-assoc! out (aget items i) nil))\n              (PersistentHashSet. nil (-persistent! out) nil))))\n       (loop [i 0\n              out (transient (.-EMPTY PersistentHashSet))]\n         (if (< i len)\n           (recur (inc i) (-conj! out (aget items i)))\n           (-persistent! out)))))))",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r1.7.228",
                                                             :filename "src/main/cljs/cljs/core.cljs",
                                                             :lines [8057
                                                                     8071]},
                                                    :full-name "cljs.core/PersistentHashSet.fromArray"},
           "cljs.core/repeatedly" {:description "Takes a function `f` of no args, presumably with side effects, and returns an\ninfinite (or length `n` if supplied) lazy sequence of calls to it.",
                                   :ns "cljs.core",
                                   :name "repeatedly",
                                   :signature ["[f]" "[n f]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/repeat"
                                             "cljs.core/iterate"
                                             "cljs.core/lazy-seq"
                                             "cljs.core/dotimes"
                                             "cljs.core/constantly"],
                                   :full-name-encode "cljs.core/repeatedly",
                                   :source {:code "(defn repeatedly\n  ([f] (lazy-seq (cons (f) (repeatedly f))))\n  ([n f] (take n (repeatedly f))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [4354 4359]},
                                   :full-name "cljs.core/repeatedly",
                                   :clj-symbol "clojure.core/repeatedly",
                                   :docstring "Takes a function of no args, presumably with side effects, and\nreturns an infinite (or length n if supplied) lazy sequence of calls\nto it"},
           "cljs.build.api/mark-cljs-ns-for-recompile!" {:ns "cljs.build.api",
                                                         :name "mark-cljs-ns-for-recompile!",
                                                         :signature ["[ns-sym]"
                                                                     "[ns-sym output-dir]"],
                                                         :history [["+"
                                                                    "0.0-2496"]],
                                                         :type "function",
                                                         :full-name-encode "cljs.build.api/mark-cljs-ns-for-recompileBANG",
                                                         :source {:code "(defn mark-cljs-ns-for-recompile!\n  ([ns-sym] (mark-cljs-ns-for-recompile! ns-sym nil))\n  ([ns-sym output-dir]\n    (let [s (target-file-for-cljs-ns ns-sym output-dir)]\n      (when (.exists s)\n        (.setLastModified s 5000)))))",
                                                                  :title "Source code",
                                                                  :repo "clojurescript",
                                                                  :tag "r1.7.228",
                                                                  :filename "src/main/clojure/cljs/build/api.clj",
                                                                  :lines [41
                                                                          47]},
                                                         :full-name "cljs.build.api/mark-cljs-ns-for-recompile!",
                                                         :docstring "Backdates a cljs target file so that it the cljs compiler will recompile it."},
           "cljs.repl.browser/parse-stacktrace" {:ns "cljs.repl.browser",
                                                 :name "parse-stacktrace",
                                                 :signature ["[repl-env st err opts]"],
                                                 :history [["+"
                                                            "0.0-3053"]
                                                           ["-"
                                                            "1.7.10"]],
                                                 :type "multimethod",
                                                 :full-name-encode "cljs.repl.browser/parse-stacktrace",
                                                 :source {:code "(defmulti parse-stacktrace (fn [repl-env st err opts] (:ua-product err)))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r3308",
                                                          :filename "src/main/clojure/cljs/repl/browser.clj",
                                                          :lines [206]},
                                                 :extra-sources ({:code "(defmethod parse-stacktrace :default\n  [repl-env st err opts] st)",
                                                                  :title "Dispatch method",
                                                                  :repo "clojurescript",
                                                                  :tag "r3308",
                                                                  :filename "src/main/clojure/cljs/repl/browser.clj",
                                                                  :lines [208
                                                                          209]}
                                                                 {:code "(defmethod parse-stacktrace :chrome\n  [repl-env st err opts]\n  (->> st\n    string/split-lines\n    (drop-while #(.startsWith % \"Error\"))\n    (take-while #(not (.startsWith % \"    at eval\")))\n    (map #(chrome-st-el->frame repl-env % opts))\n    (remove nil?)\n    vec))",
                                                                  :title "Dispatch method",
                                                                  :repo "clojurescript",
                                                                  :tag "r3308",
                                                                  :filename "src/main/clojure/cljs/repl/browser.clj",
                                                                  :lines [273
                                                                          281]}
                                                                 {:code "(defmethod parse-stacktrace :safari\n  [repl-env st err opts]\n  (->> st\n    string/split-lines\n    (drop-while #(.startsWith % \"Error\"))\n    (take-while #(not (.startsWith % \"eval code\")))\n    (remove string/blank?)\n    (map #(safari-st-el->frame repl-env % opts))\n    (remove nil?)\n    vec))",
                                                                  :title "Dispatch method",
                                                                  :repo "clojurescript",
                                                                  :tag "r3308",
                                                                  :filename "src/main/clojure/cljs/repl/browser.clj",
                                                                  :lines [343
                                                                          352]}
                                                                 {:code "(defmethod parse-stacktrace :firefox\n  [repl-env st err opts]\n  (->> st\n    string/split-lines\n    (drop-while #(.startsWith % \"Error\"))\n    (take-while #(= (.indexOf % \"> eval\") -1))\n    (remove string/blank?)\n    (map #(firefox-st-el->frame repl-env % opts))\n    (remove nil?)\n    vec))",
                                                                  :title "Dispatch method",
                                                                  :repo "clojurescript",
                                                                  :tag "r3308",
                                                                  :filename "src/main/clojure/cljs/repl/browser.clj",
                                                                  :lines [438
                                                                          447]}),
                                                 :full-name "cljs.repl.browser/parse-stacktrace",
                                                 :removed {:in "1.7.10",
                                                           :last-seen "0.0-3308"}},
           "cljs.js/ns-side-effects" {:ns "cljs.js",
                                      :name "ns-side-effects",
                                      :signature ["[bound-vars ana-env ast opts cb]"
                                                  "[load bound-vars ana-env {:keys [op], :as ast} opts cb]"],
                                      :history [["+" "1.7.10"]
                                                ["-" "1.7.28"]],
                                      :type "function",
                                      :full-name-encode "cljs.js/ns-side-effects",
                                      :source {:code "(defn ns-side-effects\n  ([bound-vars ana-env ast opts cb]\n    (ns-side-effects false bound-vars ana-env ast opts cb))\n  ([load bound-vars ana-env {:keys [op] :as ast} opts cb]\n   (when (:verbose opts)\n     (debug-prn \"Namespace side effects for\" (:name ast)))\n   (if (= :ns op)\n     (let [{:keys [deps uses requires require-macros use-macros reload reloads]} ast\n           env (:*compiler* bound-vars)]\n       (letfn [(check-uses-and-load-macros [res]\n                 (if (:error res)\n                   (cb res)\n                   (let [res (try\n                               (when (and (:*analyze-deps* bound-vars) (seq uses))\n                                 (when (:verbose opts) (debug-prn \"Checking uses\"))\n                                 (ana/check-uses uses env)\n                                 {:value nil})\n                               (catch :default cause\n                                 (wrap-error\n                                   (ana/error ana-env\n                                     (str \"Could not parse ns form \" (:name ast)) cause))))]\n                     (if (:error res)\n                       (cb res)\n                       (if (:*load-macros* bound-vars)\n                         (do\n                           (when (:verbose opts) (debug-prn \"Processing :use-macros for\" (:name ast)))\n                           (load-macros bound-vars :use-macros use-macros reload reloads opts\n                             (fn [res]\n                               (if (:error res)\n                                 (cb res)\n                                 (do\n                                   (when (:verbose opts) (debug-prn \"Processing :require-macros for\" (:name ast)))\n                                   (load-macros bound-vars :require-macros require-macros reloads reloads opts\n                                     (fn [res]\n                                       (if (:error res)\n                                         (cb res)\n                                         (let [res (try\n                                                     (when (seq use-macros)\n                                                       (when (:verbose opts) (debug-prn \"Checking :use-macros for\" (:name ast)))\n                                                       (ana/check-use-macros use-macros env))\n                                                     {:value nil}\n                                                     (catch :default cause\n                                                       (wrap-error\n                                                         (ana/error ana-env\n                                                           (str \"Could not parse ns form \" (:name ast)) cause))))]\n                                           (if (:error res)\n                                             (cb res)\n                                             (cb {:value ast})))))))))))\n                        (cb {:value ast}))))))]\n         (cond\n           (and load (seq deps))\n           (load-deps bound-vars ana-env (:name ast) deps (dissoc opts :macros-ns)\n             check-uses-and-load-macros)\n\n           (and (not load) (:*analyze-deps* bound-vars) (seq deps))\n           (analyze-deps bound-vars ana-env (:name ast) deps (dissoc opts :macros-ns)\n             check-uses-and-load-macros)\n\n           :else\n           (check-uses-and-load-macros {:value nil}))))\n     (cb {:value ast}))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.10",
                                               :filename "src/main/cljs/cljs/js.cljs",
                                               :lines [317 377]},
                                      :full-name "cljs.js/ns-side-effects",
                                      :removed {:in "1.7.28",
                                                :last-seen "1.7.10"}},
           "cljs.reader/read-delimited-list" {:ns "cljs.reader",
                                              :name "read-delimited-list",
                                              :type "function",
                                              :signature ["[delim rdr recursive?]"],
                                              :source {:code "(defn read-delimited-list\n  [delim rdr recursive?]\n  (loop [a (transient [])]\n    (let [ch (read-past whitespace? rdr)]\n      (when-not ch (reader-error rdr \"EOF while reading\"))\n      (if (identical? delim ch)\n        (persistent! a)\n        (if-let [macrofn (macros ch)]\n          (let [mret (macrofn rdr ch)]\n            (recur (if (identical? mret rdr) a (conj! a mret))))\n          (do\n            (unread rdr ch)\n            (let [o (read rdr true nil recursive?)]\n              (recur (if (identical? o rdr) a (conj! a o))))))))))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.7.228",
                                                       :filename "src/main/cljs/cljs/reader.cljs",
                                                       :lines [225
                                                               238]},
                                              :full-name "cljs.reader/read-delimited-list",
                                              :full-name-encode "cljs.reader/read-delimited-list",
                                              :history [["+"
                                                         "0.0-927"]]},
           "cljs.test/inc-report-counter!" {:ns "cljs.test",
                                            :name "inc-report-counter!",
                                            :signature ["[name]"],
                                            :history [["+" "0.0-2496"]],
                                            :type "function",
                                            :full-name-encode "cljs.test/inc-report-counterBANG",
                                            :source {:code "(defn inc-report-counter!\n  [name]\n  (if (:report-counters (get-current-env))\n    (update-current-env! [:report-counters name] (fnil inc 0))))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.7.228",
                                                     :filename "src/main/cljs/cljs/test.cljs",
                                                     :lines [305 310]},
                                            :full-name "cljs.test/inc-report-counter!",
                                            :docstring "Increments the named counter in *report-counters*, a ref to a map.\nDoes nothing if *report-counters* is nil."},
           "cljs.core/undefined?" {:return-type boolean,
                                   :ns "cljs.core",
                                   :name "undefined?",
                                   :signature ["[x]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function/macro",
                                   :full-name-encode "cljs.core/undefinedQMARK",
                                   :source {:code "(defn ^boolean undefined?\n  [x]\n  (cljs.core/undefined? x))",
                                            :title "Function code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [1990 1993]},
                                   :extra-sources [{:code "(core/defmacro undefined?\n  [x]\n  (bool-expr (core/list 'js* \"(void 0 === ~{})\" x)))",
                                                    :title "Macro code",
                                                    :repo "clojurescript",
                                                    :tag "r1.7.228",
                                                    :filename "src/main/clojure/cljs/core.cljc",
                                                    :lines [916 919]}],
                                   :full-name "cljs.core/undefined?",
                                   :docstring "Returns true if x identical to the JavaScript undefined value."},
           "clojure.zip/prev" {:ns "clojure.zip",
                               :name "prev",
                               :signature ["[loc]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip/prev",
                               :source {:code "(defn prev\n  [loc]\n    (if-let [lloc (left loc)]\n      (loop [loc lloc]\n        (if-let [child (and (branch? loc) (down loc))]\n          (recur (rightmost child))\n          loc))\n      (up loc)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/clojure/zip.cljs",
                                        :lines [221 230]},
                               :full-name "clojure.zip/prev",
                               :clj-symbol "clojure.zip/prev",
                               :docstring "Moves to the previous loc in the hierarchy, depth-first. If already\nat the root, returns nil."},
           "cljs.core/seq?" {:description "Returns true if `x` is a sequence, false otherwise.\n\nAll collections can be converted into a sequence using `seq`.",
                             :return-type boolean,
                             :ns "cljs.core",
                             :name "seq?",
                             :signature ["[x]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/seq"
                                       "cljs.core/sequential?"
                                       "cljs.core/vector?"
                                       "cljs.core/coll?"
                                       "cljs.core/list?"
                                       "cljs.core/map?"
                                       "cljs.core/set?"],
                             :full-name-encode "cljs.core/seqQMARK",
                             :source {:code "(defn ^boolean seq?\n  [s]\n  (if (nil? s)\n    false\n    (satisfies? ISeq s)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [1995 2000]},
                             :full-name "cljs.core/seq?",
                             :clj-symbol "clojure.core/seq?",
                             :docstring "Return true if s satisfies ISeq"},
           "cljs.repl.browser/browser-state" {:ns "cljs.repl.browser",
                                              :name "browser-state",
                                              :type "dynamic var",
                                              :source {:code "(def ^:dynamic browser-state nil)",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.7.228",
                                                       :filename "src/main/clojure/cljs/repl/browser.clj",
                                                       :lines [24]},
                                              :full-name "cljs.repl.browser/browser-state",
                                              :full-name-encode "cljs.repl.browser/browser-state",
                                              :history [["+"
                                                         "0.0-1503"]]},
           "cljs.pprint/formatter" {:ns "cljs.pprint",
                                    :name "formatter",
                                    :signature ["[format-in]"],
                                    :history [["+" "0.0-3255"]],
                                    :type "macro",
                                    :full-name-encode "cljs.pprint/formatter",
                                    :source {:code "(defmacro formatter\n  [format-in]\n  `(let [format-in# ~format-in\n         my-c-c# cljs.pprint/cached-compile\n         my-e-f# cljs.pprint/execute-format\n         my-i-n# cljs.pprint/init-navigator\n         cf# (if (string? format-in#) (my-c-c# format-in#) format-in#)]\n     (fn [stream# & args#]\n       (let [navigator# (my-i-n# args#)]\n         (my-e-f# stream# cf# navigator#)))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/pprint.clj",
                                             :lines [117 131]},
                                    :full-name "cljs.pprint/formatter",
                                    :clj-symbol "clojure.pprint/formatter",
                                    :docstring "Makes a function which can directly run format-in. The function is\nfn [stream & args] ... and returns nil unless the stream is nil (meaning\noutput to a string) in which case it returns the resulting string.\n\nformat-in can be either a control string or a previously compiled format."},
           "cljs.core/prn-str" {:ns "cljs.core",
                                :name "prn-str",
                                :signature ["[& objs]"],
                                :history [["+" "0.0-1011"]],
                                :type "function",
                                :full-name-encode "cljs.core/prn-str",
                                :source {:code "(defn prn-str\n  [& objs]\n  (prn-str-with-opts objs (pr-opts)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [8936 8939]},
                                :full-name "cljs.core/prn-str",
                                :clj-symbol "clojure.core/prn-str",
                                :docstring "Same as pr-str followed by (newline)"},
           "cljs.core/chunk-buffer" {:ns "cljs.core",
                                     :name "chunk-buffer",
                                     :type "function",
                                     :signature ["[capacity]"],
                                     :source {:code "(defn chunk-buffer [capacity]\n  (ChunkBuffer. (make-array capacity) 0))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/cljs/cljs/core.cljs",
                                              :lines [3089 3090]},
                                     :full-name "cljs.core/chunk-buffer",
                                     :full-name-encode "cljs.core/chunk-buffer",
                                     :history [["+" "0.0-1424"]]},
           "cljs.core/odd?" {:description "Returns true if `n` is an odd number.\n\nThrows an exception if `n` is not an integer.",
                             :return-type boolean,
                             :ns "cljs.core",
                             :name "odd?",
                             :signature ["[n]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/even?"],
                             :full-name-encode "cljs.core/oddQMARK",
                             :source {:code "(defn ^boolean odd?\n  [n] (not (even? n)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [3788 3790]},
                             :full-name "cljs.core/odd?",
                             :clj-symbol "clojure.core/odd?",
                             :docstring "Returns true if n is odd, throws an exception if n is not an integer"},
           "cljs.core/cons" {:description "Returns a new sequence where `x` is the first element and `coll` is the rest.",
                             :ns "cljs.core",
                             :name "cons",
                             :signature ["[x coll]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/conj"],
                             :full-name-encode "cljs.core/cons",
                             :source {:code "(defn cons\n  [x coll]\n  (if (or (nil? coll)\n          (implements? ISeq coll))\n    (Cons. nil x coll nil)\n    (Cons. nil x (seq coll) nil)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [2907 2913]},
                             :examples [{:id "68c769",
                                         :content "```clj\n(cons 1 (list 1 2 3))\n;;=> (1 1 2 3)\n\n(cons 1 [1 2 3])\n;;=> (1 1 2 3)\n\n(cons 1 nil)\n;;=> (1)\n\n(cons nil nil)\n;;=> (nil)\n```"}],
                             :full-name "cljs.core/cons",
                             :clj-symbol "clojure.core/cons",
                             :docstring "Returns a new seq where x is the first element and seq is the rest."},
           "syntax/function" {:description "Shorthand for creating an anonymous function:\n\n`#(...)` = `(fn [args] (...))`\n\nUse the following to access the implicit function arguments:\n\n- `%` or `%1` for first argument.\n- `%2`, `%3` and so on for subsequent arguments\n- `%&` for the rest of the arguments after the highest individually referenced argument\n\nNote that `#(1)` does not create a function that returns `1`, for the same\nreason that `(1)` does evaluate to `1`.\n\n`#()` forms cannot be nested, since this would create an ambiguity between the\nautomatically assigned `%` argument names.",
                              :ns "syntax",
                              :name "function",
                              :history [["+" "0.0-927"]],
                              :type "syntax",
                              :related ["syntax/arg"
                                        "cljs.core/fn"
                                        "cljs.core/defn"
                                        "cljs.core/partial"],
                              :full-name-encode "syntax/function",
                              :extra-sources ({:code "(defn- read-fn\n  [rdr _ opts pending-forms]\n  (if (thread-bound? #'arg-env)\n    (throw (IllegalStateException. \"Nested #()s are not allowed\")))\n  (binding [arg-env (sorted-map)]\n    (let [form (read* (doto rdr (unread \\()) true nil opts pending-forms) ;; this sets bindings\n          rargs (rseq arg-env)\n          args (if rargs\n                 (let [higharg (key (first rargs))]\n                   (let [args (loop [i 1 args (transient [])]\n                                (if (> i higharg)\n                                  (persistent! args)\n                                  (recur (inc i) (conj! args (or (get arg-env i)\n                                                                 (garg i))))))\n                         args (if (arg-env -1)\n                                (conj args '& (arg-env -1))\n                                args)]\n                     args))\n                 [])]\n      (list 'fn* args form))))",
                                               :title "Reader code",
                                               :repo "tools.reader",
                                               :tag "tools.reader-1.0.0-alpha1",
                                               :filename "src/main/clojure/clojure/tools/reader.clj",
                                               :lines [524 543]}
                                              {:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    \\? read-cond\n    nil))",
                                               :title "Reader table",
                                               :repo "tools.reader",
                                               :tag "tools.reader-1.0.0-alpha1",
                                               :filename "src/main/clojure/clojure/tools/reader.clj",
                                               :lines [764 776]}),
                              :usage ["#(...)"],
                              :examples [{:id "6a87de",
                                          :content "```clj\n(map #(* 2 %) [1 2 3])\n;;=> (2 4 6)\n\n(def f #(println %1 %2 %&))\n(f 1 2 3 4 5)\n;; prints: 1 2 (3 4 5)\n```"}],
                              :full-name "syntax/function",
                              :display "#() function",
                              :clj-doc "http://clojure.org/reader#toc2"},
           "special/deftype*" {:ns "special",
                               :name "deftype*",
                               :type "special form",
                               :source {:code "(defmethod parse 'deftype*\n  [_ env form _ _]\n  (parse-type :deftype* env form))",
                                        :title "Parser code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/clojure/cljs/analyzer.cljc",
                                        :lines [2014 2016]},
                               :full-name "special/deftype*",
                               :full-name-encode "special/deftypeSTAR",
                               :history [["+" "0.0-927"]]},
           "cljs.reader/read-set" {:ns "cljs.reader",
                                   :name "read-set",
                                   :type "function",
                                   :signature ["[rdr _]"],
                                   :source {:code "(defn read-set\n  [rdr _]\n  (set (read-delimited-list \"}\" rdr true)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/cljs/reader.cljs",
                                            :lines [396 398]},
                                   :full-name "cljs.reader/read-set",
                                   :full-name-encode "cljs.reader/read-set",
                                   :history [["+" "0.0-927"]]},
           "cljs.core/descendants" {:ns "cljs.core",
                                    :name "descendants",
                                    :signature ["[tag]" "[h tag]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :related ["cljs.core/ancestors"
                                              "cljs.core/isa?"
                                              "cljs.core/make-hierarchy"
                                              "cljs.core/derive"],
                                    :full-name-encode "cljs.core/descendants",
                                    :source {:code "(defn descendants\n  ([tag] (descendants @(get-global-hierarchy) tag))\n  ([h tag] (not-empty (get (:descendants h) tag))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [9483 9490]},
                                    :full-name "cljs.core/descendants",
                                    :clj-symbol "clojure.core/descendants",
                                    :docstring "Returns the immediate and indirect children of tag, through a\nrelationship established via derive. h must be a hierarchy obtained\nfrom make-hierarchy, if not supplied defaults to the global\nhierarchy. Note: does not work on JavaScript type inheritance\nrelationships."},
           "syntax/nil" {:description "`nil` is a representation of nothing.\n\nIt is common for operations to safely handle `nil` without\ncausing exceptions.\n\nExpressions evaluate to `nil` if there is no value to return.",
                         :ns "syntax",
                         :name "nil",
                         :history [["+" "0.0-927"]],
                         :type "special symbol",
                         :full-name-encode "syntax/nil",
                         :extra-sources [{:code "(defn- read-symbol\n  [rdr initch]\n  (let [[line column] (starting-line-col-info rdr)]\n    (when-let [token (read-token rdr initch)]\n      (case token\n\n        ;; special symbols\n        \"nil\" nil\n        \"true\" true\n        \"false\" false\n        \"/\" '/\n        \"NaN\" Double/NaN\n        \"-Infinity\" Double/NEGATIVE_INFINITY\n        (\"Infinity\" \"+Infinity\") Double/POSITIVE_INFINITY\n\n        (or (when-let [p (parse-symbol token)]\n              (with-meta (symbol (p 0) (p 1))\n                (when line\n                  (merge\n                   (when-let [file (get-file-name rdr)]\n                     {:file file})\n                   (let [[end-line end-column] (ending-line-col-info rdr)]\n                     {:line line\n                      :column column\n                      :end-line end-line\n                      :end-column end-column})))))\n            (reader-error rdr \"Invalid token: \" token))))))",
                                          :title "Reader code",
                                          :repo "tools.reader",
                                          :tag "tools.reader-1.0.0-alpha1",
                                          :filename "src/main/clojure/clojure/tools/reader.clj",
                                          :lines [303 329]}],
                         :examples [{:id "17b92a",
                                     :content "```clj\nnil\n;;=> nil\n```\n\n`nil` can sometimes mean \"not found\":\n\n```clj\n(:foo {})\n;;=> nil\n```\n\n`nil` can also mean that the operation didn't make sense:\n\n```clj\n(:foo nil)\n;;=> nil\n```"}],
                         :edn-doc "https://github.com/edn-format/edn#nil",
                         :full-name "syntax/nil",
                         :display "nil",
                         :clj-doc "http://clojure.org/reader#toc1"},
           "syntax/map" {:description "Creates a map.  Must contain pairs of key-values.  Keys and values can be any type.",
                         :ns "syntax",
                         :name "map",
                         :history [["+" "0.0-927"]],
                         :type "syntax",
                         :related ["cljs.core/hash-map"
                                   "cljs.core/array-map"
                                   "cljs.core/sorted-map"
                                   "cljs.core/sorted-map-by"],
                         :full-name-encode "syntax/map",
                         :extra-sources ({:code "(defn- read-map\n  [rdr _ opts pending-forms]\n  (let [[start-line start-column] (starting-line-col-info rdr)\n        the-map (read-delimited \\} rdr opts pending-forms)\n        map-count (count the-map)\n        [end-line end-column] (ending-line-col-info rdr)]\n    (when (odd? map-count)\n      (reader-error rdr \"Map literal must contain an even number of forms\"))\n    (with-meta\n      (if (zero? map-count)\n        {}\n        (RT/map (to-array the-map)))\n      (when start-line\n        (merge\n         (when-let [file (get-file-name rdr)]\n           {:file file})\n         {:line start-line\n          :column start-column\n          :end-line end-line\n          :end-column end-column})))))",
                                          :title "Reader code",
                                          :repo "tools.reader",
                                          :tag "tools.reader-1.0.0-alpha1",
                                          :filename "src/main/clojure/clojure/tools/reader.clj",
                                          :lines [238 258]}
                                         {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                          :title "Reader table",
                                          :repo "tools.reader",
                                          :tag "tools.reader-1.0.0-alpha1",
                                          :filename "src/main/clojure/clojure/tools/reader.clj",
                                          :lines [743 762]}),
                         :usage ["{...}"],
                         :examples [{:id "4696ad",
                                     :content "```clj\n{:foo 1 :bar 2}\n;;=> {:foo 1, :bar 2}\n```\n\nUse any value as a key:\n\n```clj\n(def m {[1 2] 3})\n(get m [1 2])\n;;=> 3\n```"}],
                         :edn-doc "https://github.com/edn-format/edn#maps",
                         :full-name "syntax/map",
                         :display "{} map",
                         :clj-doc "http://clojure.org/reader#toc1"},
           "special/new" {:ns "special",
                          :name "new",
                          :signature ["[Constructor. args*]"
                                      "[Constructor args*]"],
                          :history [["+" "0.0-927"]],
                          :type "special form",
                          :full-name-encode "special/new",
                          :source {:code "(defmethod parse 'new\n  [_ env [_ ctor & args :as form] _ _]\n  (when-not (symbol? ctor)\n    (throw (error env \"First arg to new must be a symbol\")))\n  (disallowing-recur\n   (let [enve (assoc env :context :expr)\n         ctorexpr (analyze enve ctor)\n         ctor-var (resolve-existing-var env ctor)\n         record-args\n         (when (and (:record ctor-var) (not (-> ctor meta :internal-ctor)))\n           (repeat 3 (analyze enve nil)))\n         argexprs (into (vec (map #(analyze enve %) args)) record-args)\n         known-num-fields (:num-fields ctor-var)\n         argc (count args)]\n     (when (and (not (-> ctor meta :internal-ctor))\n                known-num-fields (not= known-num-fields argc))\n       (warning :fn-arity env {:argc argc :ctor ctor}))\n     {:env env :op :new :form form :ctor ctorexpr :args argexprs\n      :children (into [ctorexpr] argexprs)\n      :tag (let [name (-> ctorexpr :info :name)]\n             (or ('{js/Object object\n                    js/String string\n                    js/Array  array\n                    js/Number number\n                    js/Function function\n                    js/Boolean boolean} name)\n                 name))})))",
                                   :title "Parser code",
                                   :repo "clojurescript",
                                   :tag "r1.7.228",
                                   :filename "src/main/clojure/cljs/analyzer.cljc",
                                   :lines [1544 1570]},
                          :full-name "special/new",
                          :clj-symbol "clojure.core/new",
                          :docstring "The args, if any, are evaluated from left to right, and\npassed to the JavaScript constructor. The constructed object is\nreturned."},
           "cljs.core/take-nth" {:description "Returns a lazy seq of every `n`th item in `coll`.\n\nReturns a stateful transducer when no collection is provided.",
                                 :ns "cljs.core",
                                 :name "take-nth",
                                 :signature ["[n]" "[n coll]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/take-nth",
                                 :source {:code "(defn take-nth\n  ([n]\n   {:pre [(number? n)]}\n     (fn [rf]\n       (let [ia (volatile! -1)]\n         (fn\n           ([] (rf))\n           ([result] (rf result))\n           ([result input]\n              (let [i (vswap! ia inc)]\n                (if (zero? (rem i n))\n                  (rf result input)\n                  result)))))))\n  ([n coll]\n   {:pre [(number? n)]}\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (cons (first s) (take-nth n (drop n s)))))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [8538 8557]},
                                 :full-name "cljs.core/take-nth",
                                 :clj-symbol "clojure.core/take-nth",
                                 :docstring "Returns a lazy seq of every nth item in coll.  Returns a stateful\ntransducer when no collection is provided."},
           "cljs.reader/throwing-reader" {:ns "cljs.reader",
                                          :name "throwing-reader",
                                          :type "function",
                                          :signature ["[msg]"],
                                          :source {:code "(defn throwing-reader\n  [msg]\n  (fn [rdr _]\n    (reader-error rdr msg)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/cljs/cljs/reader.cljs",
                                                   :lines [381 384]},
                                          :full-name "cljs.reader/throwing-reader",
                                          :full-name-encode "cljs.reader/throwing-reader",
                                          :history [["+" "0.0-927"]]},
           "cljs.repl.browser/send-static" {:ns "cljs.repl.browser",
                                            :name "send-static",
                                            :type "function",
                                            :signature ["[{path :path, :as request} conn opts]"],
                                            :source {:code "(defn send-static [{path :path :as request} conn opts]\n  (if (and (:static-dir opts)\n           (not= \"/favicon.ico\" path))\n    (let [path   (if (= \"/\" path) \"/index.html\" path)\n          st-dir (:static-dir opts)\n          local-path\n          (cond->\n            (seq (for [x (if (string? st-dir) [st-dir] st-dir)\n                       :when (.exists (io/file (str x path)))]\n                   (str x path)))\n            (complement nil?) first)\n          local-path\n          (if (nil? local-path)\n            (cond\n              (re-find #\".jar\" path)\n              (io/resource (second (string/split path #\".jar!/\")))\n              (re-find (Pattern/compile (System/getProperty \"user.dir\")) path)\n              (io/file (string/replace path (str (System/getProperty \"user.dir\") \"/\") \"\"))\n              :else nil)\n            local-path)]\n      (if local-path\n        (if-let [ext (some #(if (.endsWith path %) %) (keys ext->mime-type))]\n          (let [mime-type (ext->mime-type ext \"text/plain\")\n                encoding (mime-type->encoding mime-type \"UTF-8\")]\n            (server/send-and-close\n              conn\n              200\n              (slurp local-path :encoding encoding)\n              mime-type\n              encoding))\n          (server/send-and-close conn 200 (slurp local-path) \"text/plain\"))\n        (server/send-404 conn path)))\n    (server/send-404 conn path)))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.7.228",
                                                     :filename "src/main/clojure/cljs/repl/browser.clj",
                                                     :lines [92 124]},
                                            :full-name "cljs.repl.browser/send-static",
                                            :full-name-encode "cljs.repl.browser/send-static",
                                            :history [["+" "0.0-1211"]]},
           "cljs.analyzer.api/forms-seq" {:ns "cljs.analyzer.api",
                                          :name "forms-seq",
                                          :signature ["[rdr]"
                                                      "[rdr filename]"],
                                          :history [["+" "0.0-3208"]],
                                          :type "function",
                                          :full-name-encode "cljs.analyzer.api/forms-seq",
                                          :source {:code "(defn forms-seq\n  ([rdr] (ana/forms-seq* rdr nil))\n  ([rdr filename] (ana/forms-seq* rdr filename)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/clojure/cljs/analyzer/api.clj",
                                                   :lines [88 92]},
                                          :full-name "cljs.analyzer.api/forms-seq",
                                          :docstring "Seq of Clojure/ClojureScript forms from rdr, a java.io.Reader. Optionally\naccepts a filename argument which will be used in any emitted errors."},
           "cljs.core/double" {:return-type number,
                               :ns "cljs.core",
                               :name "double",
                               :signature ["[x]"],
                               :history [["+" "0.0-1798"]],
                               :type "function/macro",
                               :full-name-encode "cljs.core/double",
                               :source {:code "(defn ^number double [x] x)",
                                        :title "Function code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [2368]},
                               :extra-sources [{:code "(core/defmacro double [x] x)",
                                                :title "Macro code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/clojure/cljs/core.cljc",
                                                :lines [966]}],
                               :full-name "cljs.core/double",
                               :clj-symbol "clojure.core/double"},
           "cljs.analyzer.api/get-js-index" {:ns "cljs.analyzer.api",
                                             :name "get-js-index",
                                             :signature ["[]"
                                                         "[state]"],
                                             :history [["+" "1.7.122"]],
                                             :type "function",
                                             :full-name-encode "cljs.analyzer.api/get-js-index",
                                             :source {:code "(defn get-js-index\n  ([] (get-options env/*compiler*))\n  ([state]\n   (get @state :js-dependency-index)))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.7.228",
                                                      :filename "src/main/clojure/cljs/analyzer/api.clj",
                                                      :lines [61 66]},
                                             :full-name "cljs.analyzer.api/get-js-index",
                                             :docstring "Return the currently computed Google Closure js dependency index from the\ncompiler state."},
           "cljs.core/even?" {:description "Returns true if `n` is an even number.\n\nThrows an exception if `n` is not an integer.",
                              :return-type boolean,
                              :ns "cljs.core",
                              :name "even?",
                              :signature ["[n]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/odd?"],
                              :full-name-encode "cljs.core/evenQMARK",
                              :source {:code "(defn ^boolean even?\n   [n] (if (integer? n)\n        (zero? (bit-and n 1))\n        (throw (js/Error. (str \"Argument must be an integer: \" n)))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [3782 3786]},
                              :full-name "cljs.core/even?",
                              :clj-symbol "clojure.core/even?",
                              :docstring "Returns true if n is even, throws an exception if n is not an integer"},
           "cljs.core/simple-benchmark" {:ns "cljs.core",
                                         :name "simple-benchmark",
                                         :signature ["[bindings expr iterations & {:keys [print-fn], :or {print-fn (quote println)}}]"],
                                         :history [["+" "0.0-1236"]],
                                         :type "macro",
                                         :full-name-encode "cljs.core/simple-benchmark",
                                         :source {:code "(core/defmacro simple-benchmark\n  [bindings expr iterations & {:keys [print-fn] :or {print-fn 'println}}]\n  (core/let [bs-str   (pr-str bindings)\n             expr-str (pr-str expr)]\n    `(let ~bindings\n       (let [start#   (.getTime (js/Date.))\n             ret#     (dotimes [_# ~iterations] ~expr)\n             end#     (.getTime (js/Date.))\n             elapsed# (- end# start#)]\n         (~print-fn (str ~bs-str \", \" ~expr-str \", \"\n                      ~iterations \" runs, \" elapsed# \" msecs\"))))))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.7.228",
                                                  :filename "src/main/clojure/cljs/core.cljc",
                                                  :lines [2532 2548]},
                                         :full-name "cljs.core/simple-benchmark",
                                         :docstring "Runs expr iterations times in the context of a let expression with\nthe given bindings, then prints out the bindings and the expr\nfollowed by number of iterations and total time. The optional\nargument print-fn, defaulting to println, sets function used to\nprint the result. expr's string representation will be produced\nusing pr-str in any case."},
           "cljs.build.api/cljs-ns-dependents" {:ns "cljs.build.api",
                                                :name "cljs-ns-dependents",
                                                :signature ["[ns]"
                                                            "[state ns]"],
                                                :history [["+"
                                                           "0.0-2629"]
                                                          ["-"
                                                           "1.7.166"]],
                                                :type "function",
                                                :full-name-encode "cljs.build.api/cljs-ns-dependents",
                                                :source {:code "(defn cljs-ns-dependents\n  ([ns]\n   (cljs-ns-dependents\n     (if-not (nil? env/*compiler*)\n       env/*compiler*\n       (env/default-compiler-env))\n     ns))\n  ([state ns]\n   (env/with-compiler-env state\n     (ana/ns-dependents ns))))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1.7.145",
                                                         :filename "src/main/clojure/cljs/build/api.clj",
                                                         :lines [73
                                                                 85]},
                                                :full-name "cljs.build.api/cljs-ns-dependents",
                                                :docstring "Given a namespace symbol return a seq of all dependent\nnamespaces sorted in dependency order. Will include\ntransient dependents.",
                                                :removed {:in "1.7.166",
                                                          :last-seen "1.7.145"}},
           "syntax/number" {:description "ClojureScript numbers are the same as [JavaScript numbers],\ndouble-precision 64-bit format IEEE 754.\n\n[JavaScript numbers]:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Numbers_and_dates#Numbers\n\nAvailable formats listed below. Decimal points are not allowed when specifying\na custom base.\n\n- decimal `123` `1.23`\n- exponent `12e3` `1.2e3` `1.2e-3`\n- hexadecimal `0x123`\n- octal `0123`\n- binary `2r0110`\n- arbitrary `NrXXX` where `(<= 2 N 36)` and `X` is in `[0-9,A-Z]`",
                            :ns "syntax",
                            :name "number",
                            :history [["+" "0.0-927"]],
                            :type "syntax",
                            :related ["syntax/Infinity"
                                      "syntax/NaN"
                                      "cljs.core/number?"
                                      "cljs.core/integer?"
                                      "cljs.core/int"],
                            :full-name-encode "syntax/number",
                            :extra-sources [{:code "(defn- read-number\n  [rdr initch]\n  (loop [sb (doto (StringBuilder.) (.append initch))\n         ch (read-char rdr)]\n    (if (or (whitespace? ch) (macros ch) (nil? ch))\n      (let [s (str sb)]\n        (unread rdr ch)\n        (or (match-number s)\n            (reader-error rdr \"Invalid number format [\" s \"]\")))\n      (recur (doto sb (.append ch)) (read-char rdr)))))",
                                             :title "Reader code",
                                             :repo "tools.reader",
                                             :tag "tools.reader-1.0.0-alpha1",
                                             :filename "src/main/clojure/clojure/tools/reader.clj",
                                             :lines [260 269]}],
                            :examples [{:id "f96060",
                                        :content "```clj\n123\n;;=> 123\n\n123.45\n;;=> 123.45\n```\n\nScientific notation;\n\n```clj\n12e3\n;;=> 12000\n\n1.2e-3\n;;=> 0.0012\n```\n\nStandard hex and octal notations:\n\n```clj\n0x1f\n;;=> 31\n\n010\n;;=> 8\n```\n\nRadix notation for using up to base 36.\n\n```clj\n2r10111\n;;=> 23\n\n8r32\n;;=> 26\n\n16rFF\n;;=> 255\n\n36rZ\n;;=> 35\n```"}],
                            :edn-doc "https://github.com/edn-format/edn#integers",
                            :full-name "syntax/number",
                            :display "number literal",
                            :clj-doc "http://clojure.org/reader#toc1"},
           "cljs.core/persistent-array-map-seq" {:ns "cljs.core",
                                                 :name "persistent-array-map-seq",
                                                 :type "function",
                                                 :signature ["[arr i _meta]"],
                                                 :source {:code "(defn persistent-array-map-seq [arr i _meta]\n  (when (<= i (- (alength arr) 2))\n    (PersistentArrayMapSeq. arr i _meta)))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r1.7.228",
                                                          :filename "src/main/cljs/cljs/core.cljs",
                                                          :lines [5832
                                                                  5834]},
                                                 :full-name "cljs.core/persistent-array-map-seq",
                                                 :full-name-encode "cljs.core/persistent-array-map-seq",
                                                 :history [["+"
                                                            "0.0-1820"]]},
           "special/fn*" {:ns "special",
                          :name "fn*",
                          :type "special form",
                          :source {:code "(defmethod parse 'fn*\n  [op env [_ & args :as form] name _]\n  (let [[name meths] (if (symbol? (first args))\n                       [(first args) (next args)]\n                       [name (seq args)])\n        ;; turn (fn [] ...) into (fn ([]...))\n        meths        (if (vector? (first meths))\n                       (list meths)\n                       meths)\n        locals       (:locals env)\n        name-var     (fn-name-var env locals name)\n        env          (if-not (nil? name)\n                       (update-in env [:fn-scope] conj name-var)\n                       env)\n        locals       (if (and (not (nil? locals))\n                              (not (nil? name)))\n                       (assoc locals name name-var)\n                       locals)\n        form-meta    (meta form)\n        type         (::type form-meta)\n        proto-impl   (::protocol-impl form-meta)\n        proto-inline (::protocol-inline form-meta)\n        menv         (if (> (count meths) 1)\n                       (assoc env :context :expr)\n                       env)\n        menv         (merge menv\n                       {:protocol-impl proto-impl\n                        :protocol-inline proto-inline})\n        methods      (map #(analyze-fn-method menv locals % type) meths)\n        mfa          (apply max (map :max-fixed-arity methods))\n        variadic     (boolean (some :variadic methods))\n        locals       (if-not (nil? name)\n                       (update-in locals [name] assoc\n                         ;; TODO: can we simplify? - David\n                         :fn-var true\n                         :variadic variadic\n                         :max-fixed-arity mfa\n                         :method-params (map :params methods))\n                       locals)\n        methods      (if-not (nil? name)\n                       ;; a second pass with knowledge of our function-ness/arity\n                       ;; lets us optimize self calls\n                       (analyze-fn-methods-pass2 menv locals type meths)\n                       methods)\n        form         (vary-meta form dissoc ::protocol-impl ::protocol-inline ::type)\n        js-doc       (when (true? variadic)\n                       \"@param {...*} var_args\")\n        children     (mapv :expr methods)\n        ast          {:op :fn\n                      :env env\n                      :form form\n                      :name name-var\n                      :methods methods\n                      :variadic variadic\n                      :tag 'function\n                      :recur-frames *recur-frames*\n                      :loop-lets *loop-lets*\n                      :jsdoc [js-doc]\n                      :max-fixed-arity mfa\n                      :protocol-impl proto-impl\n                      :protocol-inline proto-inline\n                      :children children}]\n    (let [variadic-methods (filter :variadic methods)\n          variadic-params  (count (:params (first variadic-methods)))\n          param-counts     (map (comp count :params) methods)]\n      (when (< 1 (count variadic-methods))\n        (warning :multiple-variadic-overloads env {:name name-var}))\n      (when (not (or (zero? variadic-params) (== variadic-params (+ 1 mfa))))\n        (warning :variadic-max-arity env {:name name-var}))\n      (when (not= (distinct param-counts) param-counts)\n        (warning :overload-arity env {:name name-var})))\n    (analyze-wrap-meta ast)))",
                                   :title "Parser code",
                                   :repo "clojurescript",
                                   :tag "r1.7.228",
                                   :filename "src/main/clojure/cljs/analyzer.cljc",
                                   :lines [1282 1353]},
                          :full-name "special/fn*",
                          :full-name-encode "special/fnSTAR",
                          :history [["+" "0.0-927"]]},
           "cljs.analyzer.api/ns-specs" {:ns "cljs.analyzer.api",
                                         :name "ns-specs",
                                         :signature ["[ns]"],
                                         :history [["+" "0.0-2629"]
                                                   ["-" "0.0-2655"]],
                                         :type "function",
                                         :full-name-encode "cljs.analyzer.api/ns-specs",
                                         :source {:code "(defn ns-specs\n  [ns]\n  {:pre [(symbol? ns)]}\n  (get-in @env/*compiler* [::ana/namespaces ns :specs]))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2644",
                                                  :filename "src/clj/cljs/analyzer/api.clj",
                                                  :lines [48 53]},
                                         :full-name "cljs.analyzer.api/ns-specs",
                                         :docstring "Given a namespace return all the original specs for a namspace as originally\nprovided in the source.",
                                         :removed {:in "0.0-2655",
                                                   :last-seen "0.0-2644"}},
           "cljs.repl.nashorn/repl-env" {:ns "cljs.repl.nashorn",
                                         :name "repl-env",
                                         :signature ["[& {:as opts}]"],
                                         :history [["+" "0.0-2814"]],
                                         :type "function",
                                         :full-name-encode "cljs.repl.nashorn/repl-env",
                                         :source {:code "(defn repl-env\n      [& {:as opts}]\n      (repl-env* opts))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.7.228",
                                                  :filename "src/main/clojure/cljs/repl/nashorn.clj",
                                                  :lines [177 180]},
                                         :full-name "cljs.repl.nashorn/repl-env",
                                         :docstring "Create a Nashorn repl-env for use with the repl/repl* method in Clojurescript."},
           "clojure.set/subset?" {:description "Returns true if `a` is a subset of `b`, false otherwise.\n\nIn other words, returns true if all the elements of `a` can be found in `b`.",
                                  :ns "clojure.set",
                                  :name "subset?",
                                  :signature ["[a b]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/set"
                                            "cljs.core/set?"
                                            "clojure.set/superset?"],
                                  :full-name-encode "clojure.set/subsetQMARK",
                                  :source {:code "(defn subset? \n  [set1 set2]\n  (and (<= (count set1) (count set2))\n       (every? #(contains? set2 %) set1)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/clojure/set.cljs",
                                           :lines [131 135]},
                                  :full-name "clojure.set/subset?",
                                  :clj-symbol "clojure.set/subset?",
                                  :docstring "Is set1 a subset of set2?"},
           "cljs.core/flush" {:ns "cljs.core",
                              :name "flush",
                              :signature ["[]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/flush",
                              :source {:code "(defn flush [] ;stub\n  nil)",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [8775 8776]},
                              :full-name "cljs.core/flush",
                              :clj-symbol "clojure.core/flush"},
           "cljs.core/long-array" {:ns "cljs.core",
                                   :name "long-array",
                                   :signature ["[size-or-seq]"
                                               "[size init-val-or-seq]"],
                                   :history [["+" "0.0-1211"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/long-array",
                                   :source {:code "(defn long-array\n  ([size-or-seq]\n     (if (number? size-or-seq)\n       (long-array size-or-seq nil)\n       (into-array size-or-seq)))\n  ([size init-val-or-seq]\n     (let [a (make-array size)]\n       (if (seq? init-val-or-seq)\n         (let [s (seq init-val-or-seq)]\n           (loop [i 0 s s]\n             (if (and s (< i size))\n               (do\n                 (aset a i (first s))\n                 (recur (inc i) (next s)))\n               a)))\n         (do\n           (dotimes [i size]\n             (aset a i init-val-or-seq))\n           a)))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [3255 3275]},
                                   :full-name "cljs.core/long-array",
                                   :clj-symbol "clojure.core/long-array",
                                   :docstring "Creates an array of longs. Does not coerce array, provided for compatibility\nwith Clojure."},
           "cljs.reader/reader-error" {:ns "cljs.reader",
                                       :name "reader-error",
                                       :type "function",
                                       :signature ["[rdr & msg]"],
                                       :source {:code "(defn reader-error\n  [rdr & msg]\n  (throw (js/Error. (apply str msg))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/cljs/reader.cljs",
                                                :lines [69 71]},
                                       :full-name "cljs.reader/reader-error",
                                       :full-name-encode "cljs.reader/reader-error",
                                       :history [["+" "0.0-927"]]},
           "clojure.walk/prewalk-replace" {:ns "clojure.walk",
                                           :name "prewalk-replace",
                                           :signature ["[smap form]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "clojure.walk/prewalk-replace",
                                           :source {:code "(defn prewalk-replace\n  [smap form]\n  (prewalk (fn [x] (if (contains? smap x) (smap x) x)) form))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.7.228",
                                                    :filename "src/main/cljs/clojure/walk.cljs",
                                                    :lines [82 88]},
                                           :full-name "clojure.walk/prewalk-replace",
                                           :clj-symbol "clojure.walk/prewalk-replace",
                                           :docstring "Recursively transforms form by replacing keys in smap with their\nvalues.  Like clojure/replace but works on any data structure.  Does\nreplacement at the root of the tree first."},
           "cljs.compiler.api/emit" {:ns "cljs.compiler.api",
                                     :name "emit",
                                     :signature ["[ast]"
                                                 "[state ast]"],
                                     :history [["+" "0.0-3255"]],
                                     :type "function",
                                     :full-name-encode "cljs.compiler.api/emit",
                                     :source {:code "(defn emit\n  ([ast]\n   (emit\n     (if-not (nil? env/*compiler*)\n       env/*compiler*\n       (env/default-compiler-env))\n     ast))\n  ([state ast]\n   (env/with-compiler-env state\n     (with-out-str\n       (comp/emit ast)))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/clojure/cljs/compiler/api.clj",
                                              :lines [20 31]},
                                     :full-name "cljs.compiler.api/emit",
                                     :docstring "Given an AST node generated by the analyzer emit JavaScript as a string."},
           "cljs.core/*1" {:description "Only usable from a REPL.\n\nHolds the result of the last expression.",
                           :ns "cljs.core",
                           :name "*1",
                           :history [["+" "0.0-927"]],
                           :type "var",
                           :related ["cljs.core/*2"
                                     "cljs.core/*3"
                                     "cljs.core/*e"],
                           :full-name-encode "cljs.core/STAR1",
                           :source {:code "(def\n  ^{:doc \"bound in a repl thread to the most recent value printed\"}\n  *1)",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r1.7.228",
                                    :filename "src/main/cljs/cljs/core.cljs",
                                    :lines [156 158]},
                           :examples [{:id "30a861",
                                       :content "```clj\n(+ 1 2 3 4)\n;;=> 10\n\n*1\n;;=> 10\n\n(inc *1)\n;;=> 11\n```\n\nNote that a standalone evaluation of `*1`, `*2`, `*3`, or `*e` is not a part of\nremembered history:\n\n```clj\n:first\n;;=> :first\n\n:second\n;;=> :second\n\n:third\n;;=> :third\n\n*3\n;;=> :first\n\n*2\n;;=> :second\n\n*1\n;;=> :third\n```"}],
                           :full-name "cljs.core/*1",
                           :clj-symbol "clojure.core/*1",
                           :docstring "bound in a repl thread to the most recent value printed"},
           "cljs.core/subseq" {:description "`sc` must be a sorted collection.\n\n`test`, `start-test`, `end-test` must be `<`, `<=`, `>` or `>=`.\n\nReturns a sequence of those entries with keys `ek` for which\n`(test (.. sc comparator (compare ek key)) 0)` is true.",
                               :ns "cljs.core",
                               :name "subseq",
                               :signature ["[sc test key]"
                                           "[sc start-test start-key end-test end-key]"],
                               :history [["+" "0.0-1211"]],
                               :type "function",
                               :related ["cljs.core/rsubseq"
                                         "cljs.core/sorted-map"
                                         "cljs.core/sorted-set"
                                         "cljs.core/sorted-map-by"
                                         "cljs.core/sorted-set-by"],
                               :full-name-encode "cljs.core/subseq",
                               :source {:code "(defn subseq\n  ([sc test key]\n     (let [include (mk-bound-fn sc test key)]\n       (if (#{> >=} test)\n         (when-let [[e :as s] (-sorted-seq-from sc key true)]\n           (if (include e) s (next s)))\n         (take-while include (-sorted-seq sc true)))))\n  ([sc start-test start-key end-test end-key]\n     (when-let [[e :as s] (-sorted-seq-from sc start-key true)]\n       (take-while (mk-bound-fn sc end-test end-key)\n                   (if ((mk-bound-fn sc start-test start-key) e) s (next s))))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [8399 8412]},
                               :full-name "cljs.core/subseq",
                               :clj-symbol "clojure.core/subseq",
                               :docstring "sc must be a sorted collection, test(s) one of <, <=, > or\n>=. Returns a seq of those entries with keys ek for\nwhich (test (.. sc comparator (compare ek key)) 0) is true"},
           "cljs.core/Eduction" {:ns "cljs.core",
                                 :name "Eduction",
                                 :type "type",
                                 :signature ["[xform coll]"],
                                 :source {:code "(deftype Eduction [xform coll]\n  ISequential\n\n  ISeqable\n  (-seq [_] (seq (sequence xform coll)))\n\n  IReduce\n  (-reduce [_ f] (transduce xform (completing f) coll))\n  (-reduce [_ f init] (transduce xform (completing f) init coll))\n\n  IPrintWithWriter\n  (-pr-writer [coll writer opts]\n    (pr-sequential-writer writer pr-writer \"(\" \" \" \")\" opts coll)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [9267 9279]},
                                 :full-name "cljs.core/Eduction",
                                 :full-name-encode "cljs.core/Eduction",
                                 :history [["+" "0.0-2371"]]},
           "cljs.core/Set.EMPTY" {:ns "cljs.core",
                                  :name "Set.EMPTY",
                                  :history [["+" "0.0-927"]
                                            ["-" "0.0-1211"]],
                                  :parent-type "Set",
                                  :type "var",
                                  :full-name-encode "cljs.core/SetDOTEMPTY",
                                  :source {:code "(set! cljs.core.Set/EMPTY (Set. nil (hash-map)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [2708]},
                                  :full-name "cljs.core/Set.EMPTY",
                                  :removed {:in "0.0-1211",
                                            :last-seen "0.0-1011"}},
           "cljs.analyzer.api/analyze-file" {:ns "cljs.analyzer.api",
                                             :name "analyze-file",
                                             :signature ["[f]"
                                                         "[f opts]"
                                                         "[state f opts]"],
                                             :history [["+"
                                                        "0.0-3208"]],
                                             :type "function",
                                             :full-name-encode "cljs.analyzer.api/analyze-file",
                                             :source {:code "(defn analyze-file\n  ([f] (analyze-file f nil))\n  ([f opts]\n   (analyze-file\n     (if-not (nil? env/*compiler*)\n       env/*compiler*\n       (env/default-compiler-env opts))\n     f opts))\n  ([state f opts]\n   (env/with-compiler-env state\n     (binding [ana/*cljs-warning-handlers* (:warning-handlers opts ana/*cljs-warning-handlers*)]\n       (ana/analyze-file f opts)))))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.7.228",
                                                      :filename "src/main/clojure/cljs/analyzer/api.clj",
                                                      :lines [117 136]},
                                             :full-name "cljs.analyzer.api/analyze-file",
                                             :docstring "Given a java.io.File, java.net.URL or a string identifying a resource on the\nclasspath attempt to analyze it.\n\nThis function side-effects the ambient compilation environment\n`cljs.env/*compiler*` to aggregate analysis information. opts argument is\ncompiler options, if :cache-analysis true will cache analysis to\n\":output-dir/some/ns/foo.cljs.cache.edn\". This function does not return a\nmeaningful value."},
           "cljs.reader/read-unicode-char" {:ns "cljs.reader",
                                            :name "read-unicode-char",
                                            :signature ["[reader initch]"],
                                            :history [["+" "0.0-927"]
                                                      ["-" "0.0-1424"]],
                                            :type "function",
                                            :full-name-encode "cljs.reader/read-unicode-char",
                                            :source {:code "(defn read-unicode-char\n  [reader initch]\n  (reader-error reader \"Unicode characters not supported by reader (yet)\"))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1236",
                                                     :filename "src/cljs/cljs/reader.cljs",
                                                     :lines [171 173]},
                                            :full-name "cljs.reader/read-unicode-char",
                                            :removed {:in "0.0-1424",
                                                      :last-seen "0.0-1236"}},
           "cljs.core/dissoc" {:description "dissoc(iate)\n\nReturns a new map that does not contain a mapping for key(s).\n\nHas no effect on the map type (hashed/sorted).",
                               :ns "cljs.core",
                               :name "dissoc",
                               :signature ["[coll]"
                                           "[coll k]"
                                           "[coll k & ks]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/assoc"
                                         "cljs.core/disj"
                                         "cljs.core/select-keys"],
                               :full-name-encode "cljs.core/dissoc",
                               :source {:code "(defn dissoc\n  ([coll] coll)\n  ([coll k]\n    (when-not (nil? coll)\n      (-dissoc coll k)))\n  ([coll k & ks]\n    (when-not (nil? coll)\n      (let [ret (dissoc coll k)]\n        (if ks\n          (recur ret (first ks) (next ks))\n          ret)))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [1766 1778]},
                               :examples [{:id "fd6ae9",
                                           :content "```clj\n(dissoc {:key \"value\" :key2 \"value2\"} :key)\n;;=> {:key2 \"value2\"}\n```"}],
                               :full-name "cljs.core/dissoc",
                               :clj-symbol "clojure.core/dissoc",
                               :docstring "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\nthat does not contain a mapping for key(s)."},
           "cljs.pprint/*print-pretty*" {:ns "cljs.pprint",
                                         :name "*print-pretty*",
                                         :history [["+" "0.0-3255"]],
                                         :type "dynamic var",
                                         :full-name-encode "cljs.pprint/STARprint-prettySTAR",
                                         :source {:code "(def ^:dynamic\n ^{:doc \"Bind to true if you want write to use pretty printing\"}\n *print-pretty* true)",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.7.228",
                                                  :filename "src/main/cljs/cljs/pprint.cljs",
                                                  :lines [615 617]},
                                         :full-name "cljs.pprint/*print-pretty*",
                                         :clj-symbol "clojure.pprint/*print-pretty*",
                                         :docstring "Bind to true if you want write to use pretty printing"},
           "cljs.core/exists?" {:ns "cljs.core",
                                :name "exists?",
                                :signature ["[x]"],
                                :history [["+" "0.0-1798"]],
                                :type "macro",
                                :full-name-encode "cljs.core/existsQMARK",
                                :source {:code "(core/defmacro exists?\n  [x]\n  (bool-expr\n    (core/list 'js* \"typeof ~{} !== 'undefined'\"\n      (vary-meta x assoc :cljs.analyzer/no-resolve true))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/clojure/cljs/core.cljc",
                                         :lines [908 914]},
                                :full-name "cljs.core/exists?",
                                :docstring "Return true if argument exists, analogous to usage of typeof operator\nin JavaScript."},
           "cljs.core/ffirst" {:description "Same as `(first (first coll))`.",
                               :ns "cljs.core",
                               :name "ffirst",
                               :signature ["[coll]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/first"
                                         "cljs.core/fnext"
                                         "cljs.core/nfirst"],
                               :full-name-encode "cljs.core/ffirst",
                               :source {:code "(defn ffirst\n  [coll]\n  (first (first coll)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [1535 1538]},
                               :examples [{:id "575ba2",
                                           :content "```clj\n(ffirst [[1 2] [3 4] [5 6]])\n;;=> 1\n```"}],
                               :full-name "cljs.core/ffirst",
                               :clj-symbol "clojure.core/ffirst",
                               :docstring "Same as (first (first x))"},
           "clojure.zip/replace" {:ns "clojure.zip",
                                  :name "replace",
                                  :signature ["[loc node]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.zip/replace",
                                  :source {:code "(defn replace\n  [loc node]\n    (let [[_ path] loc]\n      (with-meta [node (assoc path :changed? true)] (meta loc))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/clojure/zip.cljs",
                                           :lines [183 187]},
                                  :full-name "clojure.zip/replace",
                                  :clj-symbol "clojure.zip/replace",
                                  :docstring "Replaces the node at this loc, without moving"},
           "cljs.core/vec" {:description "Creates a new vector containing the contents of `coll`",
                            :ns "cljs.core",
                            :name "vec",
                            :signature ["[coll]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/vector"
                                      "cljs.core/vector?"],
                            :full-name-encode "cljs.core/vec",
                            :source {:code "(defn vec\n  [coll]\n  (if (array? coll)\n    (.fromArray PersistentVector coll true)\n    (-persistent!\n      (reduce -conj!\n        (-as-transient (.-EMPTY PersistentVector))\n        coll))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.7.228",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [4943 4952]},
                            :full-name "cljs.core/vec",
                            :clj-symbol "clojure.core/vec",
                            :docstring "Creates a new vector containing the contents of coll. JavaScript arrays\nwill be aliased and should not be modified."},
           "cljs.core/or" {:description "Evaluates arguments one at a time from left to right. If an argument returns\nlogical true, `or` returns that value and doesn't evaluate any of the other\narguments, otherwise it returns the value of the last argument.\n\n`(or)` returns nil.",
                           :ns "cljs.core",
                           :name "or",
                           :signature ["[]" "[x]" "[x & next]"],
                           :history [["+" "0.0-927"]],
                           :type "macro",
                           :related ["cljs.core/and" "special/if"],
                           :full-name-encode "cljs.core/or",
                           :source {:code "(core/defmacro or\n  ([] nil)\n  ([x] x)\n  ([x & next]\n   (core/let [forms (concat [x] next)]\n     (if (every? #(simple-test-expr? &env %)\n           (map #(cljs.analyzer/analyze &env %) forms))\n       (core/let [or-str (core/->> (repeat (count forms) \"(~{})\")\n                           (interpose \" || \")\n                           (apply core/str))]\n         (bool-expr `(~'js* ~or-str ~@forms)))\n       `(let [or# ~x]\n          (if or# or# (or ~@next)))))))",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r1.7.228",
                                    :filename "src/main/clojure/cljs/core.cljc",
                                    :lines [813 829]},
                           :examples [{:id "d50433",
                                       :content "```clj\n(or)\n;;=> nil\n\n(or false)\n;;=> false\n\n(or true)\n;;=> true\n\n(or true true)\n;;=> true\n\n(or true false)\n;;=> true\n\n(or false false)\n;;=> false\n```"}
                                      {:id "62f291",
                                       :content "`nil` and `false` are the only falsy values and everything else is truthy:\n\n```clj\n(or \"foo\" \"bar\")\n;;=> \"bar\"\n\n(or \"foo\" nil)\n;;=> \"foo\"\n\n(or \"foo\" false)\n;;=> \"foo\"\n\n(or nil \"foo\")\n;;=> \"foo\"\n\n(or false \"foo\")\n;;=> \"foo\"\n```"}],
                           :full-name "cljs.core/or",
                           :clj-symbol "clojure.core/or",
                           :docstring "Evaluates exprs one at a time, from left to right. If a form\nreturns a logical true value, or returns that value and doesn't\nevaluate any of the other expressions, otherwise it returns the\nvalue of the last expression. (or) returns nil."},
           "cljs.core/doubles" {:ns "cljs.core",
                                :name "doubles",
                                :signature ["[x]"],
                                :history [["+" "0.0-1798"]],
                                :type "function",
                                :full-name-encode "cljs.core/doubles",
                                :source {:code "(defn doubles [x] x)",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [2483]},
                                :full-name "cljs.core/doubles",
                                :clj-symbol "clojure.core/doubles"},
           "cljs.core/mod" {:description "Returns the modulus of dividing numerator `n` by denominator `d`.\n\nReturns `NaN` when `d` is 0 (divide by 0 error).\n\nTruncates toward negative infinity.",
                            :ns "cljs.core",
                            :name "mod",
                            :signature ["[n d]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/rem"],
                            :full-name-encode "cljs.core/mod",
                            :source {:code "(defn mod\n  [n d]\n  (js-mod (+ (js-mod n d) d) d))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.7.228",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [2491 2494]},
                            :examples [{:id "8165e8",
                                        :content "```clj\n(mod -5 3)\n;;=> 1\n\n(mod 5 3)\n;;=> 2\n\n(mod 5 0)\n;;=> NaN\n```"}],
                            :full-name "cljs.core/mod",
                            :clj-symbol "clojure.core/mod",
                            :docstring "Modulus of num and div. Truncates toward negative infinity."},
           "cljs.core/aset" {:description "Sets `val` at index `i` in a JavaScript array.\n\n```clj\n(def a #js [1 2 3])\n(aset a 0 \"foo\")\na\n;;=> #js [\"foo\" 2 3]\n```\n\nSet nested elements with the additional `idxs` arguments.\n\n```clj\n(def a #js [1 2 #js [3 4]])\n(aset a 2 0 \"foo\")\na\n;;=> #js [1 2 #js [\"foo\" 4]]\n```\n\nFor JavaScript objects, use [`goog.object/set`].\n\n[`goog.object/set`]:http://google.github.io/closure-library/api/namespace_goog_object.html#set\n\n```clj\n(require 'goog.object)\n(def obj #js {:foo 1})\n\n(goog.object/set obj \"foo\" \"bar\")\nobj\n;;=> #js {:foo \"bar\"}\n```",
                             :ns "cljs.core",
                             :name "aset",
                             :signature ["[array i val]"
                                         "[array idx idx2 & idxv]"],
                             :history [["+" "0.0-927"]],
                             :type "function/macro",
                             :related ["cljs.core/aget"
                                       "special/set!"
                                       "cljs.core/assoc-in"],
                             :full-name-encode "cljs.core/aset",
                             :source {:code "(defn aset\n  ([array i val]\n    (cljs.core/aset array i val))\n  ([array idx idx2 & idxv]\n    (apply aset (aget array idx) idx2 idxv)))",
                                      :title "Function code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [394 399]},
                             :extra-sources [{:code "(core/defmacro aset\n  ([a i v]\n   (core/list 'js* \"(~{}[~{}] = ~{})\" a i v))\n  ([a idx idx2 & idxv]\n   (core/let [n    (core/dec (count idxv))\n              astr (apply core/str (repeat n \"[~{}]\"))]\n     `(~'js* ~(core/str \"(~{}[~{}][~{}]\" astr \" = ~{})\") ~a ~idx ~idx2 ~@idxv))))",
                                              :title "Macro code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/clojure/cljs/core.cljc",
                                              :lines [949 955]}],
                             :full-name "cljs.core/aset",
                             :clj-symbol "clojure.core/aset",
                             :docstring "Sets the value at the index."},
           "cljs.js/eval" {:ns "cljs.js",
                           :name "eval",
                           :signature ["[state form cb]"
                                       "[state form opts cb]"],
                           :history [["+" "1.7.10"]],
                           :type "function",
                           :full-name-encode "cljs.js/eval",
                           :source {:code "(defn eval\n  ([state form cb]\n   (eval state form nil cb))\n  ([state form opts cb]\n   (eval*\n     {:*compiler*     state\n      :*data-readers* tags/*cljs-data-readers*\n      :*analyze-deps* (or (:analyze-deps opts) true)\n      :*load-macros*  (or (:load-macros opts) true)\n      :*load-fn*      (or (:load opts) *load-fn*)\n      :*eval-fn*      (or (:eval opts) *eval-fn*)}\n     form opts cb)))",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r1.7.228",
                                    :filename "src/main/cljs/cljs/js.cljs",
                                    :lines [559 589]},
                           :full-name "cljs.js/eval",
                           :docstring "Evaluate a single ClojureScript form. The parameters:\n\nstate (atom)\n  the compiler state\n\nform (s-expr)\n  the ClojureScript source\n\nopts (map)\n  compilation options.\n\n  :eval - the eval function to invoke, see *eval-fn*\n  :load - library resolution function, see *load-fn*\n\ncb (function)\n  callback, will be invoked with a map. If successful the map will contain\n  a key :value with the result of evalution. If unsuccessful the map will\n  contain a key :error with an ex-info instance describing the cause of\n  failure."},
           "cljs.core/second" {:description "Returns the second item in `coll`.\n\nSame as `(first (next coll))`",
                               :ns "cljs.core",
                               :name "second",
                               :signature ["[coll]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/first"
                                         "cljs.core/nth"
                                         "cljs.core/fnext"
                                         "cljs.core/next"],
                               :full-name-encode "cljs.core/second",
                               :source {:code "(defn second\n  [coll]\n  (first (next coll)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [1530 1533]},
                               :full-name "cljs.core/second",
                               :clj-symbol "clojure.core/second",
                               :docstring "Same as (first (next x))"},
           "cljs.core/IChunkedNext" {:ns "cljs.core",
                                     :name "IChunkedNext",
                                     :history [["+" "0.0-1424"]],
                                     :type "protocol",
                                     :full-name-encode "cljs.core/IChunkedNext",
                                     :source {:code "(defprotocol IChunkedNext\n  \"Protocol for accessing the chunks of a collection.\"\n  (-chunked-next [coll]\n    \"Returns a new collection of coll without the first chunk.\"))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/cljs/cljs/core.cljs",
                                              :lines [720 723]},
                                     :methods [{:name "-chunked-next",
                                                :signature ["[coll]"],
                                                :docstring "Returns a new collection of coll without the first chunk."}],
                                     :full-name "cljs.core/IChunkedNext",
                                     :docstring "Protocol for accessing the chunks of a collection."},
           "cljs.core/bit-count" {:description "Counts the number of bits set in `x`.",
                                  :ns "cljs.core",
                                  :name "bit-count",
                                  :signature ["[x]"],
                                  :history [["+" "0.0-1211"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/bit-count",
                                  :source {:code "(defn bit-count\n  [v]\n  (let [v (- v (bit-and (bit-shift-right v 1) 0x55555555))\n        v (+ (bit-and v 0x33333333) (bit-and (bit-shift-right v 2) 0x33333333))]\n    (bit-shift-right (* (bit-and (+ v (bit-shift-right v 4)) 0xF0F0F0F) 0x1010101) 24)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [2572 2577]},
                                  :examples [{:id "35c78c",
                                              :content "Bits can be entered using radix notation:\n\n```clj\n(bit-count 2r1011)\n;;=> 3\n```\n\nSame number in decimal:\n\n```clj\n(bit-count 11)\n;;=> 3\n```"}],
                                  :full-name "cljs.core/bit-count",
                                  :docstring "Counts the number of bits set in n"},
           "clojure.set/rename" {:ns "clojure.set",
                                 :name "rename",
                                 :signature ["[xrel kmap]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "clojure.set/rename",
                                 :source {:code "(defn rename\n  [xrel kmap]\n    (set (map #(rename-keys % kmap) xrel)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/clojure/set.cljs",
                                          :lines [82 85]},
                                 :full-name "clojure.set/rename",
                                 :clj-symbol "clojure.set/rename",
                                 :docstring "Returns a rel of the maps in xrel with the keys in kmap renamed to the vals in kmap"},
           "cljs.core/m3-hash-int" {:return-type number,
                                    :ns "cljs.core",
                                    :name "m3-hash-int",
                                    :signature ["[in]"],
                                    :history [["+" "0.0-2261"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/m3-hash-int",
                                    :source {:code "(defn ^number m3-hash-int [in]\n  (if (zero? in)\n    in\n    (let [k1 (m3-mix-K1 in)\n          h1 (m3-mix-H1 m3-seed k1)]\n      (m3-fmix h1 4))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [815 820]},
                                    :full-name "cljs.core/m3-hash-int"},
           "cljs.compiler.api/compile-file" {:ns "cljs.compiler.api",
                                             :name "compile-file",
                                             :signature ["[src]"
                                                         "[src dest]"
                                                         "[src dest opts]"
                                                         "[state src dest opts]"],
                                             :history [["+"
                                                        "0.0-3255"]],
                                             :type "function",
                                             :full-name-encode "cljs.compiler.api/compile-file",
                                             :source {:code "(defn compile-file\n  ([src] (compile-file src))\n  ([src dest] (compile-file src dest))\n  ([src dest opts]\n   (compile-file\n     (if-not (nil? env/*compiler*)\n       env/*compiler*\n       (env/default-compiler-env opts))\n     src dest opts))\n  ([state src dest opts]\n   (env/with-compiler-env state\n     (binding [ana/*cljs-warning-handlers* (:warning-handlers opts ana/*cljs-warning-handlers*)]\n       (comp/compile-file src dest opts)))))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.7.228",
                                                      :filename "src/main/clojure/cljs/compiler/api.clj",
                                                      :lines [62 86]},
                                             :full-name "cljs.compiler.api/compile-file",
                                             :docstring "Compiles src to a file of the same name, but with a .js extension,\nin the src file's directory.\n\nWith dest argument, write file to provided location. If the dest\nargument is a file outside the source tree, missing parent\ndirectories will be created. The src file will only be compiled if\nthe dest file has an older modification time.\n\nBoth src and dest may be either a String or a File.\n\nReturns a map containing {:ns .. :provides .. :requires .. :file ..}.\nIf the file was not compiled returns only {:file ...}"},
           "cljs.core/assoc!" {:description "assoc(iate) on transient collection\n\nWhen applied to a transient map, adds mapping of key(s) to val(s).\n\nWhen applied to a transient vector, sets the val at index.  Note - index must\nbe <= (count vector).\n\nReturns coll.",
                               :ns "cljs.core",
                               :name "assoc!",
                               :signature ["[tcoll key val]"
                                           "[tcoll key val & kvs]"],
                               :history [["+" "0.0-1211"]],
                               :type "function",
                               :related ["cljs.core/transient"
                                         "cljs.core/persistent!"],
                               :full-name-encode "cljs.core/assocBANG",
                               :source {:code "(defn assoc!\n  ([tcoll key val]\n    (-assoc! tcoll key val))\n  ([tcoll key val & kvs]\n    (let [ntcoll (-assoc! tcoll key val)]\n      (if kvs\n        (recur ntcoll (first kvs) (second kvs) (nnext kvs))\n        ntcoll))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [3400 3410]},
                               :examples [{:id "7d1e6b",
                                           :content "```clj\n(def tcoll (transient! {}))\n(assoc! tcoll :a 1)\n(assoc! tcoll :b 2)\n\ntcoll\n;;=> #<[object Object]> \n\n(:a tcoll)\n;;=> 1\n\n(:b tcoll)\n;;=> 2\n\n(def a (persistent! tcoll))\n;;=> {:a 1 :b 2}\n```"}],
                               :full-name "cljs.core/assoc!",
                               :clj-symbol "clojure.core/assoc!",
                               :docstring "When applied to a transient map, adds mapping of key(s) to\nval(s). When applied to a transient vector, sets the val at index.\nNote - index must be <= (count vector). Returns coll."},
           "cljs.repl/mapped-line-and-column" {:ns "cljs.repl",
                                               :name "mapped-line-and-column",
                                               :signature ["[source-map line column]"],
                                               :history [["+"
                                                          "0.0-2814"]
                                                         ["-"
                                                          "0.0-3148"]],
                                               :type "function",
                                               :full-name-encode "cljs.repl/mapped-line-and-column",
                                               :source {:code "(defn mapped-line-and-column\n  [source-map line column]\n  (let [default [line column]]\n    ;; source maps are 0 indexed for lines\n    (if-let [columns (get source-map (dec line))]\n      (vec\n        (map inc\n          (map\n            ;; source maps are 0 indexed for columns\n            ;; multiple segments may exist at column\n            ;; the last segment seems most accurate\n            (last\n              (if-let [mapping (get columns (dec column))]\n                mapping\n                (second (first columns))))\n            [:line :col])))\n      default)))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r3126",
                                                        :filename "src/clj/cljs/repl.clj",
                                                        :lines [223
                                                                241]},
                                               :full-name "cljs.repl/mapped-line-and-column",
                                               :docstring "Given a cljs.source-map source map data structure map a generated line\nand column back to the original line and column.",
                                               :removed {:in "0.0-3148",
                                                         :last-seen "0.0-3126"}},
           "cljs.test/get-and-clear-env!" {:ns "cljs.test",
                                           :name "get-and-clear-env!",
                                           :type "function",
                                           :signature ["[]"],
                                           :source {:code "(defn get-and-clear-env! []\n  \"Like get-current-env, but cleans env before returning.\"\n  (let [env (cljs.test/get-current-env)]\n    (clear-env!)\n    env))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.7.228",
                                                    :filename "src/main/cljs/cljs/test.cljs",
                                                    :lines [283 287]},
                                           :full-name "cljs.test/get-and-clear-env!",
                                           :full-name-encode "cljs.test/get-and-clear-envBANG",
                                           :history [["+" "0.0-2814"]]},
           "cljs.core/delay?" {:return-type boolean,
                               :ns "cljs.core",
                               :name "delay?",
                               :signature ["[x]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/delayQMARK",
                               :source {:code "(defn ^boolean delay?\n  [x] (instance? Delay x))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [9205 9207]},
                               :full-name "cljs.core/delay?",
                               :clj-symbol "clojure.core/delay?",
                               :docstring "returns true if x is a Delay created with delay"},
           "clojure.zip/left" {:ns "clojure.zip",
                               :name "left",
                               :signature ["[loc]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip/left",
                               :source {:code "(defn left\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (when (and path (seq l))\n        (with-meta [(peek l) (assoc path :l (pop l) :r (cons node r))] (meta loc)))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/clojure/zip.cljs",
                                        :lines [150 155]},
                               :full-name "clojure.zip/left",
                               :clj-symbol "clojure.zip/left",
                               :docstring "Returns the loc of the left sibling of the node at this loc, or nil"},
           "cljs.reader/not-implemented" {:ns "cljs.reader",
                                          :name "not-implemented",
                                          :type "function",
                                          :signature ["[rdr ch]"],
                                          :source {:code "(defn not-implemented\n  [rdr ch]\n  (reader-error rdr \"Reader for \" ch \" not implemented yet\"))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/cljs/cljs/reader.cljs",
                                                   :lines [244 246]},
                                          :full-name "cljs.reader/not-implemented",
                                          :full-name-encode "cljs.reader/not-implemented",
                                          :history [["+" "0.0-927"]]},
           "cljs.core/IAssociative" {:ns "cljs.core",
                                     :name "IAssociative",
                                     :history [["+" "0.0-927"]],
                                     :type "protocol",
                                     :full-name-encode "cljs.core/IAssociative",
                                     :source {:code "(defprotocol IAssociative\n  \"Protocol for adding associativity to collections.\"\n  (^boolean -contains-key? [coll k]\n    \"Returns true if k is a key in coll.\")\n  #_(-entry-at [coll k])\n  (^clj -assoc [coll k v]\n    \"Returns a new collection of coll with a mapping from key k to\n     value v added to it.\"))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/cljs/cljs/core.cljs",
                                              :lines [515 522]},
                                     :methods [{:name "-contains-key?",
                                                :signature ["[coll k]"],
                                                :docstring "Returns true if k is a key in coll."}
                                               {:name "-assoc",
                                                :signature ["[coll k v]"],
                                                :docstring "Returns a new collection of coll with a mapping from key k to\n     value v added to it."}],
                                     :full-name "cljs.core/IAssociative",
                                     :clj-symbol "clojure.lang/Associative",
                                     :docstring "Protocol for adding associativity to collections."},
           "cljs.pprint/pprint-tab" {:ns "cljs.pprint",
                                     :name "pprint-tab",
                                     :signature ["[kind colnum colinc]"],
                                     :history [["+" "0.0-3255"]],
                                     :type "function",
                                     :full-name-encode "cljs.pprint/pprint-tab",
                                     :source {:code "(defn pprint-tab\n  [kind colnum colinc]\n  (check-enumerated-arg kind #{:line :section :line-relative :section-relative})\n  (throw (js/Error. \"pprint-tab is not yet implemented\")))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/cljs/cljs/pprint.cljs",
                                              :lines [866 881]},
                                     :full-name "cljs.pprint/pprint-tab",
                                     :clj-symbol "clojure.pprint/pprint-tab",
                                     :docstring "Tab at this point in the pretty printing stream. kind specifies whether the tab\nis :line, :section, :line-relative, or :section-relative.\n\nColnum and colinc specify the target column and the increment to move the target\nforward if the output is already past the original target.\n\nThis function is intended for use when writing custom dispatch functions.\n\nOutput is sent to *out* which must be a pretty printing writer.\n\nTHIS FUNCTION IS NOT YET IMPLEMENTED."},
           "cljs.core/ObjMap.EMPTY" {:ns "cljs.core",
                                     :name "ObjMap.EMPTY",
                                     :type "var",
                                     :parent-type "ObjMap",
                                     :source {:code "(set! (.-EMPTY ObjMap) (ObjMap. nil (array) (js-obj) 0 empty-unordered-hash))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/cljs/cljs/core.cljs",
                                              :lines [5653]},
                                     :full-name "cljs.core/ObjMap.EMPTY",
                                     :full-name-encode "cljs.core/ObjMapDOTEMPTY",
                                     :history [["+" "0.0-927"]]},
           "cljs.core/group-by" {:description "Returns a map of the elements of `coll` keyed by the result of running `f` on\neach element.\n\nThe value at each key will be a vector of the corresponding elements in the\norder they appeared in `coll`.",
                                 :ns "cljs.core",
                                 :name "group-by",
                                 :signature ["[f coll]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :related ["cljs.core/partition-by"
                                           "cljs.core/frequencies"],
                                 :full-name-encode "cljs.core/group-by",
                                 :source {:code "(defn group-by\n  [f coll]\n  (persistent!\n    (reduce\n      (fn [ret x]\n        (let [k (f x)]\n          (assoc! ret k (conj (get ret k []) x))))\n      (transient {}) coll)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [9418 9428]},
                                 :full-name "cljs.core/group-by",
                                 :clj-symbol "clojure.core/group-by",
                                 :docstring "Returns a map of the elements of coll keyed by the result of\nf on each element. The value at each key will be a vector of the\ncorresponding elements, in the order they appeared in coll."},
           "special/case*" {:ns "special",
                            :name "case*",
                            :type "special form",
                            :source {:code "(defmethod parse 'case*\n  [op env [_ sym tests thens default :as form] name _]\n  (assert (symbol? sym) \"case* must switch on symbol\")\n  (assert (every? vector? tests) \"case* tests must be grouped in vectors\")\n  (let [expr-env (assoc env :context :expr)\n        v        (disallowing-recur (analyze expr-env sym))\n        tests    (mapv #(mapv (fn [t] (analyze expr-env t)) %) tests)\n        thens    (mapv #(analyze env %) thens)\n        default  (analyze env default)]\n    (assert (every? (fn [t]\n                      (or\n                        (-> t :info :const)\n                        (and (= :constant (:op t))\n                             ((some-fn number? string? char?) (:form t)))))\n              (apply concat tests))\n      \"case* tests must be numbers, strings, or constants\")\n    {:env env :op :case* :form form\n     :v v :tests tests :thens thens :default default\n     :children (vec (concat [v] tests thens (if default [default])))}))",
                                     :title "Parser code",
                                     :repo "clojurescript",
                                     :tag "r1.7.228",
                                     :filename "src/main/clojure/cljs/analyzer.cljc",
                                     :lines [981 999]},
                            :full-name "special/case*",
                            :full-name-encode "special/caseSTAR",
                            :history [["+" "0.0-2227"]]},
           "cljs.build.api/watch" {:ns "cljs.build.api",
                                   :name "watch",
                                   :signature ["[source opts]"
                                               "[source opts compiler-env]"
                                               "[source opts compiler-env stop]"],
                                   :history [["+" "0.0-3208"]],
                                   :type "function",
                                   :full-name-encode "cljs.build.api/watch",
                                   :source {:code "(defn watch\n  ([source opts]\n   (watch source opts\n     (if-not (nil? env/*compiler*)\n       env/*compiler*\n       (env/default-compiler-env opts))))\n  ([source opts compiler-env]\n   (watch source opts compiler-env nil))\n  ([source opts compiler-env stop]\n   (binding [ana/*cljs-warning-handlers* (:warning-handlers opts ana/*cljs-warning-handlers*)]\n     (closure/watch source opts compiler-env stop))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/clojure/cljs/build/api.clj",
                                            :lines [209 220]},
                                   :full-name "cljs.build.api/watch",
                                   :docstring "Given a source which can be compiled, watch it for changes to produce."},
           "cljs.repl/special-doc-map" {:ns "cljs.repl",
                                        :name "special-doc-map",
                                        :type "var",
                                        :source {:code "(def special-doc-map\n  '{. {:forms [(.instanceMethod instance args*)\n               (.-instanceField instance)]\n       :doc \"The instance member form works for methods and fields.\n  They all expand into calls to the dot operator at macroexpansion time.\"}\n    ns {:forms [(name docstring? attr-map? references*)]\n        :doc \"You must currently use the ns form only with the following caveats\n\n    * You must use the :only form of :use\n    * :require supports :as and :refer\n      - both options can be skipped\n      - in this case a symbol can be used as a libspec directly\n        - that is, (:require lib.foo) and (:require [lib.foo]) are both\n          supported and mean the same thing\n      - prefix lists are not supported\n    * The only option for :refer-clojure is :exclude\n    * :import is available for importing Google Closure classes\n      - ClojureScript types and records should be brought in with :use\n        or :require :refer, not :import ed\n    * Macros are written in Clojure, and are referenced via the new\n      :require-macros / :use-macros options to ns\n      - :require-macros and :use-macros support the same forms that\n        :require and :use do\n\n  Implicit macro loading: If a namespace is required or used, and that\n  namespace itself requires or uses macros from its own namespace, then\n  the macros will be implicitly required or used using the same\n  specifications. This oftentimes leads to simplified library usage,\n  such that the consuming namespace need not be concerned about\n  explicitly distinguishing between whether certain vars are functions\n  or macros.\n\n  Inline macro specification: As a convenience, :require can be given\n  either :include-macros true or :refer-macros [syms...]. Both desugar\n  into forms which explicitly load the matching Clojure file containing\n  macros. (This works independently of whether the namespace being\n  required internally requires or uses its own macros.) For example:\n\n  (ns testme.core\n  (:require [foo.core :as foo :refer [foo-fn] :include-macros true]\n            [woz.core :as woz :refer [woz-fn] :refer-macros [app jx]]))\n\n  is sugar for\n\n  (ns testme.core\n  (:require [foo.core :as foo :refer [foo-fn]]\n            [woz.core :as woz :refer [woz-fn]])\n  (:require-macros [foo.core :as foo]\n                   [woz.core :as woz :refer [app jx]]))\"}\n    def {:forms [(def symbol doc-string? init?)]\n         :doc \"Creates and interns a global var with the name\n  of symbol in the current namespace (*ns*) or locates such a var if\n  it already exists.  If init is supplied, it is evaluated, and the\n  root binding of the var is set to the resulting value.  If init is\n  not supplied, the root binding of the var is unaffected.\"}\n    do {:forms [(do exprs*)]\n        :doc \"Evaluates the expressions in order and returns the value of\n  the last. If no expressions are supplied, returns nil.\"}\n    if {:forms [(if test then else?)]\n        :doc \"Evaluates test. If not the singular values nil or false,\n  evaluates and yields then, otherwise, evaluates and yields else. If\n  else is not supplied it defaults to nil.\"}\n    new {:forms [(Constructor. args*) (new Constructor args*)]\n         :url \"java_interop#new\"\n         :doc \"The args, if any, are evaluated from left to right, and\n  passed to the JavaScript constructor. The constructed object is\n  returned.\"}\n    quote {:forms [(quote form)]\n           :doc \"Yields the unevaluated form.\"}\n    recur {:forms [(recur exprs*)]\n           :doc \"Evaluates the exprs in order, then, in parallel, rebinds\n  the bindings of the recursion point to the values of the exprs.\n  Execution then jumps back to the recursion point, a loop or fn method.\"}\n    set! {:forms[(set! var-symbol expr)\n                 (set! (.- instance-expr instanceFieldName-symbol) expr)]\n          :url \"vars#set\"\n          :doc \"Used to set vars and JavaScript object fields\"}\n    throw {:forms [(throw expr)]\n           :doc \"The expr is evaluated and thrown.\"}\n    try {:forms [(try expr* catch-clause* finally-clause?)]\n         :doc \"catch-clause => (catch classname name expr*)\n  finally-clause => (finally expr*)\n  Catches and handles JavaScript exceptions.\"}\n    var {:forms [(var symbol)]\n         :doc \"The symbol must resolve to a var, and the Var object\nitself (not its value) is returned. The reader macro #'x expands to (var x).\"}})",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/clojure/cljs/repl.cljc",
                                                 :lines [988 1073]},
                                        :full-name "cljs.repl/special-doc-map",
                                        :full-name-encode "cljs.repl/special-doc-map",
                                        :history [["+" "0.0-2985"]]},
           "cljs.reader/*default-data-reader-fn*" {:ns "cljs.reader",
                                                   :name "*default-data-reader-fn*",
                                                   :type "dynamic var",
                                                   :source {:code "(def ^:dynamic *default-data-reader-fn*\n  (atom nil))",
                                                            :title "Source code",
                                                            :repo "clojurescript",
                                                            :tag "r1.7.228",
                                                            :filename "src/main/cljs/cljs/reader.cljs",
                                                            :lines [591
                                                                    592]},
                                                   :full-name "cljs.reader/*default-data-reader-fn*",
                                                   :full-name-encode "cljs.reader/STARdefault-data-reader-fnSTAR",
                                                   :history [["+"
                                                              "0.0-1576"]]},
           "cljs.core/array-index-of" {:ns "cljs.core",
                                       :name "array-index-of",
                                       :type "function",
                                       :signature ["[arr k]"],
                                       :source {:code "(defn array-index-of [arr k]\n  (cond\n    (keyword? k) (array-index-of-keyword? arr k)\n\n    (or ^boolean (goog/isString k) (number? k))\n    (array-index-of-identical? arr k)\n\n    (symbol? k) (array-index-of-symbol? arr k)\n\n    (nil? k)\n    (array-index-of-nil? arr)\n\n    :else (array-index-of-equiv? arr k)))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/cljs/core.cljs",
                                                :lines [5744 5756]},
                                       :full-name "cljs.core/array-index-of",
                                       :full-name-encode "cljs.core/array-index-of",
                                       :history [["+" "0.0-3178"]]},
           "cljs.core/*e" {:description "Only usable from a REPL.\n\nHolds the result of the last exception.",
                           :ns "cljs.core",
                           :name "*e",
                           :history [["+" "0.0-2814"]],
                           :type "var",
                           :related ["cljs.core/*1"
                                     "cljs.core/*2"
                                     "cljs.core/*3"],
                           :full-name-encode "cljs.core/STARe",
                           :source {:code "(def\n  ^{:doc \"bound in a repl thread to the most recent exception caught by the repl\"}\n  *e)",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r1.7.228",
                                    :filename "src/main/cljs/cljs/core.cljs",
                                    :lines [168 170]},
                           :examples [{:id "bea858",
                                       :content "```clj\n(defn cause-error []\n  (throw \"Error: something went wrong\"))\n\n(cause-error)\n;; Error: something went wrong\n\n*e\n;;=> \"Error: something went wrong\"\n```"}],
                           :full-name "cljs.core/*e",
                           :clj-symbol "clojure.core/*e",
                           :docstring "bound in a repl thread to the most recent exception caught by the repl"},
           "cljs.core/sorted-map-by" {:description "Returns a new sorted map with supplied mappings, using the supplied comparator\nfunction.\n\n`keyvals` must be an even number of forms.",
                                      :ns "cljs.core",
                                      :name "sorted-map-by",
                                      :signature ["[comparator & keyvals]"],
                                      :history [["+" "0.0-1211"]],
                                      :type "function",
                                      :related ["cljs.core/sorted-map"
                                                "cljs.core/subseq"
                                                "cljs.core/rsubseq"
                                                "cljs.core/sorted-set-by"],
                                      :full-name-encode "cljs.core/sorted-map-by",
                                      :source {:code "(defn sorted-map-by\n  ([comparator & keyvals]\n     (loop [in (seq keyvals)\n            out (PersistentTreeMap. (fn->comparator comparator) nil 0 nil 0)]\n       (if in\n         (recur (nnext in) (assoc out (first in) (second in)))\n         out))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [7778 7786]},
                                      :full-name "cljs.core/sorted-map-by",
                                      :clj-symbol "clojure.core/sorted-map-by",
                                      :docstring "keyval => key val\nReturns a new sorted map with supplied mappings, using the supplied comparator."},
           "cljs.core/symbol" {:ns "cljs.core",
                               :name "symbol",
                               :signature ["[name]" "[ns name]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/symbol",
                               :source {:code "(defn symbol\n  ([name]\n   (if (symbol? name)\n     name\n     (let [idx (.indexOf name \"/\")]\n       (if (== idx -1)\n         (symbol nil name)\n         (symbol (.substring name 0 idx)\n                 (.substring name (inc idx) (. name -length)))))))\n  ([ns name]\n   (let [sym-str (if-not (nil? ns)\n                   (str ns \"/\" name)\n                   name)]\n     (Symbol. ns name sym-str nil nil))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [968 981]},
                               :full-name "cljs.core/symbol",
                               :clj-symbol "clojure.core/symbol"},
           "cljs.core/volatile?" {:return-type boolean,
                                  :ns "cljs.core",
                                  :name "volatile?",
                                  :signature ["[x]"],
                                  :history [["+" "0.0-2496"]],
                                  :type "function",
                                  :related ["cljs.core/volatile!"],
                                  :full-name-encode "cljs.core/volatileQMARK",
                                  :source {:code "(defn ^boolean volatile?\n  [x] (instance? Volatile x))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [4073 4075]},
                                  :full-name "cljs.core/volatile?",
                                  :clj-symbol "clojure.core/volatile?",
                                  :docstring "Returns true if x is a volatile."},
           "cljs.core/Delay" {:ns "cljs.core",
                              :name "Delay",
                              :signature ["[f value]"],
                              :history [["+" "0.0-927"]],
                              :type "type",
                              :full-name-encode "cljs.core/Delay",
                              :source {:code "(deftype Delay [^:mutable f ^:mutable value]\n  IDeref\n  (-deref [_]\n    (when f\n      (set! value (f))\n      (set! f nil))\n    value)\n\n  IPending\n  (-realized? [x]\n    (not f)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [9193 9203]},
                              :full-name "cljs.core/Delay",
                              :clj-symbol "clojure.lang/Delay"},
           "cljs.core/methods" {:ns "cljs.core",
                                :name "methods",
                                :signature ["[multifn]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/methods",
                                :source {:code "(defn methods\n  [multifn] (-methods multifn))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [9816 9818]},
                                :full-name "cljs.core/methods",
                                :clj-symbol "clojure.core/methods",
                                :docstring "Given a multimethod, returns a map of dispatch values -> dispatch fns"},
           "cljs.test/test-vars" {:ns "cljs.test",
                                  :name "test-vars",
                                  :signature ["[vars]"],
                                  :history [["+" "0.0-2496"]],
                                  :type "function",
                                  :full-name-encode "cljs.test/test-vars",
                                  :source {:code "(defn test-vars\n  [vars]\n  (run-block (concat (test-vars-block vars)\n                     [(fn []\n                        (report {:type :end-test-vars :vars vars}))])))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/test.cljs",
                                           :lines [576 583]},
                                  :full-name "cljs.test/test-vars",
                                  :clj-symbol "clojure.test/test-vars",
                                  :docstring "Groups vars by their namespace and runs test-vars on them with\nappropriate fixtures assuming they are present in the current\ntesting environment."},
           "cljs.core/lazy-cat" {:description "Expands to code which yields a lazy sequence of the concatenation of the\nsupplied collections. Each collections expression is not evaluated until it is\nneeded.\n\n<table class=\"code-tbl-9bef6\">\n  <thead>\n    <tr>\n      <th>Code</th>\n      <th>Expands To</th></tr></thead>\n  <tbody>\n    <tr>\n      <td><code>(lazy-cat x y z)</code>\n      <td><pre>\n(concat (lazy-seq x)\n        (lazy-seq y)\n        (lazy-seq z))</pre></td></tr></tbody></table>",
                                 :ns "cljs.core",
                                 :name "lazy-cat",
                                 :signature ["[& colls]"],
                                 :history [["+" "0.0-1803"]],
                                 :type "macro",
                                 :related ["cljs.core/lazy-seq"
                                           "cljs.core/concat"],
                                 :full-name-encode "cljs.core/lazy-cat",
                                 :source {:code "(core/defmacro lazy-cat\n  [& colls]\n  `(concat ~@(map #(core/list `lazy-seq %) colls)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/clojure/cljs/core.cljc",
                                          :lines [2588 2595]},
                                 :full-name "cljs.core/lazy-cat",
                                 :clj-symbol "clojure.core/lazy-cat",
                                 :docstring "Expands to code which yields a lazy sequence of the concatenation\nof the supplied colls.  Each coll expr is not evaluated until it is\nneeded.\n\n(lazy-cat xs ys zs) === (concat (lazy-seq xs) (lazy-seq ys) (lazy-seq zs))"},
           "cljs.core/vector" {:description "Creates a new vector containing `args`.",
                               :ns "cljs.core",
                               :name "vector",
                               :signature ["[& args]"],
                               :history [["+" "0.0-927"]],
                               :type "function/macro",
                               :related ["cljs.core/vec"
                                         "cljs.core/vector?"
                                         "cljs.core/pop"
                                         "cljs.core/into"],
                               :full-name-encode "cljs.core/vector",
                               :source {:code "(defn vector\n  [& args]\n  (if (and (instance? IndexedSeq args) (zero? (.-i args)))\n    (.fromArray PersistentVector (.-arr args) true)\n    (vec args)))",
                                        :title "Function code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [4954 4959]},
                               :extra-sources [{:code "(core/defmacro vector\n  ([] '(.-EMPTY cljs.core/PersistentVector))\n  ([& xs]\n   (core/let [cnt (count xs)]\n     (if (core/< cnt 32)\n       `(cljs.core/PersistentVector. nil ~cnt 5\n          (.-EMPTY-NODE cljs.core/PersistentVector) (array ~@xs) nil)\n       (vary-meta\n         `(.fromArray cljs.core/PersistentVector (array ~@xs) true)\n         assoc :tag 'cljs.core/PersistentVector)))))",
                                                :title "Macro code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/clojure/cljs/core.cljc",
                                                :lines [2342 2351]}],
                               :full-name "cljs.core/vector",
                               :clj-symbol "clojure.core/vector",
                               :docstring "Creates a new vector containing the args."},
           "cljs.core/rand-int" {:description "Returns a random integer between 0 inclusive and `n` exclusive.",
                                 :ns "cljs.core",
                                 :name "rand-int",
                                 :signature ["[n]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :related ["cljs.core/rand"],
                                 :full-name-encode "cljs.core/rand-int",
                                 :source {:code "(defn rand-int\n  [n] (Math/floor (* (Math/random) n)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [9407 9409]},
                                 :full-name "cljs.core/rand-int",
                                 :clj-symbol "clojure.core/rand-int",
                                 :docstring "Returns a random integer between 0 (inclusive) and n (exclusive)."},
           "cljs.core/m3-seed" {:ns "cljs.core",
                                :name "m3-seed",
                                :type "var",
                                :source {:code "(def m3-seed 0)",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [796]},
                                :full-name "cljs.core/m3-seed",
                                :full-name-encode "cljs.core/m3-seed",
                                :history [["+" "0.0-2261"]]},
           "cljs.core/PersistentQueue.EMPTY" {:ns "cljs.core",
                                              :name "PersistentQueue.EMPTY",
                                              :history [["+"
                                                         "0.0-927"]],
                                              :parent-type "PersistentQueue",
                                              :type "var",
                                              :full-name-encode "cljs.core/PersistentQueueDOTEMPTY",
                                              :source {:code "(set! (.-EMPTY PersistentQueue) (PersistentQueue. nil 0 nil [] empty-ordered-hash))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.7.228",
                                                       :filename "src/main/cljs/cljs/core.cljs",
                                                       :lines [5476]},
                                              :full-name "cljs.core/PersistentQueue.EMPTY",
                                              :clj-symbol "clojure.lang/PersistentQueue.EMPTY"},
           "cljs.compiler.api/requires-compilation?" {:ns "cljs.compiler.api",
                                                      :name "requires-compilation?",
                                                      :signature ["[src dest]"
                                                                  "[src dest opts]"
                                                                  "[state src dest opts]"],
                                                      :history [["+"
                                                                 "0.0-3255"]],
                                                      :type "function",
                                                      :full-name-encode "cljs.compiler.api/requires-compilationQMARK",
                                                      :source {:code "(defn requires-compilation?\n  ([src dest] (requires-compilation? src dest nil))\n  ([src dest opts]\n   (requires-compilation?\n     (if-not (nil? env/*compiler*)\n       env/*compiler*\n       (env/default-compiler-env opts))\n     src dest opts))\n  ([state src dest opts]\n   (env/with-compiler-env state\n     (binding [ana/*cljs-warning-handlers* (:warning-handlers opts ana/*cljs-warning-handlers*)]\n       (comp/requires-compilation? src dest opts)))))",
                                                               :title "Source code",
                                                               :repo "clojurescript",
                                                               :tag "r1.7.228",
                                                               :filename "src/main/clojure/cljs/compiler/api.clj",
                                                               :lines [48
                                                                       60]},
                                                      :full-name "cljs.compiler.api/requires-compilation?",
                                                      :docstring "Return true if the src file requires compilation."},
           "cljs.core/unchecked-float" {:return-type number,
                                        :ns "cljs.core",
                                        :name "unchecked-float",
                                        :signature ["[x]"],
                                        :history [["+" "0.0-1798"]],
                                        :type "function/macro",
                                        :full-name-encode "cljs.core/unchecked-float",
                                        :source {:code "(defn ^number unchecked-float [x] x)",
                                                 :title "Function code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/cljs/cljs/core.cljs",
                                                 :lines [2373]},
                                        :extra-sources [{:code "(core/defmacro unchecked-float [x] x)",
                                                         :title "Macro code",
                                                         :repo "clojurescript",
                                                         :tag "r1.7.228",
                                                         :filename "src/main/clojure/cljs/core.cljc",
                                                         :lines [971]}],
                                        :full-name "cljs.core/unchecked-float",
                                        :clj-symbol "clojure.core/unchecked-float"},
           "clojure.core.reducers/append!" {:ns "clojure.core.reducers",
                                            :name "append!",
                                            :signature ["[acc x]"],
                                            :history [["+" "0.0-1236"]],
                                            :type "function",
                                            :full-name-encode "clojure.core.reducers/appendBANG",
                                            :source {:code "(defn append!\n  [acc x]\n  (doto acc (.push x)))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.7.228",
                                                     :filename "src/main/cljs/clojure/core/reducers.cljs",
                                                     :lines [232 235]},
                                            :full-name "clojure.core.reducers/append!",
                                            :clj-symbol "clojure.core.reducers/append!",
                                            :docstring ".adds x to acc and returns acc"},
           "syntax/js-literal" {:description "Create a literal JavaScript object or array.  Data in the form of a map `{}` or\nvector `[]` must follow the `#js` tag, which will be converted at compile-time\nto a JavaScript object or array, respectively.\n\nThis will not implicitly convert nested data into JavaScript objects or arrays.",
                                :ns "syntax",
                                :name "js-literal",
                                :history [["+" "0.0-2120"]],
                                :type "tagged literal",
                                :related ["cljs.core/js-obj"
                                          "cljs.core/array"
                                          "cljs.core/clj->js"],
                                :full-name-encode "syntax/js-literal",
                                :extra-sources ({:code "(defn read-js\n  [form]\n  (when-not (or (vector? form) (map? form))\n    (throw\n      #?(:clj  (RuntimeException.\n                 \"JavaScript literal must use map or vector notation\")\n         :cljs (js/Error.\n                 \"JavaScript literal must use map or vector notation\"))))\n  (when-not (or (not (map? form))\n                (every? valid-js-literal-key? (keys form)))\n    (throw\n      #?(:clj  (RuntimeException.\n                 \"JavaScript literal keys must be strings or unqualified keywords\")\n         :cljs (js/Error.\n                 \"JavaScript literal keys must be strings or unqualified keywords\"))))\n  (JSValue. form))",
                                                 :title "Reader code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/clojure/cljs/tagged_literals.cljc",
                                                 :lines [62 77]}
                                                {:code "(def ^:dynamic *cljs-data-readers*\n  {'queue read-queue\n   'uuid  read-uuid\n   'inst  read-inst\n   'js    read-js})",
                                                 :title "Reader table",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/clojure/cljs/tagged_literals.cljc",
                                                 :lines [79 83]}),
                                :usage ["#js [...]" "#js {...}"],
                                :examples [{:id "05e121",
                                            :content "```clj\n#js {:foo 1 bar 2}\n;;=> #js {:foo 1, :bar 2}\n\n#js [1 2 3]\n;;=> #js [1 2 3]\n```\n\nFor readability, it is sometimes preferable to use `clj->js` rather than nested\n`#js` tags.\n\n```clj\n#js {:foo #js {:bar 1}}\n;;=> #js {:foo #js {:bar 1}}\n\n(clj->js {:foo {:bar 1}})\n;;=> #js {:foo #js {:bar 1}}\n```"}],
                                :full-name "syntax/js-literal",
                                :display "#js literal"},
           "cljs.core/NodeSeq" {:ns "cljs.core",
                                :name "NodeSeq",
                                :signature ["[meta nodes i s __hash]"],
                                :history [["+" "0.0-1211"]],
                                :type "type",
                                :full-name-encode "cljs.core/NodeSeq",
                                :source {:code "(deftype NodeSeq [meta nodes i s ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IWithMeta\n  (-with-meta [coll meta] (NodeSeq. meta nodes i s __hash))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY List) meta))\n\n  ISequential\n  ISeq\n  (-first [coll]\n    (if (nil? s)\n      [(aget nodes i) (aget nodes (inc i))]\n      (first s)))\n\n  (-rest [coll]\n    (if (nil? s)\n      (create-inode-seq nodes (+ i 2) nil)\n      (create-inode-seq nodes i (next s))))\n\n  ISeqable\n  (-seq [this] this)\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [6677 6719]},
                                :full-name "cljs.core/NodeSeq",
                                :clj-symbol "clojure.lang/NodeSeq"},
           "cljs.core/letfn" {:description "Takes a vector of function definitions `fnspecs` and binds the functions to\ntheir names. All of the names are available in all of the definitions of the\nfunctions as well as `body`.\n\n`fnspecs` must be a vector with an even number of forms. See `let`.\n\n`letfn` is a wrapper over one of ClojureScript's [special forms].\n\n[special forms]:http://clojure.org/special_forms",
                              :ns "cljs.core",
                              :name "letfn",
                              :signature ["[fnspecs & body]"],
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :related ["cljs.core/let"],
                              :full-name-encode "cljs.core/letfn",
                              :source {:code "(defmacro letfn \n  [fnspecs & body] \n  `(letfn* ~(vec (interleave (map first fnspecs) \n                             (map #(cons `fn %) fnspecs)))\n           ~@body))",
                                       :title "Source code",
                                       :repo "clojure",
                                       :tag "clojure-1.7.0",
                                       :filename "src/clj/clojure/core.clj",
                                       :lines [6271 6282]},
                              :full-name "cljs.core/letfn",
                              :clj-symbol "clojure.core/letfn",
                              :docstring "fnspec ==> (fname [params*] exprs) or (fname ([params*] exprs)+)\n\nTakes a vector of function specs and a body, and generates a set of\nbindings of functions to their names. All of the names are available\nin all of the definitions of the functions, as well as the body."},
           "cljs.reader/read-discard" {:ns "cljs.reader",
                                       :name "read-discard",
                                       :type "function",
                                       :signature ["[rdr _]"],
                                       :source {:code "(defn read-discard\n  [rdr _]\n  (read rdr true nil true)\n  rdr)",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/cljs/reader.cljs",
                                                :lines [404 407]},
                                       :full-name "cljs.reader/read-discard",
                                       :full-name-encode "cljs.reader/read-discard",
                                       :history [["+" "0.0-927"]]},
           "cljs.js/wrap-error" {:ns "cljs.js",
                                 :name "wrap-error",
                                 :signature ["[ex]"],
                                 :history [["+" "1.7.10"]
                                           ["-" "1.7.28"]],
                                 :type "function",
                                 :full-name-encode "cljs.js/wrap-error",
                                 :source {:code "(defn wrap-error [ex]\n  {:error ex})",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.10",
                                          :filename "src/main/cljs/cljs/js.cljs",
                                          :lines [100 101]},
                                 :full-name "cljs.js/wrap-error",
                                 :removed {:in "1.7.28",
                                           :last-seen "1.7.10"}},
           "cljs.repl.server/read-headers" {:ns "cljs.repl.server",
                                            :name "read-headers",
                                            :type "function",
                                            :signature ["[rdr]"],
                                            :source {:code "(defn read-headers [rdr]\n  (loop [next-line (.readLine rdr) header-lines []]\n    (if (= \"\" next-line)\n      header-lines ;; we're done reading headers\n      (recur\n        (.readLine rdr)\n        (conj header-lines next-line)))))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.7.228",
                                                     :filename "src/main/clojure/cljs/repl/server.clj",
                                                     :lines [66 72]},
                                            :full-name "cljs.repl.server/read-headers",
                                            :full-name-encode "cljs.repl.server/read-headers",
                                            :history [["+" "0.0-1503"]]},
           "cljs.core/gen-apply-to" {:ns "cljs.core",
                                     :name "gen-apply-to",
                                     :type "macro",
                                     :signature ["[]"],
                                     :source {:code "(core/defmacro gen-apply-to []\n  `(do\n     (set! ~'*unchecked-if* true)\n     (defn ~'apply-to [~'f ~'argc ~'args]\n       (let [~'args (seq ~'args)]\n         (if (zero? ~'argc)\n           (~'f)\n           ~(gen-apply-to-helper))))\n     (set! ~'*unchecked-if* false)))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/clojure/cljs/core.cljc",
                                              :lines [2567 2575]},
                                     :full-name "cljs.core/gen-apply-to",
                                     :full-name-encode "cljs.core/gen-apply-to",
                                     :history [["+" "0.0-1211"]]},
           "cljs.core/inc" {:description "Returns a number one greater than `x`.",
                            :ns "cljs.core",
                            :name "inc",
                            :signature ["[x]"],
                            :history [["+" "0.0-927"]],
                            :type "function/macro",
                            :related ["cljs.core/dec"],
                            :full-name-encode "cljs.core/inc",
                            :source {:code "(defn inc\n  [x] (cljs.core/+ x 1))",
                                     :title "Function code",
                                     :repo "clojurescript",
                                     :tag "r1.7.228",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [1262 1264]},
                            :extra-sources [{:code "(core/defmacro ^::ana/numeric inc [x]\n  `(+ ~x 1))",
                                             :title "Macro code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/clojure/cljs/core.cljc",
                                             :lines [1065 1066]}],
                            :full-name "cljs.core/inc",
                            :clj-symbol "clojure.core/inc",
                            :docstring "Returns a number one greater than num."},
           "cljs.core/NodeIterator" {:ns "cljs.core",
                                     :name "NodeIterator",
                                     :type "type",
                                     :signature ["[arr i next-entry next-iter]"],
                                     :source {:code "(deftype NodeIterator [arr ^:mutable i ^:mutable next-entry ^:mutable next-iter]\n  Object\n  (advance [this]\n    (let [len (alength arr)]\n      (loop []\n        (if (< i len)\n          (let [key (aget arr i)\n                node-or-val (aget arr (inc i))\n                ^boolean found\n                (cond (some? key)\n                      (set! next-entry [key node-or-val])\n                      (some? node-or-val)\n                      (let [new-iter (-iterator node-or-val)]\n                        (if ^boolean (.hasNext new-iter)\n                          (set! next-iter new-iter)\n                          false))\n                      :else false)]\n            (set! i (+ i 2))\n            (if found true (recur)))\n          false))))\n  (hasNext [this]\n    (or (some? next-entry) (some? next-iter) (.advance this)))\n  (next [this]\n    (cond\n      (some? next-entry)\n      (let [ret next-entry]\n        (set! next-entry nil)\n        ret)\n      (some? next-iter)\n      (let [ret (.next next-iter)]\n        (when-not ^boolean (.hasNext next-iter)\n          (set! next-iter nil))\n        ret)\n      ^boolean (.advance this)\n      (.next this)\n      :else (throw (js/Error. \"No such element\"))))\n  (remove [_] (js/Error. \"Unsupported operation\")))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/cljs/cljs/core.cljs",
                                              :lines [6174 6210]},
                                     :full-name "cljs.core/NodeIterator",
                                     :full-name-encode "cljs.core/NodeIterator",
                                     :history [["+" "1.7.28"]]},
           "cljs.core/name" {:description "Returns the name string of a possibly namespace-qualified keyword or symbol.\n\nEquivalent to [doc:cljs.core/identity] for strings.",
                             :ns "cljs.core",
                             :name "name",
                             :signature ["[x]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/namespace"],
                             :full-name-encode "cljs.core/name",
                             :source {:code "(defn name\n  [x]\n  (if (implements? INamed x)\n    (-name ^not-native x)\n    (if (string? x)\n      x\n      (throw (js/Error. (str \"Doesn't support name: \" x))))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [8297 8304]},
                             :examples [{:id "363fb7",
                                         :content "With namespaces:\n\n```clj\n(name :foo/bar)\n;;=> \"bar\"\n\n(name 'foo/bar)\n;;=> \"bar\"\n```\n\nWithout namespaces:\n\n```clj\n(name :foo)\n;;=> \"foo\"\n\n(name 'foo)\n;;=> \"foo\"\n```\n\nStrings have no concept of a namespace:\n\n```clj\n(name \"foo/bar\")\n;;=> \"foo/bar\"\n\n(name \"foo\")\n;;=> \"foo\"\n```"}],
                             :full-name "cljs.core/name",
                             :clj-symbol "clojure.core/name",
                             :docstring "Returns the name String of a string, symbol or keyword."},
           "cljs.repl/decorate-specs" {:ns "cljs.repl",
                                       :name "decorate-specs",
                                       :type "function",
                                       :signature ["[specs]"],
                                       :source {:code "(defn decorate-specs [specs]\n  (if-let [k (some #{:reload :reload-all} specs)]\n    (->> specs (remove #{k}) (map #(vary-meta % assoc :reload k)))\n    specs))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/clojure/cljs/repl.cljc",
                                                :lines [578 581]},
                                       :full-name "cljs.repl/decorate-specs",
                                       :full-name-encode "cljs.repl/decorate-specs",
                                       :history [["+" "0.0-3148"]]},
           "cljs.test/test-ns-block" {:ns "cljs.test",
                                      :name "test-ns-block",
                                      :signature ["[env [quote ns :as form]]"],
                                      :history [["+" "0.0-2814"]],
                                      :type "macro",
                                      :full-name-encode "cljs.test/test-ns-block",
                                      :source {:code "(defmacro test-ns-block\n  ([env [quote ns :as form]]\n   (assert (and (= quote 'quote) (symbol? ns)) \"Argument to test-ns must be a quoted symbol\")\n   (assert (ana-api/find-ns ns) (str \"Namespace \" ns \" does not exist\"))\n   `[(fn []\n       (cljs.test/set-env! ~env)\n       (cljs.test/do-report {:type :begin-test-ns, :ns ~form})\n       ;; If the namespace has a test-ns-hook function, call that:\n       ~(if-let [v (ana-api/ns-resolve ns 'test-ns-hook)]\n          `(~(symbol (name ns) \"test-ns-hook\"))\n          ;; Otherwise, just test every var in the namespace.\n          `(cljs.test/block (cljs.test/test-all-vars-block ~form))))\n     (fn []\n       (cljs.test/do-report {:type :end-test-ns, :ns ~form}))]))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/cljs/cljs/test.clj",
                                               :lines [343 358]},
                                      :full-name "cljs.test/test-ns-block",
                                      :docstring "Like test-ns, but returns a block for further composition and\nlater execution.  Does not clear the current env."},
           "cljs.core/cycle" {:description "Returns an infinite lazy sequence of repetitions of the items in `coll`.",
                              :ns "cljs.core",
                              :name "cycle",
                              :signature ["[coll]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/lazy-seq"
                                        "cljs.core/repeatedly"],
                              :full-name-encode "cljs.core/cycle",
                              :source {:code "(defn cycle\n  [coll] (lazy-seq\n          (when-let [s (seq coll)]\n            (concat s (cycle s)))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [4334 4338]},
                              :full-name "cljs.core/cycle",
                              :clj-symbol "clojure.core/cycle",
                              :docstring "Returns a lazy (infinite!) sequence of repetitions of the items in coll."},
           "cljs.core/rsubseq" {:description "`sc` must be a sorted collection.\n\n`test`, `start-test`, `end-test` must be `<`, `<=`, `>` or `>=`.\n\nReturns a reverse sequence of those entries with keys `ek` for which\n`(test (.. sc comparator (compare ek key)) 0)` is true.",
                                :ns "cljs.core",
                                :name "rsubseq",
                                :signature ["[sc test key]"
                                            "[sc start-test start-key end-test end-key]"],
                                :history [["+" "0.0-1211"]],
                                :type "function",
                                :related ["cljs.core/subseq"],
                                :full-name-encode "cljs.core/rsubseq",
                                :source {:code "(defn rsubseq\n  ([sc test key]\n     (let [include (mk-bound-fn sc test key)]\n       (if (#{< <=} test)\n         (when-let [[e :as s] (-sorted-seq-from sc key false)]\n           (if (include e) s (next s)))\n         (take-while include (-sorted-seq sc false)))))\n  ([sc start-test start-key end-test end-key]\n     (when-let [[e :as s] (-sorted-seq-from sc end-key false)]\n       (take-while (mk-bound-fn sc start-test start-key)\n                   (if ((mk-bound-fn sc end-test end-key) e) s (next s))))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [8414 8427]},
                                :full-name "cljs.core/rsubseq",
                                :clj-symbol "clojure.core/rsubseq",
                                :docstring "sc must be a sorted collection, test(s) one of <, <=, > or\n>=. Returns a reverse seq of those entries with keys ek for\nwhich (test (.. sc comparator (compare ek key)) 0) is true"},
           "cljs.core/divide" {:ns "cljs.core",
                               :name "divide",
                               :type "macro",
                               :signature ["[x]"
                                           "[x y]"
                                           "[x y & more]"],
                               :source {:code "(core/defmacro ^::ana/numeric divide\n  ([x] `(/ 1 ~x))\n  ([x y] (core/list 'js* \"(~{} / ~{})\" x y))\n  ([x y & more] `(/ (/ ~x ~y) ~@more)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/clojure/cljs/core.cljc",
                                        :lines [1032 1035]},
                               :full-name "cljs.core/divide",
                               :full-name-encode "cljs.core/divide",
                               :history [["+" "0.0-1798"]]},
           "cljs.core/hash-ordered-coll" {:return-type number,
                                          :ns "cljs.core",
                                          :name "hash-ordered-coll",
                                          :signature ["[coll]"],
                                          :history [["+" "0.0-2261"]],
                                          :type "function",
                                          :full-name-encode "cljs.core/hash-ordered-coll",
                                          :source {:code "(defn ^number hash-ordered-coll\n  [coll]\n  (loop [n 0 hash-code 1 coll (seq coll)]\n    (if-not (nil? coll)\n      (recur (inc n) (bit-or (+ (imul 31 hash-code) (hash (first coll))) 0)\n        (next coll))\n      (mix-collection-hash hash-code n))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/cljs/cljs/core.cljs",
                                                   :lines [1193 1202]},
                                          :full-name "cljs.core/hash-ordered-coll",
                                          :clj-symbol "clojure.core/hash-ordered-coll",
                                          :docstring "Returns the hash code, consistent with =, for an external ordered\ncollection implementing Iterable.\nSee http://clojure.org/data_structures#hash for full algorithms."},
           "cljs.core/nil-iter" {:ns "cljs.core",
                                 :name "nil-iter",
                                 :type "function",
                                 :signature ["[]"],
                                 :source {:code "(defn nil-iter []\n  (reify\n    Object\n    (hasNext [_] false)\n    (next [_] (js/Error. \"No such element\"))\n    (remove [_] (js/Error. \"Unsupported operation\"))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [3521 3526]},
                                 :full-name "cljs.core/nil-iter",
                                 :full-name-encode "cljs.core/nil-iter",
                                 :history [["+" "0.0-2301"]]},
           "cljs.analyzer.api/all-ns" {:ns "cljs.analyzer.api",
                                       :name "all-ns",
                                       :signature ["[]" "[state]"],
                                       :history [["+" "0.0-2496"]],
                                       :type "function",
                                       :full-name-encode "cljs.analyzer.api/all-ns",
                                       :source {:code "(defn all-ns\n  ([]\n   (all-ns env/*compiler*))\n  ([state]\n   (keys (get @state ::ana/namespaces))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/clojure/cljs/analyzer/api.clj",
                                                :lines [152 158]},
                                       :full-name "cljs.analyzer.api/all-ns",
                                       :clj-symbol "clojure.core/all-ns",
                                       :docstring "Return all namespaces. Analagous to clojure.core/all-ns but\nreturns symbols identifying namespaces not Namespace instances."},
           "cljs.test/run-all-tests" {:ns "cljs.test",
                                      :name "run-all-tests",
                                      :signature ["[]"
                                                  "[re]"
                                                  "[re env]"],
                                      :history [["+" "0.0-2496"]],
                                      :type "macro",
                                      :full-name-encode "cljs.test/run-all-tests",
                                      :source {:code "(defmacro run-all-tests\n  ([] `(cljs.test/run-all-tests nil (cljs.test/empty-env)))\n  ([re] `(cljs.test/run-all-tests ~re (cljs.test/empty-env)))\n  ([re env]\n   `(cljs.test/run-tests ~env\n      ~@(map\n          (fn [ns] `(quote ~ns))\n          (cond->> (ana-api/all-ns)\n            re (filter #(re-matches re (name %))))))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/cljs/cljs/test.clj",
                                               :lines [297 309]},
                                      :full-name "cljs.test/run-all-tests",
                                      :clj-symbol "clojure.test/run-all-tests",
                                      :docstring "Runs all tests in all namespaces; prints results.\nOptional argument is a regular expression; only namespaces with\nnames matching the regular expression (with re-matches) will be\ntested."},
           "cljs.core/map" {:description "Returns a lazy sequence of applying function `f` to every element of `coll`.\n\nWhen more than one collection is provided, returns a lazy sequence consisting of\nthe result of applying `f` to the set of first items of each `c`, followed by\napplying `f` to the set of second items in each `c`, until any one of the `c`s\nis exhausted. Any remaining items in other `c`s are ignored. Function `f` should\naccept number-of-`c`s arguments.\n\nReturns a transducer when no collection is provided.",
                            :ns "cljs.core",
                            :name "map",
                            :signature ["[f]"
                                        "[f coll]"
                                        "[f c1 c2]"
                                        "[f c1 c2 c3]"
                                        "[f c1 c2 c3 & colls]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/map-indexed"
                                      "cljs.core/amap"
                                      "cljs.core/mapcat"
                                      "cljs.core/keep"
                                      "cljs.core/juxt"],
                            :full-name-encode "cljs.core/map",
                            :source {:code "(defn map\n  ([f]\n    (fn [rf]\n      (fn\n        ([] (rf))\n        ([result] (rf result))\n        ([result input]\n           (rf result (f input)))\n        ([result input & inputs]\n           (rf result (apply f input inputs))))))\n  ([f coll]\n   (lazy-seq\n    (when-let [s (seq coll)]\n      (if (chunked-seq? s)\n        (let [c (chunk-first s)\n              size (count c)\n              b (chunk-buffer size)]\n          (dotimes [i size]\n              (chunk-append b (f (-nth c i))))\n          (chunk-cons (chunk b) (map f (chunk-rest s))))\n        (cons (f (first s)) (map f (rest s)))))))\n  ([f c1 c2]\n   (lazy-seq\n    (let [s1 (seq c1) s2 (seq c2)]\n      (when (and s1 s2)\n        (cons (f (first s1) (first s2))\n              (map f (rest s1) (rest s2)))))))\n  ([f c1 c2 c3]\n   (lazy-seq\n    (let [s1 (seq c1) s2 (seq c2) s3 (seq c3)]\n      (when (and  s1 s2 s3)\n        (cons (f (first s1) (first s2) (first s3))\n              (map f (rest s1) (rest s2) (rest s3)))))))\n  ([f c1 c2 c3 & colls]\n   (let [step (fn step [cs]\n                 (lazy-seq\n                  (let [ss (map seq cs)]\n                    (when (every? identity ss)\n                      (cons (map first ss) (step (map rest ss)))))))]\n     (map #(apply f %) (step (conj colls c3 c2 c1))))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.7.228",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [4196 4241]},
                            :full-name "cljs.core/map",
                            :clj-symbol "clojure.core/map",
                            :docstring "Returns a lazy sequence consisting of the result of applying f to\nthe set of first items of each coll, followed by applying f to the\nset of second items in each coll, until any one of the colls is\nexhausted.  Any remaining items in other colls are ignored. Function\nf should accept number-of-colls arguments. Returns a transducer when\nno collection is provided."},
           "cljs.core/ChunkBuffer" {:ns "cljs.core",
                                    :name "ChunkBuffer",
                                    :signature ["[buf end]"],
                                    :history [["+" "0.0-1424"]],
                                    :type "type",
                                    :full-name-encode "cljs.core/ChunkBuffer",
                                    :source {:code "(deftype ChunkBuffer [^:mutable buf ^:mutable end]\n  Object\n  (add [_ o]\n    (aset buf end o)\n    (set! end (inc end)))\n\n  (chunk [_ o]\n    (let [ret (ArrayChunk. buf 0 end)]\n      (set! buf nil)\n      ret))\n\n  ICounted\n  (-count [_] end))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [3075 3087]},
                                    :full-name "cljs.core/ChunkBuffer",
                                    :clj-symbol "clojure.lang/ChunkBuffer"},
           "cljs.js/eval*" {:ns "cljs.js",
                            :name "eval*",
                            :signature ["[bound-vars form opts cb]"],
                            :history [["+" "1.7.10"] ["-" "1.7.28"]],
                            :type "function",
                            :full-name-encode "cljs.js/evalSTAR",
                            :source {:code "(defn eval* [bound-vars form opts cb]\n  (let [the-ns     (or (:ns opts) 'cljs.user)\n        bound-vars (cond-> (merge bound-vars {:*cljs-ns* the-ns})\n                     (:source-map opts) (assoc :*sm-data* (sm-data)))]\n    (binding [env/*compiler*         (:*compiler* bound-vars)\n              *eval-fn*              (:*eval-fn* bound-vars)\n              ana/*cljs-ns*          (:*cljs-ns* bound-vars)\n              *ns*                   (create-ns (:*cljs-ns* bound-vars))\n              r/*data-readers*       (:*data-readers* bound-vars)\n              comp/*source-map-data* (:*sm-data* bound-vars)]\n      (let [aenv (ana/empty-env)\n            aenv (cond-> (assoc aenv :ns (ana/get-namespace ana/*cljs-ns*))\n                   (:context opts) (assoc :context (:context opts))\n                   (:def-emits-var opts) (assoc :def-emits-var true))\n            res  (try\n                   {:value (ana/analyze aenv form nil opts)}\n                   (catch :default cause\n                     (wrap-error\n                       (ana/error aenv\n                         (str \"Could not eval \" form) cause))))]\n        (if (:error res)\n          (cb res)\n          (let [ast (:value res)]\n            (if (= :ns (:op ast))\n              (ns-side-effects true bound-vars aenv ast opts\n                (fn [res]\n                  (if (:error res)\n                    (cb res)\n                    (let [src (str \"goog.provide(\\\"\" (munge (:name ast)) \"\\\")\")]\n                      (cb (*eval-fn* {:source src}))))))\n              (let [src (with-out-str (comp/emit ast))]\n                (cb (*eval-fn* {:source src}))))))))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.7.10",
                                     :filename "src/main/cljs/cljs/js.cljs",
                                     :lines [464 495]},
                            :full-name "cljs.js/eval*",
                            :removed {:in "1.7.28",
                                      :last-seen "1.7.10"}},
           "cljs.js/ns->relpath" {:ns "cljs.js",
                                  :name "ns->relpath",
                                  :signature ["[ns-sym]"],
                                  :history [["+" "1.7.10"]],
                                  :type "function",
                                  :full-name-encode "cljs.js/ns-GTrelpath",
                                  :source {:code "(defn ns->relpath\n  [ns-sym]\n  (string/replace (ana/munge-path ns-sym) \\. \\/))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/js.cljs",
                                           :lines [30 33]},
                                  :full-name "cljs.js/ns->relpath",
                                  :docstring "Given a namespace as a symbol return the relative path sans extension"},
           "cljs.repl/repl-read" {:ns "cljs.repl",
                                  :name "repl-read",
                                  :signature ["[request-prompt request-exit]"
                                              "[request-prompt request-exit opts]"],
                                  :history [["+" "0.0-2719"]],
                                  :type "function",
                                  :full-name-encode "cljs.repl/repl-read",
                                  :source {:code "(defn repl-read\n  ([request-prompt request-exit]\n   (repl-read request-prompt request-exit *repl-opts*))\n  ([request-prompt request-exit opts]\n   (binding [*in* (if (true? (:source-map-inline opts))\n                    ((:reader opts))\n                    *in*)]\n     (or ({:line-start request-prompt :stream-end request-exit}\n          (skip-whitespace *in*))\n        (let [input (reader/read {:read-cond :allow :features #{:cljs}} *in*)]\n          (skip-if-eol *in*)\n          input)))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/clojure/cljs/repl.cljc",
                                           :lines [78 99]},
                                  :full-name "cljs.repl/repl-read",
                                  :docstring "Default :read hook for repl. Reads from *in* which must either be an\ninstance of LineNumberingPushbackReader or duplicate its behavior of both\nsupporting .unread and collapsing all of CR, LF, and CRLF into a single\n\\newline. repl-read:\n  - skips whitespace, then\n    - returns request-prompt on start of line, or\n    - returns request-exit on end of stream, or\n    - reads an object from the input stream, then\n      - skips the next input character if it's end of line, then\n      - returns the object."},
           "syntax/list" {:description "Creates a list.  The most salient feature of a list is that, when evaluated, it\nis interpreted as a _call_.\n\nIn most languages, the parenthesis is on the right side of a function when\ncalling:\n\n```js\n// (not ClojureScript)\nf(a, b)\n```\n\nIn ClojureScript, the parenthesis simply starts on the left side:\n\n```clj\n;; ClojureScript (comma is optional)\n(f a, b)\n```\n\nThus, when `(f a b)` is evaluated, it calls `f` with two arguments `a` and `b`.\n\nIf `f` is a function, its arguments `a` and `b` will be evaluated before\nthe function receives them.\n\nIf `f` is a special form or macro, it will receive its arguments `a` and `b`\nunevaluated, where they _may_ be evaluated internally.\n\n(See [doc:cljs.core/List] for data structure details.)",
                          :ns "syntax",
                          :name "list",
                          :history [["+" "0.0-927"]],
                          :type "syntax",
                          :related ["syntax/vector" "syntax/quote"],
                          :full-name-encode "syntax/list",
                          :extra-sources ({:code "(defn- read-list\n  [rdr _ opts pending-forms]\n  (let [[start-line start-column] (starting-line-col-info rdr)\n        the-list (read-delimited \\) rdr opts pending-forms)\n        [end-line end-column] (ending-line-col-info rdr)]\n    (with-meta (if (empty? the-list)\n                 '()\n                 (clojure.lang.PersistentList/create the-list))\n      (when start-line\n        (merge\n         (when-let [file (get-file-name rdr)]\n           {:file file})\n         {:line start-line\n          :column start-column\n          :end-line end-line\n          :end-column end-column})))))",
                                           :title "Reader code",
                                           :repo "tools.reader",
                                           :tag "tools.reader-1.0.0-alpha1",
                                           :filename "src/main/clojure/clojure/tools/reader.clj",
                                           :lines [204 220]}
                                          {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                           :title "Reader table",
                                           :repo "tools.reader",
                                           :tag "tools.reader-1.0.0-alpha1",
                                           :filename "src/main/clojure/clojure/tools/reader.clj",
                                           :lines [743 762]}),
                          :usage ["(...)"],
                          :examples [{:id "cd26b0",
                                      :content "The following is a list that is evaluated to create var `a`:\n\n```clj\n(def a 1)\n```\n\nAn empty list is unevaluated and left as an empty list:\n\n```clj\n()\n;;=> ()\n```\n\nTo signify an unevaluated list, precede it with a quote:\n\n```clj\n'(1 2 3)\n;;=> (1 2 3)\n```"}],
                          :edn-doc "https://github.com/edn-format/edn#lists",
                          :full-name "syntax/list",
                          :display "() list",
                          :clj-doc "http://clojure.org/reader#toc1"},
           "cljs.core/amap" {:description "For quickly creating a new JavaScript array by mapping an expression `expr`\nacross a JavaScript array `a`.  The expression can use `ret` as the current\nresult, which is initialized to `a`.  It can also use `idx` to get the current\nindex.",
                             :ns "cljs.core",
                             :name "amap",
                             :signature ["[a idx ret expr]"],
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :related ["cljs.core/map"],
                             :full-name-encode "cljs.core/amap",
                             :source {:code "(core/defmacro amap\n  [a idx ret expr]\n  `(let [a# ~a\n         ~ret (aclone a#)]\n     (loop  [~idx 0]\n       (if (< ~idx  (alength a#))\n         (do\n           (aset ~ret ~idx ~expr)\n           (recur (inc ~idx)))\n         ~ret))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/clojure/cljs/core.cljc",
                                      :lines [2421 2434]},
                             :examples [{:id "3a7471",
                                         :content "```clj\n(def a #js [1 2 3])\n(amap a i ret (* 10 (aget a i)))\n;;=> #js [10 20 30]\n```"}
                                        {:id "0f57af",
                                         :content "You can also use `ret` inside the mapped expression if you want to use the\ncurrent result:\n\n```clj\n(def a #js [1 2 3])\n(amap a i ret (+ (if (pos? i)\n                   (aget ret (dec i))\n                   0)\n                 (* 10 (aget a i))))\n;;=> #js [10 30 60]\n```"}],
                             :full-name "cljs.core/amap",
                             :clj-symbol "clojure.core/amap",
                             :docstring "Maps an expression across an array a, using an index named idx, and\nreturn value named ret, initialized to a clone of a, then setting\neach element of ret to the evaluation of expr, returning the new\narray ret."},
           "cljs.repl/repl-caught" {:ns "cljs.repl",
                                    :name "repl-caught",
                                    :type "function",
                                    :signature ["[e repl-env opts]"],
                                    :source {:code "(defn repl-caught [e repl-env opts]\n  (if (and (instance? IExceptionInfo e)\n           (#{:js-eval-error :js-eval-exception} (:type (ex-data e))))\n    (let [{:keys [type repl-env error form js]} (ex-data e)]\n      (case type\n        :js-eval-error\n        (display-error repl-env error form opts)\n\n        :js-eval-exception\n        (display-error repl-env error form\n          (if (:repl-verbose opts)\n            #(prn \"Error evaluating:\" form :as js)\n            (constantly nil))\n          opts)))\n    (.printStackTrace e *err*)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/clojure/cljs/repl.cljc",
                                             :lines [736 750]},
                                    :full-name "cljs.repl/repl-caught",
                                    :full-name-encode "cljs.repl/repl-caught",
                                    :history [["+" "0.0-2911"]]},
           "syntax/uuid-literal" {:description "Creates a universally unique identifier (UUID), using the [doc:cljs.core/UUID] type.\n\nThe format is `#uuid \"8-4-4-4-12\"`, where the numbers represent the number of hex digits.\n\nRepresenting UUIDs with `#uuid` rather than just a plain string has the following benefits:\n\n- the reader will throw an exception on malformed UUIDs\n- its UUID type is preserved and shown when serialized to [edn].\n\nTo create a UUID from an evaluated expression, use [doc:cljs.core/uuid].\n\n[edn]:https://github.com/edn-format/edn",
                                  :ns "syntax",
                                  :name "uuid-literal",
                                  :history [["+" "0.0-1211"]],
                                  :type "tagged literal",
                                  :related ["cljs.core/uuid"
                                            "cljs.core/random-uuid"],
                                  :full-name-encode "syntax/uuid-literal",
                                  :extra-sources ({:code "   (defn read-uuid\n     [form]\n     (when-not (string? form)\n       (throw (RuntimeException. \"UUID literal expects a string as its representation.\")))\n     (try\n       (java.util.UUID/fromString form)\n       (catch Throwable e\n         (throw (RuntimeException. (.getMessage e)))))))",
                                                   :title "Reader code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/clojure/cljs/tagged_literals.cljc",
                                                   :lines [16 23]}
                                                  {:code "(def ^:dynamic *cljs-data-readers*\n  {'queue read-queue\n   'uuid  read-uuid\n   'inst  read-inst\n   'js    read-js})",
                                                   :title "Reader table",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/clojure/cljs/tagged_literals.cljc",
                                                   :lines [79 83]}),
                                  :usage ["#uuid \"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\""],
                                  :examples [{:id "12c0f0",
                                              :content "```clj\n#uuid \"00000000-0000-0000-0000-000000000000\"\n;;=> #uuid \"00000000-0000-0000-0000-000000000000\"\n\n#uuid \"97bda55b-6175-4c39-9e04-7c0205c709dc\"\n;;=> #uuid \"97bda55b-6175-4c39-9e04-7c0205c709dc\"\n\n#uuid \"asdf\"\n;; clojure.lang.ExceptionInfo: Invalid UUID string: asdf\n```\n\nGet as a string:\n\n```clj\n(def foo #uuid \"97bda55b-6175-4c39-9e04-7c0205c709dc\")\n(str foo)\n;;=> \"97bda55b-6175-4c39-9e04-7c0205c709dc\"\n```"}],
                                  :edn-doc "https://github.com/edn-format/edn#uuid-f81d4fae-7dec-11d0-a765-00a0c91e6bf6",
                                  :full-name "syntax/uuid-literal",
                                  :display "#uuid literal",
                                  :clj-doc "https://github.com/clojure/clojure/blob/clojure-1.6.0/src/clj/clojure/core.clj#L6947"},
           "clojure.zip/children" {:ns "clojure.zip",
                                   :name "children",
                                   :signature ["[loc]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "clojure.zip/children",
                                   :source {:code "(defn children\n  [loc]\n    (if (branch? loc)\n      ((:zip/children (meta loc)) (node loc))\n      (throw \"called children on a leaf node\")))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/clojure/zip.cljs",
                                            :lines [69 74]},
                                   :full-name "clojure.zip/children",
                                   :clj-symbol "clojure.zip/children",
                                   :docstring "Returns a seq of the children of node at loc, which must be a branch"},
           "special/set!" {:description "Sets `js-var` to `val` using the JavaScript `=` operator.",
                           :ns "special",
                           :name "set!",
                           :signature ["[js-var val]"],
                           :history [["+" "0.0-927"]],
                           :type "special form",
                           :related ["cljs.core/aset"
                                     "cljs.core/reset!"],
                           :full-name-encode "special/setBANG",
                           :source {:code "(defmethod parse 'set!\n  [_ env [_ target val alt :as form] _ _]\n  (let [[target val] (if alt\n                       ;; (set! o -prop val)\n                       [`(. ~target ~val) alt]\n                       [target val])]\n    (disallowing-recur\n     (let [enve (assoc env :context :expr)\n           targetexpr (cond\n                       (and\n                         (= target '*unchecked-if*) ;; TODO: proper resolve\n                         (or (true? val) (false? val)))\n                       (do\n                         #?(:clj  (reset! *unchecked-if* val)\n                            :cljs (set! *unchecked-if* val))\n                         ::set-unchecked-if)\n\n                       (symbol? target)\n                       (do\n                         (when (:const (resolve-var (dissoc env :locals) target))\n                           (throw (error env \"Can't set! a constant\")))\n                         (let [local (-> env :locals target)]\n                           (when-not (or (nil? local)\n                                         (and (:field local)\n                                              (or (:mutable local)\n                                                  (:unsynchronized-mutable local)\n                                                  (:volatile-mutable local))))\n                             (throw (error env \"Can't set! local var or non-mutable field\"))))\n                         (analyze-symbol enve target))\n\n                       :else\n                       (when (seq? target)\n                         (let [targetexpr (analyze-seq enve target nil)]\n                           (when (:field targetexpr)\n                             targetexpr))))\n           valexpr (analyze enve val)]\n       (when-not targetexpr\n         (throw (error env \"set! target must be a field or a symbol naming a var\")))\n       (cond\n        (= targetexpr ::set-unchecked-if) {:env env :op :no-op}\n        :else {:env env :op :set! :form form :target targetexpr :val valexpr\n               :children [targetexpr valexpr]})))))",
                                    :title "Parser code",
                                    :repo "clojurescript",
                                    :tag "r1.7.228",
                                    :filename "src/main/clojure/cljs/analyzer.cljc",
                                    :lines [1572 1613]},
                           :full-name "special/set!",
                           :clj-symbol "clojure.core/set!",
                           :docstring "Used to set vars and JavaScript object fields"},
           "cljs.core/when-not" {:description "Evaluates `test`. If logical false, evaluates `body` in an implicit `do`.",
                                 :ns "cljs.core",
                                 :name "when-not",
                                 :signature ["[test & body]"],
                                 :history [["+" "0.0-927"]],
                                 :type "macro",
                                 :related ["cljs.core/when"
                                           "cljs.core/when-let"
                                           "special/if"],
                                 :full-name-encode "cljs.core/when-not",
                                 :source {:code "(defmacro when-not\n  [test & body]\n    (list 'if test nil (cons 'do body)))",
                                          :title "Source code",
                                          :repo "clojure",
                                          :tag "clojure-1.7.0",
                                          :filename "src/clj/clojure/core.clj",
                                          :lines [483 487]},
                                 :full-name "cljs.core/when-not",
                                 :clj-symbol "clojure.core/when-not",
                                 :docstring "Evaluates test. If logical false, evaluates body in an implicit do."},
           "clojure.set/index" {:ns "clojure.set",
                                :name "index",
                                :signature ["[xrel ks]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "clojure.set/index",
                                :source {:code "(defn index\n  [xrel ks]\n    (reduce\n     (fn [m x]\n       (let [ik (select-keys x ks)]\n         (assoc m ik (conj (get m ik #{}) x))))\n     {} xrel))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/clojure/set.cljs",
                                         :lines [87 95]},
                                :full-name "clojure.set/index",
                                :clj-symbol "clojure.set/index",
                                :docstring "Returns a map of the distinct values of ks in the xrel mapped to a\nset of the maps in xrel with the corresponding values of ks."},
           "cljs.repl.browser/send-and-close" {:moved "cljs.repl.server/send-and-close",
                                               :ns "cljs.repl.browser",
                                               :name "send-and-close",
                                               :signature ["[conn status form]"
                                                           "[conn status form content-type]"],
                                               :history [["+"
                                                          "0.0-927"]
                                                         ["-"
                                                          "0.0-1503"]],
                                               :type "function",
                                               :full-name-encode "cljs.repl.browser/send-and-close",
                                               :source {:code "(defn send-and-close\n  ([conn status form]\n     (send-and-close conn status form \"text/html\"))\n  ([conn status form content-type]\n     (let [utf-8-form (.getBytes form \"UTF-8\")\n           content-length (count utf-8-form)\n           headers (map #(.getBytes (str % \"\\r\\n\"))\n                        [(status-line status)\n                         \"Server: ClojureScript REPL\"\n                         (str \"Content-Type: \"\n                              content-type\n                              \"; charset=utf-8\")\n                         (str \"Content-Length: \" content-length)\n                         \"\"])]\n       (with-open [os (.getOutputStream conn)]\n         (do (doseq [header headers]\n               (.write os header 0 (count header)))\n             (.write os utf-8-form 0 content-length)\n             (.flush os)\n             (.close conn))))))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1450",
                                                        :filename "src/clj/cljs/repl/browser.clj",
                                                        :lines [69 90]},
                                               :full-name "cljs.repl.browser/send-and-close",
                                               :docstring "Use the passed connection to send a form to the browser. Send a\nproper HTTP response.",
                                               :removed {:in "0.0-1503",
                                                         :last-seen "0.0-1450"}},
           "cljs.build.api/compile" {:ns "cljs.build.api",
                                     :name "compile",
                                     :signature ["[opts compilable]"
                                                 "[state opts compilable]"],
                                     :history [["+" "0.0-3291"]],
                                     :type "function",
                                     :full-name-encode "cljs.build.api/compile",
                                     :source {:code "(defn compile\n  ([opts compilable]\n   (compile\n     (if-not (nil? env/*compiler*)\n       env/*compiler*\n       (env/default-compiler-env opts))\n     opts compilable))\n  ([state opts compilable]\n   (env/with-compiler-env state\n     (closure/compile compilable opts))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/clojure/cljs/build/api.clj",
                                              :lines [176 186]},
                                     :full-name "cljs.build.api/compile",
                                     :docstring "Given a Compilable, compile it and return an IJavaScript."},
           "cljs.core/chunked-seq?" {:return-type boolean,
                                     :ns "cljs.core",
                                     :name "chunked-seq?",
                                     :signature ["[x]"],
                                     :history [["+" "0.0-1424"]],
                                     :type "function",
                                     :full-name-encode "cljs.core/chunked-seqQMARK",
                                     :source {:code "(defn ^boolean chunked-seq?\n  [x] (implements? IChunkedSeq x))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/cljs/cljs/core.cljs",
                                              :lines [1937 1939]},
                                     :full-name "cljs.core/chunked-seq?",
                                     :docstring "Return true if x is satisfies IChunkedSeq."},
           "clojure.browser.dom/log" {:ns "clojure.browser.dom",
                                      :name "log",
                                      :type "function",
                                      :signature ["[& args]"],
                                      :source {:code "(defn log [& args]\n  (.log js/console (apply pr-str args)))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/cljs/clojure/browser/dom.cljs",
                                               :lines [20 21]},
                                      :full-name "clojure.browser.dom/log",
                                      :full-name-encode "clojure.browser.dom/log",
                                      :history [["+" "0.0-927"]]},
           "cljs.core/Vector.fromArray" {:ns "cljs.core",
                                         :name "Vector.fromArray",
                                         :signature ["[xs]"],
                                         :history [["+" "0.0-927"]
                                                   ["-" "0.0-1798"]],
                                         :parent-type "Vector",
                                         :type "function",
                                         :full-name-encode "cljs.core/VectorDOTfromArray",
                                         :source {:code "(set! cljs.core.Vector/fromArray (fn [xs] (Vector. nil xs nil)))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1586",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [2861]},
                                         :full-name "cljs.core/Vector.fromArray",
                                         :removed {:in "0.0-1798",
                                                   :last-seen "0.0-1586"}},
           "cljs.repl/ns-info" {:ns "cljs.repl",
                                :name "ns-info",
                                :signature ["[f]"],
                                :history [["+" "0.0-2814"]],
                                :type "function",
                                :full-name-encode "cljs.repl/ns-info",
                                :source {:code "(defn ns-info\n  [f]\n  (let [f' (js-src->cljs-src f)]\n    (when (and f' (.exists f'))\n      (ana/parse-ns f'))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/clojure/cljs/repl.cljc",
                                         :lines [244 250]},
                                :full-name "cljs.repl/ns-info",
                                :docstring "Given a path to a js source file return the ns info for the corresponding\nClojureScript file if it exists."},
           "cljs.core/make-array" {:description "Creates an empty JavaScript array of size `size`.",
                                   :return-type array,
                                   :ns "cljs.core",
                                   :name "make-array",
                                   :signature ["[size]"],
                                   :history [["+" "0.0-1211"]],
                                   :type "function/macro",
                                   :related ["cljs.core/aclone"
                                             "cljs.core/array"],
                                   :full-name-encode "cljs.core/make-array",
                                   :source {:code "(defn ^array make-array\n  ([size]\n     (js/Array. size))\n  ([type size]\n     (make-array size)))",
                                            :title "Function code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [356 362]},
                                   :extra-sources [{:code "(core/defmacro make-array\n  [size]\n  (vary-meta\n    (if (core/number? size)\n      `(array ~@(take size (repeat nil)))\n      `(js/Array. ~size))\n    assoc :tag 'array))",
                                                    :title "Macro code",
                                                    :repo "clojurescript",
                                                    :tag "r1.7.228",
                                                    :filename "src/main/clojure/cljs/core.cljc",
                                                    :lines [2329 2335]}],
                                   :full-name "cljs.core/make-array",
                                   :clj-symbol "clojure.core/make-array",
                                   :docstring "Construct a JavaScript array of specified size. Accepts ignored type\nargument for compatibility with Clojure."},
           "cljs.core/sorted-set-by" {:description "Returns a new sorted set with supplied `keys`, using the supplied `comparator`.",
                                      :ns "cljs.core",
                                      :name "sorted-set-by",
                                      :signature ["[comparator & keys]"],
                                      :history [["+" "0.0-1211"]],
                                      :type "function",
                                      :related ["cljs.core/sorted-set"
                                                "cljs.core/sorted-map-by"
                                                "cljs.core/compare"],
                                      :full-name-encode "cljs.core/sorted-set-by",
                                      :source {:code "(defn sorted-set-by\n  ([comparator & keys]\n   (reduce -conj\n           (PersistentTreeSet. nil (sorted-map-by comparator) 0)\n           keys)))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [8239 8244]},
                                      :full-name "cljs.core/sorted-set-by",
                                      :clj-symbol "clojure.core/sorted-set-by",
                                      :docstring "Returns a new sorted set with supplied keys, using the supplied comparator."},
           "cljs.repl.node/repl-env" {:ns "cljs.repl.node",
                                      :name "repl-env",
                                      :signature ["[& {:as options}]"],
                                      :history [["+" "0.0-2629"]],
                                      :type "function",
                                      :full-name-encode "cljs.repl.node/repl-env",
                                      :source {:code "(defn repl-env\n  [& {:as options}]\n  (repl-env* options))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/clojure/cljs/repl/node.clj",
                                               :lines [220 223]},
                                      :full-name "cljs.repl.node/repl-env",
                                      :docstring "Construct a Node.js evalution environment. Can supply :host and :port."},
           "syntax/impure" {:description "A naming convention for impure functions (unenforced).\n\nImpure functions are those that have side-effects on some state.\n\nSome impure functions which use this convention:\n\n- [doc:special/set!]\n- [doc:cljs.core/swap!]\n- [doc:cljs.core/conj!]\n- [doc:cljs.core/specify!]",
                            :ns "syntax",
                            :name "impure",
                            :history [["+" "0.0-927"]],
                            :type "convention",
                            :related ["syntax/predicate"],
                            :full-name-encode "syntax/impure",
                            :usage ["foo!"],
                            :examples [{:id "c1dbc0",
                                        :content "The following causes a side-effect in the state of `a`:\n\n```clj\n(def a (atom 1))\n@a\n;;=> 1\n\n(reset! a 2)\n@a\n;;=> 2\n```"}],
                            :full-name "syntax/impure",
                            :display "! impure",
                            :clj-doc "http://clojure.org/cheatsheet"},
           "cljs.pprint/*print-pprint-dispatch*" {:ns "cljs.pprint",
                                                  :name "*print-pprint-dispatch*",
                                                  :history [["+"
                                                             "0.0-3255"]],
                                                  :type "dynamic var",
                                                  :full-name-encode "cljs.pprint/STARprint-pprint-dispatchSTAR",
                                                  :source {:code "(defonce ^:dynamic\n ^{:doc \"The pretty print dispatch function. Use with-pprint-dispatch or\nset-pprint-dispatch to modify.\"\n   :added \"1.2\"}\n *print-pprint-dispatch* nil)",
                                                           :title "Source code",
                                                           :repo "clojurescript",
                                                           :tag "r1.7.228",
                                                           :filename "src/main/cljs/cljs/pprint.cljs",
                                                           :lines [619
                                                                   623]},
                                                  :full-name "cljs.pprint/*print-pprint-dispatch*",
                                                  :clj-symbol "clojure.pprint/*print-pprint-dispatch*",
                                                  :docstring "The pretty print dispatch function. Use with-pprint-dispatch or\nset-pprint-dispatch to modify."},
           "cljs.core/partition-by" {:description "Applies `f` to each value in `coll`, splitting it each time `f` returns a new\nvalue. Returns a lazy sequence of partitions.\n\nReturns a stateful transducer when no collection is provided.",
                                     :ns "cljs.core",
                                     :name "partition-by",
                                     :signature ["[f]" "[f coll]"],
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :related ["cljs.core/partition"
                                               "cljs.core/partition-all"
                                               "cljs.core/group-by"],
                                     :full-name-encode "cljs.core/partition-by",
                                     :source {:code "(defn partition-by\n  ([f]\n     (fn [rf]\n       (let [a (array-list)\n             pa (volatile! ::none)]\n         (fn\n           ([] (rf))\n           ([result]\n              (let [result (if (.isEmpty a)\n                             result\n                             (let [v (vec (.toArray a))]\n                               ;;clear first!\n                               (.clear a)\n                               (unreduced (rf result v))))]\n                (rf result)))\n           ([result input]\n              (let [pval @pa\n                    val (f input)]\n                (vreset! pa val)\n                (if (or (keyword-identical? pval ::none)\n                        (= val pval))\n                  (do\n                    (.add a input)\n                    result)\n                  (let [v (vec (.toArray a))]\n                    (.clear a)\n                    (let [ret (rf result v)]\n                      (when-not (reduced? ret)\n                        (.add a input))\n                      ret)))))))))\n  ([f coll]\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (let [fst (first s)\n               fv (f fst)\n               run (cons fst (take-while #(= fv (f %)) (next s)))]\n           (cons run (partition-by f (seq (drop (count run) s)))))))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/cljs/cljs/core.cljs",
                                              :lines [8564 8603]},
                                     :full-name "cljs.core/partition-by",
                                     :clj-symbol "clojure.core/partition-by",
                                     :docstring "Applies f to each value in coll, splitting it each time f returns a\nnew value.  Returns a lazy seq of partitions.  Returns a stateful\ntransducer when no collection is provided."},
           "cljs.repl/skip-if-eol" {:ns "cljs.repl",
                                    :name "skip-if-eol",
                                    :signature ["[s]"],
                                    :history [["+" "0.0-2719"]],
                                    :type "function",
                                    :full-name-encode "cljs.repl/skip-if-eol",
                                    :source {:code "(defn skip-if-eol\n  [s]\n  (let [c (readers/read-char s)]\n    (case c\n      \\newline :line-start\n      nil :stream-end\n      (do (readers/unread s c) :body))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/clojure/cljs/repl.cljc",
                                             :lines [45 57]},
                                    :full-name "cljs.repl/skip-if-eol",
                                    :docstring "If the next character on stream s is a newline, skips it, otherwise\nleaves the stream untouched. Returns :line-start, :stream-end, or :body\nto indicate the relative location of the next character on s. The stream\nmust either be an instance of LineNumberingPushbackReader or duplicate\nits behavior of both supporting .unread and collapsing all of CR, LF, and\nCRLF to a single \\newline."},
           "cljs.core/sort-by" {:description "Returns a sorted sequence of the items in `coll`, where the sort order is\ndetermined by comparing `(keyfn item)`.\n\n`comp` can be boolean-valued comparison function, or a -/0/+ valued comparator.\n\n`comp` defaults to `compare`.",
                                :ns "cljs.core",
                                :name "sort-by",
                                :signature ["[keyfn coll]"
                                            "[keyfn comp coll]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/sort"
                                          "cljs.core/compare"],
                                :full-name-encode "cljs.core/sort-by",
                                :source {:code "(defn sort-by\n  ([keyfn coll]\n   (sort-by keyfn compare coll))\n  ([keyfn comp coll]\n     (sort (fn [x y] ((fn->comparator comp) (keyfn x) (keyfn y))) coll)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [2137 2145]},
                                :full-name "cljs.core/sort-by",
                                :clj-symbol "clojure.core/sort-by",
                                :docstring "Returns a sorted sequence of the items in coll, where the sort\norder is determined by comparing (keyfn item).  Comp can be\nboolean-valued comparison funcion, or a -/0/+ valued comparator.\nComp defaults to compare."},
           "cljs.core/with-meta" {:description "Returns an object of the same type and value as `obj`, with map `m` as its\nmetadata.",
                                  :ns "cljs.core",
                                  :name "with-meta",
                                  :signature ["[obj m]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/alter-meta!"
                                            "cljs.core/vary-meta"],
                                  :full-name-encode "cljs.core/with-meta",
                                  :source {:code "(defn with-meta\n  [o meta]\n  (if ^boolean (goog/isFunction o)\n    (MetaFn. o meta)\n    (when-not (nil? o)\n      (-with-meta o meta))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [1838 1845]},
                                  :examples [{:id "f189d4",
                                              :content "```clj\n(def a ^:foo [1 2 3])\n(def b (with-meta a {:bar true}))\n\n(= a b)\n;;=> true\n\n(meta a)\n;;=> {:foo true}\n\n(meta b)\n;;=> {:bar true}\n```"}],
                                  :full-name "cljs.core/with-meta",
                                  :clj-symbol "clojure.core/with-meta",
                                  :docstring "Returns an object of the same type and value as obj, with\nmap m as its metadata."},
           "cljs.core/NeverEquiv" {:ns "cljs.core",
                                   :name "NeverEquiv",
                                   :type "type",
                                   :signature ["[]"],
                                   :source {:code "(deftype NeverEquiv []\n  Object\n  (equiv [this other]\n    (-equiv this other))\n  IEquiv\n  (-equiv [o other] false))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [5480 5485]},
                                   :full-name "cljs.core/NeverEquiv",
                                   :full-name-encode "cljs.core/NeverEquiv",
                                   :history [["+" "0.0-927"]]},
           "cljs.analyzer.api/in-cljs-user" {:ns "cljs.analyzer.api",
                                             :name "in-cljs-user",
                                             :signature ["[env & body]"],
                                             :history [["+"
                                                        "0.0-2629"]],
                                             :type "macro",
                                             :full-name-encode "cljs.analyzer.api/in-cljs-user",
                                             :source {:code "(defmacro in-cljs-user\n  [env & body]\n  `(binding [cljs.analyzer/*cljs-ns* 'cljs.user]\n     (cljs.env/with-compiler-env ~env\n       ~@body)))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.7.228",
                                                      :filename "src/main/clojure/cljs/analyzer/api.clj",
                                                      :lines [210 216]},
                                             :full-name "cljs.analyzer.api/in-cljs-user",
                                             :docstring "Binds cljs.analyzer/*cljs-ns* to 'cljs.user and uses the given compilation\nenvironment atom and runs body."},
           "cljs.core/select-keys" {:description "Returns a map containing only those entries in `map` whose key is in `keys`.",
                                    :ns "cljs.core",
                                    :name "select-keys",
                                    :signature ["[map keys]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/select-keys",
                                    :source {:code "(defn select-keys\n  [map keyseq]\n    (loop [ret {} keys (seq keyseq)]\n      (if keys\n        (let [key   (first keys)\n              entry (get map key ::not-found)]\n          (recur\n           (if (not= entry ::not-found)\n             (assoc ret key entry)\n             ret)\n           (next keys)))\n        (with-meta ret (meta map)))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [7948 7960]},
                                    :full-name "cljs.core/select-keys",
                                    :clj-symbol "clojure.core/select-keys",
                                    :docstring "Returns a map containing only those entries in map whose key is in keys"},
           "special/loop*" {:ns "special",
                            :name "loop*",
                            :type "special form",
                            :source {:code "(defmethod parse 'loop*\n  [op encl-env form _ _]\n  (analyze-let encl-env form true))",
                                     :title "Parser code",
                                     :repo "clojurescript",
                                     :tag "r1.7.228",
                                     :filename "src/main/clojure/cljs/analyzer.cljc",
                                     :lines [1521 1523]},
                            :full-name "special/loop*",
                            :full-name-encode "special/loopSTAR",
                            :history [["+" "0.0-927"]]},
           "cljs.core/ISeq" {:ns "cljs.core",
                             :name "ISeq",
                             :history [["+" "0.0-927"]],
                             :type "protocol",
                             :full-name-encode "cljs.core/ISeq",
                             :source {:code "(defprotocol ISeq\n  \"Protocol for collections to provide access to their items as sequences.\"\n  (-first [coll]\n    \"Returns the first item in the collection coll. Used by cljs.core/first.\")\n  (^clj -rest [coll]\n    \"Returns a new collection of coll without the first item. It should\n     always return a seq, e.g.\n     (rest []) => ()\n     (rest nil) => ()\"))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [491 499]},
                             :methods [{:name "-first",
                                        :signature ["[coll]"],
                                        :docstring "Returns the first item in the collection coll. Used by cljs.core/first."}
                                       {:name "-rest",
                                        :signature ["[coll]"],
                                        :docstring "Returns a new collection of coll without the first item. It should\n     always return a seq, e.g.\n     (rest []) => ()\n     (rest nil) => ()"}],
                             :full-name "cljs.core/ISeq",
                             :clj-symbol "clojure.lang/ISeq",
                             :docstring "Protocol for collections to provide access to their items as sequences."},
           "cljs.core/disj!" {:ns "cljs.core",
                              :name "disj!",
                              :signature ["[tcoll val]"
                                          "[tcoll val & vals]"],
                              :history [["+" "0.0-1211"]],
                              :type "function",
                              :full-name-encode "cljs.core/disjBANG",
                              :source {:code "(defn disj!\n  ([tcoll val]\n    (-disjoin! tcoll val))\n  ([tcoll val & vals]\n    (let [ntcoll (-disjoin! tcoll val)]\n      (if vals\n        (recur ntcoll (first vals) (next vals))\n        ntcoll))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [3428 3437]},
                              :full-name "cljs.core/disj!",
                              :clj-symbol "clojure.core/disj!",
                              :docstring "disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\ndoes not contain key(s)."},
           "cljs.test/try-expr" {:ns "cljs.test",
                                 :name "try-expr",
                                 :signature ["[msg form]"],
                                 :history [["+" "0.0-2496"]],
                                 :type "macro",
                                 :full-name-encode "cljs.test/try-expr",
                                 :source {:code "(defmacro try-expr\n  [msg form]\n  `(try\n     ~(cljs.test/assert-expr &env msg form)\n     (catch :default t#\n       (cljs.test/do-report \n         {:type :error, :message ~msg,\n          :expected '~form, :actual t#}))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/test.clj",
                                          :lines [135 144]},
                                 :full-name "cljs.test/try-expr",
                                 :clj-symbol "clojure.test/try-expr",
                                 :docstring "Used by the 'is' macro to catch unexpected exceptions.\nYou don't call this."},
           "cljs.pprint/pprint-indent" {:ns "cljs.pprint",
                                        :name "pprint-indent",
                                        :signature ["[relative-to n]"],
                                        :history [["+" "0.0-3255"]],
                                        :type "function",
                                        :full-name-encode "cljs.pprint/pprint-indent",
                                        :source {:code "(defn pprint-indent\n  [relative-to n]\n  (check-enumerated-arg relative-to #{:block :current})\n  (indent *out* relative-to n))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/cljs/cljs/pprint.cljs",
                                                 :lines [852 863]},
                                        :full-name "cljs.pprint/pprint-indent",
                                        :clj-symbol "clojure.pprint/pprint-indent",
                                        :docstring "Create an indent at this point in the pretty printing stream. This defines how\nfollowing lines are indented. relative-to can be either :block or :current depending\nwhether the indent should be computed relative to the start of the logical block or\nthe current column position. n is an offset.\n\nThis function is intended for use when writing custom dispatch functions.\n\nOutput is sent to *out* which must be a pretty printing writer."},
           "cljs.core/type->str" {:ns "cljs.core",
                                  :name "type->str",
                                  :type "function",
                                  :signature ["[ty]"],
                                  :source {:code "(defn type->str [ty]\n  (if-let [s (.-cljs$lang$ctorStr ty)]\n    s\n    (str ty)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [268 271]},
                                  :full-name "cljs.core/type->str",
                                  :full-name-encode "cljs.core/type-GTstr",
                                  :history [["+" "0.0-1859"]]},
           "clojure.walk/postwalk-replace" {:ns "clojure.walk",
                                            :name "postwalk-replace",
                                            :signature ["[smap form]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "clojure.walk/postwalk-replace",
                                            :source {:code "(defn postwalk-replace\n  [smap form]\n  (postwalk (fn [x] (if (contains? smap x) (smap x) x)) form))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.7.228",
                                                     :filename "src/main/cljs/clojure/walk.cljs",
                                                     :lines [90 96]},
                                            :full-name "clojure.walk/postwalk-replace",
                                            :clj-symbol "clojure.walk/postwalk-replace",
                                            :docstring "Recursively transforms form by replacing keys in smap with their\nvalues.  Like clojure/replace but works on any data structure.  Does\nreplacement at the leaves of the tree first."},
           "cljs.core/ES6SetEntriesIterator" {:ns "cljs.core",
                                              :name "ES6SetEntriesIterator",
                                              :type "type",
                                              :signature ["[s]"],
                                              :source {:code "(deftype ES6SetEntriesIterator [^:mutable s]\n  Object\n  (next [_]\n    (if-not (nil? s)\n      (let [x (first s)]\n        (set! s (next s))\n        #js {:value #js [x x] :done false})\n      #js {:value nil :done true})))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.7.228",
                                                       :filename "src/main/cljs/cljs/core.cljs",
                                                       :lines [5686
                                                               5693]},
                                              :full-name "cljs.core/ES6SetEntriesIterator",
                                              :full-name-encode "cljs.core/ES6SetEntriesIterator",
                                              :history [["+"
                                                         "0.0-2371"]]},
           "cljs.core/pr-with-opts" {:ns "cljs.core",
                                     :name "pr-with-opts",
                                     :signature ["[objs opts]"],
                                     :history [["+" "0.0-927"]
                                               ["-" "0.0-1503"]],
                                     :type "function",
                                     :full-name-encode "cljs.core/pr-with-opts",
                                     :source {:code "(defn pr-with-opts\n  [objs opts]\n  (doseq [string (pr-seq (first objs) opts)]\n    (string-print string))\n  (doseq [obj (next objs)]\n    (string-print \" \")\n    (doseq [string (pr-seq obj opts)]\n      (string-print string))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1450",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [6171 6180]},
                                     :full-name "cljs.core/pr-with-opts",
                                     :docstring "Prints a sequence of objects using string-print, observing all\nthe options given in opts",
                                     :removed {:in "0.0-1503",
                                               :last-seen "0.0-1450"}},
           "cljs.core/->>" {:description "The thread-last macro \"threads\" an expression through several forms as the last\nitem in a list.\n\nInserts `x` as the last item in the first form, making a list of it if it is not\na list already. If there are more forms, inserts the first form as the last item\nin second form, etc.\n\n<table class=\"code-tbl-9bef6\">\n  <thead>\n    <tr>\n      <th>Code</th>\n      <th>Expands To</th></tr></thead>\n  <tbody>\n    <tr>\n      <td><pre>\n(->> x\n  (a b c)\n  d\n  (x y z))</pre></td>\n      <td><pre>\n(x y z (d (a b c x)))</pre></td></tr></tbody></table>",
                            :ns "cljs.core",
                            :name "->>",
                            :signature ["[x & forms]"],
                            :history [["+" "0.0-927"]],
                            :type "macro",
                            :related ["cljs.core/->"],
                            :full-name-encode "cljs.core/-GTGT",
                            :source {:code "(defmacro ->>\n  [x & forms]\n  (loop [x x, forms forms]\n    (if forms\n      (let [form (first forms)\n            threaded (if (seq? form)\n              (with-meta `(~(first form) ~@(next form)  ~x) (meta form))\n              (list form x))]\n        (recur threaded (next forms)))\n      x)))",
                                     :title "Source code",
                                     :repo "clojure",
                                     :tag "clojure-1.7.0",
                                     :filename "src/clj/clojure/core.clj",
                                     :lines [1580 1594]},
                            :examples [{:id "1dc72c",
                                        :content "Sequence transformation functions often take a sequence as the last argument,\nthus the thread-last macro is commonly used with them.  Here we compute the sum\nof the first 10 even squares:\n\n```clj\n(->> (range)\n     (map #(* % %))\n     (filter even?)\n     (take 10)\n     (reduce +))\n;;=> 1140\n```\n\nThis expands to:\n\n```clj\n(reduce +\n  (take 10\n    (filter even?\n      (map #(* % %)\n        (range)))))\n;;=> 1140\n```"}],
                            :known-as "thread last",
                            :full-name "cljs.core/->>",
                            :clj-symbol "clojure.core/->>",
                            :docstring "Threads the expr through the forms. Inserts x as the\nlast item in the first form, making a list of it if it is not a\nlist already. If there are more forms, inserts the first form as the\nlast item in second form, etc."},
           "cljs.analyzer.api/empty-state" {:ns "cljs.analyzer.api",
                                            :name "empty-state",
                                            :signature ["[]"],
                                            :history [["+" "1.7.10"]],
                                            :type "function",
                                            :full-name-encode "cljs.analyzer.api/empty-state",
                                            :source {:code "(defn empty-state\n  []\n  (env/default-compiler-env))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.7.228",
                                                     :filename "src/main/clojure/cljs/analyzer/api.clj",
                                                     :lines [20 23]},
                                            :full-name "cljs.analyzer.api/empty-state",
                                            :docstring "Creates an empty compilation state Atom<Map>."},
           "cljs.core/defonce" {:ns "cljs.core",
                                :name "defonce",
                                :signature ["[x init]"],
                                :history [["+" "0.0-2156"]],
                                :type "macro",
                                :full-name-encode "cljs.core/defonce",
                                :source {:code "(core/defmacro defonce [x init]\n  `(when-not (exists? ~x)\n     (def ~x ~init)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/clojure/cljs/core.cljc",
                                         :lines [601 603]},
                                :full-name "cljs.core/defonce",
                                :clj-symbol "clojure.core/defonce"},
           "cljs.core/nil?" {:description "Returns true if `x` is nil, false otherwise.",
                             :return-type boolean,
                             :ns "cljs.core",
                             :name "nil?",
                             :signature ["[x]"],
                             :history [["+" "0.0-927"]],
                             :type "function/macro",
                             :related ["cljs.core/true?"
                                       "cljs.core/false?"
                                       "cljs.core/identity"],
                             :full-name-encode "cljs.core/nilQMARK",
                             :source {:code "(defn ^boolean nil?\n  [x]\n  (coercive-= x nil))",
                                      :title "Function code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [186 189]},
                             :extra-sources [{:code "(core/defmacro nil? [x]\n  `(coercive-= ~x nil))",
                                              :title "Macro code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/clojure/cljs/core.cljc",
                                              :lines [831 832]}],
                             :full-name "cljs.core/nil?",
                             :clj-symbol "clojure.core/nil?",
                             :docstring "Returns true if x is nil, false otherwise."},
           "cljs.repl.rhino/bootjs" {:ns "cljs.repl.rhino",
                                     :name "bootjs",
                                     :type "var",
                                     :return-type String,
                                     :source {:code "(def ^String bootjs\n  (str \"var global = this;\\n\"\n       \"var CLOSURE_IMPORT_SCRIPT = function(src) {\\n\"\n       \"    var ns = \\\"cljs.repl.rhino\\\",\"\n       \"        name = \\\"load-file\\\",\"\n       \"        loadFile = Packages.clojure.lang.RT[\\\"var\\\"](ns,name);\\n\"\n       \"    if(src) loadFile.invoke(___repl_env, __repl_opts, src);\\n\"\n       \"};\\n\"))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/clojure/cljs/repl/rhino.clj",
                                              :lines [23 30]},
                                     :full-name "cljs.repl.rhino/bootjs",
                                     :full-name-encode "cljs.repl.rhino/bootjs",
                                     :history [["+" "0.0-927"]]},
           "cljs.core/load-file*" {:ns "cljs.core",
                                   :name "load-file*",
                                   :signature ["[f]"],
                                   :history [["+" "0.0-2719"]
                                             ["-" "0.0-3115"]],
                                   :type "macro",
                                   :full-name-encode "cljs.core/load-fileSTAR",
                                   :source {:code "(defmacro load-file* [f]\n  (core/let [{:keys [target output-dir]} (:options @env/*compiler*)]\n    (core/condp = target\n      ;; under Node.js, always relative to JVM working directory\n      :nodejs `(. js/goog (~'nodeGlobalRequire (str ~output-dir ~File/separator ~f)))\n      `(. js/goog (~'importScript_ ~f)))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r3058",
                                            :filename "src/clj/cljs/core.clj",
                                            :lines [1926 1931]},
                                   :full-name "cljs.core/load-file*",
                                   :removed {:in "0.0-3115",
                                             :last-seen "0.0-3058"}},
           "clojure.walk/stringify-keys" {:ns "clojure.walk",
                                          :name "stringify-keys",
                                          :signature ["[m]"],
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "clojure.walk/stringify-keys",
                                          :source {:code "(defn stringify-keys\n  [m]\n  (let [f (fn [[k v]] (if (keyword? k) [(name k) v] [k v]))]\n    ;; only apply to maps\n    (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/cljs/clojure/walk.cljs",
                                                   :lines [74 80]},
                                          :full-name "clojure.walk/stringify-keys",
                                          :clj-symbol "clojure.walk/stringify-keys",
                                          :docstring "Recursively transforms all map keys from keywords to strings."},
           "clojure.browser.repl/order" {:ns "clojure.browser.repl",
                                         :name "order",
                                         :type "var",
                                         :source {:code "(def order (atom 0))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.7.228",
                                                  :filename "src/main/cljs/clojure/browser/repl.cljs",
                                                  :lines [88]},
                                         :full-name "clojure.browser.repl/order",
                                         :full-name-encode "clojure.browser.repl/order",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/memoize" {:description "Returns a memoized version of a referentially transparent function.\n\nA memoized version of a function keeps a cache of the mappings from arguments to\nresults in memory. When calls with the same arguments are repeated often, a\nmemoized function has higher performance at the expense of higher memory usage.",
                                :ns "cljs.core",
                                :name "memoize",
                                :signature ["[f]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/memoize",
                                :source {:code "(defn memoize\n  [f]\n  (let [mem (atom {})]\n    (fn [& args]\n      (let [v (get @mem args lookup-sentinel)]\n        (if (identical? v lookup-sentinel)\n          (let [ret (apply f args)]\n            (swap! mem assoc args ret)\n            ret)\n          v)))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [9370 9383]},
                                :full-name "cljs.core/memoize",
                                :clj-symbol "clojure.core/memoize",
                                :docstring "Returns a memoized version of a referentially transparent function. The\nmemoized version of the function keeps a cache of the mapping from arguments\nto results and, when calls with the same arguments are repeated often, has\nhigher performance at the expense of higher memory use."},
           "cljs.core/pr-sequential" {:ns "cljs.core",
                                      :name "pr-sequential",
                                      :signature ["[print-one begin sep end opts coll]"],
                                      :history [["+" "0.0-927"]
                                                ["-" "0.0-1798"]],
                                      :type "function",
                                      :full-name-encode "cljs.core/pr-sequential",
                                      :source {:code "(defn ^:deprecated pr-sequential\n  [print-one begin sep end opts coll]\n  (concat [begin]\n          (flatten1\n            (interpose [sep] (map #(print-one % opts) coll)))\n          [end]))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1586",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [6210 6217]},
                                      :full-name "cljs.core/pr-sequential",
                                      :docstring "Do not use this.  It is kept for backwards compatibility with the\nold IPrintable protocol.",
                                      :removed {:in "0.0-1798",
                                                :last-seen "0.0-1586"}},
           "cljs.js/load-source-map!" {:ns "cljs.js",
                                       :name "load-source-map!",
                                       :type "function",
                                       :signature ["[state ns sm-json]"],
                                       :source {:code "(defn load-source-map! [state ns sm-json]\n  (let [sm (sm/decode (.parse js/JSON sm-json))]\n    (swap! state assoc-in [:source-maps ns] sm)))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/cljs/js.cljs",
                                                :lines [118 120]},
                                       :full-name "cljs.js/load-source-map!",
                                       :full-name-encode "cljs.js/load-source-mapBANG",
                                       :history [["+" "1.7.10"]]},
           "clojure.zip/make-node" {:ns "clojure.zip",
                                    :name "make-node",
                                    :signature ["[loc node children]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "clojure.zip/make-node",
                                    :source {:code "(defn make-node\n  [loc node children]\n    ((:zip/make-node (meta loc)) node children))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/clojure/zip.cljs",
                                             :lines [76 80]},
                                    :full-name "clojure.zip/make-node",
                                    :clj-symbol "clojure.zip/make-node",
                                    :docstring "Returns a new branch node, given an existing node and new\nchildren. The loc is only used to supply the constructor."},
           "syntax/deref" {:description "`@foo` is sugar for [`(deref foo)`][doc:cljs.core/deref].\n\nRetrieve the underlying value of a reference.  References can be created by\n[doc:cljs.core/atom] or [doc:cljs.core/delay].",
                           :ns "syntax",
                           :name "deref",
                           :history [["+" "0.0-927"]],
                           :type "syntax",
                           :related ["cljs.core/deref"
                                     "cljs.core/atom"
                                     "cljs.core/delay"],
                           :full-name-encode "syntax/deref",
                           :extra-sources ({:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                            :title "Reader table",
                                            :repo "tools.reader",
                                            :tag "tools.reader-1.0.0-alpha1",
                                            :filename "src/main/clojure/clojure/tools/reader.clj",
                                            :lines [743 762]}),
                           :usage ["@foo"],
                           :examples [{:id "08f886",
                                       :content "```clj\n(def a (atom 1))\n@a\n;;=> 1\n\n(deref a)\n;;=> 1\n```"}],
                           :full-name "syntax/deref",
                           :display "@ deref",
                           :clj-doc "http://clojure.org/reader#toc2"},
           "cljs.core/PersistentVector.EMPTY" {:ns "cljs.core",
                                               :name "PersistentVector.EMPTY",
                                               :history [["+"
                                                          "0.0-1006"]],
                                               :parent-type "PersistentVector",
                                               :type "var",
                                               :full-name-encode "cljs.core/PersistentVectorDOTEMPTY",
                                               :source {:code "(set! (.-EMPTY PersistentVector)\n  (PersistentVector. nil 0 5 (.-EMPTY-NODE PersistentVector) (array) empty-ordered-hash))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.7.228",
                                                        :filename "src/main/cljs/cljs/core.cljs",
                                                        :lines [4925
                                                                4926]},
                                               :full-name "cljs.core/PersistentVector.EMPTY",
                                               :clj-symbol "clojure.lang/PersistentVector.EMPTY"},
           "specialrepl/load-namespace" {:description "Only usable from a REPL.\n\nLoad a namespace and all of its dependencies into the evaluation environment.\nThe environment is responsible for ensuring that each namespace is loaded once\nand only once.",
                                         :ns "specialrepl",
                                         :name "load-namespace",
                                         :signature ["[name]"],
                                         :history [["+" "0.0-927"]],
                                         :type "special form (repl)",
                                         :full-name-encode "specialrepl/load-namespace",
                                         :source {:code "(def default-special-fns\n  (let [load-file-fn\n        (fn self\n          ([repl-env env form]\n            (self repl-env env form nil))\n          ([repl-env env [_ file :as form] opts]\n            (load-file repl-env file opts)))\n        in-ns-fn\n        (fn self\n          ([repl-env env form]\n           (self repl-env env form nil))\n          ([repl-env env [_ [quote ns-name] :as form] _]\n            ;; guard against craziness like '5 which wreaks havoc\n           (when-not (and (= quote 'quote) (symbol? ns-name))\n             (throw (IllegalArgumentException. \"Argument to in-ns must be a symbol.\")))\n           (when-not (ana/get-namespace ns-name)\n             (swap! env/*compiler* assoc-in [::ana/namespaces ns-name] {:name ns-name})\n             (-evaluate repl-env \"<cljs repl>\" 1\n               (str \"goog.provide('\" (comp/munge ns-name) \"');\")))\n           (set! ana/*cljs-ns* ns-name)))]\n    (wrap-special-fns wrap-self\n     {'in-ns in-ns-fn\n      'clojure.core/in-ns in-ns-fn\n      'require\n      (fn self\n        ([repl-env env form]\n         (self repl-env env form nil))\n        ([repl-env env [_ & specs :as form] opts]\n         (let [is-self-require? (self-require? specs)\n               [target-ns restore-ns]\n               (if-not is-self-require?\n                 [ana/*cljs-ns* nil]\n                 ['cljs.user ana/*cljs-ns*])]\n           (evaluate-form repl-env env \"<cljs repl>\"\n                          (with-meta\n                            `(~'ns ~target-ns\n                               (:require ~@(-> specs canonicalize-specs decorate-specs)))\n                            {:merge true :line 1 :column 1})\n                          identity opts)\n           (when is-self-require?\n             (set! ana/*cljs-ns* restore-ns)))))\n      'require-macros\n      (fn self\n        ([repl-env env form]\n         (self repl-env env form nil))\n        ([repl-env env [_ & specs :as form] opts]\n         (evaluate-form repl-env env \"<cljs repl>\"\n                        (with-meta\n                          `(~'ns ~ana/*cljs-ns*\n                             (:require-macros ~@(-> specs canonicalize-specs decorate-specs)))\n                          {:merge true :line 1 :column 1})\n                        identity opts)))\n      'import\n      (fn self\n        ([repl-env env form]\n         (self repl-env env form nil))\n        ([repl-env env [_ & specs :as form] opts]\n         (evaluate-form repl-env env \"<cljs repl>\"\n                        (with-meta\n                          `(~'ns ~ana/*cljs-ns*\n                             (:import\n                              ~@(map\n                                 (fn [quoted-spec-or-kw]\n                                   (if (keyword? quoted-spec-or-kw)\n                                     quoted-spec-or-kw\n                                     (second quoted-spec-or-kw)))\n                                 specs)))\n                          {:merge true :line 1 :column 1})\n                        identity opts)))\n      'load-file load-file-fn\n      'clojure.core/load-file load-file-fn\n      'load-namespace\n      (fn self\n        ([repl-env env form]\n         (self env repl-env form nil))\n        ([repl-env env [_ ns :as form] opts]\n         (load-namespace repl-env ns opts)))})))",
                                                  :title "repl specials table",
                                                  :repo "clojurescript",
                                                  :tag "r1.7.228",
                                                  :filename "src/main/clojure/cljs/repl.cljc",
                                                  :lines [642 718]},
                                         :examples [{:id "0b1a1d",
                                                     :content "```clj\n(load-namespace 'clojure.set)\n```"}],
                                         :full-name "specialrepl/load-namespace"},
           "cljs.reader/float-pattern" {:ns "cljs.reader",
                                        :name "float-pattern",
                                        :type "var",
                                        :source {:code "(def float-pattern (re-pattern \"^([-+]?[0-9]+(\\\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?$\"))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/cljs/cljs/reader.cljs",
                                                 :lines [100]},
                                        :full-name "cljs.reader/float-pattern",
                                        :full-name-encode "cljs.reader/float-pattern",
                                        :history [["+" "0.0-927"]]},
           "cljs.core/find-ns-obj" {:ns "cljs.core",
                                    :name "find-ns-obj",
                                    :type "function",
                                    :signature ["[ns]"],
                                    :source {:code "(defn find-ns-obj [ns]\n  (let [munged-ns (munge (str ns))\n        segs (.split munged-ns \".\")]\n    (case *target*\n      \"nodejs\"  (if ^boolean js/COMPILED\n                  ; Under simple optimizations on nodejs, namespaces will be in module\n                  ; rather than global scope and must be accessed by a direct call to eval.\n                  ; The first segment may refer to an undefined variable, so its evaluation\n                  ; may throw ReferenceError.\n                  (find-ns-obj*\n                    (try\n                      (js/eval (first segs))\n                      (catch js/ReferenceError e\n                        nil))\n                    (next segs))\n                  (find-ns-obj* js/global segs))\n      \"default\" (find-ns-obj* goog/global segs)\n      (throw (js/Error. (str \"find-ns-obj not supported for target \" *target*))))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [10138 10155]},
                                    :full-name "cljs.core/find-ns-obj",
                                    :full-name-encode "cljs.core/find-ns-obj",
                                    :history [["+" "1.7.10"]]},
           "cljs.core/ancestors" {:ns "cljs.core",
                                  :name "ancestors",
                                  :signature ["[tag]" "[h tag]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/descendants"
                                            "cljs.core/isa?"
                                            "cljs.core/make-hierarchy"
                                            "cljs.core/derive"],
                                  :full-name-encode "cljs.core/ancestors",
                                  :source {:code "(defn ancestors\n  ([tag] (ancestors @(get-global-hierarchy) tag))\n  ([h tag] (not-empty (get (:ancestors h) tag))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [9475 9481]},
                                  :full-name "cljs.core/ancestors",
                                  :clj-symbol "clojure.core/ancestors",
                                  :docstring "Returns the immediate and indirect parents of tag, either via a JavaScript type\ninheritance relationship or a relationship established via derive. h\nmust be a hierarchy obtained from make-hierarchy, if not supplied\ndefaults to the global hierarchy"},
           "cljs.js/compile-str" {:ns "cljs.js",
                                  :name "compile-str",
                                  :signature ["[state source cb]"
                                              "[state source name cb]"
                                              "[state source name opts cb]"],
                                  :history [["+" "1.7.28"]],
                                  :type "function",
                                  :full-name-encode "cljs.js/compile-str",
                                  :source {:code "(defn compile-str\n  ([state source cb]\n   (compile-str state source nil cb))\n  ([state source name cb]\n   (compile-str state source name nil cb))\n  ([state source name opts cb]\n   {:pre [(atom? state) (string? source)\n          (valid-name? name) (valid-opts? opts) (fn? cb)]}\n   (compile-str*\n     {:*compiler*     state\n      :*data-readers* tags/*cljs-data-readers*\n      :*analyze-deps* (or (:analyze-deps opts) true)\n      :*load-macros*  (or (:load-macros opts) true)\n      :*load-fn*      (or (:load opts) *load-fn*)\n      :*eval-fn*      (or (:eval opts) *eval-fn*)\n      :*sm-data*      (when (:source-map opts) (sm-data))}\n     source name opts cb)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/js.cljs",
                                           :lines [644 682]},
                                  :full-name "cljs.js/compile-str",
                                  :docstring "Compile ClojureScript source into JavaScript. The parameters:\n\nstate (atom)\n  the compiler state\n\nsource (string)\n  the ClojureScript source\n\nname (symbol)\n  optional, the name of the source\n\nopts (map)\n  compilation options.\n\n  :load       - library resolution function, see *load-fn*\n  :source-map - set to true to generate inline source map information\n\ncb (function)\n  callback, will be invoked with a map. If successful the map will contain\n  a key :value with the compilation result (string). If unsuccessful the map\n  will contain a key :error with an ex-info instance describing the cause\n  of failure."},
           "cljs.core/integer?" {:description "Returns true if `n` is an integer, false otherwise.",
                                 :return-type boolean,
                                 :ns "cljs.core",
                                 :name "integer?",
                                 :signature ["[n]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :related ["cljs.core/int"],
                                 :full-name-encode "cljs.core/integerQMARK",
                                 :source {:code "(defn ^boolean integer?\n  [n]\n  (and (number? n)\n       (not ^boolean (js/isNaN n))\n       (not (identical? n js/Infinity))\n       (== (js/parseFloat n) (js/parseInt n 10))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [2020 2026]},
                                 :full-name "cljs.core/integer?",
                                 :clj-symbol "clojure.core/integer?",
                                 :docstring "Returns true if n is an integer."},
           "cljs.js/compile" {:ns "cljs.js",
                              :name "compile",
                              :signature ["[state source cb]"
                                          "[state source name cb]"
                                          "[state source name opts cb]"],
                              :history [["+" "1.7.10"] ["-" "1.7.28"]],
                              :type "function",
                              :full-name-encode "cljs.js/compile",
                              :source {:code "(defn compile\n  ([state source cb]\n   (compile state source nil cb))\n  ([state source name cb]\n   (compile state source name nil cb))\n  ([state source name opts cb]\n   {:pre [(atom? state) (string? source)\n          (valid-name? name) (valid-opts? opts) (fn? cb)]}\n   (compile*\n     {:*compiler*     state\n      :*data-readers* tags/*cljs-data-readers*\n      :*analyze-deps* (or (:analyze-deps opts) true)\n      :*load-macros*  (or (:load-macros opts) true)\n      :*load-fn*      (or (:load opts) *load-fn*)\n      :*eval-fn*      (or (:eval opts) *eval-fn*)\n      :*sm-data*      (when (:source-map opts) (sm-data))}\n     source name opts cb)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.10",
                                       :filename "src/main/cljs/cljs/js.cljs",
                                       :lines [580 618]},
                              :full-name "cljs.js/compile",
                              :docstring "Compile ClojureScript source into JavaScript. The parameters:\n\nstate (atom)\n  the compiler state\n\nsource (string)\n  the ClojureScript source\n\nname (symbol)\n  optional, the name of the source\n\nopts (map)\n  compilation options.\n\n  :load       - library resolution function, see *load-fn*\n  :source-map - set to true to generate inline source map information\n\ncb (function)\n  callback, will be invoked with a map. If successful the map will contain\n  a key :value with the compilation result (string). If unsuccessful the map\n  will contain a key :error with an ex-info instance describing the cause\n  of failure.",
                              :removed {:in "1.7.28",
                                        :last-seen "1.7.10"}},
           "cljs.core/HashMap.EMPTY" {:ns "cljs.core",
                                      :name "HashMap.EMPTY",
                                      :history [["+" "0.0-927"]
                                                ["-" "0.0-1798"]],
                                      :parent-type "HashMap",
                                      :type "var",
                                      :full-name-encode "cljs.core/HashMapDOTEMPTY",
                                      :source {:code "(set! cljs.core.HashMap/EMPTY (HashMap. nil 0 (js-obj) 0))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1586",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [3830]},
                                      :full-name "cljs.core/HashMap.EMPTY",
                                      :removed {:in "0.0-1798",
                                                :last-seen "0.0-1586"}},
           "cljs.core/Vector.EMPTY" {:ns "cljs.core",
                                     :name "Vector.EMPTY",
                                     :history [["+" "0.0-927"]
                                               ["-" "0.0-1798"]],
                                     :parent-type "Vector",
                                     :type "var",
                                     :full-name-encode "cljs.core/VectorDOTEMPTY",
                                     :source {:code "(set! cljs.core.Vector/EMPTY (Vector. nil (array) 0))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1586",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [2859]},
                                     :full-name "cljs.core/Vector.EMPTY",
                                     :removed {:in "0.0-1798",
                                               :last-seen "0.0-1586"}},
           "clojure.zip/xml-zip" {:ns "clojure.zip",
                                  :name "xml-zip",
                                  :signature ["[root]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.zip/xml-zip",
                                  :source {:code "(defn xml-zip\n  [root]\n    (zipper (complement string?) \n            (comp seq :content)\n            (fn [node children]\n              (assoc node :content (and children (apply vector children))))\n            root))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/clojure/zip.cljs",
                                           :lines [50 58]},
                                  :full-name "clojure.zip/xml-zip",
                                  :clj-symbol "clojure.zip/xml-zip",
                                  :docstring "Returns a zipper for xml elements (as from xml/parse),\ngiven a root element"},
           "clojure.walk/walk" {:ns "clojure.walk",
                                :name "walk",
                                :signature ["[inner outer form]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "clojure.walk/walk",
                                :source {:code "(defn walk\n  [inner outer form]\n  (cond\n    (list? form)   (outer (apply list (map inner form)))\n    (seq? form)    (outer (doall (map inner form)))\n    (record? form) (outer (reduce (fn [r x] (conj r (inner x))) form form))\n    (coll? form)   (outer (into (empty form) (map inner form)))\n    :else          (outer form)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/clojure/walk.cljs",
                                         :lines [37 50]},
                                :full-name "clojure.walk/walk",
                                :clj-symbol "clojure.walk/walk",
                                :docstring "Traverses form, an arbitrary data structure.  inner and outer are\nfunctions.  Applies inner to each element of form, building up a\ndata structure of the same type, then applies outer to the result.\nRecognizes all Clojure data structures. Consumes seqs as with doall."},
           "cljs.core/ifn?" {:description "Returns true if `f` implements the `IFn` protocol, false otherwise.\n\nFunctions, keywords, map, sets, and vectors can be called as functions.",
                             :return-type boolean,
                             :ns "cljs.core",
                             :name "ifn?",
                             :signature ["[f]"],
                             :history [["+" "0.0-1211"]],
                             :type "function",
                             :related ["cljs.core/fn?"],
                             :full-name-encode "cljs.core/ifnQMARK",
                             :source {:code "(defn ^boolean ifn?\n  [f]\n  (or (fn? f) (satisfies? IFn f)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [2015 2018]},
                             :full-name "cljs.core/ifn?",
                             :clj-symbol "clojure.core/ifn?",
                             :docstring "Returns true if f returns true for fn? or satisfies IFn."},
           "cljs.core/bit-xor" {:description "Bitwise \"exclusive or\". Same as `x ^ y` in JavaScript.",
                                :ns "cljs.core",
                                :name "bit-xor",
                                :signature ["[x y]" "[x y & more]"],
                                :history [["+" "0.0-927"]],
                                :type "function/macro",
                                :related ["cljs.core/bit-and"
                                          "cljs.core/bit-or"],
                                :full-name-encode "cljs.core/bit-xor",
                                :source {:code "(defn bit-xor\n  ([x y] (cljs.core/bit-xor x y))\n  ([x y & more]\n     (reduce bit-xor (cljs.core/bit-xor x y) more)))",
                                         :title "Function code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [2508 2512]},
                                :extra-sources [{:code "(core/defmacro ^::ana/numeric bit-xor\n  ([x y] (core/list 'js* \"(~{} ^ ~{})\" x y))\n  ([x y & more] `(bit-xor (bit-xor ~x ~y) ~@more)))",
                                                 :title "Macro code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/clojure/cljs/core.cljc",
                                                 :lines [1111 1113]}],
                                :examples [{:id "3ccd99",
                                            :content "Bits can be entered using radix notation:\n\n```clj\n(bit-xor 2r1100 2r1010)\n;;=> 6\n;; 6 = 2r0110\n```\n\nSame numbers in decimal:\n\n```clj\n(bit-xor 12 10)\n;;=> 6\n```"}],
                                :full-name "cljs.core/bit-xor",
                                :clj-symbol "clojure.core/bit-xor",
                                :docstring "Bitwise exclusive or"},
           "clojure.set/union" {:description "Return a set that is the union of the input sets.",
                                :ns "clojure.set",
                                :name "union",
                                :signature ["[]"
                                            "[s1]"
                                            "[s1 s2]"
                                            "[s1 s2 & sets]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["clojure.set/intersection"
                                          "clojure.set/difference"
                                          "clojure.set/superset?"],
                                :full-name-encode "clojure.set/union",
                                :source {:code "(defn union\n  ([] #{})\n  ([s1] s1)\n  ([s1 s2]\n     (if (< (count s1) (count s2))\n       (reduce conj s2 s1)\n       (reduce conj s1 s2)))\n  ([s1 s2 & sets]\n     (let [bubbled-sets (bubble-max-key count (conj sets s2 s1))]\n       (reduce into (first bubbled-sets) (rest bubbled-sets)))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/clojure/set.cljs",
                                         :lines [19 29]},
                                :full-name "clojure.set/union",
                                :clj-symbol "clojure.set/union",
                                :docstring "Return a set that is the union of the input sets"},
           "cljs.core/case" {:description "Takes an expression and a set of clauses. Each clause can take the form of\neither:\n\n`test-constant result-expr`\n\n`(test-constant1 ... test-constantN)  result-expr`\n\nThe test-constants are not evaluated. They must be compile-time literals, and\nneed not be quoted. If the expression is equal to a test-constant, the\ncorresponding `result-expr` is returned. A single default expression can follow\nthe clauses, and its value will be returned if no clause matches. If no default\nexpression is provided and no clause matches, an Error is thrown.\n\nUnlike `cond` and `condp`, `case` does a constant-time dispatch, the clauses are\nnot considered sequentially. All manner of constant expressions are acceptable\nin `case`, including numbers, strings, symbols, keywords, and ClojureScript\ncomposites thereof. Note that since lists are used to group multiple constants\nthat map to the same expression, a vector can be used to match a list if needed.\nThe test-constants need not be all of the same type.",
                             :ns "cljs.core",
                             :name "case",
                             :signature ["[e & clauses]"],
                             :history [["+" "0.0-1211"]],
                             :type "macro",
                             :related ["cljs.core/cond"
                                       "cljs.core/condp"],
                             :full-name-encode "cljs.core/case",
                             :source {:code "(core/defmacro case\n  [e & clauses]\n  (core/let [default (if (odd? (count clauses))\n                       (last clauses)\n                       `(throw\n                          (js/Error.\n                            (cljs.core/str \"No matching clause: \" ~e))))\n             env     &env\n             pairs   (reduce\n                       (core/fn [m [test expr]]\n                         (core/cond\n                           (seq? test)\n                           (reduce\n                             (core/fn [m test]\n                               (core/let [test (if (core/symbol? test)\n                                                 (core/list 'quote test)\n                                                 test)]\n                                 (assoc-test m test expr env)))\n                             m test)\n                           (core/symbol? test)\n                           (assoc-test m (core/list 'quote test) expr env)\n                           :else\n                           (assoc-test m test expr env)))\n                     {} (partition 2 clauses))\n             esym    (gensym)\n             tests   (keys pairs)]\n    (core/cond\n      (every? (some-fn core/number? core/string? core/char? #(const? env %)) tests)\n      (core/let [no-default (if (odd? (count clauses)) (butlast clauses) clauses)\n                 tests      (mapv #(if (seq? %) (vec %) [%]) (take-nth 2 no-default))\n                 thens      (vec (take-nth 2 (drop 1 no-default)))]\n        `(let [~esym ~e] (case* ~esym ~tests ~thens ~default)))\n\n      (every? core/keyword? tests)\n      (core/let [tests (core/->> tests\n                         (map #(.substring (core/str %) 1))\n                         vec\n                         (mapv #(if (seq? %) (vec %) [%])))\n                 thens (vec (vals pairs))]\n        `(let [~esym (if (keyword? ~e) (.-fqn ~e) nil)]\n           (case* ~esym ~tests ~thens ~default)))\n\n      ;; equality\n      :else\n      `(let [~esym ~e]\n         (cond\n           ~@(mapcat (core/fn [[m c]] `((cljs.core/= ~m ~esym) ~c)) pairs)\n           :else ~default)))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/clojure/cljs/core.cljc",
                                      :lines [2092 2161]},
                             :examples [{:id "09a90c",
                                         :content "```clj\n(def a 1)\n(def b 2)\n\n(case a\n  0 \"zero\"\n  1 \"one\"\n  \"default\")\n;;=> \"one\"\n\n(case b\n  0 \"zero\"\n  1 \"one\"\n  \"default\")\n;;=> \"default\"\n\n(case b\n  0 \"zero\"\n  1 \"one\")\n;; Error: No matching clause: 2\n```"}],
                             :full-name "cljs.core/case",
                             :clj-symbol "clojure.core/case",
                             :docstring "Takes an expression, and a set of clauses.\n\nEach clause can take the form of either:\n\ntest-constant result-expr\n\n(test-constant1 ... test-constantN)  result-expr\n\nThe test-constants are not evaluated. They must be compile-time\nliterals, and need not be quoted.  If the expression is equal to a\ntest-constant, the corresponding result-expr is returned. A single\ndefault expression can follow the clauses, and its value will be\nreturned if no clause matches. If no default expression is provided\nand no clause matches, an Error is thrown.\n\nUnlike cond and condp, case does a constant-time dispatch, the\nclauses are not considered sequentially.  All manner of constant\nexpressions are acceptable in case, including numbers, strings,\nsymbols, keywords, and (ClojureScript) composites thereof. Note that since\nlists are used to group multiple constants that map to the same\nexpression, a vector can be used to match a list if needed. The\ntest-constants need not be all of the same type."},
           "cljs.repl/IJavaScriptEnv" {:ns "cljs.repl",
                                       :name "IJavaScriptEnv",
                                       :type "protocol",
                                       :full-name-encode "cljs.repl/IJavaScriptEnv",
                                       :source {:code "(defprotocol IJavaScriptEnv\n  (-setup [repl-env opts] \"initialize the environment\")\n  (-evaluate [repl-env filename line js] \"evaluate a javascript string\")\n  (-load [repl-env provides url] \"load code at url into the environment\")\n  (-tear-down [repl-env] \"dispose of the environment\"))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/clojure/cljs/repl.cljc",
                                                :lines [107 111]},
                                       :methods [{:name "-setup",
                                                  :signature ["[repl-env opts]"],
                                                  :docstring "initialize the environment"}
                                                 {:name "-evaluate",
                                                  :signature ["[repl-env filename line js]"],
                                                  :docstring "evaluate a javascript string"}
                                                 {:name "-load",
                                                  :signature ["[repl-env provides url]"],
                                                  :docstring "load code at url into the environment"}
                                                 {:name "-tear-down",
                                                  :signature ["[repl-env]"],
                                                  :docstring "dispose of the environment"}],
                                       :full-name "cljs.repl/IJavaScriptEnv",
                                       :history [["+" "0.0-927"]]},
           "cljs.reader/PushbackReader" {:ns "cljs.reader",
                                         :name "PushbackReader",
                                         :type "protocol",
                                         :full-name-encode "cljs.reader/PushbackReader",
                                         :source {:code "(defprotocol PushbackReader\n  (read-char [reader] \"Returns the next char from the Reader,\nnil if the end of stream has been reached\")\n  (unread [reader ch] \"Push back a single character on to the stream\"))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.7.228",
                                                  :filename "src/main/cljs/cljs/reader.cljs",
                                                  :lines [13 16]},
                                         :methods [{:name "read-char",
                                                    :signature ["[reader]"],
                                                    :docstring "Returns the next char from the Reader,\nnil if the end of stream has been reached"}
                                                   {:name "unread",
                                                    :signature ["[reader ch]"],
                                                    :docstring "Push back a single character on to the stream"}],
                                         :full-name "cljs.reader/PushbackReader",
                                         :history [["+" "0.0-927"]]},
           "cljs.repl.rhino/-main" {:ns "cljs.repl.rhino",
                                    :name "-main",
                                    :type "function",
                                    :signature ["[]"],
                                    :source {:code "(defn -main []\n  (repl/repl (repl-env)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/clojure/cljs/repl/rhino.clj",
                                             :lines [218 219]},
                                    :full-name "cljs.repl.rhino/-main",
                                    :full-name-encode "cljs.repl.rhino/-main",
                                    :history [["+" "0.0-3165"]]},
           "cljs.repl.nashorn/repl-env*" {:ns "cljs.repl.nashorn",
                                          :name "repl-env*",
                                          :type "function",
                                          :signature ["[{:keys [debug], :as opts}]"],
                                          :source {:code "(defn repl-env* [{:keys [debug] :as opts}]\n      (let [engine (create-engine opts)]\n        (merge\n          (NashornEnv. engine debug)\n          opts)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/clojure/cljs/repl/nashorn.clj",
                                                   :lines [171 175]},
                                          :full-name "cljs.repl.nashorn/repl-env*",
                                          :full-name-encode "cljs.repl.nashorn/repl-envSTAR",
                                          :history [["+" "0.0-3030"]]},
           "cljs.core/isa?" {:return-type boolean,
                             :ns "cljs.core",
                             :name "isa?",
                             :signature ["[child parent]"
                                         "[h child parent]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/ancestors"
                                       "cljs.core/descendants"
                                       "cljs.core/make-hierarchy"
                                       "cljs.core/derive"],
                             :full-name-encode "cljs.core/isaQMARK",
                             :source {:code "(defn ^boolean isa?\n  ([child parent] (isa? @(get-global-hierarchy) child parent))\n  ([h child parent]\n     (or (= child parent)\n         ;; (and (class? parent) (class? child)\n         ;;    (. ^Class parent isAssignableFrom child))\n         (contains? ((:ancestors h) child) parent)\n         ;;(and (class? child) (some #(contains? ((:ancestors h) %) parent) (supers child)))\n         (and (vector? parent) (vector? child)\n              (== (count parent) (count child))\n              (loop [ret true i 0]\n                (if (or (not ret) (== i (count parent)))\n                  ret\n                  (recur (isa? h (child i) (parent i)) (inc i))))))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [9447 9465]},
                             :full-name "cljs.core/isa?",
                             :clj-symbol "clojure.core/isa?",
                             :docstring "Returns true if (= child parent), or child is directly or indirectly derived from\nparent, either via a JavaScript type inheritance relationship or a\nrelationship established via derive. h must be a hierarchy obtained\nfrom make-hierarchy, if not supplied defaults to the global\nhierarchy"},
           "cljs.repl.node/-main" {:ns "cljs.repl.node",
                                   :name "-main",
                                   :type "function",
                                   :signature ["[]"],
                                   :source {:code "(defn -main []\n  (repl/repl (repl-env)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/clojure/cljs/repl/node.clj",
                                            :lines [225 226]},
                                   :full-name "cljs.repl.node/-main",
                                   :full-name-encode "cljs.repl.node/-main",
                                   :history [["+" "0.0-3165"]]},
           "cljs.pprint/PrettyFlush" {:moved "cljs.pprint/IPrettyFlush",
                                      :ns "cljs.pprint",
                                      :name "PrettyFlush",
                                      :history [["+" "0.0-2496"]
                                                ["-" "0.0-3255"]],
                                      :type "protocol",
                                      :full-name-encode "cljs.pprint/PrettyFlush",
                                      :source {:code "(defprotocol PrettyFlush (ppflush [this]))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r3211",
                                               :filename "src/cljs/cljs/pprint.cljs",
                                               :lines [120]},
                                      :methods [{:name "ppflush",
                                                 :signature ["[this]"],
                                                 :docstring nil}],
                                      :full-name "cljs.pprint/PrettyFlush",
                                      :removed {:in "0.0-3255",
                                                :last-seen "0.0-3211"}},
           "cljs.build.api/add-dependencies" {:ns "cljs.build.api",
                                              :name "add-dependencies",
                                              :signature ["[opts & ijss]"],
                                              :history [["+"
                                                         "0.0-3291"]],
                                              :type "function",
                                              :full-name-encode "cljs.build.api/add-dependencies",
                                              :source {:code "(defn add-dependencies\n  [opts & ijss]\n  (closure/add-dependencies opts ijss))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.7.228",
                                                       :filename "src/main/clojure/cljs/build/api.clj",
                                                       :lines [143
                                                               148]},
                                              :full-name "cljs.build.api/add-dependencies",
                                              :docstring "Given one or more IJavaScript objects in dependency order, produce\na new sequence of IJavaScript objects which includes the input list\nplus all dependencies in dependency order."},
           "clojure.browser.net/xhr-connection" {:ns "clojure.browser.net",
                                                 :name "xhr-connection",
                                                 :signature ["[]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.browser.net/xhr-connection",
                                                 :source {:code "(defn xhr-connection\n  []\n  (XhrIo.))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r1.7.228",
                                                          :filename "src/main/cljs/clojure/browser/net.cljs",
                                                          :lines [81
                                                                  84]},
                                                 :full-name "clojure.browser.net/xhr-connection",
                                                 :docstring "Returns an XhrIo connection"},
           "cljs.core/as->" {:description "Binds `name` to `expr`, evaluates the first form in the lexical context of that\nbinding, then binds `name` to that result, repeating for each successive form,\nreturning the result of the last form.\n\nUseful for when you want a threading macro to use different \"places\" at each\nform.",
                             :ns "cljs.core",
                             :name "as->",
                             :signature ["[expr name & forms]"],
                             :history [["+" "0.0-1798"]],
                             :type "macro",
                             :related ["cljs.core/->"
                                       "cljs.core/->>"
                                       "cljs.core/cond->"
                                       "cljs.core/cond->>"
                                       "cljs.core/some->"
                                       "cljs.core/some->>"],
                             :full-name-encode "cljs.core/as-GT",
                             :source {:code "(defmacro as->\n  [expr name & forms]\n  `(let [~name ~expr\n         ~@(interleave (repeat name) forms)]\n     ~name))",
                                      :title "Source code",
                                      :repo "clojure",
                                      :tag "clojure-1.7.0",
                                      :filename "src/clj/clojure/core.clj",
                                      :lines [7261 7269]},
                             :examples [{:id "5e7eef",
                                         :content "```clj\n(as-> [1 2 3 4] x\n  (reduce + x)\n  (/ x 2))\n;;=> 5\n```"}],
                             :full-name "cljs.core/as->",
                             :clj-symbol "clojure.core/as->",
                             :docstring "Binds name to expr, evaluates the first form in the lexical context\nof that binding, then binds name to that result, repeating for each\nsuccessive form, returning the result of the last form."},
           "clojure.core.reducers/reducer" {:ns "clojure.core.reducers",
                                            :name "reducer",
                                            :signature ["[coll xf]"],
                                            :history [["+" "0.0-1236"]],
                                            :type "function",
                                            :full-name-encode "clojure.core.reducers/reducer",
                                            :source {:code "(defn reducer\n  ([coll xf]\n     (reify\n       cljs.core/IReduce\n       (-reduce [this f1]\n         (-reduce this f1 (f1)))\n       (-reduce [_ f1 init]\n         (-reduce coll (xf f1) init)))))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.7.228",
                                                     :filename "src/main/cljs/clojure/core/reducers.cljs",
                                                     :lines [66 77]},
                                            :full-name "clojure.core.reducers/reducer",
                                            :clj-symbol "clojure.core.reducers/reducer",
                                            :docstring "Given a reducible collection, and a transformation function xf,\nreturns a reducible collection, where any supplied reducing\nfn will be transformed by xf. xf is a function of reducing fn to\nreducing fn."},
           "cljs.core/uuid" {:description "Creates a universally unique identifier (UUID) from the given string, using the\n[doc:cljs.core/UUID] type.\n\nThe string has an expected format `8-4-4-12` where the numbers represent the\nnumber of hex digits.  No validation is performed.\n\nTo create a UUID literal (parsed and validated at compile time), use [doc:syntax/uuid-literal].",
                             :ns "cljs.core",
                             :name "uuid",
                             :signature ["[s]"],
                             :history [["+" "0.0-3291"]],
                             :type "function",
                             :related ["cljs.core/random-uuid"
                                       "syntax/uuid-literal"],
                             :full-name-encode "cljs.core/uuid",
                             :source {:code "(defn uuid [s]\n  (UUID. s nil))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [9863 9864]},
                             :examples [{:id "d6491d",
                                         :content "```clj\n(uuid \"00000000-0000-0000-0000-000000000000\")\n;;=> #uuid \"00000000-0000-0000-0000-000000000000\"\n\n(uuid \"97bda55b-6175-4c39-9e04-7c0205c709dc\")\n;;=> #uuid \"97bda55b-6175-4c39-9e04-7c0205c709dc\"\n```\n\nNo validation is performed:\n\n```clj\n(uuid \"\")\n;;=> #uuid \"\"\n```"}],
                             :full-name "cljs.core/uuid"},
           "cljs.core/subs" {:description "Returns the substring of `s` beginning at `start` inclusive, and ending at `end`\nexclusive.\n\n`end` defaults to the length of the string.",
                             :ns "cljs.core",
                             :name "subs",
                             :signature ["[s start]" "[s start end]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/subs",
                             :source {:code "(defn subs\n  ([s start] (.substring s start))\n  ([s start end] (.substring s start end)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [2631 2635]},
                             :full-name "cljs.core/subs",
                             :clj-symbol "clojure.core/subs",
                             :docstring "Returns the substring of s beginning at start inclusive, and ending\nat end (defaults to length of string), exclusive."},
           "syntax/unquote" {:description "(Only intended for use in Clojure macros, which can be used from but not\nwritten in ClojureScript.)\n\nIntended for use inside a [doc:syntax/syntax-quote].\n\nForces evaluation of the following form.",
                             :ns "syntax",
                             :name "unquote",
                             :history [["+" "0.0-927"]],
                             :type "syntax",
                             :related ["syntax/syntax-quote"
                                       "syntax/unquote-splicing"],
                             :full-name-encode "syntax/unquote",
                             :extra-sources ({:code "(defn- read-unquote\n  [rdr comma opts pending-forms]\n  (if-let [ch (peek-char rdr)]\n    (if (identical? \\@ ch)\n      ((wrapping-reader 'clojure.core/unquote-splicing) (doto rdr read-char) \\@ opts pending-forms)\n      ((wrapping-reader 'clojure.core/unquote) rdr \\~ opts pending-forms))))",
                                              :title "Reader code",
                                              :repo "tools.reader",
                                              :tag "tools.reader-1.0.0-alpha1",
                                              :filename "src/main/clojure/clojure/tools/reader.clj",
                                              :lines [588 593]}
                                             {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                              :title "Reader table",
                                              :repo "tools.reader",
                                              :tag "tools.reader-1.0.0-alpha1",
                                              :filename "src/main/clojure/clojure/tools/reader.clj",
                                              :lines [743 762]}),
                             :examples [{:id "1ff51e",
                                         :content "```clj\n(def foo 1)\n`~foo\n;;=> 1\n\n`(def foo ~foo)\n;;=> (def cljs.user/foo 1)\n```"}],
                             :full-name "syntax/unquote",
                             :display "~ unquote",
                             :clj-doc "http://clojure.org/reader#toc2"},
           "cljs.core/symbol?" {:return-type boolean,
                                :ns "cljs.core",
                                :name "symbol?",
                                :signature ["[x]"],
                                :history [["+" "0.0-927"]],
                                :type "function/macro",
                                :full-name-encode "cljs.core/symbolQMARK",
                                :source {:code "(defn ^boolean symbol?\n  [x]\n  (instance? Symbol x))",
                                         :title "Function code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [910 913]},
                                :extra-sources [{:code "(core/defmacro symbol? [x]\n  (bool-expr `(instance? Symbol ~x)))",
                                                 :title "Macro code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/clojure/cljs/core.cljc",
                                                 :lines [936 937]}],
                                :full-name "cljs.core/symbol?",
                                :clj-symbol "clojure.core/symbol?",
                                :docstring "Return true if x is a Symbol"},
           "clojure.data/Diff" {:ns "clojure.data",
                                :name "Diff",
                                :history [["+" "0.0-1503"]],
                                :type "protocol",
                                :full-name-encode "clojure.data/Diff",
                                :source {:code "(defprotocol Diff\n  \"Implementation detail. Subject to change.\"\n  (diff-similar [a b] \"Implementation detail. Subject to change.\"))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/clojure/data.cljs",
                                         :lines [79 81]},
                                :methods [{:name "diff-similar",
                                           :signature ["[a b]"],
                                           :docstring "Implementation detail. Subject to change."}],
                                :full-name "clojure.data/Diff",
                                :clj-symbol "clojure.data/Diff",
                                :docstring "Implementation detail. Subject to change."},
           "clojure.string/replace" {:description "Replaces all instance of `match` with `replacement` in `s`.\n\nThe options for match / replacement are:\n\n| match  | replacement |\n|--------|-------------|\n| string | string      |\n| regex  | string      |\n| regex  | function    |",
                                     :ns "clojure.string",
                                     :name "replace",
                                     :signature ["[s match replacement]"],
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :related ["cljs.core/subs"
                                               "clojure.string/split"
                                               "clojure.string/replace-first"],
                                     :full-name-encode "clojure.string/replace",
                                     :source {:code "(defn replace\n  [s match replacement]\n  (cond\n    (string? match)\n    (.replace s (js/RegExp. (gstring/regExpEscape match) \"g\") replacement)\n\n    (instance? js/RegExp match)\n    (if (string? replacement)\n      (replace-all s match replacement)\n      (replace-all s match (replace-with replacement)))\n\n    :else (throw (str \"Invalid match arg: \" match))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/cljs/clojure/string.cljs",
                                              :lines [39 55]},
                                     :full-name "clojure.string/replace",
                                     :clj-symbol "clojure.string/replace",
                                     :docstring "Replaces all instance of match with replacement in s.\nmatch/replacement can be:\n\nstring / string\npattern / (string or function of match)."},
           "cljs.core/string?" {:description "Returns true if `x` is a string, false otherwise.",
                                :return-type boolean,
                                :ns "cljs.core",
                                :name "string?",
                                :signature ["[x]"],
                                :history [["+" "0.0-927"]],
                                :type "function/macro",
                                :full-name-encode "cljs.core/stringQMARK",
                                :source {:code "(defn ^boolean string?\n  [x]\n  (goog/isString x))",
                                         :title "Function code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [222 225]},
                                :extra-sources [{:code "(core/defmacro string? [x]\n  (bool-expr (core/list 'js* \"typeof ~{} === 'string'\" x)))",
                                                 :title "Macro code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/clojure/cljs/core.cljc",
                                                 :lines [904 905]}],
                                :full-name "cljs.core/string?",
                                :clj-symbol "clojure.core/string?",
                                :docstring "Returns true if x is a JavaScript string."},
           "cljs.core/*target*" {:ns "cljs.core",
                                 :name "*target*",
                                 :docstring "Var bound to the name value of the compiler build :target option.\nFor example, if the compiler build :target is :nodejs, *target* will be bound\nto \"nodejs\". *target* is a Google Closure define and can be set by compiler\n:closure-defines option.",
                                 :type "dynamic var",
                                 :source {:code "(goog-define\n  ^{:dynamic true\n    :doc \"Var bound to the name value of the compiler build :target option.\n  For example, if the compiler build :target is :nodejs, *target* will be bound\n  to \\\"nodejs\\\". *target* is a Google Closure define and can be set by compiler\n  :closure-defines option.\"}\n  *target* \"default\")",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [20 26]},
                                 :full-name "cljs.core/*target*",
                                 :full-name-encode "cljs.core/STARtargetSTAR",
                                 :history [["+" "0.0-2985"]]},
           "cljs.core/Namespace" {:ns "cljs.core",
                                  :name "Namespace",
                                  :signature ["[obj name]"],
                                  :history [["+" "1.7.10"]],
                                  :type "type",
                                  :full-name-encode "cljs.core/Namespace",
                                  :source {:code "(deftype Namespace [obj name]\n  Object\n  (findInternedVar [this sym]\n    (let [k (munge (str sym))]\n      (when ^boolean (gobject/containsKey obj k)\n        (let [var-sym (symbol (str name) (str sym))\n              var-meta {:ns this}]\n          (Var. (ns-lookup obj k) var-sym var-meta)))))\n  (getName [_] name)\n  (toString [_]\n    (str name))\n  IEquiv\n  (-equiv [_ other]\n    (if (instance? Namespace other)\n      (= name (.-name other))\n      false))\n  IHash\n  (-hash [_]\n    (hash name)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [10108 10126]},
                                  :full-name "cljs.core/Namespace",
                                  :clj-symbol "clojure.lang/Namespace"},
           "cljs.core/partition-all" {:description "Returns a lazy sequence of lists like `partition`, but may include partitions\nwith fewer than `n` items at the end.\n\nReturns a stateful transducer when no collection is provided.",
                                      :ns "cljs.core",
                                      :name "partition-all",
                                      :signature ["[n]"
                                                  "[n coll]"
                                                  "[n step coll]"],
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :related ["cljs.core/partition"
                                                "cljs.core/partition-by"],
                                      :full-name-encode "cljs.core/partition-all",
                                      :source {:code "(defn partition-all\n  ([n]\n   (fn [rf]\n     (let [a (array-list)]\n       (fn\n         ([] (rf))\n         ([result]\n            (let [result (if (.isEmpty a)\n                           result\n                           (let [v (vec (.toArray a))]\n                             ;;clear first!\n                             (.clear a)\n                             (unreduced (rf result v))))]\n              (rf result)))\n         ([result input]\n            (.add a input)\n            (if (== n (.size a))\n              (let [v (vec (.toArray a))]\n                (.clear a)\n                (rf result v))\n              result))))))\n  ([n coll]\n     (partition-all n n coll))\n  ([n step coll]\n     (lazy-seq\n      (when-let [s (seq coll)]\n        (cons (take n s) (partition-all n step (drop step s)))))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [8343 8372]},
                                      :full-name "cljs.core/partition-all",
                                      :clj-symbol "clojure.core/partition-all",
                                      :docstring "Returns a lazy sequence of lists like partition, but may include\npartitions with fewer than n items at the end.  Returns a stateful\ntransducer when no collection is provided."},
           "cljs.core/Var" {:ns "cljs.core",
                            :name "Var",
                            :signature ["[val sym _meta]"],
                            :history [["+" "0.0-2496"]],
                            :type "type",
                            :full-name-encode "cljs.core/Var",
                            :source {:code "(deftype Var [val sym _meta]\n  Object\n  (isMacro [_]\n    (. (val) -cljs$lang$macro))\n  IDeref\n  (-deref [_] (val))\n  IMeta\n  (-meta [_] _meta)\n  IWithMeta\n  (-with-meta [_ new-meta]\n    (Var. val sym new-meta))\n  IEquiv\n  (-equiv [this other]\n    (if (instance? Var other)\n      (= (.-sym this) (.-sym other))\n      false))\n  Fn\n  IFn\n  (-invoke [_]\n    ((val)))\n  (-invoke [_ a]\n    ((val) a))\n  (-invoke [_ a b]\n    ((val) a b))\n  (-invoke [_ a b c]\n    ((val) a b c))\n  (-invoke [_ a b c d]\n    ((val) a b c d))\n  (-invoke [_ a b c d e]\n    ((val) a b c d e))\n  (-invoke [_ a b c d e f]\n    ((val) a b c d e f))\n  (-invoke [_ a b c d e f g]\n    ((val) a b c d e f g))\n  (-invoke [_ a b c d e f g h]\n    ((val) a b c d e f g h))\n  (-invoke [_ a b c d e f g h i]\n    ((val) a b c d e f g h i))\n  (-invoke [_ a b c d e f g h i j]\n    ((val) a b c d e f g h i j))\n  (-invoke [_ a b c d e f g h i j k]\n    ((val) a b c d e f g h i j k))\n  (-invoke [_ a b c d e f g h i j k l]\n    ((val) a b c d e f g h i j k l))\n  (-invoke [_ a b c d e f g h i j k l m]\n    ((val) a b c d e f g h i j k l m))\n  (-invoke [_ a b c d e f g h i j k l m n]\n    ((val) a b c d e f g h i j k l m n))\n  (-invoke [_ a b c d e f g h i j k l m n o]\n    ((val) a b c d e f g h i j k l m n o))\n  (-invoke [_ a b c d e f g h i j k l m n o p]\n    ((val) a b c d e f g h i j k l m n o p))\n  (-invoke [_ a b c d e f g h i j k l m n o p q]\n    ((val) a b c d e f g h i j k l m n o p q))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r]\n    ((val) a b c d e f g h i j k l m n o p q r))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r s]\n    ((val) a b c d e f g h i j k l m n o p q r s))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r s t]\n    ((val) a b c d e f g h i j k l m n o p q r s t))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r s t rest]\n    (apply (val) a b c d e f g h i j k l m n o p q r s t rest)))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.7.228",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [983 1044]},
                            :full-name "cljs.core/Var",
                            :clj-symbol "clojure.lang/Var"},
           "cljs.core/RedNode" {:ns "cljs.core",
                                :name "RedNode",
                                :type "type",
                                :signature ["[key val left right __hash]"],
                                :source {:code "(deftype RedNode [key val left right ^:mutable __hash]\n  Object\n  (add-left [node ins]\n    (RedNode. key val ins right nil))\n\n  (add-right [node ins]\n    (RedNode. key val left ins nil))\n\n  (remove-left [node del]\n    (RedNode. key val del right nil))\n\n  (remove-right [node del]\n    (RedNode. key val left del nil))\n\n  (blacken [node]\n    (BlackNode. key val left right nil))\n\n  (redden [node]\n    (throw (js/Error. \"red-black tree invariant violation\")))\n\n  (balance-left [node parent]\n    (cond\n      (instance? RedNode left)\n      (RedNode. key val\n                (.blacken left)\n                (BlackNode. (.-key parent) (.-val parent) right (.-right parent) nil)\n                nil)\n\n      (instance? RedNode right)\n      (RedNode. (.-key right) (.-val right)\n                (BlackNode. key val left (.-left right) nil)\n                (BlackNode. (.-key parent) (.-val parent)\n                            (.-right right)\n                            (.-right parent)\n                            nil)\n                nil)\n\n      :else\n      (BlackNode. (.-key parent) (.-val parent) node (.-right parent) nil)))\n\n  (balance-right [node parent]\n    (cond\n      (instance? RedNode right)\n      (RedNode. key val\n                (BlackNode. (.-key parent) (.-val parent)\n                            (.-left parent)\n                            left\n                            nil)\n                (.blacken right)\n                nil)\n\n      (instance? RedNode left)\n      (RedNode. (.-key left) (.-val left)\n                (BlackNode. (.-key parent) (.-val parent)\n                            (.-left parent)\n                            (.-left left)\n                            nil)\n                (BlackNode. key val (.-right left) right nil)\n                nil)\n\n      :else\n      (BlackNode. (.-key parent) (.-val parent) (.-left parent) node nil)))\n\n  (replace [node key val left right]\n    (RedNode. key val left right nil))\n\n  (kv-reduce [node f init]\n    (tree-map-kv-reduce node f init))\n\n  IMapEntry\n  (-key [node] key)\n  (-val [node] val)\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IMeta\n  (-meta [node] nil)\n\n  IWithMeta\n  (-with-meta [node meta]\n    (with-meta [key val] meta))\n\n  IStack\n  (-peek [node] val)\n\n  (-pop [node] [key])\n\n  ICollection\n  (-conj [node o] [key val o])\n\n  IEmptyableCollection\n  (-empty [node] [])\n\n  ISequential\n  ISeqable\n  (-seq [node] (list key val))\n\n  ICounted\n  (-count [node] 2)\n\n  IIndexed\n  (-nth [node n]\n    (cond (== n 0) key\n          (== n 1) val\n          :else    nil))\n\n  (-nth [node n not-found]\n    (cond (== n 0) key\n          (== n 1) val\n          :else    not-found))\n\n  ILookup\n  (-lookup [node k] (-nth node k nil))\n  (-lookup [node k not-found] (-nth node k not-found))\n\n  IAssociative\n  (-assoc [node k v]\n    (assoc [key val] k v))\n\n  IVector\n  (-assoc-n [node n v]\n    (-assoc-n [key val] n v))\n\n  IReduce\n  (-reduce [node f]\n    (ci-reduce node f))\n\n  (-reduce [node f start]\n    (ci-reduce node f start))\n\n  IFn\n  (-invoke [node k]\n    (-lookup node k))\n\n  (-invoke [node k not-found]\n    (-lookup node k not-found)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [7338 7477]},
                                :full-name "cljs.core/RedNode",
                                :full-name-encode "cljs.core/RedNode",
                                :history [["+" "0.0-1211"]]},
           "cljs.repl/IParseStacktrace" {:ns "cljs.repl",
                                         :name "IParseStacktrace",
                                         :type "protocol",
                                         :full-name-encode "cljs.repl/IParseStacktrace",
                                         :source {:code "(defprotocol IParseStacktrace\n  (-parse-stacktrace [repl-env stacktrace error build-options]\n    \"Given the original JavaScript stacktrace string, the entire original error\n     value and current compiler build options, parse the stacktrace into the\n     canonical form:\n\n     [{:file <string>\n       :function <string>\n       :line <integer>\n       :column <integer>}*]\n\n     :file must be a URL path (without protocol) relative to :output-dir. If\n     no source file can be supplied (such as REPL defs), :file may be a custom\n     identifier string surrounded by angle brackets, i.e. \\\"<cljs repl>\\\".\"))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.7.228",
                                                  :filename "src/main/clojure/cljs/repl.cljc",
                                                  :lines [135 148]},
                                         :methods [{:name "-parse-stacktrace",
                                                    :signature ["[repl-env stacktrace error build-options]"],
                                                    :docstring "Given the original JavaScript stacktrace string, the entire original error\n     value and current compiler build options, parse the stacktrace into the\n     canonical form:\n\n     [{:file <string>\n       :function <string>\n       :line <integer>\n       :column <integer>}*]\n\n     :file must be a URL path (without protocol) relative to :output-dir. If\n     no source file can be supplied (such as REPL defs), :file may be a custom\n     identifier string surrounded by angle brackets, i.e. \"<cljs repl>\"."}],
                                         :full-name "cljs.repl/IParseStacktrace",
                                         :history [["+" "0.0-2843"]]},
           "cljs.core/ExceptionInfo" {:ns "cljs.core",
                                      :name "ExceptionInfo",
                                      :signature ["[message data cause]"],
                                      :history [["+" "0.0-1576"]],
                                      :type "type",
                                      :full-name-encode "cljs.core/ExceptionInfo",
                                      :source {:code "(defn ^{:jsdoc [\"@constructor\"]}\n  ExceptionInfo [message data cause]\n  (let [e (js/Error. message)]\n    (this-as this\n      (set! (.-message this) message)\n      (set! (.-data this) data)\n      (set! (.-cause this) cause)\n      (do\n        (set! (.-name this) (.-name e))\n        ;; non-standard\n        (set! (.-description this) (.-description e))\n        (set! (.-number this) (.-number e))\n        (set! (.-fileName this) (.-fileName e))\n        (set! (.-lineNumber this) (.-lineNumber e))\n        (set! (.-columnNumber this) (.-columnNumber e))\n        (set! (.-stack this) (.-stack e)))\n      this)))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [9892 9908]},
                                      :full-name "cljs.core/ExceptionInfo",
                                      :clj-symbol "clojure.lang/ExceptionInfo"},
           "cljs.core/merge-with" {:description "Returns a map that consists of the rest of the maps `conj`-ed onto the first.\n\nIf a key occurs in more than one map, the mapping(s) from the latter (left-to-\nright) will be combined with the mapping in the result by calling `(f val-in-\nresult val-in-latter)`.",
                                   :ns "cljs.core",
                                   :name "merge-with",
                                   :signature ["[f & maps]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/merge"],
                                   :full-name-encode "cljs.core/merge-with",
                                   :source {:code "(defn merge-with\n  [f & maps]\n  (when (some identity maps)\n    (let [merge-entry (fn [m e]\n                        (let [k (first e) v (second e)]\n                          (if (contains? m k)\n                            (assoc m k (f (get m k) v))\n                            (assoc m k v))))\n          merge2 (fn [m1 m2]\n                   (reduce merge-entry (or m1 {}) (seq m2)))]\n      (reduce merge2 maps))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [7932 7946]},
                                   :full-name "cljs.core/merge-with",
                                   :clj-symbol "clojure.core/merge-with",
                                   :docstring "Returns a map that consists of the rest of the maps conj-ed onto\nthe first.  If a key occurs in more than one map, the mapping(s)\nfrom the latter (left-to-right) will be combined with the mapping in\nthe result by calling (f val-in-result val-in-latter)."},
           "cljs.repl/repl-quit-prompt" {:ns "cljs.repl",
                                         :name "repl-quit-prompt",
                                         :type "function",
                                         :signature ["[]"],
                                         :source {:code "(defn repl-quit-prompt []\n  (println \"To quit, type:\" :cljs/quit))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.7.228",
                                                  :filename "src/main/clojure/cljs/repl.cljc",
                                                  :lines [730 731]},
                                         :full-name "cljs.repl/repl-quit-prompt",
                                         :full-name-encode "cljs.repl/repl-quit-prompt",
                                         :history [["+" "0.0-3148"]]},
           "cljs.core/key" {:description "Returns the key of the map entry.",
                            :ns "cljs.core",
                            :name "key",
                            :signature ["[map-entry]"],
                            :history [["+" "0.0-1211"]],
                            :type "function",
                            :related ["cljs.core/keys"],
                            :full-name-encode "cljs.core/key",
                            :source {:code "(defn key\n  [map-entry]\n  (-key map-entry))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.7.228",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [7851 7854]},
                            :full-name "cljs.core/key",
                            :clj-symbol "clojure.core/key",
                            :docstring "Returns the key of the map entry."},
           "clojure.browser.dom/set-properties" {:ns "clojure.browser.dom",
                                                 :name "set-properties",
                                                 :signature ["[e m]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.browser.dom/set-properties",
                                                 :source {:code "(defn set-properties\n  [e m]\n  (gdom/setProperties (ensure-element e)\n                      (apply gobject/create (interleave (keys m) (vals m)))))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r1.7.228",
                                                          :filename "src/main/cljs/clojure/browser/dom.cljs",
                                                          :lines [136
                                                                  140]},
                                                 :full-name "clojure.browser.dom/set-properties",
                                                 :docstring "Set properties on an element"},
           "clojure.data/diff" {:ns "clojure.data",
                                :name "diff",
                                :signature ["[a b]"],
                                :history [["+" "0.0-1503"]],
                                :type "function",
                                :full-name-encode "clojure.data/diff",
                                :source {:code "(defn diff\n  [a b]\n  (if (= a b)\n    [nil nil a]\n    (if (= (equality-partition a) (equality-partition b))\n      (diff-similar a b)\n      (atom-diff a b))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/clojure/data.cljs",
                                         :lines [144 161]},
                                :full-name "clojure.data/diff",
                                :clj-symbol "clojure.data/diff",
                                :docstring "Recursively compares a and b, returning a tuple of\n[things-only-in-a things-only-in-b things-in-both].\nComparison rules:\n\n* For equal a and b, return [nil nil a].\n* Maps are subdiffed where keys match and values differ.\n* Sets are never subdiffed.\n* All sequential things are treated as associative collections\n  by their indexes, with results returned as vectors.\n* Everything else (including strings!) is treated as\n  an atom and compared for equality."},
           "cljs.core/ITransientAssociative" {:ns "cljs.core",
                                              :name "ITransientAssociative",
                                              :history [["+"
                                                         "0.0-1211"]],
                                              :type "protocol",
                                              :full-name-encode "cljs.core/ITransientAssociative",
                                              :source {:code "(defprotocol ITransientAssociative\n  \"Protocol for adding associativity to transient collections.\"\n  (^clj -assoc! [tcoll key val]\n    \"Returns a new transient collection of tcoll with a mapping from key to\n     val added to it.\"))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.7.228",
                                                       :filename "src/main/cljs/cljs/core.cljs",
                                                       :lines [679
                                                               683]},
                                              :methods [{:name "-assoc!",
                                                         :signature ["[tcoll key val]"],
                                                         :docstring "Returns a new transient collection of tcoll with a mapping from key to\n     val added to it."}],
                                              :full-name "cljs.core/ITransientAssociative",
                                              :clj-symbol "clojure.lang/ITransientAssociative",
                                              :docstring "Protocol for adding associativity to transient collections."},
           "cljs.core/trampoline" {:ns "cljs.core",
                                   :name "trampoline",
                                   :signature ["[f]" "[f & args]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/trampoline",
                                   :source {:code "(defn trampoline\n  ([f]\n     (let [ret (f)]\n       (if (fn? ret)\n         (recur ret)\n         ret)))\n  ([f & args]\n     (trampoline #(apply f args))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [9385 9399]},
                                   :full-name "cljs.core/trampoline",
                                   :clj-symbol "clojure.core/trampoline",
                                   :docstring "trampoline can be used to convert algorithms requiring mutual\nrecursion without stack consumption. Calls f with supplied args, if\nany. If f returns a fn, calls that fn with no arguments, and\ncontinues to repeat, until the return value is not a fn, then\nreturns that non-fn value. Note that if you want to return a fn as a\nfinal value, you must wrap it in some data structure and unpack it\nafter trampoline returns."},
           "cljs.test/test-ns" {:ns "cljs.test",
                                :name "test-ns",
                                :signature ["[ns]"
                                            "[env [quote ns :as form]]"],
                                :history [["+" "0.0-2496"]],
                                :type "macro",
                                :full-name-encode "cljs.test/test-ns",
                                :source {:code "(defmacro test-ns\n  ([ns] `(cljs.test/test-ns (cljs.test/empty-env) ~ns))\n  ([env [quote ns :as form]]\n   `(cljs.test/run-block\n     (concat (cljs.test/test-ns-block ~env ~form)\n             [(fn []\n                (cljs.test/clear-env!))]))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/test.clj",
                                         :lines [360 372]},
                                :full-name "cljs.test/test-ns",
                                :clj-symbol "clojure.test/test-ns",
                                :docstring "If the namespace defines a function named test-ns-hook, calls that.\nOtherwise, calls test-all-vars on the namespace.  'ns' is a\nnamespace object or a symbol.\n\nInternally binds *report-counters* to a ref initialized to\n*initial-report-counters*.  "},
           "cljs.core/implements?" {:ns "cljs.core",
                                    :name "implements?",
                                    :signature ["[psym x]"],
                                    :history [["+" "0.0-2014"]],
                                    :type "macro",
                                    :full-name-encode "cljs.core/implementsQMARK",
                                    :source {:code "(core/defmacro implements?\n  [psym x]\n  (core/let [p          (:name\n                          (cljs.analyzer/resolve-var\n                            (dissoc &env :locals) psym))\n             prefix     (protocol-prefix p)\n             xsym       (bool-expr (gensym))\n             [part bit] (fast-path-protocols p)\n             msym       (symbol\n                          (core/str \"-cljs$lang$protocol_mask$partition\" part \"$\"))]\n    (core/if-not (core/symbol? x)\n      `(let [~xsym ~x]\n         (if ~xsym\n           (if (or ~(if bit `(unsafe-bit-and (. ~xsym ~msym) ~bit) false)\n                   ~(bool-expr `(. ~xsym ~(symbol (core/str \"-\" prefix)))))\n             true\n             false)\n           false))\n      `(if-not (nil? ~x)\n         (if (or ~(if bit `(unsafe-bit-and (. ~x ~msym) ~bit) false)\n                 ~(bool-expr `(. ~x ~(symbol (core/str \"-\" prefix)))))\n           true\n           false)\n         false))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/clojure/cljs/core.cljc",
                                             :lines [1921 1945]},
                                    :full-name "cljs.core/implements?",
                                    :docstring "EXPERIMENTAL"},
           "cljs.repl.browser/handle-connection" {:ns "cljs.repl.browser",
                                                  :name "handle-connection",
                                                  :signature ["[opts conn]"],
                                                  :history [["+"
                                                             "0.0-927"]
                                                            ["-"
                                                             "0.0-1503"]],
                                                  :type "function",
                                                  :full-name-encode "cljs.repl.browser/handle-connection",
                                                  :source {:code "(defn handle-connection\n  [opts conn]\n  (let [rdr (BufferedReader. (InputStreamReader. (.getInputStream conn)))]\n    (if-let [request (read-request rdr)]\n      (case (:method request)\n        :get (handle-get opts conn request)\n        :post (handle-post conn (read-string (:content request)))\n        (.close conn))\n      (.close conn))))",
                                                           :title "Source code",
                                                           :repo "clojurescript",
                                                           :tag "r1450",
                                                           :filename "src/clj/cljs/repl/browser.clj",
                                                           :lines [248
                                                                   256]},
                                                  :full-name "cljs.repl.browser/handle-connection",
                                                  :removed {:in "0.0-1503",
                                                            :last-seen "0.0-1450"}},
           "cljs.js/prefix" {:ns "cljs.js",
                             :name "prefix",
                             :signature ["[s pre]"],
                             :history [["+" "1.7.10"] ["-" "1.7.28"]],
                             :type "function",
                             :full-name-encode "cljs.js/prefix",
                             :source {:code "(defn prefix [s pre]\n  (str pre s))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.10",
                                      :filename "src/main/cljs/cljs/js.cljs",
                                      :lines [128 129]},
                             :full-name "cljs.js/prefix",
                             :removed {:in "1.7.28",
                                       :last-seen "1.7.10"}},
           "clojure.browser.repl/send-print" {:ns "clojure.browser.repl",
                                              :name "send-print",
                                              :signature ["[url data]"
                                                          "[url data n]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "clojure.browser.repl/send-print",
                                              :source {:code "(defn send-print\n  ([url data]\n   (send-print url data 0))\n  ([url data n]\n   (let [conn (net/xhr-connection)]\n     (event/listen conn :error\n       (fn [_]\n         (if (< n 10)\n           (send-print url data (inc n))\n           (.log js/console (str \"Could not send \" data \" after \" n \" attempts.\")))))\n     (net/transmit conn url \"POST\" data nil 0))))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.7.228",
                                                       :filename "src/main/cljs/clojure/browser/repl.cljs",
                                                       :lines [74 86]},
                                              :full-name "clojure.browser.repl/send-print",
                                              :docstring "Send data to be printed in the REPL. If there is an error, try again\nup to 10 times."},
           "cljs.build.api/inputs" {:ns "cljs.build.api",
                                    :name "inputs",
                                    :signature ["[& xs]"],
                                    :history [["+" "0.0-3208"]],
                                    :type "function",
                                    :full-name-encode "cljs.build.api/inputs",
                                    :source {:code "(defn inputs\n  [& xs]\n  (reify\n    closure/Inputs\n    (-paths [_]\n      (map io/file xs))\n    closure/Compilable\n    (-compile [_ opts]\n      (letfn [(compile-input [x]\n                (let [compiled (closure/-compile x opts)]\n                  (if (sequential? compiled)\n                    compiled\n                    [compiled])))]\n        (mapcat compile-input xs)))\n    (-find-sources [_ opts]\n      (mapcat #(closure/-find-sources % opts) xs))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/clojure/cljs/build/api.clj",
                                             :lines [157 174]},
                                    :full-name "cljs.build.api/inputs",
                                    :docstring "Given a list of directories and files, return a compilable object that may\nbe passed to build or watch."},
           "cljs.core/ICounted" {:ns "cljs.core",
                                 :name "ICounted",
                                 :history [["+" "0.0-927"]],
                                 :type "protocol",
                                 :full-name-encode "cljs.core/ICounted",
                                 :source {:code "(defprotocol ICounted\n  \"Protocol for adding the ability to count a collection in constant time.\"\n  (^number -count [coll]\n    \"Calculates the count of coll in constant time. Used by cljs.core/count.\"))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [460 463]},
                                 :methods [{:name "-count",
                                            :signature ["[coll]"],
                                            :docstring "Calculates the count of coll in constant time. Used by cljs.core/count."}],
                                 :full-name "cljs.core/ICounted",
                                 :clj-symbol "clojure.lang/Counted",
                                 :docstring "Protocol for adding the ability to count a collection in constant time."},
           "cljs.core/IEquiv" {:ns "cljs.core",
                               :name "IEquiv",
                               :history [["+" "0.0-927"]],
                               :type "protocol",
                               :full-name-encode "cljs.core/IEquiv",
                               :source {:code "(defprotocol IEquiv\n  \"Protocol for adding value comparison functionality to a type.\"\n  (^boolean -equiv [o other]\n    \"Returns true if o and other are equal, false otherwise.\"))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [590 593]},
                               :methods [{:name "-equiv",
                                          :signature ["[o other]"],
                                          :docstring "Returns true if o and other are equal, false otherwise."}],
                               :full-name "cljs.core/IEquiv",
                               :docstring "Protocol for adding value comparison functionality to a type."},
           "cljs.pprint/print-length-loop" {:ns "cljs.pprint",
                                            :name "print-length-loop",
                                            :signature ["[bindings & body]"],
                                            :history [["+" "0.0-3255"]],
                                            :type "macro",
                                            :full-name-encode "cljs.pprint/print-length-loop",
                                            :source {:code "(defmacro print-length-loop\n  [bindings & body]\n  (let [count-var (gensym \"length-count\")\n        mod-body (pll-mod-body count-var body)]\n    `(loop ~(apply vector count-var 0 bindings)\n       (if (or (not cljs.core/*print-length*) (< ~count-var cljs.core/*print-length*))\n         (do ~@mod-body)\n         (~'-write cljs.core/*out* \"...\")))))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.7.228",
                                                     :filename "src/main/cljs/cljs/pprint.clj",
                                                     :lines [92 101]},
                                            :full-name "cljs.pprint/print-length-loop",
                                            :clj-symbol "clojure.pprint/print-length-loop",
                                            :docstring "A version of loop that iterates at most *print-length* times. This is designed\nfor use in pretty-printer dispatch functions."},
           "cljs.core/reduce-kv" {:description "Reduces an associative collection.\n\n`f` should be a function of 3 arguments. Returns the result of applying `f` to\n`init`, the first key and the first value in `coll`, then applying `f` to that\nresult and the 2nd key and value, etc.\n\nIf `coll` contains no entries, returns `init` and `f` is not called.\n\nNote that `reduce-kv` is supported on vectors, where the keys will be the\nordinals.",
                                  :ns "cljs.core",
                                  :name "reduce-kv",
                                  :signature ["[f init coll]"],
                                  :history [["+" "0.0-1211"]],
                                  :type "function",
                                  :related ["cljs.core/reduce"],
                                  :full-name-encode "cljs.core/reduce-kv",
                                  :source {:code "(defn reduce-kv\n  ([f init coll]\n    (if-not (nil? coll)\n      (-kv-reduce coll f init)\n      init)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [2214 2224]},
                                  :full-name "cljs.core/reduce-kv",
                                  :clj-symbol "clojure.core/reduce-kv",
                                  :docstring "Reduces an associative collection. f should be a function of 3\narguments. Returns the result of applying f to init, the first key\nand the first value in coll, then applying f to that result and the\n2nd key and value, etc. If coll contains no entries, returns init\nand f is not called. Note that reduce-kv is supported on vectors,\nwhere the keys will be the ordinals."},
           "cljs.core/js-delete" {:description "Deletes property `key` in JavaScript object `obj`.\n\nEquivalent to `delete obj[key]` in JavaScript.",
                                  :ns "cljs.core",
                                  :name "js-delete",
                                  :signature ["[obj key]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function/macro",
                                  :related ["cljs.core/dissoc"],
                                  :full-name-encode "cljs.core/js-delete",
                                  :source {:code "(defn js-delete\n  [obj key]\n  (cljs.core/js-delete obj key))",
                                           :title "Function code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [1957 1960]},
                                  :extra-sources [{:code "(core/defmacro js-delete [obj key]\n  (core/list 'js* \"delete ~{}[~{}]\" obj key))",
                                                   :title "Macro code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/clojure/cljs/core.cljc",
                                                   :lines [860 861]}],
                                  :examples [{:id "5b24ea",
                                              :content "```clj\n(def a #js {:foo 1 :bar 2})\n(js-delete a \"foo\")\n\na\n;;=> #js {:bar 2}\n```"}],
                                  :full-name "cljs.core/js-delete",
                                  :docstring "Delete a property from a JavaScript object."},
           "syntax/NaN" {:description "The IEEE 754 Floating Point representation of NaN (not a number), an undefined\nor unrepresentable value.\n\nTo test for NaN, use the native JavaScript [`js/isNaN`] or the safer [`js/Number.isNaN`].\n\n[`js/isNaN`]:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/isNaN\n[`js/Number.isNaN`]:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN",
                         :ns "syntax",
                         :name "NaN",
                         :history [["+" "0.0-1853"]],
                         :type "special symbol",
                         :related ["syntax/Infinity" "syntax/nil"],
                         :full-name-encode "syntax/NaN",
                         :extra-sources [{:code "(defn- read-symbol\n  [rdr initch]\n  (let [[line column] (starting-line-col-info rdr)]\n    (when-let [token (read-token rdr initch)]\n      (case token\n\n        ;; special symbols\n        \"nil\" nil\n        \"true\" true\n        \"false\" false\n        \"/\" '/\n        \"NaN\" Double/NaN\n        \"-Infinity\" Double/NEGATIVE_INFINITY\n        (\"Infinity\" \"+Infinity\") Double/POSITIVE_INFINITY\n\n        (or (when-let [p (parse-symbol token)]\n              (with-meta (symbol (p 0) (p 1))\n                (when line\n                  (merge\n                   (when-let [file (get-file-name rdr)]\n                     {:file file})\n                   (let [[end-line end-column] (ending-line-col-info rdr)]\n                     {:line line\n                      :column column\n                      :end-line end-line\n                      :end-column end-column})))))\n            (reader-error rdr \"Invalid token: \" token))))))",
                                          :title "Reader code",
                                          :repo "tools.reader",
                                          :tag "tools.reader-1.0.0-alpha1",
                                          :filename "src/main/clojure/clojure/tools/reader.clj",
                                          :lines [303 329]}],
                         :examples [{:id "9661ba",
                                     :content "```clj\nNaN\n;;=> NaN\n```\n\nTesting for NaN:\n\n```clj\n(js/Number.isNaN (/ 0 0))\n;;=> true\n\n(js/Number.isNaN 1)\n;;=> false\n```\n\nEquivalent to the JavaScript symbol:\n\n```clj\njs/NaN\n;;=> NaN\n```"}],
                         :full-name "syntax/NaN",
                         :display "NaN"},
           "cljs.core/PersistentTreeSet.EMPTY" {:ns "cljs.core",
                                                :name "PersistentTreeSet.EMPTY",
                                                :history [["+"
                                                           "0.0-1211"]],
                                                :parent-type "PersistentTreeSet",
                                                :type "var",
                                                :full-name-encode "cljs.core/PersistentTreeSetDOTEMPTY",
                                                :source {:code "(set! (.-EMPTY PersistentTreeSet)\n  (PersistentTreeSet. nil (.-EMPTY PersistentTreeMap) empty-unordered-hash))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1.7.228",
                                                         :filename "src/main/cljs/cljs/core.cljs",
                                                         :lines [8200
                                                                 8201]},
                                                :full-name "cljs.core/PersistentTreeSet.EMPTY",
                                                :clj-symbol "clojure.lang/PersistentTreeSet.EMPTY"},
           "cljs.core/comment" {:description "Ignores all `body` forms (i.e. \"commenting out\"). Returns nil.\n\nThis is often used near the bottom of a file to hold expressions that test\ndifferent functions during development.  Specific expressions within the\n`comment` can then be selected and evaluated from some editors.\n\nYou can also use `;` to \"comment out\" code until the end of a line.",
                                :ns "cljs.core",
                                :name "comment",
                                :signature ["[& body]"],
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :full-name-encode "cljs.core/comment",
                                :source {:code "(defmacro comment\n  [& body])",
                                         :title "Source code",
                                         :repo "clojure",
                                         :tag "clojure-1.7.0",
                                         :filename "src/clj/clojure/core.clj",
                                         :lines [4531 4534]},
                                :examples [{:id "482fd7",
                                            :content "```clj\n(comment 123)\n;;=> nil\n\n(comment\n  (foo 1 2 3)\n  (bar \"hello\"))\n;;=> nil\n```\n\nInner forms must still be syntactically correct:\n\n```clj\n(comment [1 2 3]])\n;; Error: Unmatched delimiter ]\n\n(comment a : b)\n;; Error: Invalid token :\n```"}],
                                :full-name "cljs.core/comment",
                                :clj-symbol "clojure.core/comment",
                                :docstring "Ignores body, yields nil"},
           "cljs.reader/special-symbols" {:ns "cljs.reader",
                                          :name "special-symbols",
                                          :type "function",
                                          :signature ["[t not-found]"],
                                          :source {:code "(defn special-symbols [t not-found]\n  (cond\n    (identical? t \"nil\") nil\n    (identical? t \"true\") true\n    (identical? t \"false\") false\n    (identical? t \"/\") '/\n    :else not-found))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/cljs/cljs/reader.cljs",
                                                   :lines [319 325]},
                                          :full-name "cljs.reader/special-symbols",
                                          :full-name-encode "cljs.reader/special-symbols",
                                          :history [["+" "0.0-927"]]},
           "cljs.js/analyze-str" {:ns "cljs.js",
                                  :name "analyze-str",
                                  :signature ["[state source cb]"
                                              "[state source name cb]"
                                              "[state source name opts cb]"],
                                  :history [["+" "1.7.28"]],
                                  :type "function",
                                  :full-name-encode "cljs.js/analyze-str",
                                  :source {:code "(defn analyze-str\n  ([state source cb]\n   (analyze-str state source nil cb))\n  ([state source name cb]\n   (analyze-str state source name nil cb))\n  ([state source name opts cb]\n   {:pre [(atom? state) (string? source)\n          (valid-name? name) (valid-opts? opts) (fn? cb)]}\n   (analyze-str*\n     {:*compiler*     state\n      :*data-readers* tags/*cljs-data-readers*\n      :*passes*       (or (:passes opts) ana/*passes*)\n      :*analyze-deps* (or (:analyze-deps opts) true)\n      :*load-macros*  (or (:load-macros opts) true)\n      :*load-fn*      (or (:load opts) *load-fn*)\n      :*eval-fn*      (or (:eval opts) *eval-fn*)}\n     source name opts cb)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/js.cljs",
                                           :lines [480 519]},
                                  :full-name "cljs.js/analyze-str",
                                  :docstring "Analyze ClojureScript source. The compiler state will be populated with\nthe results of analyzes. The parameters:\n\nstate (atom)\n  the compiler state\n\nsource (string)\n  the ClojureScript source\n\nname (symbol)\n  optional, the name of the source\n\nopts (map)\n  compilation options.\n\n:eval - the eval function to invoke, see *eval-fn*\n:load - library resolution function, see *load-fn*\n\ncb (function)\n  callback, will be invoked with a map. If successful the map will contain\n  a key :value, the actual value is not meaningful. If unsuccessful the\n  map will contain a key :error with an ex-info instance describing the cause\n  of failure."},
           "cljs.core/record?" {:return-type boolean,
                                :ns "cljs.core",
                                :name "record?",
                                :signature ["[x]"],
                                :history [["+" "0.0-3255"]],
                                :type "function",
                                :full-name-encode "cljs.core/recordQMARK",
                                :source {:code "(defn ^boolean record?\n  [x]\n  (satisfies? IRecord x))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [1926 1929]},
                                :full-name "cljs.core/record?",
                                :clj-symbol "clojure.core/record?",
                                :docstring "Return true if x satisfies IRecord"},
           "cljs.build.api/source-on-disk" {:ns "cljs.build.api",
                                            :name "source-on-disk",
                                            :signature ["[opts ijs]"],
                                            :history [["+" "0.0-3291"]],
                                            :type "function",
                                            :full-name-encode "cljs.build.api/source-on-disk",
                                            :source {:code "(defn source-on-disk\n  [opts ijs]\n  (closure/source-on-disk opts ijs))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.7.228",
                                                     :filename "src/main/clojure/cljs/build/api.clj",
                                                     :lines [119 123]},
                                            :full-name "cljs.build.api/source-on-disk",
                                            :docstring "Ensure that the given IJavaScript exists on disk in the output directory.\nReturn updated IJavaScript with the new location if necessary."},
           "cljs.repl.node/setup" {:ns "cljs.repl.node",
                                   :name "setup",
                                   :type "function",
                                   :signature ["[repl-env]"
                                               "[repl-env opts]"],
                                   :source {:code "(defn setup\n  ([repl-env] (setup repl-env nil))\n  ([repl-env opts]\n    (let [output-dir   (io/file (util/output-directory opts))\n          _            (.mkdirs output-dir)\n          of           (io/file output-dir \"node_repl.js\")\n          _            (spit of\n                         (string/replace (slurp (io/resource \"cljs/repl/node_repl.js\"))\n                           \"var PORT = 5001;\"\n                           (str \"var PORT = \" (:port repl-env) \";\")))\n          xs           (cond-> [(get opts :node-command \"node\")]\n                         (:debug-port repl-env) (conj (str \"--debug=\" (:debug-port repl-env))))\n          proc         (-> (ProcessBuilder. (into-array xs))\n                         (.redirectInput of)\n                         .start)\n          _            (do (.start (Thread. (bound-fn [] (pipe proc (.getInputStream proc) *out*))))\n                           (.start (Thread. (bound-fn [] (pipe proc (.getErrorStream proc) *err*)))))\n          env          (ana/empty-env)\n          core         (io/resource \"cljs/core.cljs\")\n          ;; represent paths as vectors so we can emit JS arrays, this is to\n          ;; paper over Windows issues with minimum hassle - David\n          path         (.getPath (.getCanonicalFile output-dir))\n          [fc & cs]    (rest (util/path-seq path)) ;; remove leading empty string\n          root         (.substring path 0 (+ (.indexOf path fc) (count fc)))\n          root-path    (vec (cons root cs))\n          rewrite-path (conj root-path \"goog\")]\n      (reset! (:proc repl-env) proc)\n      (loop [r nil]\n        (when-not (= r \"ready\")\n          (Thread/sleep 50)\n          (try\n            (reset! (:socket repl-env) (socket (:host repl-env) (:port repl-env)))\n            (catch Exception e))\n          (if @(:socket repl-env)\n            (recur (read-response (:in @(:socket repl-env))))\n            (recur nil))))\n      ;; compile cljs.core & its dependencies, goog/base.js must be available\n      ;; for bootstrap to load, use new closure/compile as it can handle\n      ;; resources in JARs\n      (let [core-js (closure/compile core\n                      (assoc opts\n                        :output-file\n                        (closure/src-file->target-file core)))\n            deps    (closure/add-dependencies opts core-js)]\n        ;; output unoptimized code and the deps file\n        ;; for all compiled namespaces\n        (apply closure/output-unoptimized\n          (assoc opts\n            :output-to (.getPath (io/file output-dir \"node_repl_deps.js\")))\n          deps))\n      ;; bootstrap, replace __dirname as __dirname won't be set\n      ;; properly due to how we are running it - David\n      (node-eval repl-env\n        (-> (slurp (io/resource \"cljs/bootstrap_node.js\"))\n          (string/replace \"path.resolve(__dirname, '..', 'base.js')\"\n            (platform-path (conj rewrite-path \"bootstrap\" \"..\" \"base.js\")))\n          (string/replace\n            \"path.join(\\\".\\\", \\\"..\\\", src)\"\n            (str \"path.join(\" (platform-path rewrite-path) \", src)\"))\n          (string/replace\n            \"var CLJS_ROOT = \\\".\\\";\"\n            (str \"var CLJS_ROOT = \" (platform-path root-path) \";\"))))\n      ;; load the deps file so we can goog.require cljs.core etc.\n      (node-eval repl-env\n        (str \"require(\"\n             (platform-path (conj root-path \"node_repl_deps.js\"))\n             \")\"))\n      ;; monkey-patch isProvided_ to avoid useless warnings - David\n      (node-eval repl-env\n        (str \"goog.isProvided_ = function(x) { return false; };\"))\n      ;; monkey-patch goog.require, skip all the loaded checks\n      (repl/evaluate-form repl-env env \"<cljs repl>\"\n        '(set! (.-require js/goog)\n           (fn [name]\n             (js/CLOSURE_IMPORT_SCRIPT\n               (aget (.. js/goog -dependencies_ -nameToPath) name)))))\n      ;; load cljs.core, setup printing\n      (repl/evaluate-form repl-env env \"<cljs repl>\"\n        '(do\n           (.require js/goog \"cljs.core\")\n           (enable-console-print!)))\n      ;; redef goog.require to track loaded libs\n      (repl/evaluate-form repl-env env \"<cljs repl>\"\n        '(do\n           (set! *target* \"nodejs\")\n           (set! *loaded-libs* #{\"cljs.core\"})\n           (set! (.-require js/goog)\n             (fn [name reload]\n               (when (or (not (contains? *loaded-libs* name)) reload)\n                 (set! *loaded-libs* (conj (or *loaded-libs* #{}) name))\n                 (js/CLOSURE_IMPORT_SCRIPT\n                   (aget (.. js/goog -dependencies_ -nameToPath) name))))))))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/clojure/cljs/repl/node.clj",
                                            :lines [99 190]},
                                   :full-name "cljs.repl.node/setup",
                                   :full-name-encode "cljs.repl.node/setup",
                                   :history [["+" "0.0-2629"]]},
           "cljs.core/BitmapIndexedNode.EMPTY" {:ns "cljs.core",
                                                :name "BitmapIndexedNode.EMPTY",
                                                :history [["+"
                                                           "0.0-1211"]],
                                                :parent-type "BitmapIndexedNode",
                                                :type "var",
                                                :full-name-encode "cljs.core/BitmapIndexedNodeDOTEMPTY",
                                                :source {:code "(set! (.-EMPTY BitmapIndexedNode) (BitmapIndexedNode. nil 0 (make-array 0)))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1.7.228",
                                                         :filename "src/main/cljs/cljs/core.cljs",
                                                         :lines [6412]},
                                                :full-name "cljs.core/BitmapIndexedNode.EMPTY",
                                                :clj-symbol "clojure.lang/BitmapIndexedNode.EMPTY"},
           "cljs.reader/register-default-tag-parser!" {:ns "cljs.reader",
                                                       :name "register-default-tag-parser!",
                                                       :type "function",
                                                       :signature ["[f]"],
                                                       :source {:code "(defn register-default-tag-parser!\n  [f]\n  (let [old-parser @*default-data-reader-fn*]\n    (swap! *default-data-reader-fn* (fn [_] f))\n    old-parser))",
                                                                :title "Source code",
                                                                :repo "clojurescript",
                                                                :tag "r1.7.228",
                                                                :filename "src/main/cljs/cljs/reader.cljs",
                                                                :lines [620
                                                                        624]},
                                                       :full-name "cljs.reader/register-default-tag-parser!",
                                                       :full-name-encode "cljs.reader/register-default-tag-parserBANG",
                                                       :history [["+"
                                                                  "0.0-1576"]]},
           "cljs.core/alength" {:description "For interop, it returns the length of a JavaScript array or string.",
                                :return-type number,
                                :ns "cljs.core",
                                :name "alength",
                                :signature ["[a]"],
                                :history [["+" "0.0-927"]],
                                :type "function/macro",
                                :related ["cljs.core/count"],
                                :full-name-encode "cljs.core/alength",
                                :source {:code "(defn ^number alength\n  [array]\n  (cljs.core/alength array))",
                                         :title "Function code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [401 404]},
                                :extra-sources [{:code "(core/defmacro alength [a]\n  (vary-meta\n    (core/list 'js* \"~{}.length\" a)\n    assoc :tag 'number))",
                                                 :title "Macro code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/clojure/cljs/core.cljc",
                                                 :lines [2416 2419]}],
                                :examples [{:id "26f79f",
                                            :content "```clj\n(def a #js [1 2 3])\n\n(alength a)\n;;=> 3\n\n(.-length a)\n;;=> 3\n\n(aget a \"length\")\n;;=> 3\n\n(count a)\n;;=> 3\n```"}],
                                :full-name "cljs.core/alength",
                                :clj-symbol "clojure.core/alength",
                                :docstring "Returns the length of the array. Works on arrays of all types."},
           "cljs.core/mk-bound-fn" {:ns "cljs.core",
                                    :name "mk-bound-fn",
                                    :type "function",
                                    :signature ["[sc test key]"],
                                    :source {:code "(defn mk-bound-fn\n  [sc test key]\n  (fn [e]\n    (let [comp (-comparator sc)]\n      (test (comp (-entry-key sc e) key) 0))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [8393 8397]},
                                    :full-name "cljs.core/mk-bound-fn",
                                    :full-name-encode "cljs.core/mk-bound-fn",
                                    :history [["+" "0.0-1211"]]},
           "cljs.reader/validate-unicode-escape" {:ns "cljs.reader",
                                                  :name "validate-unicode-escape",
                                                  :type "function",
                                                  :signature ["[unicode-pattern reader escape-char unicode-str]"],
                                                  :source {:code "(defn validate-unicode-escape [unicode-pattern reader escape-char unicode-str]\n  (if (re-matches unicode-pattern unicode-str)\n    unicode-str\n    (reader-error reader \"Unexpected unicode escape \\\\\" escape-char unicode-str)))",
                                                           :title "Source code",
                                                           :repo "clojurescript",
                                                           :tag "r1.7.228",
                                                           :filename "src/main/cljs/cljs/reader.cljs",
                                                           :lines [184
                                                                   187]},
                                                  :full-name "cljs.reader/validate-unicode-escape",
                                                  :full-name-encode "cljs.reader/validate-unicode-escape",
                                                  :history [["+"
                                                             "0.0-1424"]]},
           "special/quote" {:ns "special",
                            :name "quote",
                            :signature ["[form]"],
                            :history [["+" "0.0-927"]],
                            :type "special form",
                            :full-name-encode "special/quote",
                            :source {:code "(defmethod parse 'quote\n  [_ env [_ x] _ _]\n  (analyze (assoc env :quoted? true) x))",
                                     :title "Parser code",
                                     :repo "clojurescript",
                                     :tag "r1.7.228",
                                     :filename "src/main/clojure/cljs/analyzer.cljc",
                                     :lines [1540 1542]},
                            :full-name "special/quote",
                            :clj-symbol "clojure.core/quote",
                            :docstring "Yields the unevaluated form."},
           "cljs.js/analyze-deps" {:ns "cljs.js",
                                   :name "analyze-deps",
                                   :signature ["[bound-vars ana-env lib deps cb]"
                                               "[bound-vars ana-env lib deps opts cb]"],
                                   :history [["+" "1.7.10"]
                                             ["-" "1.7.28"]],
                                   :type "function",
                                   :full-name-encode "cljs.js/analyze-deps",
                                   :source {:code "(defn analyze-deps\n  ([bound-vars ana-env lib deps cb]\n   (analyze-deps bound-vars ana-env lib deps nil cb))\n  ([bound-vars ana-env lib deps opts cb]\n   (let [compiler @(:*compiler* bound-vars)]\n     (binding [ana/*cljs-dep-set* (vary-meta (conj (:*cljs-dep-set* bound-vars) lib)\n                                    update-in [:dep-path] conj lib)]\n       (assert (every? #(not (contains? (:*cljs-dep-set* bound-vars) %)) deps)\n         (str \"Circular dependency detected \"\n           (-> (:*cljs-dep-set* bound-vars) meta :dep-path)))\n       (if (seq deps)\n         (let [dep (first deps)]\n           (try\n             ((:*load-fn* bound-vars) {:name dep :path (ns->relpath dep)}\n              (fn [resource]\n                (assert (or (map? resource) (nil? resource))\n                  \"*load-fn* may only return a map or nil\")\n                (if resource\n                  (let [{:keys [name lang source]} resource]\n                    (condp = lang\n                      :clj (analyze* bound-vars source name opts\n                             (fn [res]\n                               (if-not (:error res)\n                                 (analyze-deps bound-vars ana-env lib (next deps) opts cb)\n                                 (cb res))))\n                      :js (analyze-deps bound-vars ana-env lib (next deps) opts cb)\n                      (wrap-error\n                        (ana/error ana-env\n                          (str \"Invalid :lang specified \" lang \", only :clj or :js allowed\")))))\n                  (cb (wrap-error\n                        (ana/error ana-env\n                          (ana/error-message :undeclared-ns\n                            {:ns-sym dep :js-provide (name dep)})))))))\n             (catch :default cause\n               (cb (wrap-error\n                     (ana/error ana-env\n                       (str \"Could not analyze dep \" dep) cause))))))\n         (cb {:value nil}))))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.10",
                                            :filename "src/main/cljs/cljs/js.cljs",
                                            :lines [261 298]},
                                   :full-name "cljs.js/analyze-deps",
                                   :removed {:in "1.7.28",
                                             :last-seen "1.7.10"}},
           "cljs.core/VectorNode" {:ns "cljs.core",
                                   :name "VectorNode",
                                   :type "type",
                                   :signature ["[edit arr]"],
                                   :source {:code "(deftype VectorNode [edit arr])",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [4622]},
                                   :full-name "cljs.core/VectorNode",
                                   :full-name-encode "cljs.core/VectorNode",
                                   :history [["+" "0.0-1211"]]},
           "cljs.core/string-hash-cache-count" {:ns "cljs.core",
                                                :name "string-hash-cache-count",
                                                :type "var",
                                                :source {:code "(def string-hash-cache-count 0)",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1.7.228",
                                                         :filename "src/main/cljs/cljs/core.cljs",
                                                         :lines [842]},
                                                :full-name "cljs.core/string-hash-cache-count",
                                                :full-name-encode "cljs.core/string-hash-cache-count",
                                                :history [["+"
                                                           "0.0-1424"]]},
           "cljs.core/tree-seq" {:description "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n\n`branch?` must be a function of one argument that returns true if passed a node\nthat can have children (but may not).\n\n`children` must be a function of one argument that returns a sequence of the\nchildren. `children` will only be called on nodes for which `branch?` returns\ntrue.\n\n`root` is the root node of the tree.",
                                 :ns "cljs.core",
                                 :name "tree-seq",
                                 :signature ["[branch? children root]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/tree-seq",
                                 :source {:code "(defn tree-seq\n   [branch? children root]\n   (let [walk (fn walk [node]\n                (lazy-seq\n                 (cons node\n                  (when (branch? node)\n                    (mapcat walk (children node))))))]\n     (walk root)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [4463 4476]},
                                 :full-name "cljs.core/tree-seq",
                                 :clj-symbol "clojure.core/tree-seq",
                                 :docstring "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n branch? must be a fn of one arg that returns true if passed a node\n that can have children (but may not).  children must be a fn of one\n arg that returns a sequence of the children. Will only be called on\n nodes for which branch? returns true. Root is the root node of the\ntree."},
           "cljs.reader/read-unmatched-delimiter" {:ns "cljs.reader",
                                                   :name "read-unmatched-delimiter",
                                                   :type "function",
                                                   :signature ["[rdr ch]"],
                                                   :source {:code "(defn read-unmatched-delimiter\n  [rdr ch]\n  (reader-error rdr \"Unmatched delimiter \" ch))",
                                                            :title "Source code",
                                                            :repo "clojurescript",
                                                            :tag "r1.7.228",
                                                            :filename "src/main/cljs/cljs/reader.cljs",
                                                            :lines [260
                                                                    262]},
                                                   :full-name "cljs.reader/read-unmatched-delimiter",
                                                   :full-name-encode "cljs.reader/read-unmatched-delimiter",
                                                   :history [["+"
                                                              "0.0-927"]]},
           "clojure.core.reducers/take-while" {:ns "clojure.core.reducers",
                                               :name "take-while",
                                               :signature ["[pred]"
                                                           "[pred coll]"],
                                               :history [["+"
                                                          "0.0-1236"]],
                                               :type "function",
                                               :full-name-encode "clojure.core.reducers/take-while",
                                               :source {:code "(defcurried take-while\n  \"Ends the reduction of coll when (pred val) returns logical false.\"\n  {}\n  [pred coll]\n  (reducer coll\n   (fn [f1]\n     (rfn [f1 k]\n          ([ret k v]\n             (if (pred k v)\n               (f1 ret k v)\n               (reduced ret)))))))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.7.228",
                                                        :filename "src/main/cljs/clojure/core/reducers.cljs",
                                                        :lines [152
                                                                162]},
                                               :full-name "clojure.core.reducers/take-while",
                                               :clj-symbol "clojure.core.reducers/take-while",
                                               :docstring "Ends the reduction of coll when (pred val) returns logical false."},
           "cljs.reader/register-tag-parser!" {:ns "cljs.reader",
                                               :name "register-tag-parser!",
                                               :type "function",
                                               :signature ["[tag f]"],
                                               :source {:code "(defn register-tag-parser!\n  [tag f]\n  (let [tag (str tag)\n        old-parser (get @*tag-table* tag)]\n    (swap! *tag-table* assoc tag f)\n    old-parser))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.7.228",
                                                        :filename "src/main/cljs/cljs/reader.cljs",
                                                        :lines [606
                                                                611]},
                                               :full-name "cljs.reader/register-tag-parser!",
                                               :full-name-encode "cljs.reader/register-tag-parserBANG",
                                               :history [["+"
                                                          "0.0-1236"]]},
           "cljs.core/every-pred" {:description "Takes a set of predicate functions and returns a function `f` that returns true\nif all of its composing predicates return a logical true value against all of\nits arguments, else it returns false.\n\nNote that `f` is short-circuiting in that it will stop execution on the first\nargument that triggers a logical false result against the original predicates.",
                                   :ns "cljs.core",
                                   :name "every-pred",
                                   :signature ["[p]"
                                               "[p1 p2]"
                                               "[p1 p2 p3]"
                                               "[p1 p2 p3 & ps]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/some-fn"
                                             "cljs.core/and"],
                                   :full-name-encode "cljs.core/every-pred",
                                   :source {:code "(defn every-pred\n  ([p]\n     (fn ep1\n       ([] true)\n       ([x] (boolean (p x)))\n       ([x y] (boolean (and (p x) (p y))))\n       ([x y z] (boolean (and (p x) (p y) (p z))))\n       ([x y z & args] (boolean (and (ep1 x y z)\n                                     (every? p args))))))\n  ([p1 p2]\n     (fn ep2\n       ([] true)\n       ([x] (boolean (and (p1 x) (p2 x))))\n       ([x y] (boolean (and (p1 x) (p1 y) (p2 x) (p2 y))))\n       ([x y z] (boolean (and (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z))))\n       ([x y z & args] (boolean (and (ep2 x y z)\n                                     (every? #(and (p1 %) (p2 %)) args))))))\n  ([p1 p2 p3]\n     (fn ep3\n       ([] true)\n       ([x] (boolean (and (p1 x) (p2 x) (p3 x))))\n       ([x y] (boolean (and (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y))))\n       ([x y z] (boolean (and (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y) (p1 z) (p2 z) (p3 z))))\n       ([x y z & args] (boolean (and (ep3 x y z)\n                                     (every? #(and (p1 %) (p2 %) (p3 %)) args))))))\n  ([p1 p2 p3 & ps]\n     (let [ps (list* p1 p2 p3 ps)]\n       (fn epn\n         ([] true)\n         ([x] (every? #(% x) ps))\n         ([x y] (every? #(and (% x) (% y)) ps))\n         ([x y z] (every? #(and (% x) (% y) (% z)) ps))\n         ([x y z & args] (boolean (and (epn x y z)\n                                       (every? #(every? % args) ps))))))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [4118 4155]},
                                   :full-name "cljs.core/every-pred",
                                   :clj-symbol "clojure.core/every-pred",
                                   :docstring "Takes a set of predicates and returns a function f that returns true if all of its\ncomposing predicates return a logical true value against all of its arguments, else it returns\nfalse. Note that f is short-circuiting in that it will stop execution on the first\nargument that triggers a logical false result against the original predicates."},
           "special/var" {:ns "special",
                          :name "var",
                          :signature ["[symbol]"],
                          :history [["+" "0.0-2496"]],
                          :type "special form",
                          :full-name-encode "special/var",
                          :source {:code "(defmethod parse 'var\n  [op env [_ sym :as form] _ _]\n  (merge\n    {:env env\n     :op :var-special\n     :form form}\n    (var-ast env sym)))",
                                   :title "Parser code",
                                   :repo "clojurescript",
                                   :tag "r1.7.228",
                                   :filename "src/main/clojure/cljs/analyzer.cljc",
                                   :lines [958 964]},
                          :full-name "special/var",
                          :clj-symbol "clojure.core/var",
                          :docstring "The symbol must resolve to a var, and the Var object\nitself (not its value) is returned. The reader macro #'x expands to (var x)."},
           "cljs.core/PersistentHashSet" {:ns "cljs.core",
                                          :name "PersistentHashSet",
                                          :signature ["[meta hash-map __hash]"],
                                          :history [["+" "0.0-1211"]],
                                          :type "type",
                                          :full-name-encode "cljs.core/PersistentHashSet",
                                          :source {:code "(deftype PersistentHashSet [meta hash-map ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  ;; EXPERIMENTAL: subject to change\n  (keys [coll]\n    (es6-iterator (seq coll)))\n  (entries [coll]\n    (es6-set-entries-iterator (seq coll)))\n  (values [coll]\n    (es6-iterator (seq coll)))\n  (has [coll k]\n    (contains? coll k))\n  (forEach [coll f]\n    (doseq [[k v] coll]\n      (f v k)))\n\n  ICloneable\n  (-clone [_] (PersistentHashSet. meta hash-map __hash))\n\n  IIterable\n  (-iterator [coll]\n    (HashSetIter. (-iterator hash-map)))\n\n  IWithMeta\n  (-with-meta [coll meta] (PersistentHashSet. meta hash-map __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll o]\n    (PersistentHashSet. meta (assoc hash-map o nil) nil))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY PersistentHashSet) meta))\n\n  IEquiv\n  (-equiv [coll other]\n    (and\n     (set? other)\n     (== (count coll) (count other))\n     (every? #(contains? coll %)\n             other)))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-unordered-coll __hash))\n\n  ISeqable\n  (-seq [coll] (keys hash-map))\n\n  ICounted\n  (-count [coll] (-count hash-map))\n\n  ILookup\n  (-lookup [coll v]\n    (-lookup coll v nil))\n  (-lookup [coll v not-found]\n    (if (-contains-key? hash-map v)\n      v\n      not-found))\n\n  ISet\n  (-disjoin [coll v]\n    (PersistentHashSet. meta (-dissoc hash-map v) nil))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found))\n\n  IEditableCollection\n  (-as-transient [coll] (TransientHashSet. (-as-transient hash-map))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/cljs/cljs/core.cljs",
                                                   :lines [7976 8052]},
                                          :full-name "cljs.core/PersistentHashSet",
                                          :clj-symbol "clojure.lang/PersistentHashSet"},
           "cljs.repl/doc" {:description "Prints documentation for the var or special form with the name `name`.",
                            :ns "cljs.repl",
                            :name "doc",
                            :signature ["[name]"],
                            :history [["+" "0.0-2496"]],
                            :type "macro",
                            :related ["cljs.repl/find-doc"
                                      "cljs.core/meta"
                                      "special/var"],
                            :full-name-encode "cljs.repl/doc",
                            :source {:code "(defmacro doc\n  [name]\n  `(print\n     (binding [cljs.core/*print-newline* true]\n       (with-out-str\n         ~(if-let [special-name ('{& fn catch try finally try} name)]\n            `(cljs.repl/print-doc (quote ~(special-doc special-name)))\n            (cond\n              (special-doc-map name)\n              `(cljs.repl/print-doc (quote ~(special-doc name)))\n\n              (repl-special-doc-map name)\n              `(cljs.repl/print-doc (quote ~(repl-special-doc name)))\n\n              (ana-api/find-ns name)\n              `(cljs.repl/print-doc\n                 (quote ~(select-keys (ana-api/find-ns name) [:name :doc])))\n\n              (ana-api/resolve &env name)\n              `(cljs.repl/print-doc\n                 (quote ~(let [var (ana-api/resolve &env name)\n                               m (select-keys var\n                                   [:ns :name :doc :forms :arglists :macro :url])]\n                           (cond-> (update-in m [:name] clojure.core/name)\n                             (:protocol-symbol var)\n                             (assoc :protocol true\n                                    :methods\n                                    (->> (get-in var [:protocol-info :methods])\n                                      (map (fn [[fname sigs]]\n                                             [fname {:doc (:doc\n                                                            (ana-api/resolve &env\n                                                              (symbol (str (:ns var)) (str fname))))\n                                                     :arglists (seq sigs)}]))\n                                      (into {})))))))))))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.7.228",
                                     :filename "src/main/clojure/cljs/repl.cljc",
                                     :lines [1149 1183]},
                            :examples [{:id "4d2768",
                                        :content "```clj\n(doc map)\n;; Prints:\n;;  -------------------------\n;;  cljs.core/map\n;;  [f coll]\n;;    Returns a lazy sequence consisting of the result of applying f to\n;;    the set of first items of each coll, followed by applying f to the\n;;    set of second items in each coll, until any one of the colls is\n;;    exhausted.  Any remaining items in other colls are ignored. Function\n;;    f should accept number-of-colls arguments. Returns a transducer when\n;;    no collection is provided.\n;;\n;;=> nil\n```"}],
                            :full-name "cljs.repl/doc",
                            :clj-symbol "clojure.repl/doc",
                            :docstring "Prints documentation for a var or special form given its name"},
           "clojure.set/rename-keys" {:ns "clojure.set",
                                      :name "rename-keys",
                                      :signature ["[map kmap]"],
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "clojure.set/rename-keys",
                                      :source {:code "(defn rename-keys\n  [map kmap]\n    (reduce\n     (fn [m [old new]]\n       (if (contains? map old)\n         (assoc m new (get map old))\n         m))\n     (apply dissoc map (keys kmap)) kmap))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/cljs/clojure/set.cljs",
                                               :lines [72 80]},
                                      :full-name "clojure.set/rename-keys",
                                      :clj-symbol "clojure.set/rename-keys",
                                      :docstring "Returns the map with the keys in kmap renamed to the vals in kmap"},
           "cljs.core/peek" {:description "Returns the first element of a list; same as `first`.\n\nReturns the last element of a vector, and much more efficient than using `last`.\n\nReturns nil if `coll` is empty.",
                             :ns "cljs.core",
                             :name "peek",
                             :signature ["[coll]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/first"
                                       "cljs.core/pop"
                                       "cljs.core/conj"],
                             :full-name-encode "cljs.core/peek",
                             :source {:code "(defn peek\n  [coll]\n  (when-not (nil? coll)\n    (-peek coll)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [1854 1859]},
                             :examples [{:id "4abc4c",
                                         :content "With vectors:\n\n```clj\n(peek [1 2 3])\n;;=> 3\n\n(peek [1 2])\n;;=> 2\n\n(peek [1])\n;;=> 1\n\n(peek [])\n;;=> nil\n```"}
                                        {:id "d50bd0",
                                         :content "With lists:\n\n```clj\n(peek '(1 2 3))\n;;=> 1\n\n(peek '(1 2))\n;;=> 1\n\n(peek '(1))\n;;=> 1\n\n(peek '())\n;;=> nil\n```"}],
                             :full-name "cljs.core/peek",
                             :clj-symbol "clojure.core/peek",
                             :docstring "For a list or queue, same as first, for a vector, same as, but much\nmore efficient than, last. If the collection is empty, returns nil."},
           "cljs.core/pr-str-with-opts" {:ns "cljs.core",
                                         :name "pr-str-with-opts",
                                         :signature ["[objs opts]"],
                                         :history [["+" "0.0-927"]],
                                         :type "function",
                                         :full-name-encode "cljs.core/pr-str-with-opts",
                                         :source {:code "(defn pr-str-with-opts\n  [objs opts]\n  (if (empty? objs)\n    \"\"\n    (str (pr-sb-with-opts objs opts))))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.7.228",
                                                  :filename "src/main/cljs/cljs/core.cljs",
                                                  :lines [8901 8907]},
                                         :full-name "cljs.core/pr-str-with-opts",
                                         :docstring "Prints a sequence of objects to a string, observing all the\noptions given in opts"},
           "cljs.core/IChunk" {:ns "cljs.core",
                               :name "IChunk",
                               :history [["+" "0.0-1424"]],
                               :type "protocol",
                               :full-name-encode "cljs.core/IChunk",
                               :source {:code "(defprotocol IChunk\n  \"Protocol for accessing the items of a chunk.\"\n  (-drop-first [coll]\n    \"Return a new chunk of coll with the first item removed.\"))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [708 711]},
                               :methods [{:name "-drop-first",
                                          :signature ["[coll]"],
                                          :docstring "Return a new chunk of coll with the first item removed."}],
                               :full-name "cljs.core/IChunk",
                               :clj-symbol "clojure.lang/IChunk",
                               :docstring "Protocol for accessing the items of a chunk."},
           "cljs.core/ITransientVector" {:ns "cljs.core",
                                         :name "ITransientVector",
                                         :history [["+" "0.0-1211"]],
                                         :type "protocol",
                                         :full-name-encode "cljs.core/ITransientVector",
                                         :source {:code "(defprotocol ITransientVector\n  \"Protocol for adding vector functionality to transient collections.\"\n  (^clj -assoc-n! [tcoll n val]\n    \"Returns tcoll with value val added at position n.\")\n  (^clj -pop! [tcoll]\n    \"Returns tcoll with the last item removed from it.\"))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.7.228",
                                                  :filename "src/main/cljs/cljs/core.cljs",
                                                  :lines [690 695]},
                                         :methods [{:name "-assoc-n!",
                                                    :signature ["[tcoll n val]"],
                                                    :docstring "Returns tcoll with value val added at position n."}
                                                   {:name "-pop!",
                                                    :signature ["[tcoll]"],
                                                    :docstring "Returns tcoll with the last item removed from it."}],
                                         :full-name "cljs.core/ITransientVector",
                                         :clj-symbol "clojure.lang/ITransientVector",
                                         :docstring "Protocol for adding vector functionality to transient collections."},
           "cljs.core/IPrintWithWriter" {:ns "cljs.core",
                                         :name "IPrintWithWriter",
                                         :history [["+" "0.0-1503"]],
                                         :type "protocol",
                                         :full-name-encode "cljs.core/IPrintWithWriter",
                                         :source {:code "(defprotocol IPrintWithWriter\n  \"The old IPrintable protocol's implementation consisted of building a giant\n   list of strings to concatenate.  This involved lots of concat calls,\n   intermediate vectors, and lazy-seqs, and was very slow in some older JS\n   engines.  IPrintWithWriter implements printing via the IWriter protocol, so it\n   be implemented efficiently in terms of e.g. a StringBuffer append.\"\n  (-pr-writer [o writer opts]))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.7.228",
                                                  :filename "src/main/cljs/cljs/core.cljs",
                                                  :lines [643 649]},
                                         :methods [{:name "-pr-writer",
                                                    :signature ["[o writer opts]"],
                                                    :docstring nil}],
                                         :full-name "cljs.core/IPrintWithWriter",
                                         :docstring "The old IPrintable protocol's implementation consisted of building a giant\n   list of strings to concatenate.  This involved lots of concat calls,\n   intermediate vectors, and lazy-seqs, and was very slow in some older JS\n   engines.  IPrintWithWriter implements printing via the IWriter protocol, so it\n   be implemented efficiently in terms of e.g. a StringBuffer append."},
           "cljs.core/test" {:ns "cljs.core",
                             :name "test",
                             :signature ["[v]"],
                             :history [["+" "0.0-2496"]],
                             :type "function",
                             :full-name-encode "cljs.core/test",
                             :source {:code "(defn test\n  [v]\n  (let [f (.-cljs$lang$test v)]\n    (if f\n      (do (f) :ok)\n      :no-test)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [9962 9969]},
                             :full-name "cljs.core/test",
                             :clj-symbol "clojure.core/test",
                             :docstring "test [v] finds fn at key :test in var metadata and calls it,\npresuming failure will throw exception"},
           "cljs.core/map?" {:description "Returns true if `x` is a map, false otherwise.",
                             :return-type boolean,
                             :ns "cljs.core",
                             :name "map?",
                             :signature ["[x]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/hash-map"
                                       "cljs.core/sorted-map"],
                             :full-name-encode "cljs.core/mapQMARK",
                             :source {:code "(defn ^boolean map?\n  [x]\n  (if (nil? x)\n    false\n    (satisfies? IMap x)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [1919 1924]},
                             :full-name "cljs.core/map?",
                             :clj-symbol "clojure.core/map?",
                             :docstring "Return true if x satisfies IMap"},
           "syntax/predicate" {:description "A naming convention for predicate functions (unenforced).\n\nA predicate function is one that returns `true` or `false`, and is presumably\npure (not having any side-effects on state).\n\nSome predicate functions which use this convention:\n\n- [doc:cljs.core/even?]\n- [doc:cljs.core/empty?]\n- [doc:cljs.core/contains?]\n- [doc:cljs.core/nil?]\n\nIt is sometimes used to name boolean values as well, not just predicate functions.",
                               :ns "syntax",
                               :name "predicate",
                               :history [["+" "0.0-927"]],
                               :type "convention",
                               :related ["syntax/impure"],
                               :full-name-encode "syntax/predicate",
                               :usage ["foo?"],
                               :examples [{:id "5a85c7",
                                           :content "Create a `divisible?` predicate:\n\n```clj\n(defn divisible? [n factor]\n  (zero? (mod n factor)))\n\n(divisible? 15 3)\n;;=> true\n\n(divisible? 15 2)\n;;=> false\n\n(filter #(divisible? 15 %) (range 15))\n;;=> (1 3 5)\n```"}],
                               :full-name "syntax/predicate",
                               :display "? predicate",
                               :clj-doc "http://clojure.org/cheatsheet"},
           "cljs.repl.node/node-eval" {:ns "cljs.repl.node",
                                       :name "node-eval",
                                       :signature ["[repl-env js]"],
                                       :history [["+" "0.0-2629"]],
                                       :type "function",
                                       :full-name-encode "cljs.repl.node/node-eval",
                                       :source {:code "(defn node-eval\n  [repl-env js]\n  (let [{:keys [in out]} @(:socket repl-env)]\n    ;; escape backslash for Node.js under Windows\n    (write out js)\n    (let [result (json/read-str\n                   (read-response in) :key-fn keyword)]\n      (condp = (:status result)\n        \"success\"\n        {:status :success\n         :value (:value result)}\n\n        \"exception\"\n        {:status :exception\n         :value (:value result)}))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/clojure/cljs/repl/node.clj",
                                                :lines [52 67]},
                                       :full-name "cljs.repl.node/node-eval",
                                       :docstring "Evaluate a JavaScript string in the Node REPL process."},
           "cljs.reader/StringPushbackReader" {:ns "cljs.reader",
                                               :name "StringPushbackReader",
                                               :type "type",
                                               :signature ["[s buffer idx]"],
                                               :source {:code "(deftype StringPushbackReader [s buffer ^:mutable idx]\n  PushbackReader\n  (read-char [reader]\n    (if (zero? (alength buffer))\n      (do\n        (set! idx (inc idx))\n        (aget s idx))\n      (.pop buffer)))\n  (unread [reader ch]\n    (.push buffer ch)))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.7.228",
                                                        :filename "src/main/cljs/cljs/reader.cljs",
                                                        :lines [18 27]},
                                               :full-name "cljs.reader/StringPushbackReader",
                                               :full-name-encode "cljs.reader/StringPushbackReader",
                                               :history [["+"
                                                          "0.0-927"]]},
           "cljs.pprint/code-dispatch" {:ns "cljs.pprint",
                                        :name "code-dispatch",
                                        :history [["+" "0.0-3255"]],
                                        :type "multimethod",
                                        :full-name-encode "cljs.pprint/code-dispatch",
                                        :source {:code "(defmulti\n  code-dispatch\n  \"The pretty print dispatch function for pretty printing Clojure code.\"\n  {:added \"1.2\" :arglists '[[object]]}\n  type-dispatcher)",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/cljs/cljs/pprint.cljs",
                                                 :lines [3196 3200]},
                                        :full-name "cljs.pprint/code-dispatch",
                                        :clj-symbol "clojure.pprint/code-dispatch",
                                        :docstring "The pretty print dispatch function for pretty printing Clojure code."},
           "cljs.core/PersistentTreeMap" {:ns "cljs.core",
                                          :name "PersistentTreeMap",
                                          :signature ["[comp tree cnt meta __hash]"],
                                          :history [["+" "0.0-1211"]],
                                          :type "type",
                                          :full-name-encode "cljs.core/PersistentTreeMap",
                                          :source {:code "(deftype PersistentTreeMap [comp tree cnt meta ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  ;; EXPERIMENTAL: subject to change\n  (keys [coll]\n    (es6-iterator (keys coll)))\n  (entries [coll]\n    (es6-entries-iterator (seq coll)))\n  (values [coll]\n    (es6-iterator (vals coll)))\n  (has [coll k]\n    (contains? coll k))\n  (get [coll k not-found]\n    (-lookup coll k not-found))\n  (forEach [coll f]\n    (doseq [[k v] coll]\n      (f v k)))\n\n  (entry-at [coll k]\n    (loop [t tree]\n      (if-not (nil? t)\n        (let [c (comp k (.-key t))]\n          (cond (zero? c) t\n                (neg? c)  (recur (.-left t))\n                :else     (recur (.-right t)))))))\n\n  ICloneable\n  (-clone [_] (PersistentTreeMap. comp tree cnt meta __hash))\n\n  IWithMeta\n  (-with-meta [coll meta] (PersistentTreeMap. comp tree cnt meta __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (loop [ret coll es (seq entry)]\n        (if (nil? es)\n          ret\n          (let [e (first es)]\n            (if (vector? e)\n              (recur (-assoc ret (-nth e 0) (-nth e 1))\n                     (next es))\n              (throw (js/Error. \"conj on a map takes map entries or seqables of map entries\"))))))))\n\n  IEmptyableCollection\n  (-empty [coll] (PersistentTreeMap. comp nil 0 meta 0))\n\n  IEquiv\n  (-equiv [coll other] (equiv-map coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-unordered-coll __hash))\n\n  ICounted\n  (-count [coll] cnt)\n\n  IKVReduce\n  (-kv-reduce [coll f init]\n    (if-not (nil? tree)\n      (tree-map-kv-reduce tree f init)\n      init))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found))\n\n  ISeqable\n  (-seq [coll]\n    (if (pos? cnt)\n      (create-tree-map-seq tree true cnt)))\n\n  IReversible\n  (-rseq [coll]\n    (if (pos? cnt)\n      (create-tree-map-seq tree false cnt)))\n\n  ILookup\n  (-lookup [coll k]\n    (-lookup coll k nil))\n\n  (-lookup [coll k not-found]\n    (let [n (.entry-at coll k)]\n      (if-not (nil? n)\n        (.-val n)\n        not-found)))\n\n  IAssociative\n  (-assoc [coll k v]\n    (let [found (array nil)\n          t     (tree-map-add comp tree k v found)]\n      (if (nil? t)\n        (let [found-node (nth found 0)]\n          (if (= v (.-val found-node))\n            coll\n            (PersistentTreeMap. comp (tree-map-replace comp tree k v) cnt meta nil)))\n        (PersistentTreeMap. comp (.blacken t) (inc cnt) meta nil))))\n\n  (-contains-key? [coll k]\n    (not (nil? (.entry-at coll k))))\n\n  IMap\n  (-dissoc [coll k]\n    (let [found (array nil)\n          t     (tree-map-remove comp tree k found)]\n      (if (nil? t)\n        (if (nil? (nth found 0))\n          coll\n          (PersistentTreeMap. comp nil 0 meta nil))\n        (PersistentTreeMap. comp (.blacken t) (dec cnt) meta nil))))\n\n  ISorted\n  (-sorted-seq [coll ascending?]\n    (if (pos? cnt)\n      (create-tree-map-seq tree ascending? cnt)))\n\n  (-sorted-seq-from [coll k ascending?]\n    (if (pos? cnt)\n      (loop [stack nil t tree]\n        (if-not (nil? t)\n          (let [c (comp k (.-key t))]\n            (cond\n              (zero? c)  (PersistentTreeMapSeq. nil (conj stack t) ascending? -1 nil)\n              ascending? (if (neg? c)\n                           (recur (conj stack t) (.-left t))\n                           (recur stack          (.-right t)))\n              :else      (if (pos? c)\n                           (recur (conj stack t) (.-right t))\n                           (recur stack          (.-left t)))))\n          (when-not (nil? stack)\n            (PersistentTreeMapSeq. nil stack ascending? -1 nil))))))\n\n  (-entry-key [coll entry] (key entry))\n\n  (-comparator [coll] comp))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/cljs/cljs/core.cljs",
                                                   :lines [7588 7732]},
                                          :full-name "cljs.core/PersistentTreeMap",
                                          :clj-symbol "clojure.lang/PersistentTreeMap"},
           "cljs.core/HashMap.fromArrays" {:ns "cljs.core",
                                           :name "HashMap.fromArrays",
                                           :signature ["[ks vs]"],
                                           :history [["+" "0.0-927"]
                                                     ["-" "0.0-1798"]],
                                           :parent-type "HashMap",
                                           :type "function",
                                           :full-name-encode "cljs.core/HashMapDOTfromArrays",
                                           :source {:code "(set! cljs.core.HashMap/fromArrays (fn [ks vs]\n  (let [len (alength ks)]\n    (loop [i 0, out cljs.core.HashMap/EMPTY]\n      (if (< i len)\n        (recur (inc i) (assoc out (aget ks i) (aget vs i)))\n        out)))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1586",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [3832 3837]},
                                           :full-name "cljs.core/HashMap.fromArrays",
                                           :removed {:in "0.0-1798",
                                                     :last-seen "0.0-1586"}},
           "cljs.core/deref" {:description "Returns the current value of atom `x`.\n\nThe `@` reader macro is often used instead of `deref`. `@foo` is the same thing\nas `(deref foo)`.",
                              :ns "cljs.core",
                              :name "deref",
                              :signature ["[x]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/atom"],
                              :full-name-encode "cljs.core/deref",
                              :source {:code "(defn deref\n  [o]\n  (-deref o))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [1294 1300]},
                              :full-name "cljs.core/deref",
                              :clj-symbol "clojure.core/deref",
                              :docstring "Also reader macro: @var/@atom/@delay. Returns the\nmost-recently-committed value of ref. When applied to a var\nor atom, returns its current state. When applied to a delay, forces\nit if not already forced. See also - realized?."},
           "cljs.core/reductions" {:description "Returns a lazy sequence of the intermediate values of the reduction (as per\n`reduce`) of `coll` by `f`, starting with `init`.",
                                   :ns "cljs.core",
                                   :name "reductions",
                                   :signature ["[f coll]"
                                               "[f init coll]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/reduce"],
                                   :full-name-encode "cljs.core/reductions",
                                   :source {:code "(defn reductions\n  ([f coll]\n     (lazy-seq\n      (if-let [s (seq coll)]\n        (reductions f (first s) (rest s))\n        (list (f)))))\n  ([f init coll]\n     (cons init\n           (lazy-seq\n            (when-let [s (seq coll)]\n              (reductions f (f init (first s)) (rest s)))))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [8614 8626]},
                                   :full-name "cljs.core/reductions",
                                   :clj-symbol "clojure.core/reductions",
                                   :docstring "Returns a lazy seq of the intermediate values of the reduction (as\nper reduce) of coll by f, starting with init."},
           "cljs.core/false?" {:description "Returns true if `x` is the value false, false otherwise.",
                               :return-type boolean,
                               :ns "cljs.core",
                               :name "false?",
                               :signature ["[x]"],
                               :history [["+" "0.0-927"]],
                               :type "function/macro",
                               :related ["cljs.core/true?"
                                         "cljs.core/not"],
                               :full-name-encode "cljs.core/falseQMARK",
                               :source {:code "(defn ^boolean false?\n  [x] (cljs.core/false? x))",
                                        :title "Function code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [1982 1984]},
                               :extra-sources [{:code "(core/defmacro false? [x]\n  (bool-expr (core/list 'js* \"~{} === false\" x)))",
                                                :title "Macro code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/clojure/cljs/core.cljc",
                                                :lines [901 902]}],
                               :full-name "cljs.core/false?",
                               :clj-symbol "clojure.core/false?",
                               :docstring "Returns true if x is the value false, false otherwise."},
           "cljs.core/bit-flip" {:description "Flip bit at index `n`.  Same as `x ^ (1 << y)` in JavaScript.",
                                 :ns "cljs.core",
                                 :name "bit-flip",
                                 :signature ["[x n]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function/macro",
                                 :related ["cljs.core/bit-set"
                                           "cljs.core/bit-clear"],
                                 :full-name-encode "cljs.core/bit-flip",
                                 :source {:code "(defn bit-flip\n  [x n]\n  (cljs.core/bit-flip x n))",
                                          :title "Function code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [2537 2540]},
                                 :extra-sources [{:code "(core/defmacro ^::ana/numeric bit-flip [x n]\n  (core/list 'js* \"(~{} ^ (1 << ~{}))\" x n))",
                                                  :title "Macro code",
                                                  :repo "clojurescript",
                                                  :tag "r1.7.228",
                                                  :filename "src/main/clojure/cljs/core.cljc",
                                                  :lines [1122 1123]}],
                                 :examples [{:id "5d7ee0",
                                             :content "Bits can be entered using radix notation:\n\n```clj\n(bit-flip 2r1111 2)\n;;=> 11\n;; 11 = 2r1011\n```\n\nSame numbers in decimal:\n\n```clj\n(bit-flip 15 2)\n;;=> 11\n```"}],
                                 :full-name "cljs.core/bit-flip",
                                 :clj-symbol "clojure.core/bit-flip",
                                 :docstring "Flip bit at index n"},
           "cljs.test/deftest" {:ns "cljs.test",
                                :name "deftest",
                                :signature ["[name & body]"],
                                :history [["+" "0.0-2496"]],
                                :type "macro",
                                :full-name-encode "cljs.test/deftest",
                                :source {:code "(defmacro deftest\n  [name & body]\n  (when ana/*load-tests*\n    `(do\n       (def ~(vary-meta name assoc :test `(fn [] ~@body))\n         (fn [] (cljs.test/test-var (.-cljs$lang$var ~name))))\n       (set! (.-cljs$lang$var ~name) (var ~name)))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/test.clj",
                                         :lines [205 221]},
                                :full-name "cljs.test/deftest",
                                :clj-symbol "clojure.test/deftest",
                                :docstring "Defines a test function with no arguments.  Test functions may call\nother tests, so tests may be composed.  If you compose tests, you\nshould also define a function named test-ns-hook; run-tests will\ncall test-ns-hook instead of testing all vars.\n\nNote: Actually, the test body goes in the :test metadata on the var,\nand the real function (the value of the var) calls test-var on\nitself.\n\nWhen cljs.analyzer/*load-tests* is false, deftest is ignored."},
           "cljs.core/ISet" {:ns "cljs.core",
                             :name "ISet",
                             :history [["+" "0.0-927"]],
                             :type "protocol",
                             :full-name-encode "cljs.core/ISet",
                             :source {:code "(defprotocol ISet\n  \"Protocol for adding set functionality to a collection.\"\n  (^clj -disjoin [coll v]\n    \"Returns a new collection of coll that does not contain v.\"))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [537 540]},
                             :methods [{:name "-disjoin",
                                        :signature ["[coll v]"],
                                        :docstring "Returns a new collection of coll that does not contain v."}],
                             :full-name "cljs.core/ISet",
                             :clj-symbol "clojure.lang/IPersistentSet",
                             :docstring "Protocol for adding set functionality to a collection."},
           "cljs.core/StringIter" {:ns "cljs.core",
                                   :name "StringIter",
                                   :type "type",
                                   :signature ["[s i]"],
                                   :source {:code "(deftype StringIter [s ^:mutable i]\n  Object\n  (hasNext [_] (< i (alength s)))\n  (next [_]\n    (let [ret (.charAt s i)]\n      (set! i (inc i))\n      ret))\n  (remove [_] (js/Error. \"Unsupported operation\")))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [3528 3535]},
                                   :full-name "cljs.core/StringIter",
                                   :full-name-encode "cljs.core/StringIter",
                                   :history [["+" "0.0-2301"]]},
           "cljs.core/LazySeq" {:ns "cljs.core",
                                :name "LazySeq",
                                :signature ["[meta fn s __hash]"],
                                :history [["+" "0.0-927"]],
                                :type "type",
                                :full-name-encode "cljs.core/LazySeq",
                                :source {:code "(deftype LazySeq [meta ^:mutable fn ^:mutable s ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (sval [coll]\n    (if (nil? fn)\n      s\n      (do\n        (set! s (fn))\n        (set! fn nil)\n        s)))\n\n  IPending\n  (-realized? [x]\n    (not fn))\n\n  IWithMeta\n  (-with-meta [coll meta] (LazySeq. meta fn s __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll]\n    (-seq coll)\n    (when-not (nil? s)\n      (first s)))\n  (-rest [coll]\n    (-seq coll)\n    (if-not (nil? s)\n      (rest s)\n      ()))\n\n  INext\n  (-next [coll]\n    (-seq coll)\n    (when-not (nil? s)\n      (next s)))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY List) meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (.sval coll)\n    (when-not (nil? s)\n      (loop [ls s]\n        (if (instance? LazySeq ls)\n          (recur (.sval ls))\n          (do (set! s ls)\n            (seq s))))))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [3003 3069]},
                                :full-name "cljs.core/LazySeq",
                                :clj-symbol "clojure.lang/LazySeq"},
           "cljs.core/pop!" {:ns "cljs.core",
                             :name "pop!",
                             :signature ["[tcoll]"],
                             :history [["+" "0.0-1211"]],
                             :type "function",
                             :full-name-encode "cljs.core/popBANG",
                             :source {:code "(defn pop!\n  [tcoll]\n  (-pop! tcoll))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [3422 3426]},
                             :full-name "cljs.core/pop!",
                             :clj-symbol "clojure.core/pop!",
                             :docstring "Removes the last item from a transient vector. If\nthe collection is empty, throws an exception. Returns coll"},
           "cljs.analyzer.api/with-state" {:ns "cljs.analyzer.api",
                                           :name "with-state",
                                           :signature ["[state body]"],
                                           :history [["+" "1.7.10"]],
                                           :type "macro",
                                           :full-name-encode "cljs.analyzer.api/with-state",
                                           :source {:code "(defmacro with-state\n  [state body]\n  `(env/with-compiler-env ~state\n     ~@body))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.7.228",
                                                    :filename "src/main/clojure/cljs/analyzer/api.clj",
                                                    :lines [25 29]},
                                           :full-name "cljs.analyzer.api/with-state",
                                           :docstring "Run the body with the given compilation state Atom<Map>."},
           "cljs.reader/parse-timestamp" {:ns "cljs.reader",
                                          :name "parse-timestamp",
                                          :type "function",
                                          :signature ["[ts]"],
                                          :source {:code "(defn parse-timestamp\n  [ts]\n  (if-let [[years months days hours minutes seconds ms offset]\n           (parse-and-validate-timestamp ts)]\n    (js/Date.\n     (- (.UTC js/Date years (dec months) days hours minutes seconds ms)\n        (* offset 60 1000)))\n    (reader-error nil (str \"Unrecognized date/time syntax: \" ts))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/cljs/cljs/reader.cljs",
                                                   :lines [535 542]},
                                          :full-name "cljs.reader/parse-timestamp",
                                          :full-name-encode "cljs.reader/parse-timestamp",
                                          :history [["+" "0.0-1424"]]},
           "cljs.build.api/ns->location" {:ns "cljs.build.api",
                                          :name "ns->location",
                                          :signature ["[ns]"
                                                      "[ns compiler-env]"],
                                          :history [["+" "0.0-3291"]],
                                          :type "function",
                                          :full-name-encode "cljs.build.api/ns-GTlocation",
                                          :source {:code "(defn ns->location\n  ([ns]\n   (ns->location ns\n     (if-not (nil? env/*compiler*)\n       env/*compiler*\n       (env/default-compiler-env))))\n  ([ns compiler-env]\n   (closure/source-for-namespace ns compiler-env)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/clojure/cljs/build/api.clj",
                                                   :lines [130 141]},
                                          :full-name "cljs.build.api/ns->location",
                                          :docstring "Given a namespace and compilation environment return the relative path and\nuri of the corresponding source regardless of the source language extension:\n.cljs, .cljc, .js. Returns a map containing :relative-path a string, and\n:uri a URL."},
           "cljs.repl/mapped-stacktrace" {:ns "cljs.repl",
                                          :name "mapped-stacktrace",
                                          :signature ["[stacktrace]"
                                                      "[stacktrace opts]"],
                                          :history [["+" "0.0-2843"]],
                                          :type "function",
                                          :full-name-encode "cljs.repl/mapped-stacktrace",
                                          :source {:code "(defn mapped-stacktrace\n  ([stacktrace] (mapped-stacktrace stacktrace nil))\n  ([stacktrace opts]\n   (vec\n     (let [mapped-frames (map (memoize #(mapped-frame % opts)) stacktrace)]\n       ;; take each non-nil :call and optionally merge it into :function one-level up\n       ;; to avoid replacing with local symbols, we only replace munged name if we can munge call symbol back to it\n       (map #(merge-with (fn [munged-fn-name unmunged-call-name]\n                           (if (= munged-fn-name (string/replace (cljs.compiler/munge unmunged-call-name) \".\" \"$\"))\n                             unmunged-call-name\n                             munged-fn-name)) %1 %2)\n         (map #(dissoc % :call) mapped-frames)\n         (concat (rest (map #(if (:call %)\n                              (hash-map :function (:call %))\n                              {})\n                         mapped-frames)) [{}]))))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/clojure/cljs/repl.cljc",
                                                   :lines [313 341]},
                                          :full-name "cljs.repl/mapped-stacktrace",
                                          :docstring "Given a vector representing the canonicalized JavaScript stacktrace\nreturn the ClojureScript stacktrace. The canonical stacktrace must be\nin the form:\n\n [{:file <string>\n   :function <string>\n   :line <integer>\n   :column <integer>}*]\n\n:file must be a URL path (without protocol) relative to :output-dir or a\nidentifier delimited by angle brackets. The returned mapped stacktrace will\nalso contain :url entries to the original sources if it can be determined\nfrom the classpath."},
           "cljs.repl.rhino/IEval" {:ns "cljs.repl.rhino",
                                    :name "IEval",
                                    :type "protocol",
                                    :full-name-encode "cljs.repl.rhino/IEval",
                                    :source {:code "(defprotocol IEval\n  (-eval [this env filename line]))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/clojure/cljs/repl/rhino.clj",
                                             :lines [35 36]},
                                    :methods [{:name "-eval",
                                               :signature ["[this env filename line]"],
                                               :docstring nil}],
                                    :full-name "cljs.repl.rhino/IEval",
                                    :history [["+" "0.0-927"]]},
           "cljs.core/chunk-first" {:ns "cljs.core",
                                    :name "chunk-first",
                                    :type "function",
                                    :signature ["[s]"],
                                    :source {:code "(defn chunk-first [s]\n  (-chunked-first s))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [3199 3200]},
                                    :full-name "cljs.core/chunk-first",
                                    :full-name-encode "cljs.core/chunk-first",
                                    :history [["+" "0.0-1424"]]},
           "cljs.core/ChunkedSeq" {:ns "cljs.core",
                                   :name "ChunkedSeq",
                                   :signature ["[vec node i off meta __hash]"],
                                   :history [["+" "0.0-1424"]],
                                   :type "type",
                                   :full-name-encode "cljs.core/ChunkedSeq",
                                   :source {:code "(deftype ChunkedSeq [vec node i off meta ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  IWithMeta\n  (-with-meta [coll m]\n    (chunked-seq vec node i off m))\n  IMeta\n  (-meta [coll] meta)\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ASeq\n  ISeq\n  (-first [coll]\n    (aget node off))\n  (-rest [coll]\n    (if (< (inc off) (alength node))\n      (let [s (chunked-seq vec node i (inc off))]\n        (if (nil? s)\n          ()\n          s))\n      (-chunked-rest coll)))\n\n  INext\n  (-next [coll]\n    (if (< (inc off) (alength node))\n      (let [s (chunked-seq vec node i (inc off))]\n        (if (nil? s)\n          nil\n          s))\n      (-chunked-next coll)))\n\n  ICollection\n  (-conj [coll o]\n    (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll]\n    (with-meta (.-EMPTY PersistentVector) meta))\n\n  IChunkedSeq\n  (-chunked-first [coll]\n    (array-chunk node off))\n  (-chunked-rest [coll]\n    (let [end (+ i (alength node))]\n      (if (< end (-count vec))\n        (chunked-seq vec (unchecked-array-for vec end) end 0)\n        ())))\n\n  IChunkedNext\n  (-chunked-next [coll]\n    (let [end (+ i (alength node))]\n      (when (< end (-count vec))\n        (chunked-seq vec (unchecked-array-for vec end) end 0))))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  IReduce\n  (-reduce [coll f]\n    (ci-reduce (subvec vec (+ i off) (count vec)) f))\n\n  (-reduce [coll f start]\n    (ci-reduce (subvec vec (+ i off) (count vec)) f start)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [4963 5035]},
                                   :full-name "cljs.core/ChunkedSeq",
                                   :clj-symbol "clojure.lang/ChunkedSeq"},
           "cljs.test/testing" {:ns "cljs.test",
                                :name "testing",
                                :signature ["[string & body]"],
                                :history [["+" "0.0-2496"]],
                                :type "macro",
                                :full-name-encode "cljs.test/testing",
                                :source {:code "(defmacro testing\n  ([string & body]\n   `(do\n      (cljs.test/update-current-env! [:testing-contexts] conj ~string)\n      (try\n        ~@body\n        (finally\n          (cljs.test/update-current-env! [:testing-contexts] rest))))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/test.clj",
                                         :lines [191 200]},
                                :full-name "cljs.test/testing",
                                :clj-symbol "clojure.test/testing",
                                :docstring "Adds a new string to the list of testing contexts.  May be nested,\nbut must occur inside a test function (deftest)."},
           "cljs.analyzer.api/resolve" {:ns "cljs.analyzer.api",
                                        :name "resolve",
                                        :signature ["[env sym]"],
                                        :history [["+" "0.0-2496"]],
                                        :type "function",
                                        :full-name-encode "cljs.analyzer.api/resolve",
                                        :source {:code "(defn resolve\n  [env sym]\n  {:pre [(map? env) (symbol? sym)]}\n  (try\n    (ana/resolve-var env sym\n      (ana/confirm-var-exists-throw))\n    (catch Exception e\n      (ana/resolve-macro-var env sym))))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/clojure/cljs/analyzer/api.clj",
                                                 :lines [141 150]},
                                        :full-name "cljs.analyzer.api/resolve",
                                        :clj-symbol "clojure.core/resolve",
                                        :docstring "Given an analysis environment resolve a var. Analogous to\nclojure.core/resolve"},
           "cljs.repl.browser/start-server" {:moved "cljs.repl.server/start",
                                             :ns "cljs.repl.browser",
                                             :name "start-server",
                                             :signature ["[opts]"],
                                             :history [["+" "0.0-927"]
                                                       ["-"
                                                        "0.0-1503"]],
                                             :type "function",
                                             :full-name-encode "cljs.repl.browser/start-server",
                                             :source {:code "(defn start-server\n  [opts]\n  (let [ss (ServerSocket. (:port opts))]\n    (future (server-loop opts ss))\n    (swap! server-state (fn [old] (assoc old :socket ss :port (:port opts))))))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1450",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [265 270]},
                                             :full-name "cljs.repl.browser/start-server",
                                             :docstring "Start the server on the specified port.",
                                             :removed {:in "0.0-1503",
                                                       :last-seen "0.0-1450"}},
           "cljs.core/*2" {:description "Only usable from a REPL.\n\nHolds the result of the second to last expression.",
                           :ns "cljs.core",
                           :name "*2",
                           :history [["+" "0.0-927"]],
                           :type "var",
                           :related ["cljs.core/*1"
                                     "cljs.core/*3"
                                     "cljs.core/*e"],
                           :full-name-encode "cljs.core/STAR2",
                           :source {:code "(def\n  ^{:doc \"bound in a repl thread to the second most recent value printed\"}\n  *2)",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r1.7.228",
                                    :filename "src/main/cljs/cljs/core.cljs",
                                    :lines [160 162]},
                           :examples [{:id "208d41",
                                       :content "```clj\n(+ 1 2 3 4)\n;;=> 10\n\n(+ 4 8)\n;;=> 12\n\n*2\n;;=> 10\n\n(inc *2)\n;;=> 11\n```\n\nNote that a standalone evaluation of `*1`, `*2`, `*3`, or `*e` is not a part of\nremembered history:\n\n```clj\n:first\n;;=> :first\n\n:second\n;;=> :second\n\n:third\n;;=> :third\n\n*3\n;;=> :first\n\n*2\n;;=> :second\n\n*1\n;;=> :third\n```"}],
                           :full-name "cljs.core/*2",
                           :clj-symbol "clojure.core/*2",
                           :docstring "bound in a repl thread to the second most recent value printed"},
           "cljs.repl.server/send-and-close" {:ns "cljs.repl.server",
                                              :name "send-and-close",
                                              :signature ["[conn status form]"
                                                          "[conn status form content-type]"
                                                          "[conn status form content-type encoding]"],
                                              :history [["+"
                                                         "0.0-1503"]],
                                              :type "function",
                                              :full-name-encode "cljs.repl.server/send-and-close",
                                              :source {:code "(defn send-and-close\n  ([conn status form]\n    (send-and-close conn status form \"text/html\"))\n  ([conn status form content-type]\n    (send-and-close conn status form content-type \"UTF-8\"))\n  ([conn status form content-type encoding]\n    (let [byte-form (.getBytes form encoding)\n          content-length (count byte-form)\n          headers (map #(.getBytes (str % \"\\r\\n\"))\n                    [(status-line status)\n                     \"Server: ClojureScript REPL\"\n                     (str \"Content-Type: \"\n                       content-type\n                       \"; charset=\" encoding)\n                     (str \"Content-Length: \" content-length)\n                     \"\"])]\n      (with-open [os (.getOutputStream conn)]\n        (doseq [header headers]\n          (.write os header 0 (count header)))\n        (.write os byte-form 0 content-length)\n        (.flush os)\n        (.close conn)))))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.7.228",
                                                       :filename "src/main/clojure/cljs/repl/server.clj",
                                                       :lines [106
                                                               129]},
                                              :full-name "cljs.repl.server/send-and-close",
                                              :docstring "Use the passed connection to send a form to the browser. Send a\nproper HTTP response."},
           "clojure.browser.event/total-listener-count" {:ns "clojure.browser.event",
                                                         :name "total-listener-count",
                                                         :type "function",
                                                         :signature ["[]"],
                                                         :source {:code "(defn total-listener-count []\n  (events/getTotalListenerCount))",
                                                                  :title "Source code",
                                                                  :repo "clojurescript",
                                                                  :tag "r1.7.228",
                                                                  :filename "src/main/cljs/clojure/browser/event.cljs",
                                                                  :lines [87
                                                                          88]},
                                                         :full-name "clojure.browser.event/total-listener-count",
                                                         :full-name-encode "clojure.browser.event/total-listener-count",
                                                         :history [["+"
                                                                    "0.0-927"]]},
           "cljs.core/goog-define" {:ns "cljs.core",
                                    :name "goog-define",
                                    :signature ["[sym default]"],
                                    :history [["+" "1.7.48"]],
                                    :type "macro",
                                    :full-name-encode "cljs.core/goog-define",
                                    :source {:code "(core/defmacro goog-define\n  [sym default]\n  (assert-args goog-define\n   (core/or (core/string? default)\n            (core/number? default)\n            (core/true? default)\n            (core/false? default)) \"a string, number or boolean as default value\")\n  (core/let [defname (comp/munge (core/str *ns* \"/\" sym))\n             type    (core/cond\n                       (core/string? default) \"string\"\n                       (core/number? default) \"number\"\n                       (core/or (core/true? default) (core/false? default)) \"boolean\")]\n    `(do\n       (declare ~(symbol sym))\n       (~'js* ~(core/str \"/** @define {\" type \"} */\"))\n       (goog/define ~defname ~default))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/clojure/cljs/core.cljc",
                                             :lines [690 718]},
                                    :full-name "cljs.core/goog-define",
                                    :docstring "Defines a var using `goog.define`. Passed default value must be\nstring, number or boolean.\n\nDefault value can be overridden at compile time using the\ncompiler option `:closure-defines`.\n\nExample:\n  (ns your-app.core)\n  (goog-define DEBUG! false)\n  ;; can be overridden with\n  :closure-defines {\"your_app.core.DEBUG_BANG_\" true}\n  or\n  :closure-defines {'your-app.core/DEBUG! true}"},
           "cljs.core/MultiStepper" {:ns "cljs.core",
                                     :name "MultiStepper",
                                     :type "type",
                                     :signature ["[xform iters nexts]"],
                                     :source {:code "(deftype MultiStepper [xform iters nexts]\n  Object\n  (hasNext [_]\n    (loop [iters (seq iters)]\n      (if-not (nil? iters)\n        (let [iter (first iters)]\n          (if-not (.hasNext iter)\n            false\n            (recur (next iters))))\n        true)))\n  (next [_]\n    (dotimes [i (alength iters)]\n      (aset nexts i (.next (aget iters i))))\n    (prim-seq nexts 0))\n  (step [this lt]\n    (loop []\n      (if (and (not (nil? (.-stepper lt)))\n               (.hasNext this))\n        (if (reduced? (apply xform (cons lt (.next this))))\n          (when-not (nil? (.-rest lt))\n            (set! (.. lt -rest -stepper) nil))\n          (recur))))\n    (when-not (nil? (.-stepper lt))\n      (xform lt))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/cljs/cljs/core.cljs",
                                              :lines [3619 3642]},
                                     :full-name "cljs.core/MultiStepper",
                                     :full-name-encode "cljs.core/MultiStepper",
                                     :history [["+" "0.0-2301"]]},
           "cljs.core/alter-meta!" {:description "Alter the metadata of `data` to be `(apply f its-current-meta args)`.\n\nMetadata of vars cannot be altered since they are statically determined at compile-time.",
                                    :ns "cljs.core",
                                    :name "alter-meta!",
                                    :signature ["[data f & args]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :related ["cljs.core/with-meta"
                                              "cljs.core/vary-meta"],
                                    :full-name-encode "cljs.core/alter-metaBANG",
                                    :source {:code "(defn alter-meta!\n  [iref f & args]\n  (set! (.-meta iref) (apply f (.-meta iref) args)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [9127 9134]},
                                    :examples [{:id "8378a0",
                                                :content "Metadata of symbols and collections can be altered:\n\n```clj\n(def a ^:foo [1 2 3])\n(meta a)\n;;=> {:foo true}\n\n(alter-meta! a assoc :bar true)\n(meta a)\n;;=> {:foo true, :bar true}\n```\n\nMetadata of vars cannot be altered:\n\n```clj\n(def a [1 2 3])\n(meta #'a)\n;;=> {:arglists (), :test nil, :name a, :column 1, :line 1, :file \"<cljs repl>\", :doc nil, :ns cljs.user}\n\n(alter-meta! #'a assoc :bar true)\n(:bar (meta #'a))\n;;=> nil\n```"}],
                                    :full-name "cljs.core/alter-meta!",
                                    :clj-symbol "clojure.core/alter-meta!",
                                    :docstring "Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\n\n(apply f its-current-meta args)\n\nf must be free of side-effects"},
           "clojure.browser.dom/click-element" {:ns "clojure.browser.dom",
                                                :name "click-element",
                                                :type "function",
                                                :signature ["[e]"],
                                                :source {:code "(defn click-element\n  [e]\n  (.click (ensure-element e) ()))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1.7.228",
                                                         :filename "src/main/cljs/clojure/browser/dom.cljs",
                                                         :lines [147
                                                                 149]},
                                                :full-name "clojure.browser.dom/click-element",
                                                :full-name-encode "clojure.browser.dom/click-element",
                                                :history [["+"
                                                           "0.0-927"]]},
           "cljs.core/*assert*" {:ns "cljs.core",
                                 :name "*assert*",
                                 :type "dynamic var",
                                 :source {:code "(def\n  ^{:dynamic true}\n  *assert* true)",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [39 41]},
                                 :full-name "cljs.core/*assert*",
                                 :full-name-encode "cljs.core/STARassertSTAR",
                                 :history [["+" "1.7.10"]]},
           "cljs.core/seq-iter" {:ns "cljs.core",
                                 :name "seq-iter",
                                 :type "function",
                                 :signature ["[coll]"],
                                 :source {:code "(defn seq-iter [coll]\n  (SeqIter. INIT coll))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [3573 3574]},
                                 :full-name "cljs.core/seq-iter",
                                 :full-name-encode "cljs.core/seq-iter",
                                 :history [["+" "0.0-2301"]]},
           "clojure.string/includes?" {:return-type boolean,
                                       :ns "clojure.string",
                                       :name "includes?",
                                       :signature ["[s substr]"],
                                       :history [["+" "1.7.145"]],
                                       :type "function",
                                       :full-name-encode "clojure.string/includesQMARK",
                                       :source {:code "(defn ^boolean includes?\n  [s substr]\n  (gstring/contains s substr))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/clojure/string.cljs",
                                                :lines [255 258]},
                                       :full-name "clojure.string/includes?",
                                       :docstring "True if s includes substr."},
           "cljs.core/unchecked-remainder-int" {:ns "cljs.core",
                                                :name "unchecked-remainder-int",
                                                :signature ["[x n]"],
                                                :history [["+"
                                                           "0.0-1798"]],
                                                :type "function/macro",
                                                :full-name-encode "cljs.core/unchecked-remainder-int",
                                                :source {:code "(defn unchecked-remainder-int [x n]\n  (cljs.core/unchecked-remainder-int x n))",
                                                         :title "Function code",
                                                         :repo "clojurescript",
                                                         :tag "r1.7.228",
                                                         :filename "src/main/cljs/cljs/core.cljs",
                                                         :lines [2435
                                                                 2436]},
                                                :extra-sources [{:code "(core/defmacro ^::ana/numeric unchecked-remainder-int\n  ([x n] `(mod ~x ~n)))",
                                                                 :title "Macro code",
                                                                 :repo "clojurescript",
                                                                 :tag "r1.7.228",
                                                                 :filename "src/main/clojure/cljs/core.cljc",
                                                                 :lines [1007
                                                                         1008]}],
                                                :full-name "cljs.core/unchecked-remainder-int",
                                                :clj-symbol "clojure.core/unchecked-remainder-int"},
           "cljs.core/bit-shift-right-zero-fill" {:ns "cljs.core",
                                                  :name "bit-shift-right-zero-fill",
                                                  :signature ["[x n]"],
                                                  :history [["+"
                                                             "0.0-1211"]],
                                                  :type "function/macro",
                                                  :full-name-encode "cljs.core/bit-shift-right-zero-fill",
                                                  :source {:code "(defn bit-shift-right-zero-fill\n  [x n] (cljs.core/bit-shift-right-zero-fill x n))",
                                                           :title "Function code",
                                                           :repo "clojurescript",
                                                           :tag "r1.7.228",
                                                           :filename "src/main/cljs/cljs/core.cljs",
                                                           :lines [2564
                                                                   2566]},
                                                  :extra-sources [{:code "(core/defmacro ^::ana/numeric bit-shift-right-zero-fill [x n]\n  (core/list 'js* \"(~{} >>> ~{})\" x n))",
                                                                   :title "Macro code",
                                                                   :repo "clojurescript",
                                                                   :tag "r1.7.228",
                                                                   :filename "src/main/clojure/cljs/core.cljc",
                                                                   :lines [1134
                                                                           1135]}],
                                                  :full-name "cljs.core/bit-shift-right-zero-fill",
                                                  :docstring "DEPRECATED: Bitwise shift right with zero fill"},
           "cljs.repl.rhino/repl-env*" {:ns "cljs.repl.rhino",
                                        :name "repl-env*",
                                        :type "function",
                                        :signature ["[opts]"],
                                        :source {:code "(defn repl-env*\n  [opts]\n  (let [cx (Context/enter)]\n    ;; just avoid the 64K method limit\n    ;; Rhino is slow even with optimizations enabled\n    (.setOptimizationLevel cx -1)\n    (merge (RhinoEnv.)\n      {:cx cx\n       :scope (.initStandardObjects cx)})))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/clojure/cljs/repl/rhino.clj",
                                                 :lines [202 210]},
                                        :full-name "cljs.repl.rhino/repl-env*",
                                        :full-name-encode "cljs.repl.rhino/repl-envSTAR",
                                        :history [["+" "0.0-3030"]]},
           "cljs.core/when-some" {:description "When `test` is not nil, evaluates `body` with `x` bound to the value of `test`.",
                                  :ns "cljs.core",
                                  :name "when-some",
                                  :signature ["[[x test] & body]"],
                                  :history [["+" "0.0-2261"]],
                                  :type "macro",
                                  :related ["cljs.core/if-some"],
                                  :full-name-encode "cljs.core/when-some",
                                  :source {:code "(defmacro when-some\n  [bindings & body]\n  (assert-args\n     (vector? bindings) \"a vector for its binding\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n   (let [form (bindings 0) tst (bindings 1)]\n    `(let [temp# ~tst]\n       (if (nil? temp#)\n         nil\n         (let [~form temp#]\n           ~@body)))))",
                                           :title "Source code",
                                           :repo "clojure",
                                           :tag "clojure-1.7.0",
                                           :filename "src/clj/clojure/core.clj",
                                           :lines [1782 1797]},
                                  :full-name "cljs.core/when-some",
                                  :clj-symbol "clojure.core/when-some",
                                  :docstring "bindings => binding-form test\n\nWhen test is not nil, evaluates body with binding-form bound to the\nvalue of test"},
           "cljs.repl.browser/server-loop" {:ns "cljs.repl.browser",
                                            :name "server-loop",
                                            :signature ["[opts server-socket]"],
                                            :history [["+" "0.0-927"]
                                                      ["-" "0.0-1503"]],
                                            :type "function",
                                            :full-name-encode "cljs.repl.browser/server-loop",
                                            :source {:code "(defn server-loop\n  [opts server-socket]\n  (let [conn (.accept server-socket)]\n    (do (.setKeepAlive conn true)\n        (future (handle-connection opts conn))\n        (recur opts server-socket))))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1450",
                                                     :filename "src/clj/cljs/repl/browser.clj",
                                                     :lines [258 263]},
                                            :full-name "cljs.repl.browser/server-loop",
                                            :removed {:in "0.0-1503",
                                                      :last-seen "0.0-1450"}},
           "cljs.reader/read-meta" {:ns "cljs.reader",
                                    :name "read-meta",
                                    :type "function",
                                    :signature ["[rdr _]"],
                                    :source {:code "(defn read-meta\n  [rdr _]\n  (let [m (desugar-meta (read rdr true nil true))]\n    (when-not (map? m)\n      (reader-error rdr \"Metadata must be Symbol,Keyword,String or Map\"))\n    (let [o (read rdr true nil true)]\n      (if (satisfies? IWithMeta o)\n        (with-meta o (merge (meta o) m))\n        (reader-error rdr \"Metadata can only be applied to IWithMetas\")))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/reader.cljs",
                                             :lines [386 394]},
                                    :full-name "cljs.reader/read-meta",
                                    :full-name-encode "cljs.reader/read-meta",
                                    :history [["+" "0.0-927"]]},
           "cljs.repl.server/send-404" {:ns "cljs.repl.server",
                                        :name "send-404",
                                        :type "function",
                                        :signature ["[conn path]"],
                                        :source {:code "(defn send-404 [conn path]\n  (send-and-close conn 404\n    (str\n      \"<html><body>\"\n      \"<h2>Page not found</h2>\"\n      \"No page \" path \" found on this server.\"\n      \"</body></html>\")\n    \"text/html\"))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/clojure/cljs/repl/server.clj",
                                                 :lines [131 138]},
                                        :full-name "cljs.repl.server/send-404",
                                        :full-name-encode "cljs.repl.server/send-404",
                                        :history [["+" "0.0-1503"]]},
           "special/try*" {:ns "special",
                           :name "try*",
                           :type "special form",
                           :source {:code "(defmethod parse 'try*\n  [op env [_ & body :as form] name]\n  (let [body (vec body)\n        catchenv (update-in env [:context] #(if (= :expr %) :return %))\n        tail (peek body)\n        fblock (when (and (seq? tail) (= 'finally (first tail)))\n                  (rest tail))\n        finally (when fblock\n                  (analyze (assoc env :context :statement) `(do ~@fblock)))\n        body (if finally (pop body) body)\n        tail (peek body)\n        cblock (when (and (seq? tail)\n                          (= 'catch (first tail)))\n                 (rest tail))\n        name (first cblock)\n        locals (:locals catchenv)\n        locals (if name\n                 (assoc locals name\n                   {:name name\n                    :line (get-line name env)\n                    :column (get-col name env)})\n                 locals)\n        catch (when cblock\n                (analyze (assoc catchenv :locals locals) `(do ~@(rest cblock))))\n        body (if name (pop body) body)\n        try (analyze (if (or name finally) catchenv env) `(do ~@body))]\n    (when name (assert (not (namespace name)) \"Can't qualify symbol in catch\"))\n    {:env env :op :try* :form form\n     :try try\n     :finally finally\n     :name name\n     :catch catch\n     :children [try catch finally]}))",
                                    :title "Parser code",
                                    :repo "clojurescript",
                                    :tag "r1913",
                                    :filename "src/clj/cljs/analyzer.clj",
                                    :lines [280 312]},
                           :full-name "special/try*",
                           :full-name-encode "special/trySTAR",
                           :history [["+" "0.0-927"] ["-" "0.0-1933"]],
                           :removed {:in "0.0-1933",
                                     :last-seen "0.0-1913"},
                           :moved "special/try"},
           "syntax/ignore" {:description "Causes the following form to be completely skipped by the reader.  This is a\nmore complete removal than the `comment` macro which yields nil.",
                            :ns "syntax",
                            :name "ignore",
                            :history [["+" "0.0-927"]],
                            :type "syntax",
                            :related ["syntax/comment"
                                      "cljs.core/comment"],
                            :full-name-encode "syntax/ignore",
                            :extra-sources ({:code "(defn- read-discard\n  [rdr _ opts pending-forms]\n  (doto rdr\n    (read* true nil opts pending-forms)))",
                                             :title "Reader code",
                                             :repo "tools.reader",
                                             :tag "tools.reader-1.0.0-alpha1",
                                             :filename "src/main/clojure/clojure/tools/reader.clj",
                                             :lines [404 408]}
                                            {:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    \\? read-cond\n    nil))",
                                             :title "Reader table",
                                             :repo "tools.reader",
                                             :tag "tools.reader-1.0.0-alpha1",
                                             :filename "src/main/clojure/clojure/tools/reader.clj",
                                             :lines [764 776]}),
                            :examples [{:id "f36d7a",
                                        :content "```clj\n{:foo #_bar 2}\n;;=> {:foo 2}\n```\n\nTo comment out the last line of a function without worrying about commenting out\nthe trailing parentheses:\n\n```clj\n(defn foo []\n  (println \"hello\")\n  #_(println \"world\"))\n```"}],
                            :edn-doc "https://github.com/edn-format/edn#discard",
                            :full-name "syntax/ignore",
                            :display "#_ ignore",
                            :clj-doc "http://clojure.org/reader#toc2"},
           "cljs.test/test-var-block" {:ns "cljs.test",
                                       :name "test-var-block",
                                       :signature ["[v]"],
                                       :history [["+" "0.0-2814"]],
                                       :type "function",
                                       :full-name-encode "cljs.test/test-var-block",
                                       :source {:code "(defn test-var-block\n  [v]\n  (if-let [t (:test (meta v))]\n    (test-var-block* v t)))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/cljs/test.cljs",
                                                :lines [476 481]},
                                       :full-name "cljs.test/test-var-block",
                                       :docstring "Like test-var, but returns a block for further composition and\nlater execution."},
           "syntax/destructure-vector" {:description "A helpful shorthand for destructuring a sequence into multiple names.\n\n```clj\n(let [ [a b c]   ;; <-- destructure vector\n       [1 2 3] ]\n  (println a b c))\n;; 1 2 3\n```\n\nUse `& foo` to name the rest of the items in the sequence:\n\n```clj\n(let [ [a b c & d]\n       [1 2 3 4 5] ]\n  (println a b c d))\n;; 1 2 3 (4 5)\n```\n\nUse `:as foo` to name the original value:\n\n```clj\n(let [ [a b c & d :as whole]\n       [1 2 3 4 5] ]\n  whole)\n;;=> [1 2 3 4 5]\n```\n\nUse the special destructure vector in place of any local name binding in the\nfollowing forms:\n\n- `(let [...])`\n- `(fn [...])`\n- `(loop [...])`\n\nDestructure vectors can be nested, even in place of names in [destructure\nmaps][doc:syntax/destructure-map].",
                                        :ns "syntax",
                                        :name "destructure-vector",
                                        :history [["+" "0.0-927"]],
                                        :type "binding",
                                        :related ["syntax/destructure-map"],
                                        :full-name-encode "syntax/destructure-vector",
                                        :source {:code "(core/defn destructure [bindings]\n  (core/let [bents (partition 2 bindings)\n             pb (core/fn pb [bvec b v]\n                  (core/let [pvec\n                             (core/fn [bvec b val]\n                               (core/let [gvec (gensym \"vec__\")]\n                                 (core/loop [ret (core/-> bvec (conj gvec) (conj val))\n                                             n 0\n                                             bs b\n                                             seen-rest? false]\n                                   (if (seq bs)\n                                     (core/let [firstb (first bs)]\n                                       (core/cond\n                                         (= firstb '&) (recur (pb ret (second bs) (core/list `nthnext gvec n))\n                                                         n\n                                                         (nnext bs)\n                                                         true)\n                                         (= firstb :as) (pb ret (second bs) gvec)\n                                         :else (if seen-rest?\n                                                 (throw\n                                                   #?(:clj (new Exception \"Unsupported binding form, only :as can follow & parameter\")\n                                                      :cljs (new js/Error \"Unsupported binding form, only :as can follow & parameter\")))\n                                                 (recur (pb ret firstb (core/list `nth gvec n nil))\n                                                   (core/inc n)\n                                                   (next bs)\n                                                   seen-rest?))))\n                                     ret))))\n                             pmap\n                             (core/fn [bvec b v]\n                               (core/let [gmap (gensym \"map__\")\n                                          defaults (:or b)]\n                                 (core/loop [ret (core/-> bvec (conj gmap) (conj v)\n                                                   (conj gmap) (conj `(if (implements? ISeq ~gmap) (apply hash-map ~gmap) ~gmap))\n                                                   ((core/fn [ret]\n                                                      (if (:as b)\n                                                        (conj ret (:as b) gmap)\n                                                        ret))))\n                                             bes (reduce\n                                                   (core/fn [bes entry]\n                                                     (reduce #(assoc %1 %2 ((val entry) %2))\n                                                       (dissoc bes (key entry))\n                                                       ((key entry) bes)))\n                                                   (dissoc b :as :or)\n                                                   {:keys #(if (core/keyword? %) % (keyword (core/str %))),\n                                                    :strs core/str, :syms #(core/list `quote %)})]\n                                   (if (seq bes)\n                                     (core/let [bb (key (first bes))\n                                                bk (val (first bes))\n                                                has-default (contains? defaults bb)]\n                                       (recur (pb ret bb (if has-default\n                                                           (core/list `get gmap bk (defaults bb))\n                                                           (core/list `get gmap bk)))\n                                         (next bes)))\n                                     ret))))]\n                    (core/cond\n                      (core/symbol? b) (core/-> bvec (conj (if (namespace b) (symbol (name b)) b)) (conj v))\n                      (core/keyword? b) (core/-> bvec (conj (symbol (name b))) (conj v))\n                      (vector? b) (pvec bvec b v)\n                      (map? b) (pmap bvec b v)\n                      :else (throw\n                              #?(:clj (new Exception (core/str \"Unsupported binding form: \" b))\n                                 :cljs (new js/Error (core/str \"Unsupported binding form: \" b)))))))\n             process-entry (core/fn [bvec b] (pb bvec (first b) (second b)))]\n    (if (every? core/symbol? (map first bents))\n      bindings\n      (core/if-let [kwbs (seq (filter #(core/keyword? (first %)) bents))]\n        (throw\n          #?(:clj (new Exception (core/str \"Unsupported binding key: \" (ffirst kwbs)))\n             :cljs (new js/Error (core/str \"Unsupported binding key: \" (ffirst kwbs)))))\n        (reduce process-entry [] bents)))))",
                                                 :title "Parser code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/clojure/cljs/core.cljc",
                                                 :lines [619 688]},
                                        :usage ["[arg1 arg2 & args :as name]"],
                                        :examples [{:id "acab87",
                                                    :content "Use destructure vectors in function parameters:\n\n```clj\n(defn foo [[a b] c]\n  (+ a b c))\n\n(foo [1 2] 3)\n;;=> 6\n```"}
                                                   {:id "fa4e05",
                                                    :content "Destructure vectors can be nested:\n\n```clj\n(let [ [[a b] c]\n       [[1 2] 3] ]\n  (println a b c))\n;; 1 2 3\n```"}],
                                        :full-name "syntax/destructure-vector",
                                        :display "destructure []",
                                        :clj-doc "http://clojure.org/special_forms#toc18"},
           "cljs.core/range" {:description "Returns a lazy sequence of nums from `start` (inclusive) to `end` (exclusive),\nby `step`, where `start` defaults to 0, `step` to 1, and `end` to infinity.",
                              :ns "cljs.core",
                              :name "range",
                              :signature ["[]"
                                          "[end]"
                                          "[start end]"
                                          "[start end step]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/repeat"],
                              :full-name-encode "cljs.core/range",
                              :source {:code "(defn range\n  ([] (range 0 (.-MAX-VALUE js/Number) 1))\n  ([end] (range 0 end 1))\n  ([start end] (range start end 1))\n  ([start end step] (Range. nil start end step nil)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [8529 8536]},
                              :full-name "cljs.core/range",
                              :clj-symbol "clojure.core/range",
                              :docstring "Returns a lazy seq of nums from start (inclusive) to end\n(exclusive), by step, where start defaults to 0, step to 1,\nand end to infinity."},
           "cljs.repl.browser/read-post" {:moved "cljs.repl.server/read-post",
                                          :ns "cljs.repl.browser",
                                          :name "read-post",
                                          :signature ["[line rdr]"],
                                          :history [["+" "0.0-927"]
                                                    ["-" "0.0-1503"]],
                                          :type "function",
                                          :full-name-encode "cljs.repl.browser/read-post",
                                          :source {:code "(defn read-post [line rdr]\n  (let [[_ path _] (str/split line #\" \")\n        headers (parse-headers (read-headers rdr))\n        content-length (Integer/parseInt (:content-length headers))\n        content (char-array content-length)]\n    (io! (.read rdr content 0 content-length)\n         {:method :post\n          :path path\n          :headers headers\n          :content (String. content)})))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1450",
                                                   :filename "src/clj/cljs/repl/browser.clj",
                                                   :lines [143 152]},
                                          :full-name "cljs.repl.browser/read-post",
                                          :removed {:in "0.0-1503",
                                                    :last-seen "0.0-1450"}},
           "cljs.core/reify" {:ns "cljs.core",
                              :name "reify",
                              :signature ["[& impls]"],
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :full-name-encode "cljs.core/reify",
                              :source {:code "(core/defmacro reify\n  [& impls]\n  (core/let [t        (with-meta\n                        (gensym\n                          (core/str \"t_\"\n                            (string/replace (core/str (munge ana/*cljs-ns*)) \".\" \"$\")))\n                        {:anonymous true})\n             meta-sym (gensym \"meta\")\n             this-sym (gensym \"_\")\n             locals   (keys (:locals &env))\n             ns       (core/-> &env :ns :name)\n             munge    comp/munge]\n    `(do\n       (when-not (exists? ~(symbol (core/str ns) (core/str t)))\n         (deftype ~t [~@locals ~meta-sym]\n           IWithMeta\n           (~'-with-meta [~this-sym ~meta-sym]\n             (new ~t ~@locals ~meta-sym))\n           IMeta\n           (~'-meta [~this-sym] ~meta-sym)\n           ~@impls))\n       (new ~t ~@locals ~(ana/elide-reader-meta (meta &form))))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/clojure/cljs/core.cljc",
                                       :lines [1218 1276]},
                              :full-name "cljs.core/reify",
                              :clj-symbol "clojure.core/reify",
                              :docstring "reify is a macro with the following structure:\n\n(reify options* specs*)\n\n Currently there are no options.\n\n Each spec consists of the protocol name followed by zero\n or more method bodies:\n\n protocol\n (methodName [args+] body)*\n\n Methods should be supplied for all methods of the desired\n protocol(s). You can also define overrides for Object methods. Note that\n the first parameter must be supplied to correspond to the target object\n ('this' in JavaScript parlance). Note also that recur calls\n to the method head should *not* pass the target object, it will be supplied\n automatically and can not be substituted.\n\n recur works to method heads The method bodies of reify are lexical\n closures, and can refer to the surrounding local scope:\n\n (str (let [f \"foo\"]\n      (reify Object\n        (toString [this] f))))\n == \"foo\"\n\n (seq (let [f \"foo\"]\n      (reify ISeqable\n        (-seq [this] (-seq f)))))\n == (\\f \\o \\o))\n\n reify always implements IMeta and IWithMeta and transfers meta\n data of the form to the created object.\n\n (meta ^{:k :v} (reify Object (toString [this] \"foo\")))\n == {:k :v}"},
           "cljs.core/satisfies?" {:ns "cljs.core",
                                   :name "satisfies?",
                                   :signature ["[psym x]"],
                                   :history [["+" "0.0-927"]],
                                   :type "macro",
                                   :full-name-encode "cljs.core/satisfiesQMARK",
                                   :source {:code "(core/defmacro satisfies?\n  [psym x]\n  (core/let [p          (:name\n                          (cljs.analyzer/resolve-var\n                            (dissoc &env :locals) psym))\n             prefix     (protocol-prefix p)\n             xsym       (bool-expr (gensym))\n             [part bit] (fast-path-protocols p)\n             msym       (symbol\n                          (core/str \"-cljs$lang$protocol_mask$partition\" part \"$\"))]\n    (core/if-not (core/symbol? x)\n      `(let [~xsym ~x]\n         (if-not (nil? ~xsym)\n           (if (or ~(if bit `(unsafe-bit-and (. ~xsym ~msym) ~bit) false)\n                   ~(bool-expr `(. ~xsym ~(symbol (core/str \"-\" prefix)))))\n             true\n             (if (coercive-not (. ~xsym ~msym))\n               (cljs.core/native-satisfies? ~psym ~xsym)\n               false))\n           (cljs.core/native-satisfies? ~psym ~xsym)))\n      `(if-not (nil? ~x)\n         (if (or ~(if bit `(unsafe-bit-and (. ~x ~msym) ~bit) false)\n                 ~(bool-expr `(. ~x ~(symbol (core/str \"-\" prefix)))))\n           true\n           (if (coercive-not (. ~x ~msym))\n             (cljs.core/native-satisfies? ~psym ~x)\n             false))\n         (cljs.core/native-satisfies? ~psym ~x)))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/clojure/cljs/core.cljc",
                                            :lines [1947 1975]},
                                   :full-name "cljs.core/satisfies?",
                                   :clj-symbol "clojure.core/satisfies?",
                                   :docstring "Returns true if x satisfies the protocol"},
           "cljs.core/nth" {:description "Returns the value at index `n` or `not-found` if the index is out of bounds.\n\n`nth` will throw an exception if `n` is out of bounds and `not-found` is not\nsupplied.\n\n`nth` works for Strings, Arrays, Regex Matchers, Lists, and Sequences. For\nSequences, `nth` takes O(n) time.",
                            :ns "cljs.core",
                            :name "nth",
                            :signature ["[coll n]"
                                        "[coll n not-found]"],
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :related ["cljs.core/first"
                                      "cljs.core/second"
                                      "cljs.core/nthnext"
                                      "cljs.core/get"],
                            :full-name-encode "cljs.core/nth",
                            :source {:code "(defn nth\n  ([coll n]\n    (cond\n      (not (number? n))\n      (throw (js/Error. \"index argument to nth must be a number\"))\n\n      (nil? coll)\n      coll\n\n      (implements? IIndexed coll)\n      (-nth ^not-native coll n)\n\n      (array? coll)\n      (when (< n (.-length coll))\n        (aget coll n))\n\n      (string? coll)\n      (when (< n (.-length coll))\n        (.charAt coll n))\n\n      (implements? ISeq coll)\n      (linear-traversal-nth coll n)\n\n      (native-satisfies? IIndexed coll)\n      (-nth coll n)\n\n      :else\n      (throw (js/Error. (str \"nth not supported on this type \"\n                          (type->str (type coll)))))))\n  ([coll n not-found]\n    (cond\n      (not (number? n))\n      (throw (js/Error. \"index argument to nth must be a number.\"))\n\n      (nil? coll)\n      not-found\n\n      (implements? IIndexed coll)\n      (-nth ^not-native coll n not-found)\n\n      (array? coll)\n      (if (< n (.-length coll))\n        (aget coll n)\n        not-found)\n\n      (string? coll)\n      (if (< n (.-length coll))\n        (.charAt coll n)\n        not-found)\n\n      (implements? ISeq coll)\n      (linear-traversal-nth coll n not-found)\n\n      (native-satisfies? IIndexed coll)\n      (-nth coll n)\n\n      :else\n      (throw (js/Error. (str \"nth not supported on this type \"\n                          (type->str (type coll))))))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.7.228",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [1635 1697]},
                            :full-name "cljs.core/nth",
                            :clj-symbol "clojure.core/nth",
                            :docstring "Returns the value at the index. get returns nil if index out of\nbounds, nth throws an exception unless not-found is supplied.  nth\nalso works for strings, arrays, regex Matchers and Lists, and,\nin O(n) time, for sequences."},
           "cljs.core/list" {:description "Creates a new list containing `items`.",
                             :ns "cljs.core",
                             :name "list",
                             :signature ["[& items]"],
                             :history [["+" "0.0-927"]],
                             :type "function/macro",
                             :related ["cljs.core/vector"
                                       "cljs.core/list?"],
                             :full-name-encode "cljs.core/list",
                             :source {:code "(defn list\n  [& xs]\n  (let [arr (if (and (instance? IndexedSeq xs) (zero? (.-i xs)))\n              (.-arr xs)\n              (let [arr (array)]\n                (loop [^not-native xs xs]\n                  (if-not (nil? xs)\n                    (do\n                      (.push arr (-first xs))\n                      (recur (-next xs)))\n                    arr))))]\n    (loop [i (alength arr) ^not-native r ()]\n      (if (> i 0)\n        (recur (dec i) (-conj r (aget arr (dec i))))\n        r))))",
                                      :title "Function code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [2841 2856]},
                             :extra-sources [{:code "(core/defmacro list\n  ([] '(.-EMPTY cljs.core/List))\n  ([x & xs]\n    `(-conj (list ~@xs) ~x)))",
                                              :title "Macro code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/clojure/cljs/core.cljc",
                                              :lines [2337 2340]}],
                             :full-name "cljs.core/list",
                             :clj-symbol "clojure.core/list",
                             :docstring "Creates a new list containing the items."},
           "cljs.core/defn" {:description "Defines a function.\n\n`doc-string?` is an optional documentation string.\n\n`attr-map?` is an optional map of [metadata](http://clojure.org/metadata) to\nattach to the global variable name.\n\n`prepost-map?` is an optional map with optional keys `:pre` and `:post` that\ncontain collections of [pre or post conditions](http://blog.fogus.me/2009/12/21/clojures-pre-and-post/)\nfor the function.\n\n<table class=\"code-tbl-9bef6\">\n  <thead>\n    <tr>\n      <th>Code</th>\n      <th>Expands To</th></tr></thead>\n  <tbody>\n    <tr>\n      <td><pre>\n(defn foo [a b c]\n  (\\* a b c))</pre></td>\n      <td><pre>\n(def foo\n  (fn [a b c]\n    (\\* a b c)))</pre></td></tr></tbody></table>",
                             :ns "cljs.core",
                             :name "defn",
                             :signature ["[name doc-string? attr-map? [params*] prepost-map? body]"
                                         "[name doc-string? attr-map? ([params*] prepost-map? body) + attr-map?]"],
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :related ["special/def"
                                       "cljs.core/defn-"
                                       "cljs.core/defmacro"
                                       "cljs.core/fn"],
                             :full-name-encode "cljs.core/defn",
                             :source {:code "(def\n  ^{:doc \"Same as (def name (core/fn [params* ] exprs*)) or (def\n    name (core/fn ([params* ] exprs*)+)) with any doc-string or attrs added\n    to the var metadata. prepost-map defines a map with optional keys\n    :pre and :post that contain collections of pre or post conditions.\"\n    :arglists '([name doc-string? attr-map? [params*] prepost-map? body]\n                 [name doc-string? attr-map? ([params*] prepost-map? body)+ attr-map?])}\n  defn (core/fn defn [&form &env name & fdecl]\n         ;; Note: Cannot delegate this check to def because of the call to (with-meta name ..)\n         (if (core/instance? #?(:clj clojure.lang.Symbol :cljs Symbol) name)\n           nil\n           (throw\n             #?(:clj (IllegalArgumentException. \"First argument to defn must be a symbol\")\n                :cljs (js/Error. \"First argument to defn must be a symbol\"))))\n         (core/let [m (if (core/string? (first fdecl))\n                        {:doc (first fdecl)}\n                        {})\n                    fdecl (if (core/string? (first fdecl))\n                            (next fdecl)\n                            fdecl)\n                    m (if (map? (first fdecl))\n                        (conj m (first fdecl))\n                        m)\n                    fdecl (if (map? (first fdecl))\n                            (next fdecl)\n                            fdecl)\n                    fdecl (if (vector? (first fdecl))\n                            (core/list fdecl)\n                            fdecl)\n                    m (if (map? (last fdecl))\n                        (conj m (last fdecl))\n                        m)\n                    fdecl (if (map? (last fdecl))\n                            (butlast fdecl)\n                            fdecl)\n                    m (conj {:arglists (core/list 'quote (sigs fdecl))} m)\n                    ;; no support for :inline\n                    ;m (core/let [inline (:inline m)\n                    ;             ifn (first inline)\n                    ;             iname (second inline)]\n                    ;    ;; same as: (if (and (= 'fn ifn) (not (symbol? iname))) ...)\n                    ;    (if (if #?(:clj (clojure.lang.Util/equiv 'fn ifn)\n                    ;               :cljs (= 'fn ifn))\n                    ;          (if #?(:clj (core/instance? clojure.lang.Symbol iname)\n                    ;                 :cljs (core/instance? Symbol iname)) false true))\n                    ;      ;; inserts the same fn name to the inline fn if it does not have one\n                    ;      (assoc m\n                    ;        :inline (cons ifn\n                    ;                  (cons (clojure.lang.Symbol/intern\n                    ;                          (.concat (.getName ^clojure.lang.Symbol name) \"__inliner\"))\n                    ;                    (next inline))))\n                    ;      m))\n                    m (conj (if (meta name) (meta name) {}) m)]\n           (core/cond\n             (multi-arity-fn? fdecl)\n             (multi-arity-fn name\n               (if (comp/checking-types?)\n                 (update-in m [:jsdoc] conj \"@param {...*} var_args\")\n                 m) fdecl)\n\n             (variadic-fn? fdecl)\n             (variadic-fn name\n               (if (comp/checking-types?)\n                 (update-in m [:jsdoc] conj \"@param {...*} var_args\")\n                 m) fdecl)\n\n             :else\n             (core/list 'def (with-meta name m)\n               ;;todo - restore propagation of fn name\n               ;;must figure out how to convey primitive hints to self calls first\n               (cons `fn fdecl))))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/clojure/cljs/core.cljc",
                                      :lines [2807 2877]},
                             :full-name "cljs.core/defn",
                             :clj-symbol "clojure.core/defn",
                             :docstring "Same as (def name (core/fn [params* ] exprs*)) or (def\n name (core/fn ([params* ] exprs*)+)) with any doc-string or attrs added\n to the var metadata. prepost-map defines a map with optional keys\n :pre and :post that contain collections of pre or post conditions."},
           "cljs.core/rand-nth" {:description "Returns a random element from a sequential collection `coll`.\n\nHas the same performance characteristics as `nth`.",
                                 :ns "cljs.core",
                                 :name "rand-nth",
                                 :signature ["[coll]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :related ["cljs.core/rand"],
                                 :full-name-encode "cljs.core/rand-nth",
                                 :source {:code "(defn rand-nth\n  [coll]\n  (nth coll (rand-int (count coll))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [9411 9416]},
                                 :full-name "cljs.core/rand-nth",
                                 :clj-symbol "clojure.core/rand-nth",
                                 :docstring "Return a random element of the (sequential) collection. Will have\nthe same performance characteristics as nth for the given\ncollection."},
           "cljs.core/ex-cause" {:ns "cljs.core",
                                 :name "ex-cause",
                                 :signature ["[ex]"],
                                 :history [["+" "0.0-1576"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/ex-cause",
                                 :source {:code "(defn ex-cause\n  [ex]\n  (when (instance? ExceptionInfo ex)\n    (.-cause ex)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [9942 9948]},
                                 :full-name "cljs.core/ex-cause",
                                 :docstring "Returns exception cause (an Error / ExceptionInfo) if ex is an\nExceptionInfo.\nOtherwise returns nil."},
           "cljs.core/atom" {:description "Creates and returns an atom with an initial value of `x`.\n\n`opts` is an optional map with optional keys `:meta` and `:validator`.\n\n`:meta` should be a [metadata-map](http://clojure.org/metadata) for the atom.\n\n`:validator` should be a validator function for the atom. See `set-validator!`\nfor more information.",
                             :ns "cljs.core",
                             :name "atom",
                             :signature ["[x]" "[x opts]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/atom"
                                       "cljs.core/swap!"
                                       "cljs.core/reset!"
                                       "cljs.core/set-validator!"
                                       "cljs.core/get-validator"],
                             :full-name-encode "cljs.core/atom",
                             :source {:code "(defn atom\n  ([x] (Atom. x nil nil nil))\n  ([x & {:keys [meta validator]}] (Atom. x meta validator nil)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [3980 3995]},
                             :examples [{:id "e6a38a",
                                         :content "```clj\n(def a (atom 1))\n\n@a\n;;=> 1\n\n(reset! a 2)\n@a\n;;=> 2\n\n(swap! a inc)\n@a\n;;=> 3\n```"}],
                             :full-name "cljs.core/atom",
                             :clj-symbol "clojure.core/atom",
                             :docstring "Creates and returns an Atom with an initial value of x and zero or\nmore options (in any order):\n\n:meta metadata-map\n\n:validator validate-fn\n\nIf metadata-map is supplied, it will be come the metadata on the\natom. validate-fn must be nil or a side-effect-free fn of one\nargument, which will be passed the intended new state on any state\nchange. If the new state is unacceptable, the validate-fn should\nreturn false or throw an Error.  If either of these error conditions\noccur, then the value of the atom will not change."},
           "cljs.reader/read-keyword" {:ns "cljs.reader",
                                       :name "read-keyword",
                                       :type "function",
                                       :signature ["[reader initch]"],
                                       :source {:code "(defn read-keyword\n  [reader initch]\n  (let [token (read-token reader (read-char reader))\n        a (re-matches* symbol-pattern token)\n        token (aget a 0)\n        ns (aget a 1)\n        name (aget a 2)]\n    (if (or (and (not (undefined? ns))\n                 (identical? (. ns (substring (- (.-length ns) 2) (.-length ns))) \":/\"))\n            (identical? (aget name (dec (.-length name))) \":\")\n            (not (== (.indexOf token \"::\" 1) -1)))\n      (reader-error reader \"Invalid token: \" token)\n      (if (and (not (nil? ns)) (> (.-length ns) 0))\n        (keyword (.substring ns 0 (.indexOf ns \"/\")) name)\n        (keyword token)))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/cljs/reader.cljs",
                                                :lines [352 366]},
                                       :full-name "cljs.reader/read-keyword",
                                       :full-name-encode "cljs.reader/read-keyword",
                                       :history [["+" "0.0-927"]]},
           "cljs.core/Vector" {:ns "cljs.core",
                               :name "Vector",
                               :signature ["[meta array __hash]"],
                               :history [["+" "0.0-927"]
                                         ["-" "0.0-1798"]],
                               :type "type",
                               :full-name-encode "cljs.core/Vector",
                               :source {:code "(deftype Vector [meta array ^:mutable __hash]\n  Object\n  (toString [this]\n    (pr-str this))\n\n  IWithMeta\n  (-with-meta [coll meta] (Vector. meta array __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IStack\n  (-peek [coll]\n    (let [count (alength array)]\n      (when (> count 0)\n        (aget array (dec count)))))\n  (-pop [coll]\n    (if (> (alength array) 0)\n      (let [new-array (aclone array)]\n        (. new-array (pop))\n        (Vector. meta new-array nil))\n      (throw (js/Error. \"Can't pop empty vector\"))))\n\n  ICollection\n  (-conj [coll o]\n    (let [new-array (aclone array)]\n      (.push new-array o)\n      (Vector. meta new-array nil)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.Vector/EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (when (> (alength array) 0)\n      (let [vector-seq\n             (fn vector-seq [i]\n               (lazy-seq\n                 (when (< i (alength array))\n                   (cons (aget array i) (vector-seq (inc i))))))]\n        (vector-seq 0))))\n\n  ICounted\n  (-count [coll] (alength array))\n\n  IIndexed\n  (-nth [coll n]\n    (if (and (<= 0 n) (< n (alength array)))\n      (aget array n)\n      #_(throw (js/Error. (str \"No item \" n \" in vector of length \" (alength array))))))\n  (-nth [coll n not-found]\n    (if (and (<= 0 n) (< n (alength array)))\n      (aget array n)\n      not-found))\n\n  ILookup\n  (-lookup [coll k] (-nth coll k nil))\n  (-lookup [coll k not-found] (-nth coll k not-found))\n\n  IAssociative\n  (-assoc [coll k v]\n    (let [new-array (aclone array)]\n      (aset new-array k v)\n      (Vector. meta new-array nil)))\n\n  IVector\n  (-assoc-n [coll n val] (-assoc coll n val))\n\n  IReduce\n  (-reduce [v f]\n    (ci-reduce array f))\n  (-reduce [v f start]\n    (ci-reduce array f start))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1586",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [2772 2857]},
                               :full-name "cljs.core/Vector",
                               :removed {:in "0.0-1798",
                                         :last-seen "0.0-1586"}},
           "cljs.reader/skip-line" {:ns "cljs.reader",
                                    :name "skip-line",
                                    :signature ["[reader _]"],
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.reader/skip-line",
                                    :source {:code "(defn skip-line\n  [reader _]\n  (loop []\n    (let [ch (read-char reader)]\n      (if (or (identical? ch \\newline) (identical? ch \\return) (nil? ch))\n        reader\n        (recur)))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/reader.cljs",
                                             :lines [89 96]},
                                    :full-name "cljs.reader/skip-line",
                                    :docstring "Advances the reader to the end of a line. Returns the reader"},
           "cljs.core/namespace" {:description "Returns the namespace string of a possibly namespace-qualified keyword or symbol.\n\nReturns [doc:syntax/nil] if not present.",
                                  :ns "cljs.core",
                                  :name "namespace",
                                  :signature ["[x]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/name"],
                                  :full-name-encode "cljs.core/namespace",
                                  :source {:code "(defn namespace\n  [x]\n  (if (implements? INamed x)\n    (-namespace ^not-native x)\n    (throw (js/Error. (str \"Doesn't support namespace: \" x)))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [2981 2986]},
                                  :examples [{:id "5bd3b4",
                                              :content "With namespaces:\n\n```clj\n(namespace :foo/bar)\n;;=> \"foo\"\n\n(namespace 'foo/bar)\n;;=> \"foo\"\n```\n\nWithout namespaces:\n\n```clj\n(namespace :foo)\n;;=> nil\n\n(namespace 'foo)\n;;=> nil\n```\n\nStrings have no concept of a namespace:\n\n```clj\n(name \"foo/bar\")\n;;=> nil\n```"}],
                                  :full-name "cljs.core/namespace",
                                  :clj-symbol "clojure.core/namespace",
                                  :docstring "Returns the namespace String of a symbol or keyword, or nil if not present."},
           "cljs.core/ns-name" {:ns "cljs.core",
                                :name "ns-name",
                                :signature ["[ns-obj]"],
                                :history [["+" "1.7.10"]],
                                :type "function",
                                :full-name-encode "cljs.core/ns-name",
                                :source {:code "(defn ns-name [ns-obj]\n  (.-name ns-obj))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [10201 10202]},
                                :full-name "cljs.core/ns-name",
                                :clj-symbol "clojure.core/ns-name"},
           "cljs.nodejs/require" {:ns "cljs.nodejs",
                                  :name "require",
                                  :type "var",
                                  :source {:code "(def require (js* \"require\"))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/nodejs.cljs",
                                           :lines [15]},
                                  :full-name "cljs.nodejs/require",
                                  :full-name-encode "cljs.nodejs/require",
                                  :history [["+" "0.0-927"]]},
           "cljs.core/chunk-rest" {:ns "cljs.core",
                                   :name "chunk-rest",
                                   :type "function",
                                   :signature ["[s]"],
                                   :source {:code "(defn chunk-rest [s]\n  (-chunked-rest s))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [3202 3203]},
                                   :full-name "cljs.core/chunk-rest",
                                   :full-name-encode "cljs.core/chunk-rest",
                                   :history [["+" "0.0-1424"]]},
           "cljs.core/unchecked-long" {:ns "cljs.core",
                                       :name "unchecked-long",
                                       :signature ["[x]"],
                                       :history [["+" "0.0-1798"]],
                                       :type "function",
                                       :full-name-encode "cljs.core/unchecked-long",
                                       :source {:code "(defn unchecked-long\n  [x]\n  (fix x))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/cljs/core.cljs",
                                                :lines [2472 2475]},
                                       :full-name "cljs.core/unchecked-long",
                                       :clj-symbol "clojure.core/unchecked-long",
                                       :docstring "Coerce to long by stripping decimal places. Identical to `int'."},
           "cljs.repl/source-fn" {:ns "cljs.repl",
                                  :name "source-fn",
                                  :signature ["[env x]"],
                                  :history [["+" "0.0-2985"]],
                                  :type "function",
                                  :full-name-encode "cljs.repl/source-fn",
                                  :source {:code "(defn source-fn\n  [env x]\n  (when-let [v (ana-api/resolve env x)]\n    (when-let [filepath (:file v)]\n      (let [f (io/file filepath)\n            f (if (.exists f)\n                f\n                (io/resource filepath))]\n        (when f\n          (with-open [pbr (PushbackReader. (io/reader f))]\n            (let [rdr (readers/source-logging-push-back-reader pbr)]\n              (dotimes [_ (dec (:line v))] (readers/read-line rdr))\n              (-> (reader/read {:read-cond :allow :features #{:cljs}} rdr)\n                meta :source))))))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/clojure/cljs/repl.cljc",
                                           :lines [1209 1229]},
                                  :full-name "cljs.repl/source-fn",
                                  :clj-symbol "clojure.repl/source-fn",
                                  :docstring "Returns a string of the source code for the given symbol, if it can\nfind it.  This requires that the symbol resolve to a Var defined in\na namespace for which the .clj is in the classpath.  Returns nil if\nit can't find the source.  For most REPL usage, 'source' is more\nconvenient.\n\nExample: (source-fn 'filter)"},
           "cljs.repl.server/connection" {:ns "cljs.repl.server",
                                          :name "connection",
                                          :signature ["[]"],
                                          :history [["+" "0.0-1503"]],
                                          :type "function",
                                          :full-name-encode "cljs.repl.server/connection",
                                          :source {:code "(defn connection\n  []\n  (let [p    (promise)\n        conn (:connection @state)]\n    (if (and conn (not (.isClosed conn)))\n      (do\n        (deliver p conn)\n        p)\n      (do\n        (swap! state (fn [old] (assoc old :promised-conn p)))\n        p))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/clojure/cljs/repl/server.clj",
                                                   :lines [10 22]},
                                          :full-name "cljs.repl.server/connection",
                                          :docstring "Promise to return a connection when one is available. If a\nconnection is not available, store the promise in server/state."},
           "clojure.browser.event/EventType" {:moved "clojure.browser.event/IEventType",
                                              :ns "clojure.browser.event",
                                              :name "EventType",
                                              :history [["+"
                                                         "0.0-927"]
                                                        ["-"
                                                         "0.0-2301"]],
                                              :type "protocol",
                                              :full-name-encode "clojure.browser.event/EventType",
                                              :source {:code "(defprotocol EventType\n  (event-types [this]))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r2280",
                                                       :filename "src/cljs/clojure/browser/event.cljs",
                                                       :lines [17 18]},
                                              :methods [{:name "event-types",
                                                         :signature ["[this]"],
                                                         :docstring nil}],
                                              :full-name "clojure.browser.event/EventType",
                                              :removed {:in "0.0-2301",
                                                        :last-seen "0.0-2280"}},
           "cljs.pprint/IPrettyFlush" {:ns "cljs.pprint",
                                       :name "IPrettyFlush",
                                       :type "protocol",
                                       :full-name-encode "cljs.pprint/IPrettyFlush",
                                       :source {:code "(defprotocol IPrettyFlush\n  (-ppflush [pp]))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/cljs/pprint.cljs",
                                                :lines [144 145]},
                                       :methods [{:name "-ppflush",
                                                  :signature ["[pp]"],
                                                  :docstring nil}],
                                       :full-name "cljs.pprint/IPrettyFlush",
                                       :history [["+" "0.0-3255"]]},
           "cljs.js/file->ns" {:ns "cljs.js",
                               :name "file->ns",
                               :type "function",
                               :signature ["[file]"],
                               :source {:code "(defn file->ns\n  [file]\n  (let [lib-name (subs (string/replace file \"/\" \".\")\n                   0 (- (count file) 5))]\n    (symbol (demunge lib-name))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/js.cljs",
                                        :lines [35 39]},
                               :full-name "cljs.js/file->ns",
                               :full-name-encode "cljs.js/file-GTns",
                               :history [["+" "1.7.10"]]},
           "cljs.core/ranged-iterator" {:ns "cljs.core",
                                        :name "ranged-iterator",
                                        :type "function",
                                        :signature ["[v start end]"],
                                        :source {:code "(defn ranged-iterator [v start end]\n  (let [i start]\n    (RangedIterator. i (- i (js-mod i 32))\n      (when (< start (count v))\n        (unchecked-array-for v i))\n      v start end)))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/cljs/cljs/core.cljs",
                                                 :lines [4731 4736]},
                                        :full-name "cljs.core/ranged-iterator",
                                        :full-name-encode "cljs.core/ranged-iterator",
                                        :history [["+" "0.0-2371"]]},
           "cljs.pprint/print-table" {:ns "cljs.pprint",
                                      :name "print-table",
                                      :signature ["[ks rows]"
                                                  "[rows]"],
                                      :history [["+" "0.0-3255"]],
                                      :type "function",
                                      :full-name-encode "cljs.pprint/print-table",
                                      :source {:code "(defn print-table\n  ([ks rows]\n   (binding [*print-newline*]\n     (when (seq rows)\n       (let [widths (map\n                      (fn [k]\n                        (apply max (count (str k)) (map #(count (str (get % k))) rows)))\n                      ks)\n             spacers (map #(apply str (repeat % \"-\")) widths)\n             fmt-row (fn [leader divider trailer row]\n                       (str leader\n                            (apply str (interpose divider\n                                                  (for [[col width] (map vector (map #(get row %) ks) widths)]\n                                                    (add-padding width (str col)))))\n                            trailer))]\n         (cljs.core/println)\n         (cljs.core/println (fmt-row \"| \" \" | \" \" |\" (zipmap ks ks)))\n         (cljs.core/println (fmt-row \"|-\" \"-+-\" \"-|\" (zipmap ks spacers)))\n         (doseq [row rows]\n           (cljs.core/println (fmt-row \"| \" \" | \" \" |\" row)))))))\n  ([rows] (print-table (keys (first rows)) rows)))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/cljs/cljs/pprint.cljs",
                                               :lines [3295 3319]},
                                      :full-name "cljs.pprint/print-table",
                                      :clj-symbol "clojure.pprint/print-table",
                                      :docstring "Prints a collection of maps in a textual table. Prints table headings\nks, and then a line of output for each row, corresponding to the keys\nin ks. If ks are not specified, use the keys of the first item in rows."},
           "cljs.core/create-ns" {:ns "cljs.core",
                                  :name "create-ns",
                                  :signature ["[sym]" "[sym ns-obj]"],
                                  :history [["+" "1.7.10"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/create-ns",
                                  :source {:code "(defn create-ns\n  ([sym]\n   (create-ns sym (find-ns-obj sym)))\n  ([sym ns-obj]\n   (Namespace. ns-obj sym)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [10167 10171]},
                                  :full-name "cljs.core/create-ns",
                                  :clj-symbol "clojure.core/create-ns"},
           "cljs.repl.rhino/rhino-setup" {:ns "cljs.repl.rhino",
                                          :name "rhino-setup",
                                          :type "function",
                                          :signature ["[repl-env opts]"],
                                          :source {:code "(defn rhino-setup [repl-env opts]\n  (let [scope   (:scope repl-env)\n        env     (ana/empty-env)\n        core    (io/resource \"cljs/core.cljs\")\n        base-js (io/resource \"goog/base.js\")\n        core-js (closure/compile core\n                  (assoc opts\n                    :output-file\n                    (closure/src-file->target-file core)))\n        deps    (closure/add-dependencies opts core-js)\n        output-dir (util/output-directory opts)\n        repl-deps (io/file output-dir \"rhino_repl_deps.js\")]\n    ;; emit core and deps\n    (apply closure/output-unoptimized\n      (assoc opts :output-to (.getPath repl-deps)) deps)\n\n    ;; setup back references & output stream\n    (ScriptableObject/putProperty scope\n      \"___repl_env\" (Context/javaToJS repl-env scope))\n    (ScriptableObject/putProperty scope \"__repl_opts\"\n      (Context/javaToJS opts scope))\n    (ScriptableObject/putProperty scope\n      \"out\" (Context/javaToJS *out* scope))\n    (ScriptableObject/putProperty scope\n      \"err\" (Context/javaToJS *err* scope))\n\n    ;; define file loading, load goog.base, load repl deps\n    (rhino-eval repl-env \"bootjs\" 1 bootjs)\n    (rhino-eval repl-env \"goog/base.js\" 1 (io/reader base-js))\n    (rhino-eval repl-env \"rhino_repl_deps.js\" 1 (io/reader repl-deps))\n\n    ;; === Bootstrap ===\n    ;; load cljs.core, setup printing\n    (repl/evaluate-form repl-env env \"<cljs repl>\"\n      '(do\n         (.require js/goog \"cljs.core\")\n         (set! *print-fn* (fn [x] (.write js/out x)))\n         (set! *print-err-fn* (fn [x] (.write js/err x)))))\n\n    ;; allow namespace reloading\n    (repl/evaluate-form repl-env env \"<cljs repl>\"\n      '(set! js/goog.isProvided_ (fn [x] false)))\n\n    ;; monkey-patch goog.require\n    (repl/evaluate-form repl-env env \"<cljs repl>\"\n      '(do\n         (set! *loaded-libs* #{\"cljs.core\"})\n         (set! (.-require js/goog)\n           (fn [name reload]\n             (when (or (not (contains? *loaded-libs* name)) reload)\n               (set! *loaded-libs* (conj (or *loaded-libs* #{}) name))\n               (js/CLOSURE_IMPORT_SCRIPT\n                 (aget (.. js/goog -dependencies_ -nameToPath) name)))))))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/clojure/cljs/repl/rhino.clj",
                                                   :lines [104 156]},
                                          :full-name "cljs.repl.rhino/rhino-setup",
                                          :full-name-encode "cljs.repl.rhino/rhino-setup",
                                          :history [["+" "0.0-927"]]},
           "cljs.repl.browser/parse-file-line-column" {:ns "cljs.repl.browser",
                                                       :name "parse-file-line-column",
                                                       :signature ["[flc]"],
                                                       :history [["+"
                                                                  "0.0-3053"]
                                                                 ["-"
                                                                  "1.7.10"]],
                                                       :type "function",
                                                       :full-name-encode "cljs.repl.browser/parse-file-line-column",
                                                       :source {:code "(defn parse-file-line-column [flc]\n  (let [xs (string/split flc #\":\")\n        [pre [line column]]\n        (reduce\n          (fn [[pre post] [x i]]\n            (if (<= i 2)\n              [pre (conj post x)]\n              [(conj pre x) post]))\n          [[] []] (map vector xs (range (count xs) 0 -1)))\n        file (string/join \":\" pre)]\n    [(cond-> file\n       (.startsWith file \"(\") (string/replace \"(\" \"\"))\n     (Long/parseLong\n       (cond-> line\n         (.endsWith line \")\") (string/replace \")\" \"\")))\n     (Long/parseLong\n       (cond-> column\n         (.endsWith column \")\") (string/replace \")\" \"\")))]))",
                                                                :title "Source code",
                                                                :repo "clojurescript",
                                                                :tag "r3308",
                                                                :filename "src/main/clojure/cljs/repl/browser.clj",
                                                                :lines [211
                                                                        228]},
                                                       :full-name "cljs.repl.browser/parse-file-line-column",
                                                       :removed {:in "1.7.10",
                                                                 :last-seen "0.0-3308"}},
           "cljs.core/merge" {:description "Returns a map that consists of the rest of the maps `conj`-ed onto the first.\n\nIf a key occurs in more than one map, the mapping from the rightmost map will\n\"win\".",
                              :ns "cljs.core",
                              :name "merge",
                              :signature ["[& maps]"],
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :related ["cljs.core/merge-with"
                                        "cljs.core/hash-map"],
                              :full-name-encode "cljs.core/merge",
                              :source {:code "(defn merge\n  [& maps]\n  (when (some identity maps)\n    (reduce #(conj (or %1 {}) %2) maps)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [7924 7930]},
                              :full-name "cljs.core/merge",
                              :clj-symbol "clojure.core/merge",
                              :docstring "Returns a map that consists of the rest of the maps conj-ed onto\nthe first.  If a key occurs in more than one map, the mapping from\nthe latter (left-to-right) will be the mapping in the result."},
           "clojure.core.reducers/remove" {:ns "clojure.core.reducers",
                                           :name "remove",
                                           :signature ["[pred]"
                                                       "[pred coll]"],
                                           :history [["+" "0.0-1236"]],
                                           :type "function",
                                           :full-name-encode "clojure.core.reducers/remove",
                                           :source {:code "(defcurried remove\n  \"Removes values in the reduction of coll for which (pred val)\n  returns logical true. Foldable.\"\n  {}\n  [pred coll]\n  (filter (complement pred) coll))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.7.228",
                                                    :filename "src/main/cljs/clojure/core/reducers.cljs",
                                                    :lines [145 150]},
                                           :full-name "clojure.core.reducers/remove",
                                           :clj-symbol "clojure.core.reducers/remove",
                                           :docstring "Removes values in the reduction of coll for which (pred val)\n  returns logical true. Foldable."},
           "cljs.build.api/src-file->goog-require" {:return-type String,
                                                    :ns "cljs.build.api",
                                                    :name "src-file->goog-require",
                                                    :signature ["[src]"
                                                                "[src options]"
                                                                "[state src options]"],
                                                    :history [["+"
                                                               "0.0-2629"]],
                                                    :type "function",
                                                    :full-name-encode "cljs.build.api/src-file-GTgoog-require",
                                                    :source {:code "(defn ^String src-file->goog-require\n  ([src] (src-file->goog-require src nil))\n  ([src options]\n   (src-file->goog-require\n     (if-not (nil? env/*compiler*)\n       env/*compiler*\n       (env/default-compiler-env))\n     src options))\n  ([state src options]\n   (env/with-compiler-env state\n     (binding [ana/*cljs-warning-handlers* (:warning-handlers options ana/*cljs-warning-handlers*)]\n       (closure/src-file->goog-require src options)))))",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r1.7.228",
                                                             :filename "src/main/clojure/cljs/build/api.clj",
                                                             :lines [95
                                                                     108]},
                                                    :full-name "cljs.build.api/src-file->goog-require",
                                                    :docstring "Given a ClojureScript or Google Closure style JavaScript source file return\nthe goog.require statement for it."},
           "cljs.repl.node/write" {:ns "cljs.repl.node",
                                   :name "write",
                                   :type "function",
                                   :signature ["[out js]"],
                                   :source {:code "(defn write [^BufferedWriter out ^String js]\n  (.write out js)\n  (.write out (int 0)) ;; terminator\n  (.flush out))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/clojure/cljs/repl/node.clj",
                                            :lines [35 38]},
                                   :full-name "cljs.repl.node/write",
                                   :full-name-encode "cljs.repl.node/write",
                                   :history [["+" "0.0-2629"]]},
           "cljs.repl/read-source-map" {:ns "cljs.repl",
                                        :name "read-source-map",
                                        :signature ["[f]"],
                                        :history [["+" "0.0-2814"]],
                                        :type "function",
                                        :full-name-encode "cljs.repl/read-source-map",
                                        :source {:code "(defn read-source-map\n  [f]\n  (when-let [smf (util/file-or-resource (str f \".map\"))]\n    (let [ns (if (= f \"cljs/core.aot.js\")\n               'cljs.core\n               (some-> (js-src->cljs-src f) ana/parse-ns :ns))]\n      (when ns\n        (as-> @env/*compiler* compiler-env\n          (let [t (util/last-modified smf)]\n            (if (or (and (= ns 'cljs.core)\n                         (nil? (get-in compiler-env [::source-maps ns])))\n                    (and (not= ns 'cljs.core)\n                         (> t (get-in compiler-env [::source-maps ns :last-modified] 0))))\n              (swap! env/*compiler* assoc-in [::source-maps ns]\n                {:last-modified t\n                 :source-map (sm/decode (json/read-str (slurp smf) :key-fn keyword))})\n              compiler-env))\n          (get-in compiler-env [::source-maps ns :source-map]))))))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/clojure/cljs/repl.cljc",
                                                 :lines [224 242]},
                                        :full-name "cljs.repl/read-source-map",
                                        :docstring "Return the source map for the JavaScript source file."},
           "cljs.core/set-entries-iterator" {:ns "cljs.core",
                                             :name "set-entries-iterator",
                                             :signature ["[coll]"],
                                             :history [["+"
                                                        "0.0-2268"]
                                                       ["-"
                                                        "0.0-2371"]],
                                             :type "function",
                                             :full-name-encode "cljs.core/set-entries-iterator",
                                             :source {:code "(defn set-entries-iterator [coll]\n  (SetEntriesIterator. (seq coll)))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r2356",
                                                      :filename "src/cljs/cljs/core.cljs",
                                                      :lines [4896
                                                              4897]},
                                             :full-name "cljs.core/set-entries-iterator",
                                             :removed {:in "0.0-2371",
                                                       :last-seen "0.0-2356"}},
           "clojure.browser.repl/send-result" {:ns "clojure.browser.repl",
                                               :name "send-result",
                                               :type "function",
                                               :signature ["[connection url data]"],
                                               :source {:code "(defn send-result [connection url data]\n  (net/transmit connection url \"POST\" data nil 0))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.7.228",
                                                        :filename "src/main/cljs/clojure/browser/repl.cljs",
                                                        :lines [71 72]},
                                               :full-name "clojure.browser.repl/send-result",
                                               :full-name-encode "clojure.browser.repl/send-result",
                                               :history [["+"
                                                          "0.0-927"]]},
           "cljs.js/with-state" {:ns "cljs.js",
                                 :name "with-state",
                                 :type "macro",
                                 :signature ["[state & body]"],
                                 :source {:code "(defmacro with-state\n  [state & body]\n  `(menv/with-compiler-env ~state\n     ~@body))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/js.clj",
                                          :lines [15 18]},
                                 :full-name "cljs.js/with-state",
                                 :full-name-encode "cljs.js/with-state",
                                 :history [["+" "1.7.10"]]},
           "clojure.walk/keywordize-keys" {:ns "clojure.walk",
                                           :name "keywordize-keys",
                                           :signature ["[m]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "clojure.walk/keywordize-keys",
                                           :source {:code "(defn keywordize-keys\n  [m]\n  (let [f (fn [[k v]] (if (string? k) [(keyword k) v] [k v]))]\n    ;; only apply to maps\n    (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.7.228",
                                                    :filename "src/main/cljs/clojure/walk.cljs",
                                                    :lines [66 72]},
                                           :full-name "clojure.walk/keywordize-keys",
                                           :clj-symbol "clojure.walk/keywordize-keys",
                                           :docstring "Recursively transforms all map keys from strings to keywords."},
           "cljs.pprint/*print-miser-width*" {:ns "cljs.pprint",
                                              :name "*print-miser-width*",
                                              :history [["+"
                                                         "0.0-3255"]],
                                              :type "dynamic var",
                                              :full-name-encode "cljs.pprint/STARprint-miser-widthSTAR",
                                              :source {:code "(def ^:dynamic\n ^{:doc \"The column at which to enter miser style. Depending on the dispatch table,\nmiser style add newlines in more places to try to keep lines short allowing for further\nlevels of nesting.\",\n   :added \"1.2\"}\n *print-miser-width* 40)",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.7.228",
                                                       :filename "src/main/cljs/cljs/pprint.cljs",
                                                       :lines [632
                                                               637]},
                                              :full-name "cljs.pprint/*print-miser-width*",
                                              :clj-symbol "clojure.pprint/*print-miser-width*",
                                              :docstring "The column at which to enter miser style. Depending on the dispatch table,\nmiser style add newlines in more places to try to keep lines short allowing for further\nlevels of nesting."},
           "cljs.core/entries-iterator" {:ns "cljs.core",
                                         :name "entries-iterator",
                                         :signature ["[coll]"],
                                         :history [["+" "0.0-2268"]
                                                   ["-" "0.0-2371"]],
                                         :type "function",
                                         :full-name-encode "cljs.core/entries-iterator",
                                         :source {:code "(defn entries-iterator [coll]\n  (EntriesIterator. (seq coll)))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2356",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [4883 4884]},
                                         :full-name "cljs.core/entries-iterator",
                                         :removed {:in "0.0-2371",
                                                   :last-seen "0.0-2356"}},
           "cljs.analyzer.api/empty-env" {:ns "cljs.analyzer.api",
                                          :name "empty-env",
                                          :signature ["[]"],
                                          :history [["+" "0.0-3208"]],
                                          :type "function",
                                          :full-name-encode "cljs.analyzer.api/empty-env",
                                          :source {:code "(defn empty-env\n  []\n  (ana/empty-env))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/clojure/cljs/analyzer/api.clj",
                                                   :lines [31 34]},
                                          :full-name "cljs.analyzer.api/empty-env",
                                          :docstring "Creates an empty analysis environment."},
           "cljs.core/reduced" {:ns "cljs.core",
                                :name "reduced",
                                :signature ["[x]"],
                                :history [["+" "0.0-1211"]],
                                :type "function",
                                :full-name-encode "cljs.core/reduced",
                                :source {:code "(defn reduced\n  [x]\n  (Reduced. x))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [1272 1275]},
                                :full-name "cljs.core/reduced",
                                :clj-symbol "clojure.core/reduced",
                                :docstring "Wraps x in a way such that a reduce will terminate with the value x"},
           "cljs.reader/read-string*" {:ns "cljs.reader",
                                       :name "read-string*",
                                       :type "function",
                                       :signature ["[reader _]"],
                                       :source {:code "(defn read-string*\n  [reader _]\n  (loop [buffer (gstring/StringBuffer.)\n         ch (read-char reader)]\n    (cond\n     (nil? ch) (reader-error reader \"EOF while reading\")\n     (identical? \"\\\\\" ch) (recur (do (.append buffer (escape-char buffer reader)) buffer)\n                        (read-char reader))\n     (identical? \\\" ch) (. buffer (toString))\n     :default (recur (do (.append buffer ch) buffer) (read-char reader)))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/cljs/reader.cljs",
                                                :lines [293 302]},
                                       :full-name "cljs.reader/read-string*",
                                       :full-name-encode "cljs.reader/read-stringSTAR",
                                       :history [["+" "0.0-1236"]]},
           "cljs.core/ArrayNodeIterator" {:ns "cljs.core",
                                          :name "ArrayNodeIterator",
                                          :type "type",
                                          :signature ["[arr i next-iter]"],
                                          :source {:code "(deftype ArrayNodeIterator [arr ^:mutable i ^:mutable next-iter]\n  Object\n  (hasNext [this]\n    (let [len (alength arr)]\n      (loop []\n        (if-not (and  (some? next-iter) ^boolean (.hasNext next-iter))\n          (if (< i len)\n            (let [node (aget arr i)]\n              (set! i (inc i))\n              (when (some? node)\n                (set! next-iter (-iterator node)))\n              (recur))\n            false)\n          true))))\n  (next [this]\n    (if ^boolean (.hasNext this)\n      (.next next-iter)\n      (throw (js/Error. \"No such element\"))))\n  (remove [_] (js/Error. \"Unsupported operation\")))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/cljs/cljs/core.cljs",
                                                   :lines [6427 6445]},
                                          :full-name "cljs.core/ArrayNodeIterator",
                                          :full-name-encode "cljs.core/ArrayNodeIterator",
                                          :history [["+" "1.7.28"]]},
           "cljs.core/ChunkedCons" {:ns "cljs.core",
                                    :name "ChunkedCons",
                                    :signature ["[chunk more meta __hash]"],
                                    :history [["+" "0.0-1424"]],
                                    :type "type",
                                    :full-name-encode "cljs.core/ChunkedCons",
                                    :source {:code "(deftype ChunkedCons [chunk more meta ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  \n  IWithMeta\n  (-with-meta [coll m]\n    (ChunkedCons. chunk more m __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ASeq\n  ISeq\n  (-first [coll] (-nth chunk 0))\n  (-rest [coll]\n    (if (> (-count chunk) 1)\n      (ChunkedCons. (-drop-first chunk) more meta nil)\n      (if (nil? more)\n        ()\n        more)))\n\n  INext\n  (-next [coll]\n    (if (> (-count chunk) 1)\n      (ChunkedCons. (-drop-first chunk) more meta nil)\n      (let [more (-seq more)]\n        (when-not (nil? more)\n          more))))\n\n  IChunkedSeq\n  (-chunked-first [coll] chunk)\n  (-chunked-rest [coll]\n    (if (nil? more)\n      ()\n      more))\n\n  IChunkedNext\n  (-chunked-next [coll]\n    (if (nil? more)\n      nil\n      more))\n\n  ICollection\n  (-conj [this o]\n    (cons o this))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY List) meta))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [3124 3184]},
                                    :full-name "cljs.core/ChunkedCons",
                                    :clj-symbol "clojure.lang/ChunkedCons"},
           "cljs.core/derive" {:ns "cljs.core",
                               :name "derive",
                               :signature ["[tag parent]"
                                           "[h tag parent]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/ancestors"
                                         "cljs.core/descendants"
                                         "cljs.core/isa?"
                                         "cljs.core/make-hierarchy"],
                               :full-name-encode "cljs.core/derive",
                               :source {:code "(defn derive\n  ([tag parent]\n   (assert (namespace parent))\n   ;; (assert (or (class? tag) (and (instance? cljs.core.Named tag) (namespace tag))))\n   (swap-global-hierarchy! derive tag parent) nil)\n  ([h tag parent]\n   (assert (not= tag parent))\n   ;; (assert (or (class? tag) (instance? clojure.lang.Named tag)))\n   ;; (assert (instance? clojure.lang.INamed tag))\n   ;; (assert (instance? clojure.lang.INamed parent))\n   (let [tp (:parents h)\n         td (:descendants h)\n         ta (:ancestors h)\n         tf (fn [m source sources target targets]\n              (reduce (fn [ret k]\n                        (assoc ret k\n                               (reduce conj (get targets k #{}) (cons target (targets target)))))\n                      m (cons source (sources source))))]\n     (or\n      (when-not (contains? (tp tag) parent)\n        (when (contains? (ta tag) parent)\n          (throw (js/Error. (str tag \"already has\" parent \"as ancestor\"))))\n        (when (contains? (ta parent) tag)\n          (throw (js/Error. (str \"Cyclic derivation:\" parent \"has\" tag \"as ancestor\"))))\n        {:parents (assoc (:parents h) tag (conj (get tp tag #{}) parent))\n         :ancestors (tf (:ancestors h) tag td parent ta)\n         :descendants (tf (:descendants h) parent ta tag td)})\n      h))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [9492 9524]},
                               :full-name "cljs.core/derive",
                               :clj-symbol "clojure.core/derive",
                               :docstring "Establishes a parent/child relationship between parent and\ntag. Parent must be a namespace-qualified symbol or keyword and\nchild can be either a namespace-qualified symbol or keyword or a\nclass. h must be a hierarchy obtained from make-hierarchy, if not\nsupplied defaults to, and modifies, the global hierarchy."},
           "clojure.zip/zipper" {:ns "clojure.zip",
                                 :name "zipper",
                                 :signature ["[branch? children make-node root]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "clojure.zip/zipper",
                                 :source {:code "(defn zipper\n  [branch? children make-node root]\n    ^{:zip/branch? branch? :zip/children children :zip/make-node make-node}\n    [root nil])",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/clojure/zip.cljs",
                                          :lines [18 32]},
                                 :full-name "clojure.zip/zipper",
                                 :clj-symbol "clojure.zip/zipper",
                                 :docstring "Creates a new zipper structure. \n\nbranch? is a fn that, given a node, returns true if can have\nchildren, even if it currently doesn't.\n\nchildren is a fn that, given a branch node, returns a seq of its\nchildren.\n\nmake-node is a fn that, given an existing node and a seq of\nchildren, returns a new branch node with the supplied children.\nroot is the root node."},
           "cljs.test/empty-env" {:ns "cljs.test",
                                  :name "empty-env",
                                  :signature ["[]" "[reporter]"],
                                  :history [["+" "0.0-2496"]],
                                  :type "function",
                                  :full-name-encode "cljs.test/empty-env",
                                  :source {:code "(defn empty-env\n  ([] (empty-env ::default))\n  ([reporter]\n   (cond-> {:report-counters {:test 0 :pass 0 :fail 0 :error 0}\n            :testing-vars ()\n            :testing-contexts ()\n            :formatter pr-str\n            :reporter reporter}\n     (= ::pprint reporter) (assoc :reporter ::default\n                             :formatter pprint/pprint))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/test.cljs",
                                           :lines [252 267]},
                                  :full-name "cljs.test/empty-env",
                                  :docstring "Generates a testing environment with a reporter.\n(empty-env) - uses the :cljs.test/default reporter.\n(empty-env :cljs.test/pprint) - pretty prints all data structures. \n(empty-env reporter) - uses a reporter of your choosing.\n\nTo create your own reporter see cljs.test/report"},
           "clojure.core.reducers/mapcat" {:ns "clojure.core.reducers",
                                           :name "mapcat",
                                           :signature ["[f]"
                                                       "[f coll]"],
                                           :history [["+" "0.0-1236"]],
                                           :type "function",
                                           :full-name-encode "clojure.core.reducers/mapcat",
                                           :source {:code "(defcurried mapcat\n  \"Applies f to every value in the reduction of coll, concatenating the result\n  colls of (f val). Foldable.\"\n  {}\n  [f coll]\n  (folder coll\n   (fn [f1]\n     (rfn [f1 k]\n          ([ret k v]\n             (reduce f1 ret (f k v)))))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.7.228",
                                                    :filename "src/main/cljs/clojure/core/reducers.cljs",
                                                    :lines [106 115]},
                                           :full-name "clojure.core.reducers/mapcat",
                                           :clj-symbol "clojure.core.reducers/mapcat",
                                           :docstring "Applies f to every value in the reduction of coll, concatenating the result\n  colls of (f val). Foldable."},
           "clojure.zip/remove" {:ns "clojure.zip",
                                 :name "remove",
                                 :signature ["[loc]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "clojure.zip/remove",
                                 :source {:code "(defn remove\n  [loc]\n    (let [[node {l :l, ppath :ppath, pnodes :pnodes, rs :r, :as path}] loc]\n      (if (nil? path)\n        (throw \"Remove at top\")\n        (if (pos? (count l))\n          (loop [loc (with-meta [(peek l) (assoc path :l (pop l) :changed? true)] (meta loc))]\n            (if-let [child (and (branch? loc) (down loc))]\n              (recur (rightmost child))\n              loc))\n          (with-meta [(make-node loc (peek pnodes) rs) \n                      (and ppath (assoc ppath :changed? true))]\n                     (meta loc))))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/clojure/zip.cljs",
                                          :lines [237 251]},
                                 :full-name "clojure.zip/remove",
                                 :clj-symbol "clojure.zip/remove",
                                 :docstring "Removes the node at loc, returning the loc that would have preceded\nit in a depth-first walk."},
           "syntax/var" {:description "`#'foo` is sugar for [`(var foo)`][doc:special/var].\n\nAccesses the var attached to the given symbol.",
                         :ns "syntax",
                         :name "var",
                         :history [["+" "0.0-927"]],
                         :type "syntax",
                         :related ["special/var"],
                         :full-name-encode "syntax/var",
                         :extra-sources ({:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    \\? read-cond\n    nil))",
                                          :title "Reader table",
                                          :repo "tools.reader",
                                          :tag "tools.reader-1.0.0-alpha1",
                                          :filename "src/main/clojure/clojure/tools/reader.clj",
                                          :lines [764 776]}),
                         :usage ["#'foo" "#'foo/bar"],
                         :examples [{:id "673ef6",
                                     :content "Access the metadata of a var:\n\n```clj\n(def x 123)\n(meta #'x)\n;;=> {:arglists (), :test nil, :name x, :column 1, :line 1, :file \"<cljs repl>\", :doc nil, :ns cljs.user}\n```"}],
                         :full-name "syntax/var",
                         :display "#' var",
                         :clj-doc "http://clojure.org/reader#toc2"},
           "cljs.repl.browser/handle-post" {:ns "cljs.repl.browser",
                                            :name "handle-post",
                                            :signature ["[m _ _]"],
                                            :history [["+" "0.0-927"]],
                                            :type "multimethod",
                                            :full-name-encode "cljs.repl.browser/handle-post",
                                            :source {:code "(defmulti handle-post (fn [m _ _ ] (:type m)))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.7.228",
                                                     :filename "src/main/clojure/cljs/repl/browser.clj",
                                                     :lines [136]},
                                            :extra-sources ({:code "(defmethod handle-post :ready [_ conn _]\n  (send-via es ordering (fn [_] {:expecting nil :fns {}}))\n  (send-for-eval conn\n    (cljsc/-compile\n      '[(set! *print-fn* clojure.browser.repl/repl-print)\n        (set! *print-err-fn* clojure.browser.repl/repl-print)\n        (set! *print-newline* true)\n        (when (pos? (count clojure.browser.repl/print-queue))\n          (clojure.browser.repl/flush-print-queue!\n            @clojure.browser.repl/xpc-connection))] {})\n    identity))",
                                                             :title "Dispatch method",
                                                             :repo "clojurescript",
                                                             :tag "r1.7.228",
                                                             :filename "src/main/clojure/cljs/repl/browser.clj",
                                                             :lines [140
                                                                     150]}
                                                            {:code "(defmethod handle-post :print [{:keys [content order]} conn _ ]\n  (constrain-order order\n    (fn []\n      (print (read-string content))\n      (.flush *out*)))\n  (server/send-and-close conn 200 \"ignore__\"))",
                                                             :title "Dispatch method",
                                                             :repo "clojurescript",
                                                             :tag "r1.7.228",
                                                             :filename "src/main/clojure/cljs/repl/browser.clj",
                                                             :lines [171
                                                                     176]}
                                                            {:code "(defmethod handle-post :result [{:keys [content order]} conn _ ]\n  (constrain-order order\n    (fn []\n      (return-value content)\n      (server/set-connection conn))))",
                                                             :title "Dispatch method",
                                                             :repo "clojurescript",
                                                             :tag "r1.7.228",
                                                             :filename "src/main/clojure/cljs/repl/browser.clj",
                                                             :lines [178
                                                                     182]}),
                                            :full-name "cljs.repl.browser/handle-post"},
           "cljs.repl/find-doc" {:description "Prints documentation for any var whose documentation or name\ncontains a match for `re-string-or-pattern`.",
                                 :ns "cljs.repl",
                                 :name "find-doc",
                                 :signature ["[re-string-or-pattern]"],
                                 :history [["+" "0.0-2985"]],
                                 :type "macro",
                                 :related ["cljs.repl/doc"],
                                 :full-name-encode "cljs.repl/find-doc",
                                 :source {:code "(defmacro find-doc\n  [re-string-or-pattern]\n  (let [re (re-pattern re-string-or-pattern)\n        ms (concat\n             (mapcat\n               (fn [ns]\n                 (map\n                   (fn [m]\n                     (update-in (select-keys m [:ns :name :doc :forms :arglists :macro :url])\n                       [:name] #(if-not (nil? %) (clojure.core/name %) %)))\n                   (sort-by :name (vals (ana-api/ns-interns ns)))))\n               (ana-api/all-ns))\n             (map #(select-keys (ana-api/find-ns %) [:name :doc]) (ana-api/all-ns))\n             (map special-doc (keys special-doc-map)))\n        ms (for [m ms\n                 :when (and (:doc m)\n                            (or (re-find (re-matcher re (:doc m)))\n                                (re-find (re-matcher re (str (:name m))))))]\n             m)]\n    `(doseq [m# (quote ~ms)]\n       (cljs.repl/print-doc m#))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/clojure/cljs/repl.cljc",
                                          :lines [1185 1207]},
                                 :examples [{:id "50ec43",
                                             :content "```clj\n(find-doc \"some\")\n;; Prints: (docs truncated)\n;; - IPrintWriter (docstring match)\n;; - contains? (docstring match)\n;; - gensym (docstring match)\n;; - cljs.core/if-some\n;; - some\n;; - cljs.core/some->\n;; - cljs.core/some->>\n;; - some-fn\n;; - some?\n;; - trampoline (docstring match)\n;; - cljs.core/when-some\n;; - cljs.core/while (docstring match)\n;;\n;;=> nil\n```"}],
                                 :full-name "cljs.repl/find-doc",
                                 :clj-symbol "clojure.repl/find-doc",
                                 :docstring "Prints documentation for any var whose documentation or name\ncontains a match for re-string-or-pattern"},
           "cljs.core/find" {:description "Returns the map entry for key `k`, or nil if `k` is not found.",
                             :ns "cljs.core",
                             :name "find",
                             :signature ["[coll k]"],
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :related ["cljs.core/get"
                                       "cljs.core/get-in"],
                             :full-name-encode "cljs.core/find",
                             :source {:code "(defn find\n  [coll k]\n  (when (and (not (nil? coll))\n             (associative? coll)\n             (contains? coll k))\n    [k (get coll k)]))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [2039 2045]},
                             :full-name "cljs.core/find",
                             :clj-symbol "clojure.core/find",
                             :docstring "Returns the map entry for key, or nil if key not present."},
           "cljs.repl.node/repl-env*" {:ns "cljs.repl.node",
                                       :name "repl-env*",
                                       :type "function",
                                       :signature ["[options]"],
                                       :source {:code "(defn repl-env* [options]\n  (let [{:keys [host port debug-port]}\n        (merge\n          {:host \"localhost\"\n           :port (+ 49000 (rand-int 10000))}\n          options)]\n    (assoc (NodeEnv. host port (atom nil) (atom nil))\n      :debug-port debug-port)))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/clojure/cljs/repl/node.clj",
                                                :lines [211 218]},
                                       :full-name "cljs.repl.node/repl-env*",
                                       :full-name-encode "cljs.repl.node/repl-envSTAR",
                                       :history [["+" "0.0-2629"]]},
           "cljs.core/hash-set" {:description "Returns a new hash set with supplied `keys`.\n\nAny equal keys are handled as if by repeated uses of `conj`.",
                                 :ns "cljs.core",
                                 :name "hash-set",
                                 :signature ["[]" "[& keys]"],
                                 :history [["+" "0.0-1443"]],
                                 :type "function/macro",
                                 :related ["cljs.core/set"
                                           "cljs.core/sorted-set"],
                                 :full-name-encode "cljs.core/hash-set",
                                 :source {:code "(defn hash-set\n  ([] #{})\n  ([& keys] (set keys)))",
                                          :title "Function code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [8228 8232]},
                                 :extra-sources [{:code "(core/defmacro hash-set\n  ([] `(.-EMPTY cljs.core/PersistentHashSet))\n  ([& xs]\n    (if (core/and (core/<= (count xs) 8)\n                  (every? #(= (:op %) :constant)\n                    (map #(cljs.analyzer/analyze &env %) xs))\n                  (= (count (into #{} xs)) (count xs)))\n      `(cljs.core/PersistentHashSet. nil\n         (cljs.core/PersistentArrayMap. nil ~(count xs) (array ~@(interleave xs (repeat nil))) nil)\n         nil)\n      (vary-meta\n        `(.fromArray cljs.core/PersistentHashSet (array ~@xs) true)\n        assoc :tag 'cljs.core/PersistentHashSet))))",
                                                  :title "Macro code",
                                                  :repo "clojurescript",
                                                  :tag "r1.7.228",
                                                  :filename "src/main/clojure/cljs/core.cljc",
                                                  :lines [2373 2385]}],
                                 :full-name "cljs.core/hash-set",
                                 :clj-symbol "clojure.core/hash-set",
                                 :docstring "Returns a new hash set with supplied keys.  Any equal keys are\nhandled as if by repeated uses of conj."},
           "cljs.core/*print-dup*" {:ns "cljs.core",
                                    :name "*print-dup*",
                                    :history [["+" "0.0-927"]],
                                    :type "dynamic var",
                                    :full-name-encode "cljs.core/STARprint-dupSTAR",
                                    :source {:code "(def\n  ^{:dynamic true\n    :doc \"When set to logical true, objects will be printed in a way that preserves\n  their type when read in later.\n\n  Defaults to false.\"}\n  *print-dup* false)",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.7.228",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [97 103]},
                                    :full-name "cljs.core/*print-dup*",
                                    :clj-symbol "clojure.core/*print-dup*",
                                    :docstring "When set to logical true, objects will be printed in a way that preserves\ntheir type when read in later.\n\nDefaults to false."},
           "cljs.analyzer.api/analyze" {:ns "cljs.analyzer.api",
                                        :name "analyze",
                                        :signature ["[env form]"
                                                    "[env form name]"
                                                    "[env form name opts]"
                                                    "[state env form name opts]"],
                                        :history [["+" "0.0-3208"]],
                                        :type "function",
                                        :full-name-encode "cljs.analyzer.api/analyze",
                                        :source {:code "(defn analyze\n  ([env form] (analyze env form nil))\n  ([env form name] (analyze env form name nil))\n  ([env form name opts]\n   (analyze\n     (if-not (nil? env/*compiler*)\n       env/*compiler*\n       (env/default-compiler-env opts))\n     env form name opts))\n  ([state env form name opts]\n   (env/with-compiler-env state\n     (binding [ana/*cljs-warning-handlers* (:warning-handlers opts ana/*cljs-warning-handlers*)]\n       (ana/analyze env form name opts)))))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/clojure/cljs/analyzer/api.clj",
                                                 :lines [68 86]},
                                        :full-name "cljs.analyzer.api/analyze",
                                        :docstring "Given an environment, a map containing {:locals (mapping of names to bindings), :context\n(one of :statement, :expr, :return), :ns (a symbol naming the\ncompilation ns)}, and form, returns an expression object (a map\ncontaining at least :form, :op and :env keys). If expr has any (immediately)\nnested exprs, must have :children [exprs...] entry. This will\nfacilitate code walking without knowing the details of the op set."},
           "cljs.core/set-from-indexed-seq" {:ns "cljs.core",
                                             :name "set-from-indexed-seq",
                                             :type "function",
                                             :signature ["[iseq]"],
                                             :source {:code "(defn set-from-indexed-seq [iseq]\n  (let [arr (.-arr iseq)\n        ret (areduce arr i ^not-native res (-as-transient #{})\n              (-conj! res (aget arr i)))]\n    (-persistent! ^not-native ret)))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.7.228",
                                                      :filename "src/main/cljs/cljs/core.cljs",
                                                      :lines [8205
                                                              8209]},
                                             :full-name "cljs.core/set-from-indexed-seq",
                                             :full-name-encode "cljs.core/set-from-indexed-seq",
                                             :history [["+"
                                                        "0.0-1877"]]},
           "cljs.core/object-array" {:ns "cljs.core",
                                     :name "object-array",
                                     :signature ["[size-or-seq]"
                                                 "[size init-val-or-seq]"],
                                     :history [["+" "0.0-1211"]],
                                     :type "function",
                                     :full-name-encode "cljs.core/object-array",
                                     :source {:code "(defn object-array\n  ([size-or-seq]\n     (if (number? size-or-seq)\n       (object-array size-or-seq nil)\n       (into-array size-or-seq)))\n  ([size init-val-or-seq]\n     (let [a (make-array size)]\n       (if (seq? init-val-or-seq)\n         (let [s (seq init-val-or-seq)]\n           (loop [i 0 s s]\n             (if (and s (< i size))\n               (do\n                 (aset a i (first s))\n                 (recur (inc i) (next s)))\n               a)))\n         (do\n           (dotimes [i size]\n             (aset a i init-val-or-seq))\n           a)))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/cljs/cljs/core.cljs",
                                              :lines [3299 3319]},
                                     :full-name "cljs.core/object-array",
                                     :clj-symbol "clojure.core/object-array",
                                     :docstring "Creates an array of objects. Does not coerce array, provided for compatibility\nwith Clojure."},
           "cljs.core/indexed?" {:return-type boolean,
                                 :ns "cljs.core",
                                 :name "indexed?",
                                 :signature ["[x]"],
                                 :history [["+" "0.0-1211"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/indexedQMARK",
                                 :source {:code "(defn ^boolean indexed?\n  [x] (satisfies? IIndexed x))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [1372 1374]},
                                 :full-name "cljs.core/indexed?",
                                 :docstring "Returns true if coll implements nth in constant time"},
           "cljs.core/partial" {:description "Takes a function `f` and fewer than the normal arguments to `f`. Returns a\nfunction that takes a variable number of additional arguments. When called, the\nreturned function calls `f` with the original arguments plus the additional\narguments.\n\n`((partial f a b) c d)` => `(f a b c d)`",
                                :ns "cljs.core",
                                :name "partial",
                                :signature ["[f]"
                                            "[f arg1]"
                                            "[f arg1 arg2]"
                                            "[f arg1 arg2 arg3]"
                                            "[f arg1 arg2 arg3 & more]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/comp"
                                          "cljs.core/juxt"],
                                :full-name-encode "cljs.core/partial",
                                :source {:code "(defn partial\n  ([f] f)\n  ([f arg1]\n   (fn\n     ([] (f arg1))\n     ([x] (f arg1 x))\n     ([x y] (f arg1 x y))\n     ([x y z] (f arg1 x y z))\n     ([x y z & args] (apply f arg1 x y z args))))\n  ([f arg1 arg2]\n   (fn\n     ([] (f arg1 arg2))\n     ([x] (f arg1 arg2 x))\n     ([x y] (f arg1 arg2 x y))\n     ([x y z] (f arg1 arg2 x y z))\n     ([x y z & args] (apply f arg1 arg2 x y z args))))\n  ([f arg1 arg2 arg3]\n   (fn\n     ([] (f arg1 arg2 arg3))\n     ([x] (f arg1 arg2 arg3 x))\n     ([x y] (f arg1 arg2 arg3 x y))\n     ([x y z] (f arg1 arg2 arg3 x y z))\n     ([x y z & args] (apply f arg1 arg2 arg3 x y z args))))\n  ([f arg1 arg2 arg3 & more]\n   (fn [& args] (apply f arg1 arg2 arg3 (concat more args)))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [3835 3862]},
                                :full-name "cljs.core/partial",
                                :clj-symbol "clojure.core/partial",
                                :docstring "Takes a function f and fewer than the normal arguments to f, and\nreturns a fn that takes a variable number of additional args. When\ncalled, the returned function calls f with args + additional args."},
           "cljs.core/keyword?" {:return-type boolean,
                                 :ns "cljs.core",
                                 :name "keyword?",
                                 :signature ["[x]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function/macro",
                                 :full-name-encode "cljs.core/keywordQMARK",
                                 :source {:code "(defn ^boolean keyword?\n  [x]\n  (instance? Keyword x))",
                                          :title "Function code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [2958 2961]},
                                 :extra-sources [{:code "(core/defmacro keyword? [x]\n  (bool-expr `(instance? Keyword ~x)))",
                                                  :title "Macro code",
                                                  :repo "clojurescript",
                                                  :tag "r1.7.228",
                                                  :filename "src/main/clojure/cljs/core.cljc",
                                                  :lines [939 940]}],
                                 :full-name "cljs.core/keyword?",
                                 :clj-symbol "clojure.core/keyword?",
                                 :docstring "Return true if x is a Keyword"},
           "cljs.repl.rhino/stacktrace" {:ns "cljs.repl.rhino",
                                         :name "stacktrace",
                                         :type "multimethod",
                                         :source {:code "(defmulti stacktrace class)",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.7.228",
                                                  :filename "src/main/clojure/cljs/repl/rhino.clj",
                                                  :lines [50]},
                                         :full-name "cljs.repl.rhino/stacktrace",
                                         :full-name-encode "cljs.repl.rhino/stacktrace",
                                         :extra-sources ({:code "(defmethod stacktrace :default [e]\n  (apply str\n    (interpose \"\\n\"\n      (map #(str \"        \" (.toString %))\n        (.getStackTrace e)))))",
                                                          :title "Dispatch method",
                                                          :repo "clojurescript",
                                                          :tag "r1.7.228",
                                                          :filename "src/main/clojure/cljs/repl/rhino.clj",
                                                          :lines [52
                                                                  56]}
                                                         {:code "(defmethod stacktrace RhinoException [^RhinoException e]\n  (.getScriptStackTrace e))",
                                                          :title "Dispatch method",
                                                          :repo "clojurescript",
                                                          :tag "r1.7.228",
                                                          :filename "src/main/clojure/cljs/repl/rhino.clj",
                                                          :lines [58
                                                                  59]}),
                                         :history [["+" "0.0-927"]]},
           "clojure.browser.event/fire-listeners" {:ns "clojure.browser.event",
                                                   :name "fire-listeners",
                                                   :type "function",
                                                   :signature ["[obj type capture event]"],
                                                   :source {:code "(defn fire-listeners\n  [obj type capture event])",
                                                            :title "Source code",
                                                            :repo "clojurescript",
                                                            :tag "r1.7.228",
                                                            :filename "src/main/cljs/clojure/browser/event.cljs",
                                                            :lines [84
                                                                    85]},
                                                   :full-name "clojure.browser.event/fire-listeners",
                                                   :full-name-encode "clojure.browser.event/fire-listeners",
                                                   :history [["+"
                                                              "0.0-927"]]},
           "cljs.core/Iterator" {:ns "cljs.core",
                                 :name "Iterator",
                                 :signature ["[s]"],
                                 :history [["+" "0.0-2268"]
                                           ["-" "0.0-2371"]],
                                 :type "type",
                                 :full-name-encode "cljs.core/Iterator",
                                 :source {:code "(deftype Iterator [^:mutable s]\n  Object\n  (next [_]\n    (if-not (nil? s)\n      (let [x (first s)]\n        (set! s (next s))\n        #js {:value x :done false})\n      #js {:value nil :done true})))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2356",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [4861 4868]},
                                 :full-name "cljs.core/Iterator",
                                 :removed {:in "0.0-2371",
                                           :last-seen "0.0-2356"}},
           "cljs.core/vreset!" {:ns "cljs.core",
                                :name "vreset!",
                                :signature ["[vol newval]"],
                                :history [["+" "0.0-2496"]],
                                :type "function",
                                :related ["cljs.core/vswap!"
                                          "cljs.core/volatile!"],
                                :full-name-encode "cljs.core/vresetBANG",
                                :source {:code "(defn vreset!\n  [vol newval]  (-vreset! vol newval))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [4077 4080]},
                                :full-name "cljs.core/vreset!",
                                :clj-symbol "clojure.core/vreset!",
                                :docstring "Sets the value of volatile to newval without regard for the\ncurrent value. Returns newval."},
           "cljs.pprint/*print-right-margin*" {:ns "cljs.pprint",
                                               :name "*print-right-margin*",
                                               :history [["+"
                                                          "0.0-3255"]],
                                               :type "dynamic var",
                                               :full-name-encode "cljs.pprint/STARprint-right-marginSTAR",
                                               :source {:code "(def ^:dynamic\n ^{:doc \"Pretty printing will try to avoid anything going beyond this column.\nSet it to nil to have pprint let the line be arbitrarily long. This will ignore all\nnon-mandatory newlines.\",\n   :added \"1.2\"}\n *print-right-margin* 72)",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.7.228",
                                                        :filename "src/main/cljs/cljs/pprint.cljs",
                                                        :lines [625
                                                                630]},
                                               :full-name "cljs.pprint/*print-right-margin*",
                                               :clj-symbol "clojure.pprint/*print-right-margin*",
                                               :docstring "Pretty printing will try to avoid anything going beyond this column.\nSet it to nil to have pprint let the line be arbitrarily long. This will ignore all\nnon-mandatory newlines."},
           "cljs.core/interleave" {:description "Returns a lazy seq of the first item in each collection, then the second items,\nthen the third, etc.",
                                   :ns "cljs.core",
                                   :name "interleave",
                                   :signature ["[c1 c2]"
                                               "[c1 c2 & colls]"],
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :related ["cljs.core/interpose"
                                             "cljs.core/zipmap"],
                                   :full-name-encode "cljs.core/interleave",
                                   :source {:code "(defn interleave\n  ([c1 c2]\n     (lazy-seq\n      (let [s1 (seq c1) s2 (seq c2)]\n        (when (and s1 s2)\n          (cons (first s1) (cons (first s2)\n                                 (interleave (rest s1) (rest s2))))))))\n  ([c1 c2 & colls]\n     (lazy-seq\n      (let [ss (map seq (conj colls c2 c1))]\n        (when (every? identity ss)\n          (concat (map first ss) (apply interleave (map rest ss))))))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [4366 4378]},
                                   :full-name "cljs.core/interleave",
                                   :clj-symbol "clojure.core/interleave",
                                   :docstring "Returns a lazy seq of the first item in each coll, then the second etc."},
           "cljs.core/TransientHashSet" {:ns "cljs.core",
                                         :name "TransientHashSet",
                                         :signature ["[transient-map]"],
                                         :history [["+" "0.0-1211"]],
                                         :type "type",
                                         :full-name-encode "cljs.core/TransientHashSet",
                                         :source {:code "(deftype TransientHashSet [^:mutable transient-map]\n  ITransientCollection\n  (-conj! [tcoll o]\n    (set! transient-map (assoc! transient-map o nil))\n    tcoll)\n\n  (-persistent! [tcoll]\n    (PersistentHashSet. nil (persistent! transient-map) nil))\n\n  ITransientSet\n  (-disjoin! [tcoll v]\n    (set! transient-map (dissoc! transient-map v))\n    tcoll)\n\n  ICounted\n  (-count [tcoll] (count transient-map))\n\n  ILookup\n  (-lookup [tcoll v]\n    (-lookup tcoll v nil))\n\n  (-lookup [tcoll v not-found]\n    (if (identical? (-lookup transient-map v lookup-sentinel) lookup-sentinel)\n      not-found\n      v))\n\n  IFn\n  (-invoke [tcoll k]\n    (if (identical? (-lookup transient-map k lookup-sentinel) lookup-sentinel)\n      nil\n      k))\n\n  (-invoke [tcoll k not-found]\n    (if (identical? (-lookup transient-map k lookup-sentinel) lookup-sentinel)\n      not-found\n      k)))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.7.228",
                                                  :filename "src/main/cljs/cljs/core.cljs",
                                                  :lines [8075 8110]},
                                         :full-name "cljs.core/TransientHashSet",
                                         :clj-symbol "clojure.lang/TransientHashSet"},
           "cljs.core/*flush-on-newline*" {:ns "cljs.core",
                                           :name "*flush-on-newline*",
                                           :history [["+" "0.0-927"]],
                                           :type "dynamic var",
                                           :full-name-encode "cljs.core/STARflush-on-newlineSTAR",
                                           :source {:code "(def\n  ^{:dynamic true\n    :doc \"When set to true, output will be flushed whenever a newline is printed.\n\n  Defaults to true.\"}\n  *flush-on-newline* true)",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.7.228",
                                                    :filename "src/main/cljs/cljs/core.cljs",
                                                    :lines [67 72]},
                                           :full-name "cljs.core/*flush-on-newline*",
                                           :clj-symbol "clojure.core/*flush-on-newline*",
                                           :docstring "When set to true, output will be flushed whenever a newline is printed.\n\nDefaults to true."},
           "cljs.core/get-in" {:description "Returns the value in a nested associative structure, where `ks` is a sequence of\nkeys.\n\nReturns nil if the key is not found, or `not-found` if supplied.",
                               :ns "cljs.core",
                               :name "get-in",
                               :signature ["[m ks]"
                                           "[m ks not-found]"],
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :related ["cljs.core/assoc-in"
                                         "cljs.core/update-in"
                                         "cljs.core/find"
                                         "cljs.core/get"],
                               :full-name-encode "cljs.core/get-in",
                               :source {:code "(defn get-in\n  ([m ks]\n     (get-in m ks nil))\n  ([m ks not-found]\n     (loop [sentinel lookup-sentinel\n            m m\n            ks (seq ks)]\n       (if ks\n         (if (not (satisfies? ILookup m))\n           not-found\n           (let [m (get m (first ks) sentinel)]\n             (if (identical? sentinel m)\n               not-found\n               (recur sentinel m (next ks)))))\n         m))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.228",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [4547 4566]},
                               :full-name "cljs.core/get-in",
                               :clj-symbol "clojure.core/get-in",
                               :docstring "Returns the value in a nested associative structure,\nwhere ks is a sequence of keys. Returns nil if the key is not present,\nor the not-found value if supplied."},
           "clojure.browser.dom/element" {:ns "clojure.browser.dom",
                                          :name "element",
                                          :type "function",
                                          :signature ["[tag-or-text]"
                                                      "[tag & children]"],
                                          :source {:code "(defn element\n  ([tag-or-text]\n     (log \"(element \" tag-or-text \")\")\n     (-element tag-or-text))\n  ([tag & children]\n     (log \"(element \" tag \" \" children \")\")\n     (let [attrs (first children)]\n       (if (map? attrs)\n         (-element tag attrs (rest children))\n         (-element tag nil children)))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.7.228",
                                                   :filename "src/main/cljs/clojure/browser/dom.cljs",
                                                   :lines [81 90]},
                                          :full-name "clojure.browser.dom/element",
                                          :full-name-encode "clojure.browser.dom/element",
                                          :history [["+" "0.0-927"]]},
           "cljs.core/prim-seq" {:ns "cljs.core",
                                 :name "prim-seq",
                                 :signature ["[prim]" "[prim i]"],
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/prim-seq",
                                 :source {:code "(defn prim-seq\n  ([prim]\n     (prim-seq prim 0))\n  ([prim i]\n     (when (< i (alength prim))\n       (IndexedSeq. prim i))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [1458 1464]},
                                 :full-name "cljs.core/prim-seq",
                                 :docstring "Create seq from a primitive JavaScript Array-like."},
           "cljs.pprint/pprint-logical-block" {:ns "cljs.pprint",
                                               :name "pprint-logical-block",
                                               :signature ["[& args]"],
                                               :history [["+"
                                                          "0.0-3255"]],
                                               :type "macro",
                                               :full-name-encode "cljs.pprint/pprint-logical-block",
                                               :source {:code "(defmacro pprint-logical-block\n  [& args]\n  (let [[options body] (parse-lb-options #{:prefix :per-line-prefix :suffix} args)]\n    `(do (if (cljs.pprint/level-exceeded)\n           (~'-write cljs.core/*out* \"#\")\n           (do\n             (cljs.core/binding [cljs.pprint/*current-level* (inc cljs.pprint/*current-level*)\n                       cljs.pprint/*current-length* 0]\n               (cljs.pprint/start-block cljs.core/*out*\n                                        ~(:prefix options)\n                                        ~(:per-line-prefix options)\n                                        ~(:suffix options))\n               ~@body\n               (cljs.pprint/end-block cljs.core/*out*))))\n         nil)))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.7.228",
                                                        :filename "src/main/cljs/cljs/pprint.clj",
                                                        :lines [57 79]},
                                               :full-name "cljs.pprint/pprint-logical-block",
                                               :clj-symbol "clojure.pprint/pprint-logical-block",
                                               :docstring "Execute the body as a pretty printing logical block with output to *out* which\nmust be a pretty printing writer. When used from pprint or cl-format, this can be\nassumed.\n\nThis function is intended for use when writing custom dispatch functions.\n\nBefore the body, the caller can optionally specify options: :prefix, :per-line-prefix\nand :suffix."},
           "cljs.core/<=" {:description "Returns true if each successive number argument is greater than or equal to the\nprevious one, false otherwise.",
                           :return-type boolean,
                           :ns "cljs.core",
                           :name "<=",
                           :signature ["[x]" "[x y]" "[x y & more]"],
                           :history [["+" "0.0-927"]],
                           :type "function/macro",
                           :related ["cljs.core/<"],
                           :full-name-encode "cljs.core/LTEQ",
                           :source {:code "(defn ^boolean <=\n  ([x] true)\n  ([x y] (cljs.core/<= x y))\n  ([x y & more]\n   (if (cljs.core/<= x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (cljs.core/<= y (first more)))\n     false)))",
                                    :title "Function code",
                                    :repo "clojurescript",
                                    :tag "r1.7.228",
                                    :filename "src/main/cljs/cljs/core.cljs",
                                    :lines [2302 2312]},
                           :extra-sources [{:code "(core/defmacro ^::ana/numeric <=\n  ([x] true)\n  ([x y] (bool-expr (core/list 'js* \"(~{} <= ~{})\" x y)))\n  ([x y & more] `(and (<= ~x ~y) (<= ~y ~@more))))",
                                            :title "Macro code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/clojure/cljs/core.cljc",
                                            :lines [1042 1045]}],
                           :examples [{:id "adb3fd",
                                       :content "```clj\n(<= 1 2)\n;;=> true\n\n(<= 2 2)\n;;=> true\n\n(<= 3 2)\n;;=> false\n\n(<= 2 3 4 5 6)\n;;=> true\n```"}],
                           :full-name "cljs.core/<=",
                           :clj-symbol "clojure.core/<=",
                           :docstring "Returns non-nil if nums are in monotonically non-decreasing order,\notherwise false."},
           "cljs.compiler.api/compile-root" {:ns "cljs.compiler.api",
                                             :name "compile-root",
                                             :signature ["[src-dir]"
                                                         "[src-dir target-dir]"
                                                         "[src-dir target-dir opts]"
                                                         "[state src-dir target-dir opts]"],
                                             :history [["+"
                                                        "0.0-3255"]],
                                             :type "function",
                                             :full-name-encode "cljs.compiler.api/compile-root",
                                             :source {:code "(defn compile-root\n  ([src-dir] (compile-root src-dir \"out\"))\n  ([src-dir target-dir] (compile-root src-dir target-dir nil))\n  ([src-dir target-dir opts]\n   (compile-root\n     (if-not (nil? env/*compiler*)\n       env/*compiler*\n       (env/default-compiler-env opts))\n     src-dir target-dir opts))\n  ([state src-dir target-dir opts]\n   (env/with-compiler-env state\n     (binding [ana/*cljs-warning-handlers* (:warning-handlers opts ana/*cljs-warning-handlers*)]\n       (comp/compile-root src-dir target-dir opts)))))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.7.228",
                                                      :filename "src/main/clojure/cljs/compiler/api.clj",
                                                      :lines [93 110]},
                                             :full-name "cljs.compiler.api/compile-root",
                                             :docstring "Looks recursively in src-dir for .cljs files and compiles them to\n.js files. If target-dir is provided, output will go into this\ndirectory mirroring the source directory structure. Returns a list\nof maps containing information about each file which was compiled\nin dependency order."},
           "clojure.set/map-invert" {:ns "clojure.set",
                                     :name "map-invert",
                                     :signature ["[m]"],
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "clojure.set/map-invert",
                                     :source {:code "(defn map-invert\n  [m] (reduce (fn [m [k v]] (assoc m v k)) {} m))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/cljs/clojure/set.cljs",
                                              :lines [97 99]},
                                     :full-name "clojure.set/map-invert",
                                     :clj-symbol "clojure.set/map-invert",
                                     :docstring "Returns the map with the vals mapped to the keys."},
           "clojure.browser.event/listen" {:ns "clojure.browser.event",
                                           :name "listen",
                                           :type "function",
                                           :signature ["[src type fn]"
                                                       "[src type fn capture?]"],
                                           :source {:code "(defn listen\n  ([src type fn]\n     (listen src type fn false))\n  ([src type fn capture?]\n     (events/listen src\n                    (get (event-types src) type type)\n                    fn\n                    capture?)))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.7.228",
                                                    :filename "src/main/cljs/clojure/browser/event.cljs",
                                                    :lines [46 53]},
                                           :full-name "clojure.browser.event/listen",
                                           :full-name-encode "clojure.browser.event/listen",
                                           :history [["+" "0.0-927"]]},
           "cljs.core/neg?" {:description "Returns true if `n` is less than 0, false otherwise.",
                             :return-type boolean,
                             :ns "cljs.core",
                             :name "neg?",
                             :signature ["[n]"],
                             :history [["+" "0.0-927"]],
                             :type "function/macro",
                             :related ["cljs.core/pos?"
                                       "cljs.core/zero?"],
                             :full-name-encode "cljs.core/negQMARK",
                             :source {:code "(defn ^boolean neg?\n  [x] (cljs.core/neg? x))",
                                      :title "Function code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [2601 2603]},
                             :extra-sources [{:code "(core/defmacro ^::ana/numeric neg? [x]\n  `(< ~x 0))",
                                              :title "Macro code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/clojure/cljs/core.cljc",
                                              :lines [1074 1075]}],
                             :full-name "cljs.core/neg?",
                             :clj-symbol "clojure.core/neg?",
                             :docstring "Returns true if num is less than zero, else false"},
           "cljs.analyzer.api/ns-interns" {:ns "cljs.analyzer.api",
                                           :name "ns-interns",
                                           :signature ["[ns]"
                                                       "[state ns]"],
                                           :history [["+" "0.0-2496"]],
                                           :type "function",
                                           :full-name-encode "cljs.analyzer.api/ns-interns",
                                           :source {:code "(defn ns-interns\n  ([ns]\n   (ns-interns env/*compiler* ns))\n  ([state ns]\n   {:pre [(symbol? ns)]}\n   (merge\n     (get-in @state [::ana/namespaces ns :macros])\n     (get-in @state [::ana/namespaces ns :defs]))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.7.228",
                                                    :filename "src/main/clojure/cljs/analyzer/api.clj",
                                                    :lines [169 178]},
                                           :full-name "cljs.analyzer.api/ns-interns",
                                           :clj-symbol "clojure.core/ns-interns",
                                           :docstring "Given a namespace return all the var analysis maps. Analagous to\nclojure.core/ns-interns but returns var analysis maps not vars."},
           "cljs.repl.browser/firefox-clean-function" {:ns "cljs.repl.browser",
                                                       :name "firefox-clean-function",
                                                       :signature ["[f]"],
                                                       :history [["+"
                                                                  "0.0-3053"]
                                                                 ["-"
                                                                  "1.7.10"]],
                                                       :type "function",
                                                       :full-name-encode "cljs.repl.browser/firefox-clean-function",
                                                       :source {:code "(defn firefox-clean-function [f]\n  (as-> f f\n    (cond\n      (string/blank? f) nil\n      (not= (.indexOf f \"</\") -1)\n      (let [idx (.indexOf f \"</\")]\n        (.substring f (+ idx 2)))\n      :else f)\n    (-> f\n      (string/replace #\"<\" \"\")\n      (string/replace #\"\\/\" \"\"))))",
                                                                :title "Source code",
                                                                :repo "clojurescript",
                                                                :tag "r3308",
                                                                :filename "src/main/clojure/cljs/repl/browser.clj",
                                                                :lines [392
                                                                        402]},
                                                       :full-name "cljs.repl.browser/firefox-clean-function",
                                                       :removed {:in "1.7.10",
                                                                 :last-seen "0.0-3308"}},
           "cljs.core/mix-collection-hash" {:return-type number,
                                            :ns "cljs.core",
                                            :name "mix-collection-hash",
                                            :signature ["[hash-basis count]"],
                                            :history [["+" "0.0-2261"]],
                                            :type "function",
                                            :full-name-encode "cljs.core/mix-collection-hash",
                                            :source {:code "(defn ^number mix-collection-hash\n  [hash-basis count]\n  (let [h1 m3-seed\n        k1 (m3-mix-K1 hash-basis)\n        h1 (m3-mix-H1 h1 k1)]\n    (m3-fmix h1 count)))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.7.228",
                                                     :filename "src/main/cljs/cljs/core.cljs",
                                                     :lines [1181
                                                             1191]},
                                            :full-name "cljs.core/mix-collection-hash",
                                            :clj-symbol "clojure.core/mix-collection-hash",
                                            :docstring "Mix final collection hash for ordered or unordered collections.\nhash-basis is the combined collection hash, count is the number\nof elements included in the basis. Note this is the hash code\nconsistent with =, different from .hashCode.\nSee http://clojure.org/data_structures#hash for full algorithms."},
           "clojure.browser.dom/replace-node" {:ns "clojure.browser.dom",
                                               :name "replace-node",
                                               :signature ["[old-node new-node]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "clojure.browser.dom/replace-node",
                                               :source {:code "(defn replace-node\n  [old-node new-node]\n  (let [old-node (ensure-element old-node)\n        new-node (ensure-element new-node)]\n    (gdom/replaceNode new-node old-node)\n    new-node))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.7.228",
                                                        :filename "src/main/cljs/clojure/browser/dom.cljs",
                                                        :lines [114
                                                                122]},
                                               :full-name "clojure.browser.dom/replace-node",
                                               :docstring "Replace old-node with new-node. old-node can be an element or a\nkeyword which is the id of the node to replace.  new-node can be an\nelement or an html string."},
           "syntax/boolean" {:description "Special symbols representing the boolean literals `true` and `false`.\nBoth evaluate to themselves.",
                             :ns "syntax",
                             :name "boolean",
                             :history [["+" "0.0-927"]],
                             :type "special symbol",
                             :related ["cljs.core/boolean"
                                       "special/if"
                                       "cljs.core/not"
                                       "cljs.core/true?"
                                       "cljs.core/false?"],
                             :full-name-encode "syntax/boolean",
                             :extra-sources [{:code "(defn- read-symbol\n  [rdr initch]\n  (let [[line column] (starting-line-col-info rdr)]\n    (when-let [token (read-token rdr initch)]\n      (case token\n\n        ;; special symbols\n        \"nil\" nil\n        \"true\" true\n        \"false\" false\n        \"/\" '/\n        \"NaN\" Double/NaN\n        \"-Infinity\" Double/NEGATIVE_INFINITY\n        (\"Infinity\" \"+Infinity\") Double/POSITIVE_INFINITY\n\n        (or (when-let [p (parse-symbol token)]\n              (with-meta (symbol (p 0) (p 1))\n                (when line\n                  (merge\n                   (when-let [file (get-file-name rdr)]\n                     {:file file})\n                   (let [[end-line end-column] (ending-line-col-info rdr)]\n                     {:line line\n                      :column column\n                      :end-line end-line\n                      :end-column end-column})))))\n            (reader-error rdr \"Invalid token: \" token))))))",
                                              :title "Reader code",
                                              :repo "tools.reader",
                                              :tag "tools.reader-1.0.0-alpha1",
                                              :filename "src/main/clojure/clojure/tools/reader.clj",
                                              :lines [303 329]}],
                             :usage ["true" "false"],
                             :examples [{:id "1afc59",
                                         :content "```clj\ntrue\n;;=> true\n\nfalse\n;;=> false\n```"}],
                             :edn-doc "https://github.com/edn-format/edn#booleans",
                             :full-name "syntax/boolean",
                             :display "boolean literal",
                             :clj-doc "http://clojure.org/reader#toc1"},
           "cljs.core/TaggedLiteral" {:ns "cljs.core",
                                      :name "TaggedLiteral",
                                      :signature ["[tag form]"],
                                      :history [["+" "0.0-3255"]],
                                      :type "type",
                                      :full-name-encode "cljs.core/TaggedLiteral",
                                      :source {:code "(deftype TaggedLiteral [tag form]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n\n  IEquiv\n  (-equiv [this other]\n    (and (instance? TaggedLiteral other)\n         (= tag (.-tag other))\n         (= form (.-form other))))\n\n  IHash\n  (-hash [this]\n    (+ (* 31 (hash tag))\n       (hash form)))\n\n  ILookup\n  (-lookup [this v]\n    (-lookup this v nil))\n  (-lookup [this v not-found]\n    (case v\n      :tag tag\n      :form form\n      not-found))\n\n  IPrintWithWriter\n  (-pr-writer [o writer opts]\n    (-write writer (str \"#\" tag \" \"))\n    (pr-writer form writer opts)))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [9972 10000]},
                                      :full-name "cljs.core/TaggedLiteral",
                                      :clj-symbol "clojure.lang/TaggedLiteral"},
           "cljs.core/DEMUNGE_PATTERN" {:ns "cljs.core",
                                        :name "DEMUNGE_PATTERN",
                                        :type "var",
                                        :source {:code "(def DEMUNGE_PATTERN nil)",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.228",
                                                 :filename "src/main/cljs/cljs/core.cljs",
                                                 :lines [337]},
                                        :full-name "cljs.core/DEMUNGE_PATTERN",
                                        :full-name-encode "cljs.core/DEMUNGE_PATTERN",
                                        :history [["+" "1.7.10"]]},
           "special/catch" {:description "`catch` should be used inside of a `try` expression.\n\n`exception-type` should be the type of exception thrown (usually `js/Error` or\n`js/Object`). When there is a match, the thrown exception will be bound to\n`name` inside of `expr*` and `expr*` will be evaluated and returned as the value\nof the `try` expression.\n\nSince JavaScript allows you to throw anything, `exception-type` can be set to\n`:default` to catch all types of exceptions.",
                            :ns "special",
                            :name "catch",
                            :signature ["[exception-type name expr*]"],
                            :history [["+" "0.0-927"]],
                            :type "special form",
                            :related ["special/try"
                                      "special/finally"
                                      "special/throw"],
                            :full-name-encode "special/catch",
                            :source {:code "(defmethod parse 'try\n  [op env [_ & body :as form] name _]\n  (let [catchenv (update-in env [:context] #(if (= :expr %) :return %))\n        catch? (every-pred seq? #(= (first %) 'catch))\n        default? (every-pred catch? #(= (second %) :default))\n        finally? (every-pred seq? #(= (first %) 'finally))\n\n        {:keys [body cblocks dblock fblock]}\n        (loop [parser {:state :start :forms body\n                       :body [] :cblocks [] :dblock nil :fblock nil}]\n          (if (seq? (:forms parser))\n            (let [[form & forms*] (:forms parser)\n                  parser* (assoc parser :forms forms*)]\n              (case (:state parser)\n                :start (cond\n                         (catch? form) (recur (assoc parser :state :catches))\n                         (finally? form) (recur (assoc parser :state :finally))\n                         :else (recur (update-in parser* [:body] conj form)))\n                :catches (cond\n                           (default? form) (recur (assoc parser* :dblock form :state :finally))\n                           (catch? form) (recur (update-in parser* [:cblocks] conj form))\n                           (finally? form) (recur (assoc parser :state :finally))\n                           :else (throw (error env \"Invalid try form\")))\n                :finally (recur (assoc parser* :fblock form :state :done))\n                :done (throw (error env \"Unexpected form after finally\"))))\n            parser))\n\n        finally (when (seq fblock)\n                  (analyze (assoc env :context :statement) `(do ~@(rest fblock))))\n        e (when (or (seq cblocks) dblock) (gensym \"e\"))\n        default (if-let [[_ _ name & cb] dblock]\n                  `(cljs.core/let [~name ~e] ~@cb)\n                  `(throw ~e))\n        cblock (if (seq cblocks)\n                 `(cljs.core/cond\n                   ~@(mapcat\n                      (fn [[_ type name & cb]]\n                        (when name (assert (not (namespace name)) \"Can't qualify symbol in catch\"))\n                        `[(cljs.core/instance? ~type ~e)\n                          (cljs.core/let [~name ~e] ~@cb)])\n                      cblocks)\n                   :else ~default)\n                 default)\n        locals (:locals catchenv)\n        locals (if e\n                 (assoc locals e\n                        {:name e\n                         :line (get-line e env)\n                         :column (get-col e env)})\n                 locals)\n        catch (when cblock\n                (analyze (assoc catchenv :locals locals) cblock))\n        try (analyze (if (or e finally) catchenv env) `(do ~@body))]\n\n    {:env env :op :try :form form\n     :try try\n     :finally finally\n     :name e\n     :catch catch\n     :children [try catch finally]}))",
                                     :title "Parser code",
                                     :repo "clojurescript",
                                     :tag "r1.7.228",
                                     :filename "src/main/clojure/cljs/analyzer.cljc",
                                     :lines [1008 1067]},
                            :full-name "special/catch",
                            :clj-symbol "clojure.core/catch",
                            :docstring "catch-clause => (catch classname name expr*)\nfinally-clause => (finally expr*)\nCatches and handles JavaScript exceptions."},
           "cljs.core/reverse" {:description "Returns a sequence of the items in `coll` in reverse order. Not lazy.",
                                :ns "cljs.core",
                                :name "reverse",
                                :signature ["[coll]"],
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :related ["cljs.core/rseq"],
                                :full-name-encode "cljs.core/reverse",
                                :source {:code "(defn reverse\n  [coll]\n  (if (reversible? coll)\n    (rseq coll)\n    (reduce conj () coll)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [2834 2839]},
                                :full-name "cljs.core/reverse",
                                :clj-symbol "clojure.core/reverse",
                                :docstring "Returns a seq of the items in coll in reverse order. Not lazy."},
           "cljs.repl.browser/ordering" {:ns "cljs.repl.browser",
                                         :name "ordering",
                                         :type "dynamic var",
                                         :source {:code "(def ^:dynamic ordering nil)",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.7.228",
                                                  :filename "src/main/clojure/cljs/repl/browser.clj",
                                                  :lines [25]},
                                         :full-name "cljs.repl.browser/ordering",
                                         :full-name-encode "cljs.repl.browser/ordering",
                                         :history [["+" "0.0-927"]]},
           "cljs.pprint/*out*" {:ns "cljs.pprint",
                                :name "*out*",
                                :type "dynamic var",
                                :source {:code "(def ^:dynamic *out* nil)",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r3308",
                                         :filename "src/main/cljs/cljs/pprint.cljs",
                                         :lines [21]},
                                :full-name "cljs.pprint/*out*",
                                :full-name-encode "cljs.pprint/STARoutSTAR",
                                :history [["+" "0.0-3255"]
                                          ["-" "1.7.10"]],
                                :removed {:in "1.7.10",
                                          :last-seen "0.0-3308"}},
           "cljs.core/realized?" {:description "Returns true if a value has been produced for a lazy sequence.",
                                  :return-type boolean,
                                  :ns "cljs.core",
                                  :name "realized?",
                                  :signature ["[x]"],
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :related ["cljs.core/lazy-seq"],
                                  :full-name-encode "cljs.core/realizedQMARK",
                                  :source {:code "(defn ^boolean realized?\n  [x]\n  (-realized? x))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [9216 9219]},
                                  :full-name "cljs.core/realized?",
                                  :clj-symbol "clojure.core/realized?",
                                  :docstring "Returns true if a value has been produced for a delay or lazy sequence."},
           "cljs.core/ensure-reduced" {:ns "cljs.core",
                                       :name "ensure-reduced",
                                       :signature ["[x]"],
                                       :history [["+" "0.0-2411"]],
                                       :type "function",
                                       :full-name-encode "cljs.core/ensure-reduced",
                                       :source {:code "(defn ensure-reduced\n  [x]\n  (if (reduced? x) x (reduced x)))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/cljs/core.cljs",
                                                :lines [1282 1285]},
                                       :full-name "cljs.core/ensure-reduced",
                                       :clj-symbol "clojure.core/ensure-reduced",
                                       :docstring "If x is already reduced?, returns it, else returns (reduced x)"}},
 :namespaces {"cljs.repl.server" {:ns "cljs.repl.server",
                                  :type "namespace",
                                  :source {:code "(ns cljs.repl.server\n  (:refer-clojure :exclude [loaded-libs])\n  (:require [clojure.string :as str])\n  (:import java.io.BufferedReader\n           java.io.InputStreamReader\n           java.net.ServerSocket))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.228",
                                           :filename "src/main/clojure/cljs/repl/server.clj",
                                           :lines [1 6]},
                                  :full-name "cljs.repl.server",
                                  :full-name-encode "cljs.repl.server",
                                  :history [["+" "0.0-1503"]]},
              "clojure.zip" {:caption "functional hierarchical zipper, w/ navigation/editing/enumeration",
                             :ns "clojure.zip",
                             :history [["+" "0.0-927"]],
                             :type "namespace",
                             :full-name-encode "clojure.zip",
                             :source {:code "(ns ^{:doc \"Functional hierarchical zipper, with navigation, editing,\n  and enumeration.  See Huet\"\n       :author \"Rich Hickey\"}\n  clojure.zip\n  (:refer-clojure :exclude (replace remove next)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/clojure/zip.cljs",
                                      :lines [12 16]},
                             :clj-ns "clojure.zip",
                             :author "Rich Hickey",
                             :full-name "clojure.zip",
                             :docstring "Functional hierarchical zipper, with navigation, editing,\n  and enumeration.  See Huet"},
              "clojure.reflect" {:ns "clojure.reflect",
                                 :type "namespace",
                                 :source {:code "(ns clojure.reflect\n  ^{:doc \"DEPRECATED. Do not use, superceded by REPL enhancements.\"}\n  (:refer-clojure :exclude [meta])\n  (:require [clojure.browser.net :as net]\n            [clojure.browser.event :as event]))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/cljs/clojure/reflect.cljs",
                                          :lines [1 5]},
                                 :full-name "clojure.reflect",
                                 :full-name-encode "clojure.reflect",
                                 :clj-ns "clojure.reflect",
                                 :history [["+" "0.0-1503"]],
                                 :caption "deprecated"},
              "cljs.compiler.api" {:ns "cljs.compiler.api",
                                   :docstring "This is intended to be a stable api for those who need programmatic access\n  to the compiler.",
                                   :type "namespace",
                                   :source {:code "(ns cljs.compiler.api\n  \"This is intended to be a stable api for those who need programmatic access\n  to the compiler.\"\n  (:require [cljs.util :as util]\n            [cljs.env :as env]\n            [cljs.analyzer :as ana]\n            [cljs.compiler :as comp]))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/clojure/cljs/compiler/api.clj",
                                            :lines [9 15]},
                                   :full-name "cljs.compiler.api",
                                   :full-name-encode "cljs.compiler.api",
                                   :history [["+" "0.0-3255"]],
                                   :caption "programmatic access to the compiler (emitting JS)"},
              "cljs.test" {:caption "a unit-testing framework",
                           :ns "cljs.test",
                           :history [["+" "0.0-2496"]],
                           :type "namespace",
                           :full-name-encode "cljs.test",
                           :source {:code "(ns\n^{:author \"Stuart Sierra, with contributions and suggestions by \n  Chas Emerick, Allen Rohner, Stuart Halloway, David Nolen, and\n  Leon Grapenthin\",\n     :doc \"A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the \\\"is\\\" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (= 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith \\\"abcde\\\" \\\"ab\\\"))\n\n   You can type an \\\"is\\\" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user> (is (= 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (= 5 (+ 2 2))\n         actual: (not (= 5 4))\n       false\n\n   The \\\"expected:\\\" line shows you the original expression, and the\n   \\\"actual:\\\" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not = to 5.  Finally, the\n   \\\"false\\\" on the last line is the value returned from the\n   expression.  The \\\"is\\\" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   \\\"(is (thrown? c ...))\\\" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0))) \n\n   \\\"(is (thrown-with-msg? c re ...))\\\" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #\\\"Divide by zero\\\"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   \\\"is\\\" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (= 5 (+ 2 2)) \\\"Crazy arithmetic\\\")\n\n   In addition, you can document groups of assertions with the\n   \\\"testing\\\" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to \\\"testing\\\" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec <http://rspec.info/>\n\n   (testing \\\"Arithmetic\\\"\n     (testing \\\"with positive integers\\\"\n       (is (= 4 (+ 2 2)))\n       (is (= 7 (+ 3 4))))\n     (testing \\\"with negative integers\\\"\n       (is (= -4 (+ -2 -2)))\n       (is (= -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the \\\"testing\\\" macro may only be used\n   INSIDE a \\\"deftest\\\" form (see below).\n\n\n   DEFINING TESTS\n\n   (deftest addition\n     (is (= 4 (+ 2 2)))\n     (is (= 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (= 1 (- 4 3)))\n     (is (= 3 (- 7 4))))\n\n   This creates functions named \\\"addition\\\" and \\\"subtraction\\\", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel's \\\"Practical Common Lisp\\\"\n   <http://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html>\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   \\\"(arithmetic addition)\\\", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n   DEFINING ASYNC TESTS\n\n   (deftest addition\n     (async done\n       (is (= 4 (+ 2 2)))\n       (is (= 7 (+ 3 4)))\n       (done)))\n\n   Async tests are constructed with the async macro. The first argument to\n   the macro is the test completion callback. The body of the async macro may\n   be any series of expressions. The completion callback must be invoked when\n   all assertions have run. There is no support for asynchronous coordination -\n   core.async is recommended for this. Note the body of the async test must be\n   truly asynchronous to avoid stack overflow.\n\n   RUNNING TESTS\n\n   Run tests with the function \\\"(run-tests namespaces...)\\\":\n\n   (run-tests 'your.namespace 'some.other.namespace)\n\n   If you don't specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use \\\"(run-all-tests)\\\".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the \\\"arithmetic\\\" example above, you\n   probably do not want the \\\"addition\\\" and \\\"subtraction\\\" tests run\n   separately.  In that case, you must define a special function\n   named \\\"test-ns-hook\\\" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   \\\"run-tests\\\" also optionally takes a testing enviroment. A default\n   one is supplied for you by invoking \\\"empty-env\\\".  The test\n   environment contains everything needed to run tests including the\n   report results map. Fixtures must be present here if you want them\n   to run. Note that code that relies on \\\"test-ns\\\" will\n   automatically be supplied the appropriate defined fixtures.  For\n   example, this is done for you if you use \\\"run-tests\\\".\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can set the ClojureScript compiler build option\n   \\\":load-tests\\\" to false when loading or compiling code in\n   production.  This will prevent any tests from being created by\n   or \\\"deftest\\\".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is a map of one or two functions that run code before and\n   after tests.  It looks like this:\n\n   {:before (fn []\n              Perform setup, establish bindings, whatever.\n              )\n    :after (fn []\n             Tear-down / clean-up code here.\n             )}\n\n   Both are optional and can be left out.\n\n   Fixtures are attached to namespaces in one of two ways.  \\\"each\\\"\n   fixtures are run repeatedly, once for each test function created\n   with \\\"deftest\\\".  \\\"each\\\" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   \\\"each\\\" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just maps like the example above.\n   They can also be passed directly, like this:\n   (use-fixtures :each\n     {:before (fn [] setup...), :after (fn [] cleanup...)})\n\n   The other kind of fixture, a \\\"once\\\" fixture, is only run once,\n   around ALL the tests in the namespace.  \\\"once\\\" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach \\\"once\\\" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   WRAPPING FIXTURES\n\n   Instead of a map, a fixture can be specified like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   This style is incompatible with async tests. If an async test is\n   encountered, testing will be aborted. It can't be mixed with\n   fixtures specified as maps.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the \\\"is\\\" macro by defining new\n   methods for the \\\"assert-expr\\\" multimethod.  These methods are\n   called during expansion of the \\\"is\\\" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by specifying a\n   :reporter key in the test environment. It is normally set to\n   :cljs.test/default. Set this to the desired key and supply custom\n   implementations of the \\\"report\\\" multimethod.\n\n   The 'event' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to 'is'\n\n   The \\\"testing\\\" strings will be a list in the :testing-contexts\n   property of the test environment, and the vars being tested will be\n   a list in the :testing-vars property of the test environment.\n\n   For additional event types, see the examples in the code.\n\"}\n  cljs.test\n  (:require-macros [clojure.template :as temp]\n                   [cljs.test :as test])\n  (:require [clojure.string :as string]\n            [cljs.pprint :as pprint]))",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r1.7.228",
                                    :filename "src/main/cljs/cljs/test.cljs",
                                    :lines [9 247]},
                           :clj-ns "clojure.test",
                           :author "Stuart Sierra, with contributions and suggestions by \n  Chas Emerick, Allen Rohner, Stuart Halloway, David Nolen, and\n  Leon Grapenthin",
                           :full-name "cljs.test",
                           :docstring "A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the \"is\" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (= 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith \"abcde\" \"ab\"))\n\n   You can type an \"is\" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user> (is (= 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (= 5 (+ 2 2))\n         actual: (not (= 5 4))\n       false\n\n   The \"expected:\" line shows you the original expression, and the\n   \"actual:\" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not = to 5.  Finally, the\n   \"false\" on the last line is the value returned from the\n   expression.  The \"is\" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   \"(is (thrown? c ...))\" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0))) \n\n   \"(is (thrown-with-msg? c re ...))\" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #\"Divide by zero\"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   \"is\" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (= 5 (+ 2 2)) \"Crazy arithmetic\")\n\n   In addition, you can document groups of assertions with the\n   \"testing\" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to \"testing\" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec <http://rspec.info/>\n\n   (testing \"Arithmetic\"\n     (testing \"with positive integers\"\n       (is (= 4 (+ 2 2)))\n       (is (= 7 (+ 3 4))))\n     (testing \"with negative integers\"\n       (is (= -4 (+ -2 -2)))\n       (is (= -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the \"testing\" macro may only be used\n   INSIDE a \"deftest\" form (see below).\n\n\n   DEFINING TESTS\n\n   (deftest addition\n     (is (= 4 (+ 2 2)))\n     (is (= 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (= 1 (- 4 3)))\n     (is (= 3 (- 7 4))))\n\n   This creates functions named \"addition\" and \"subtraction\", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel's \"Practical Common Lisp\"\n   <http://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html>\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   \"(arithmetic addition)\", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n   DEFINING ASYNC TESTS\n\n   (deftest addition\n     (async done\n       (is (= 4 (+ 2 2)))\n       (is (= 7 (+ 3 4)))\n       (done)))\n\n   Async tests are constructed with the async macro. The first argument to\n   the macro is the test completion callback. The body of the async macro may\n   be any series of expressions. The completion callback must be invoked when\n   all assertions have run. There is no support for asynchronous coordination -\n   core.async is recommended for this. Note the body of the async test must be\n   truly asynchronous to avoid stack overflow.\n\n   RUNNING TESTS\n\n   Run tests with the function \"(run-tests namespaces...)\":\n\n   (run-tests 'your.namespace 'some.other.namespace)\n\n   If you don't specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use \"(run-all-tests)\".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the \"arithmetic\" example above, you\n   probably do not want the \"addition\" and \"subtraction\" tests run\n   separately.  In that case, you must define a special function\n   named \"test-ns-hook\" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   \"run-tests\" also optionally takes a testing enviroment. A default\n   one is supplied for you by invoking \"empty-env\".  The test\n   environment contains everything needed to run tests including the\n   report results map. Fixtures must be present here if you want them\n   to run. Note that code that relies on \"test-ns\" will\n   automatically be supplied the appropriate defined fixtures.  For\n   example, this is done for you if you use \"run-tests\".\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can set the ClojureScript compiler build option\n   \":load-tests\" to false when loading or compiling code in\n   production.  This will prevent any tests from being created by\n   or \"deftest\".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is a map of one or two functions that run code before and\n   after tests.  It looks like this:\n\n   {:before (fn []\n              Perform setup, establish bindings, whatever.\n              )\n    :after (fn []\n             Tear-down / clean-up code here.\n             )}\n\n   Both are optional and can be left out.\n\n   Fixtures are attached to namespaces in one of two ways.  \"each\"\n   fixtures are run repeatedly, once for each test function created\n   with \"deftest\".  \"each\" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   \"each\" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just maps like the example above.\n   They can also be passed directly, like this:\n   (use-fixtures :each\n     {:before (fn [] setup...), :after (fn [] cleanup...)})\n\n   The other kind of fixture, a \"once\" fixture, is only run once,\n   around ALL the tests in the namespace.  \"once\" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach \"once\" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   WRAPPING FIXTURES\n\n   Instead of a map, a fixture can be specified like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   This style is incompatible with async tests. If an async test is\n   encountered, testing will be aborted. It can't be mixed with\n   fixtures specified as maps.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the \"is\" macro by defining new\n   methods for the \"assert-expr\" multimethod.  These methods are\n   called during expansion of the \"is\" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by specifying a\n   :reporter key in the test environment. It is normally set to\n   :cljs.test/default. Set this to the desired key and supply custom\n   implementations of the \"report\" multimethod.\n\n   The 'event' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to 'is'\n\n   The \"testing\" strings will be a list in the :testing-contexts\n   property of the test environment, and the vars being tested will be\n   a list in the :testing-vars property of the test environment.\n\n   For additional event types, see the examples in the code.\n"},
              "cljs.repl.browser" {:ns "cljs.repl.browser",
                                   :type "namespace",
                                   :source {:code "(ns cljs.repl.browser\n  (:refer-clojure :exclude [loaded-libs])\n  (:require [clojure.java.io :as io]\n            [clojure.string :as string]\n            [clojure.edn :as edn]\n            [cljs.compiler :as comp]\n            [cljs.util :as util]\n            [cljs.env :as env]\n            [cljs.closure :as cljsc]\n            [cljs.repl :as repl]\n            [cljs.repl.server :as server]\n            [cljs.stacktrace :as st])\n  (:import [java.util.regex Pattern]\n           [java.util.concurrent Executors]))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/clojure/cljs/repl/browser.clj",
                                            :lines [9 22]},
                                   :full-name "cljs.repl.browser",
                                   :full-name-encode "cljs.repl.browser",
                                   :history [["+" "0.0-927"]],
                                   :caption "browser-connected REPL"},
              "cljs.repl.rhino" {:ns "cljs.repl.rhino",
                                 :type "namespace",
                                 :source {:code "(ns cljs.repl.rhino\n  (:refer-clojure :exclude [load-file])\n  (:require [clojure.string :as string]\n            [clojure.java.io :as io]\n            [cljs.compiler :as comp]\n            [cljs.closure :as closure]\n            [cljs.analyzer :as ana]\n            [cljs.repl :as repl]\n            [cljs.util :as util]\n            [cljs.stacktrace :as st])\n  (:import [java.io File Reader]\n           [org.mozilla.javascript Context ScriptableObject\n                                   RhinoException Undefined]))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.228",
                                          :filename "src/main/clojure/cljs/repl/rhino.clj",
                                          :lines [9 21]},
                                 :full-name "cljs.repl.rhino",
                                 :full-name-encode "cljs.repl.rhino",
                                 :history [["+" "0.0-927"]],
                                 :caption "Rhino REPL (JS on Java 6+)"},
              "specialrepl" {:ns "specialrepl",
                             :pseudo-ns? true,
                             :type "namespace",
                             :full-name "specialrepl",
                             :full-name-encode "specialrepl",
                             :clj-ns "clojure.core",
                             :history [["+" "0.0-927"]],
                             :display "Special Forms (REPL)",
                             :description "These are Special Forms that are only available in a ClojureScript REPL\nsession.  They mainly allow you to cherry-pick individual facilities out of the\nlarger [`ns`][doc:special/ns] form.\n\nThis is useful in a REPL so you can quickly reference symbols, reload\nnamespaces if they have changed since you've started the REPL, or change your\nevaluation context to a specific namespace.\n\nYou can also use the [`cljs.repl` macros][doc:library/cljs.repl] for exploring\ncode from the REPL."},
              "clojure.browser.dom" {:ns "clojure.browser.dom",
                                     :type "namespace",
                                     :source {:code "(ns clojure.browser.dom\n  (:require [goog.dom :as gdom]\n            [goog.object :as gobject]))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/cljs/clojure/browser/dom.cljs",
                                              :lines [9 11]},
                                     :full-name "clojure.browser.dom",
                                     :full-name-encode "clojure.browser.dom",
                                     :history [["+" "0.0-927"]],
                                     :caption "browser DOM library, wrapping [goog.dom](http://www.closurecheatsheet.com/dom)"},
              "clojure.set" {:caption "set operations such as union/intersection",
                             :ns "clojure.set",
                             :history [["+" "0.0-927"]],
                             :type "namespace",
                             :full-name-encode "clojure.set",
                             :source {:code "(ns ^{:doc \"Set operations such as union/intersection.\"\n       :author \"Rich Hickey\"}\n       clojure.set)",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/clojure/set.cljs",
                                      :lines [9 11]},
                             :clj-ns "clojure.set",
                             :author "Rich Hickey",
                             :full-name "clojure.set",
                             :docstring "Set operations such as union/intersection."},
              "cljs.repl.node" {:ns "cljs.repl.node",
                                :type "namespace",
                                :source {:code "(ns cljs.repl.node\n  (:require [clojure.string :as string]\n            [clojure.java.io :as io]\n            [cljs.util :as util]\n            [cljs.analyzer :as ana]\n            [cljs.compiler :as comp]\n            [cljs.repl :as repl]\n            [cljs.closure :as closure]\n            [clojure.data.json :as json])\n  (:import java.net.Socket\n           java.lang.StringBuilder\n           [java.io File BufferedReader BufferedWriter InputStream\n            Writer InputStreamReader IOException]\n           [java.lang ProcessBuilder Process]))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/clojure/cljs/repl/node.clj",
                                         :lines [9 22]},
                                :full-name "cljs.repl.node",
                                :full-name-encode "cljs.repl.node",
                                :history [["+" "0.0-2629"]],
                                :caption "Node.js REPL"},
              "cljs.nodejs" {:ns "cljs.nodejs",
                             :type "namespace",
                             :source {:code "(ns cljs.nodejs)",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/nodejs.cljs",
                                      :lines [12]},
                             :full-name "cljs.nodejs",
                             :full-name-encode "cljs.nodejs",
                             :history [["+" "0.0-927"]],
                             :caption "nodejs support functions"},
              "cljs.repl.reflect" {:ns "cljs.repl.reflect",
                                   :type "namespace",
                                   :source {:code "(ns cljs.repl.reflect\n  (:refer-clojure :exclude [macroexpand])\n  (:require [cljs.repl.server :as server]\n            [cljs.analyzer :as analyzer]\n            [cljs.compiler :as compiler]\n            [clojure.string :as str]\n            [clojure.pprint :as pprint]))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/clojure/cljs/repl/reflect.clj",
                                            :lines [1 7]},
                                   :full-name "cljs.repl.reflect",
                                   :full-name-encode "cljs.repl.reflect",
                                   :history [["+" "0.0-1503"]]},
              "clojure.walk" {:caption "a generic tree walker for Clojure data structures",
                              :ns "clojure.walk",
                              :history [["+" "0.0-927"]],
                              :type "namespace",
                              :full-name-encode "clojure.walk",
                              :source {:code "(ns \n  ^{:author \"Stuart Sierra\",\n     :doc \"This file defines a generic tree walker for Clojure data\nstructures.  It takes any data structure (list, vector, map, set,\nseq), calls a function on every element, and uses the return value\nof the function in place of the original.  This makes it fairly\neasy to write recursive search-and-replace functions, as shown in\nthe examples.\n\nNote: \\\"walk\\\" supports all Clojure data structures EXCEPT maps\ncreated with sorted-map-by.  There is no (obvious) way to retrieve\nthe sorting function.\"}\n  clojure.walk)",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/clojure/walk.cljs",
                                       :lines [23 35]},
                              :clj-ns "clojure.walk",
                              :author "Stuart Sierra",
                              :full-name "clojure.walk",
                              :docstring "This file defines a generic tree walker for Clojure data\nstructures.  It takes any data structure (list, vector, map, set,\nseq), calls a function on every element, and uses the return value\nof the function in place of the original.  This makes it fairly\neasy to write recursive search-and-replace functions, as shown in\nthe examples.\n\nNote: \"walk\" supports all Clojure data structures EXCEPT maps\ncreated with sorted-map-by.  There is no (obvious) way to retrieve\nthe sorting function."},
              "cljs.js" {:ns "cljs.js",
                         :type "namespace",
                         :source {:code "(ns cljs.js\n  (:require-macros [cljs.js :refer [dump-core]]\n                   [cljs.env.macros :as env])\n  (:require [clojure.string :as string]\n            [cljs.env :as env]\n            [cljs.analyzer :as ana]\n            [cljs.compiler :as comp]\n            [cljs.tools.reader :as r]\n            [cljs.tools.reader.reader-types :as rt]\n            [cljs.tagged-literals :as tags]\n            [goog.crypt.base64 :as base64]\n            [cljs.source-map :as sm])\n  (:import [goog.string StringBuffer]))",
                                  :title "Source code",
                                  :repo "clojurescript",
                                  :tag "r1.7.228",
                                  :filename "src/main/cljs/cljs/js.cljs",
                                  :lines [9 21]},
                         :full-name "cljs.js",
                         :full-name-encode "cljs.js",
                         :history [["+" "1.7.10"]],
                         :caption "compile/analyze ClojureScript code at runtime.",
                         :description "This is what is referred to as the \"Bootstrapped Compiler\", which allows\nyou to compile ClojureScript with nothing but ClojureScript.  In other\nwords, this namespace provides the ability to evaluate ClojureScript\ncode at runtime."},
              "cljs.repl.nashorn" {:ns "cljs.repl.nashorn",
                                   :type "namespace",
                                   :source {:code "(ns cljs.repl.nashorn\n  (:require [clojure.java.io :as io]\n            [clojure.string :as string]\n            [clojure.stacktrace]\n            [cljs.analyzer :as ana]\n            [cljs.env :as env]\n            [cljs.util :as util]\n            [cljs.repl :as repl]\n            [cljs.compiler :as comp]\n            [cljs.closure :as closure]\n            [cljs.stacktrace :as st])\n  (:import [java.io File]\n           [javax.script ScriptEngine ScriptEngineManager ScriptException ScriptEngineFactory]\n           [com.google.common.base Throwables]))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/clojure/cljs/repl/nashorn.clj",
                                            :lines [9 22]},
                                   :full-name "cljs.repl.nashorn",
                                   :full-name-encode "cljs.repl.nashorn",
                                   :history [["+" "0.0-2814"]],
                                   :caption "Nashorn REPL (JS on Java 8)"},
              "special" {:ns "special",
                         :pseudo-ns? true,
                         :type "namespace",
                         :full-name "special",
                         :full-name-encode "special",
                         :clj-ns "clojure.core",
                         :history [["+" "0.0-927"]],
                         :display "Special Forms",
                         :description "Special Forms are a small collection of symbols which comprise the core\nconstructs of ClojureScript, upon which all functions and macros are built.\n\nThese special forms are special in the sense that they are not in a designated\nnamespace.  They also have special argument evaluation rules specific to each\nform to allow things not possible with normal functions or macros.\n\nIt should also be noted that special forms have reserved names which cannot be\nshadowed by your own vars."},
              "cljs.build.api" {:ns "cljs.build.api",
                                :docstring "This is intended to be a stable api for those who need programmatic access\n  to ClojureScript's project building facilities.\n\n  For example: a build script may need to how to invalidate compiled\n  files so that they will be recompiled.",
                                :type "namespace",
                                :source {:code "(ns cljs.build.api\n  \"This is intended to be a stable api for those who need programmatic access\n  to ClojureScript's project building facilities.\n\n  For example: a build script may need to how to invalidate compiled\n  files so that they will be recompiled.\"\n  (:refer-clojure :exclude [compile])\n  (:require [cljs.util :as util]\n            [cljs.env :as env]\n            [cljs.analyzer :as ana]\n            [cljs.compiler :as comp]\n            [cljs.closure :as closure]\n            [clojure.set :refer [intersection]]\n            [cljs.js-deps :as js-deps]\n            [clojure.java.io :as io])\n  (:import java.io.File))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/clojure/cljs/build/api.clj",
                                         :lines [8 23]},
                                :full-name "cljs.build.api",
                                :full-name-encode "cljs.build.api",
                                :history [["+" "0.0-2496"]],
                                :caption "programmatic access to project-building facilities"},
              "clojure.browser.event" {:ns "clojure.browser.event",
                                       :docstring "This namespace contains functions to work with browser\nevents.  It is based on the Google Closure Library event system.",
                                       :author "Bobby Calderwood",
                                       :type "namespace",
                                       :source {:code "(ns ^{:doc \"This namespace contains functions to work with browser\nevents.  It is based on the Google Closure Library event system.\"\n      :author \"Bobby Calderwood\"}\n  clojure.browser.event\n  (:require [goog.events :as events])\n  (:import (goog.events EventTarget EventType)))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/clojure/browser/event.cljs",
                                                :lines [9 14]},
                                       :full-name "clojure.browser.event",
                                       :full-name-encode "clojure.browser.event",
                                       :history [["+" "0.0-927"]],
                                       :caption "browser event library, wrapping [goog.events](http://www.closurecheatsheet.com/events)"},
              "cljs.reader" {:ns "cljs.reader",
                             :type "namespace",
                             :source {:code "(ns cljs.reader\n  (:require [goog.string :as gstring])\n  (:import goog.string.StringBuffer))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/reader.cljs",
                                      :lines [9 11]},
                             :full-name "cljs.reader",
                             :full-name-encode "cljs.reader",
                             :history [["+" "0.0-927"]],
                             :caption "a reader to parse text and produce data structures"},
              "clojure.string" {:ns "clojure.string",
                                :type "namespace",
                                :source {:code "(ns clojure.string\n  (:refer-clojure :exclude [replace reverse])\n  (:require [goog.string :as gstring])\n  (:import [goog.string StringBuffer]))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.228",
                                         :filename "src/main/cljs/clojure/string.cljs",
                                         :lines [9 12]},
                                :full-name "clojure.string",
                                :full-name-encode "clojure.string",
                                :clj-ns "clojure.string",
                                :history [["+" "0.0-927"]],
                                :caption "string operations"},
              "cljs.repl" {:caption-library "macros auto-imported into a ClojureScript REPL",
                           :caption-compiler "interactive ClojureScript REPL (Read Eval Print Loop)",
                           :ns "cljs.repl",
                           :history [["+" "0.0-927"]],
                           :type "namespace",
                           :full-name-encode "cljs.repl",
                           :source {:code "(ns cljs.repl\n  (:refer-clojure :exclude [load-file])\n  (:require [clojure.java.io :as io]\n            [clojure.string :as string]\n            [clojure.data.json :as json]\n            [clojure.tools.reader :as reader]\n            [clojure.tools.reader.reader-types :as readers]\n            [clojure.stacktrace :as trace]\n            [clojure.repl :as cljrepl]\n            [clojure.edn :as edn]\n            [cljs.util :as util]\n            [cljs.compiler :as comp]\n            [cljs.analyzer :as ana]\n            [cljs.analyzer.api :as ana-api]\n            [cljs.env :as env]\n            [cljs.js-deps :as deps]\n            [cljs.tagged-literals :as tags]\n            [cljs.closure :as cljsc]\n            [cljs.source-map :as sm])\n  (:import [java.io File PushbackReader FileWriter PrintWriter]\n           [java.net URL]\n           [javax.xml.bind DatatypeConverter]\n           [clojure.lang IExceptionInfo]\n           [java.util.regex Pattern]\n           [com.google.common.base Throwables]))",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r1.7.228",
                                    :filename "src/main/clojure/cljs/repl.cljc",
                                    :lines [9 33]},
                           :clj-ns "clojure.repl",
                           :description-library "In addition to the [REPL's special forms][doc:library/specialrepl], this\nnamespace mainly provides reflection capabilities to assist you in exploring\ncode in a REPL.  It comes with macros that are automatically imported into your\nREPL environment, but you can use them outside of one as well.\n\nThese macros allow you to explore code by listing/searching available vars in a\nnamespace and viewing a var's documentation or source.",
                           :full-name "cljs.repl"},
              "clojure.browser.net" {:ns "clojure.browser.net",
                                     :docstring "Network communication library, wrapping goog.net.\nIncludes a common API over XhrIo, CrossPageChannel, and Websockets.",
                                     :author "Bobby Calderwood and Alex Redington",
                                     :type "namespace",
                                     :source {:code "(ns ^{:doc \"Network communication library, wrapping goog.net.\nIncludes a common API over XhrIo, CrossPageChannel, and Websockets.\"\n      :author \"Bobby Calderwood and Alex Redington\"}\n  clojure.browser.net\n  (:require [clojure.browser.event :as event]\n            [goog.json :as gjson])\n  (:import [goog.net XhrIo EventType WebSocket]\n           [goog.net.xpc CfgFields CrossPageChannel]\n           [goog Uri]))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.7.228",
                                              :filename "src/main/cljs/clojure/browser/net.cljs",
                                              :lines [9 17]},
                                     :full-name "clojure.browser.net",
                                     :full-name-encode "clojure.browser.net",
                                     :history [["+" "0.0-927"]],
                                     :caption "network communication library, wrapping [goog.net](http://www.closurecheatsheet.com/net)"},
              "syntax" {:ns "syntax",
                        :pseudo-ns? true,
                        :type "namespace",
                        :full-name "syntax",
                        :full-name-encode "syntax",
                        :history [["+" "0.0-927"]],
                        :display "syntax forms",
                        :caption "syntax forms (not in a namespace)",
                        :description "This is an index of ClojureScript's syntax forms, including syntax literals,\nnaming conventions, and other syntax patterns.  We hope that you can have any\nquestion about syntax answered by referencing its appearance in this index."},
              "cljs.core" {:ns "cljs.core",
                           :type "namespace",
                           :source {:code "(ns cljs.core\n  (:require [goog.string :as gstring]\n            [goog.object :as gobject]\n            [goog.array :as garray])\n  (:import [goog.string StringBuffer]))",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r1.7.228",
                                    :filename "src/main/cljs/cljs/core.cljs",
                                    :lines [9 13]},
                           :full-name "cljs.core",
                           :full-name-encode "cljs.core",
                           :clj-ns "clojure.core",
                           :history [["+" "0.0-927"]],
                           :caption "fundamental library of the ClojureScript language",
                           :description "This is the core library of ClojureScript, which builds on the Special Forms to\ncomplete the language's fundamental constructs. It also provides a slew of core\noperations for managing state, creating/manipulating/querying data structures,\ninterop with JS, many predicates, etc.\n\n###### Some side notes:\n\n- All of the core library can be referenced without the `cljs.core/` qualification.\n- Operations listed as `function/macro` are flexible and can be used as macros\n  or functions when appropriate.  [details here](https://github.com/clojure/clojurescript/wiki/Differences-from-Clojure#macros)\n- You can use this reference to explore the core types and protocols used to\n  implement many of the operations in this core library.\n- We are currently only listing the \"ClojureScript JVM\" implementations here.\n  The \"ClojureScript JS\" macro implementations are not listed here, but their\n  API is identical of course."},
              "cljs.analyzer.api" {:ns "cljs.analyzer.api",
                                   :docstring "This is intended to be a stable api for those who need programmatic access\n  to the analyzer.",
                                   :type "namespace",
                                   :source {:code "(ns cljs.analyzer.api\n  \"This is intended to be a stable api for those who need programmatic access\n  to the analyzer.\"\n  (:refer-clojure :exclude [all-ns ns-interns ns-resolve resolve find-ns\n                            ns-publics remove-ns])\n  (:require [cljs.env :as env]\n            [cljs.analyzer :as ana]))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.228",
                                            :filename "src/main/clojure/cljs/analyzer/api.clj",
                                            :lines [9 15]},
                                   :full-name "cljs.analyzer.api",
                                   :full-name-encode "cljs.analyzer.api",
                                   :history [["+" "0.0-2496"]],
                                   :caption "programmatic access to the analyzer (producing AST)"},
              "cljs.pprint" {:ns "cljs.pprint",
                             :type "namespace",
                             :source {:code "(ns cljs.pprint\n  (:refer-clojure :exclude [deftype print println pr prn])\n  (:require-macros\n    [cljs.pprint :as m :refer [with-pretty-writer getf setf deftype\n                               pprint-logical-block print-length-loop\n                               defdirectives formatter-out]])\n  (:require\n    [cljs.core :refer [IWriter IDeref]]\n    [clojure.string :as string]\n    [goog.string :as gstring])\n  (:import [goog.string StringBuffer]))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.228",
                                      :filename "src/main/cljs/cljs/pprint.cljs",
                                      :lines [9 19]},
                             :full-name "cljs.pprint",
                             :full-name-encode "cljs.pprint",
                             :clj-ns "clojure.pprint",
                             :history [["+" "0.0-2496"]],
                             :caption "a pretty-printer for printing data structures",
                             :description "This is a pretty-printer for ClojureScript data structures and code.  Its most salient\nuse case is to properly indent data for readable logging."},
              "clojure.data" {:caption "non-core data functions",
                              :ns "clojure.data",
                              :history [["+" "0.0-1503"]],
                              :type "namespace",
                              :full-name-encode "clojure.data",
                              :source {:code "(ns \n  ^{:author \"Stuart Halloway\",\n    :doc \"Non-core data functions.\"}\n  clojure.data\n  (:require [clojure.set :as set]))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.228",
                                       :filename "src/main/cljs/clojure/data.cljs",
                                       :lines [9 13]},
                              :clj-ns "clojure.data",
                              :author "Stuart Halloway",
                              :full-name "clojure.data",
                              :docstring "Non-core data functions."},
              "clojure.core.reducers" {:caption "a library for reduction and parallel folding (parallelism not supported)",
                                       :ns "clojure.core.reducers",
                                       :history [["+" "0.0-1236"]],
                                       :type "namespace",
                                       :full-name-encode "clojure.core.reducers",
                                       :source {:code "(ns ^{:doc\n      \"A library for reduction and parallel folding. Alpha and subject\n      to change.  Note that fold and its derivatives require\n      jsr166y.jar for fork/join support. See Clojure's pom.xml for the\n      dependency info.\"\n      :author \"Rich Hickey\"}\n  clojure.core.reducers\n  (:refer-clojure :exclude [reduce map mapcat filter remove take take-while drop flatten cat])\n  (:require [cljs.core :as core]))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.7.228",
                                                :filename "src/main/cljs/clojure/core/reducers.cljs",
                                                :lines [9 17]},
                                       :clj-ns "clojure.core.reducers",
                                       :author "Rich Hickey",
                                       :full-name "clojure.core.reducers",
                                       :docstring "A library for reduction and parallel folding. Alpha and subject\n      to change.  Note that fold and its derivatives require\n      jsr166y.jar for fork/join support. See Clojure's pom.xml for the\n      dependency info."},
              "clojure.browser.repl" {:ns "clojure.browser.repl",
                                      :docstring "Receive - Eval - Print - Loop\n\n  Receive a block of JS (presumably generated by a ClojureScript compiler)\n  Evaluate it naively\n  Print the result of evaluation to a string\n  Send the resulting string back to the server Loop!",
                                      :author "Bobby Calderwood and Alex Redington",
                                      :type "namespace",
                                      :source {:code "(ns ^{:doc \"Receive - Eval - Print - Loop\n\n  Receive a block of JS (presumably generated by a ClojureScript compiler)\n  Evaluate it naively\n  Print the result of evaluation to a string\n  Send the resulting string back to the server Loop!\"\n\n      :author \"Bobby Calderwood and Alex Redington\"}\n  clojure.browser.repl\n  (:require [goog.dom :as gdom]\n            [goog.object :as gobj]\n            [goog.array :as garray]\n            [goog.userAgent.product :as product]\n            [clojure.browser.net :as net]\n            [clojure.browser.event :as event]\n            ;; repl-connection callback will receive goog.require('cljs.repl')\n            ;; and monkey-patched require expects to be able to derive it\n            ;; via goog.basePath, so this namespace should be compiled together\n            ;; with clojure.browser.repl:\n            [cljs.repl]))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.228",
                                               :filename "src/main/cljs/clojure/browser/repl.cljs",
                                               :lines [9 28]},
                                      :full-name "clojure.browser.repl",
                                      :full-name-encode "clojure.browser.repl",
                                      :history [["+" "0.0-927"]],
                                      :caption "evaluate compiled cljs in a browser. send results back to server"}},
 :api {:syntax {:changes [{:cljs-version "0.0-927",
                           :cljs-date "2012-01-20",
                           :clj-version "1.3.0",
                           :gclosure-lib "20110323-r790",
                           :added #{"syntax/symbol"
                                    "syntax/vector"
                                    "syntax/whitespace"
                                    "syntax/earmuffs"
                                    "syntax/Math-namespace"
                                    "syntax/comma"
                                    "syntax/string"
                                    "syntax/comment"
                                    "syntax/js-namespace"
                                    "syntax/quote"
                                    "syntax/namespace"
                                    "syntax/keyword-qualify"
                                    "syntax/meta"
                                    "syntax/regex"
                                    "syntax/eval"
                                    "syntax/dot"
                                    "syntax/unused"
                                    "syntax/unquote-splicing"
                                    "syntax/rest"
                                    "syntax/keyword"
                                    "syntax/character"
                                    "syntax/unreadable"
                                    "syntax/auto-gensym"
                                    "syntax/arg"
                                    "syntax/set"
                                    "syntax/destructure-map"
                                    "syntax/syntax-quote"
                                    "syntax/dispatch"
                                    "syntax/shebang"
                                    "syntax/function"
                                    "syntax/nil"
                                    "syntax/map"
                                    "syntax/number"
                                    "syntax/list"
                                    "syntax/impure"
                                    "syntax/deref"
                                    "syntax/unquote"
                                    "syntax/predicate"
                                    "syntax/ignore"
                                    "syntax/destructure-vector"
                                    "syntax/var"
                                    "syntax/boolean"}}
                          {:cljs-version "0.0-971",
                           :cljs-date "2012-01-27",
                           :clj-version "1.3.0",
                           :gclosure-lib "20110323-r790"}
                          {:cljs-version "0.0-993",
                           :cljs-date "2012-02-27",
                           :clj-version "1.3.0",
                           :gclosure-lib "20110323-r790"}
                          {:cljs-version "0.0-1006",
                           :cljs-date "2012-03-30",
                           :clj-version "1.3.0",
                           :gclosure-lib "20110323-r790"}
                          {:cljs-version "0.0-1011",
                           :cljs-date "2012-04-02",
                           :clj-version "1.3.0",
                           :gclosure-lib "20110323-r790"}
                          {:cljs-version "0.0-1211",
                           :cljs-date "2012-05-09",
                           :clj-version "1.4.0",
                           :gclosure-lib "20111110-r1376",
                           :added #{"syntax/inst-literal"
                                    "syntax/tagged-literal"
                                    "syntax/uuid-literal"}}
                          {:cljs-version "0.0-1236",
                           :cljs-date "2012-05-16",
                           :clj-version "1.4.0",
                           :gclosure-lib "20111110-r1376"}
                          {:cljs-version "0.0-1424",
                           :cljs-date "2012-06-16",
                           :clj-version "1.4.0",
                           :gclosure-lib "20111110-r1376",
                           :added #{"syntax/queue-literal"}}
                          {:cljs-version "0.0-1443",
                           :cljs-date "2012-07-06",
                           :clj-version "1.4.0",
                           :gclosure-lib "20111110-r1376"}
                          {:cljs-version "0.0-1449",
                           :cljs-date "2012-07-24",
                           :clj-version "1.4.0",
                           :gclosure-lib "20111110-r1376"}
                          {:cljs-version "0.0-1450",
                           :cljs-date "2012-07-25",
                           :clj-version "1.4.0",
                           :gclosure-lib "20111110-r1376"}
                          {:cljs-version "0.0-1503",
                           :cljs-date "2012-10-12",
                           :clj-version "1.4.0",
                           :gclosure-lib "20111110-r1376"}
                          {:cljs-version "0.0-1513",
                           :cljs-date "2012-10-19",
                           :clj-version "1.4.0",
                           :gclosure-lib "20111110-r1376"}
                          {:cljs-version "0.0-1535",
                           :cljs-date "2012-11-08",
                           :clj-version "1.4.0",
                           :gclosure-lib "20120710-r2029"}
                          {:cljs-version "0.0-1552",
                           :cljs-date "2012-12-03",
                           :clj-version "1.4.0",
                           :gclosure-lib "20120710-r2029"}
                          {:cljs-version "0.0-1576",
                           :cljs-date "2013-01-27",
                           :clj-version "1.4.0",
                           :gclosure-lib "20120710-r2029"}
                          {:cljs-version "0.0-1586",
                           :cljs-date "2013-02-16",
                           :clj-version "1.4.0",
                           :gclosure-lib "20120710-r2029"}
                          {:cljs-version "0.0-1798",
                           :cljs-date "2013-05-03",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-2029-2"}
                          {:cljs-version "0.0-1803",
                           :cljs-date "2013-05-06",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-2029-2"}
                          {:cljs-version "0.0-1806",
                           :cljs-date "2013-05-10",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-2029-2"}
                          {:cljs-version "0.0-1820",
                           :cljs-date "2013-06-07",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-2029-2"}
                          {:cljs-version "0.0-1835",
                           :cljs-date "2013-06-21",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-2029-2"}
                          {:cljs-version "0.0-1843",
                           :cljs-date "2013-07-16",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-2029-2"}
                          {:cljs-version "0.0-1844",
                           :cljs-date "2013-07-19",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-2029-2"}
                          {:cljs-version "0.0-1847",
                           :cljs-date "2013-07-23",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f"}
                          {:cljs-version "0.0-1853",
                           :cljs-date "2013-08-05",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.7.5",
                           :added #{"syntax/Infinity" "syntax/NaN"}}
                          {:cljs-version "0.0-1859",
                           :cljs-date "2013-08-19",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.7.6"}
                          {:cljs-version "0.0-1877",
                           :cljs-date "2013-09-08",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.7.6"}
                          {:cljs-version "0.0-1878",
                           :cljs-date "2013-09-11",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.7.6"}
                          {:cljs-version "0.0-1885",
                           :cljs-date "2013-09-15",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.7.6"}
                          {:cljs-version "0.0-1886",
                           :cljs-date "2013-09-15",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.7.6"}
                          {:cljs-version "0.0-1889",
                           :cljs-date "2013-09-15",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.7.6"}
                          {:cljs-version "0.0-1895",
                           :cljs-date "2013-09-24",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.7.6"}
                          {:cljs-version "0.0-1896",
                           :cljs-date "2013-09-24",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.7.6"}
                          {:cljs-version "0.0-1909",
                           :cljs-date "2013-09-27",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.7.8"}
                          {:cljs-version "0.0-1913",
                           :cljs-date "2013-10-05",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.7.8"}
                          {:cljs-version "0.0-1933",
                           :cljs-date "2013-10-11",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.7.9"}
                          {:cljs-version "0.0-1934",
                           :cljs-date "2013-10-11",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.7.9"}
                          {:cljs-version "0.0-1978",
                           :cljs-date "2013-10-28",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.7.10"}
                          {:cljs-version "0.0-2014",
                           :cljs-date "2013-11-06",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.7.10"}
                          {:cljs-version "0.0-2024",
                           :cljs-date "2013-11-08",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.7.10"}
                          {:cljs-version "0.0-2027",
                           :cljs-date "2013-11-08",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.7.10"}
                          {:cljs-version "0.0-2030",
                           :cljs-date "2013-11-08",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.7.10"}
                          {:cljs-version "0.0-2060",
                           :cljs-date "2013-11-21",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.7.10"}
                          {:cljs-version "0.0-2067",
                           :cljs-date "2013-11-22",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.8.0"}
                          {:cljs-version "0.0-2069",
                           :cljs-date "2013-11-22",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.8.0"}
                          {:cljs-version "0.0-2075",
                           :cljs-date "2013-11-23",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.8.0"}
                          {:cljs-version "0.0-2080",
                           :cljs-date "2013-11-23",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.8.0"}
                          {:cljs-version "0.0-2120",
                           :cljs-date "2013-12-13",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.8.0",
                           :added #{"syntax/js-literal"}}
                          {:cljs-version "0.0-2127",
                           :cljs-date "2013-12-20",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.8.0"}
                          {:cljs-version "0.0-2134",
                           :cljs-date "2013-12-30",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.8.0"}
                          {:cljs-version "0.0-2138",
                           :cljs-date "2013-12-31",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.8.0"}
                          {:cljs-version "0.0-2156",
                           :cljs-date "2014-01-29",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.8.3"}
                          {:cljs-version "0.0-2173",
                           :cljs-date "2014-02-22",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.8.3"}
                          {:cljs-version "0.0-2197",
                           :cljs-date "2014-03-26",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.8.3"}
                          {:cljs-version "0.0-2199",
                           :cljs-date "2014-04-01",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.8.3"}
                          {:cljs-version "0.0-2202",
                           :cljs-date "2014-04-02",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.8.3"}
                          {:cljs-version "0.0-2227",
                           :cljs-date "2014-05-22",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.8.3"}
                          {:cljs-version "0.0-2234",
                           :cljs-date "2014-06-13",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                           :treader-version "0.8.3"}
                          {:cljs-version "0.0-2261",
                           :cljs-date "2014-07-02",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140226-71326067",
                           :treader-version "0.8.4"}
                          {:cljs-version "0.0-2268",
                           :cljs-date "2014-07-06",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140226-71326067",
                           :treader-version "0.8.4"}
                          {:cljs-version "0.0-2277",
                           :cljs-date "2014-07-25",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140226-71326067",
                           :treader-version "0.8.4"}
                          {:cljs-version "0.0-2280",
                           :cljs-date "2014-08-01",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.4"}
                          {:cljs-version "0.0-2301",
                           :cljs-date "2014-08-07",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.4"}
                          {:cljs-version "0.0-2307",
                           :cljs-date "2014-08-07",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.4"}
                          {:cljs-version "0.0-2311",
                           :cljs-date "2014-08-09",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.4"}
                          {:cljs-version "0.0-2322",
                           :cljs-date "2014-08-27",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.4"}
                          {:cljs-version "0.0-2341",
                           :cljs-date "2014-09-18",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.4"}
                          {:cljs-version "0.0-2342",
                           :cljs-date "2014-09-18",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.9"}
                          {:cljs-version "0.0-2356",
                           :cljs-date "2014-09-26",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.9"}
                          {:cljs-version "0.0-2371",
                           :cljs-date "2014-10-10",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.9"}
                          {:cljs-version "0.0-2411",
                           :cljs-date "2014-12-05",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}
                          {:cljs-version "0.0-2496",
                           :cljs-date "2014-12-17",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}
                          {:cljs-version "0.0-2498",
                           :cljs-date "2014-12-19",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}
                          {:cljs-version "0.0-2505",
                           :cljs-date "2014-12-21",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}
                          {:cljs-version "0.0-2511",
                           :cljs-date "2014-12-22",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}
                          {:cljs-version "0.0-2629",
                           :cljs-date "2015-01-01",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}
                          {:cljs-version "0.0-2644",
                           :cljs-date "2015-01-02",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}
                          {:cljs-version "0.0-2655",
                           :cljs-date "2015-01-03",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}
                          {:cljs-version "0.0-2657",
                           :cljs-date "2015-01-03",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}
                          {:cljs-version "0.0-2665",
                           :cljs-date "2015-01-04",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}
                          {:cljs-version "0.0-2719",
                           :cljs-date "2015-01-24",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}
                          {:cljs-version "0.0-2723",
                           :cljs-date "2015-01-24",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}
                          {:cljs-version "0.0-2725",
                           :cljs-date "2015-01-24",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}
                          {:cljs-version "0.0-2727",
                           :cljs-date "2015-01-25",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}
                          {:cljs-version "0.0-2740",
                           :cljs-date "2015-01-28",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}
                          {:cljs-version "0.0-2755",
                           :cljs-date "2015-02-01",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}
                          {:cljs-version "0.0-2758",
                           :cljs-date "2015-02-02",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}
                          {:cljs-version "0.0-2760",
                           :cljs-date "2015-02-02",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}
                          {:cljs-version "0.0-2814",
                           :cljs-date "2015-02-10",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}
                          {:cljs-version "0.0-2816",
                           :cljs-date "2015-02-10",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}
                          {:cljs-version "0.0-2843",
                           :cljs-date "2015-02-12",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}
                          {:cljs-version "0.0-2850",
                           :cljs-date "2015-02-13",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}
                          {:cljs-version "0.0-2911",
                           :cljs-date "2015-02-21",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}
                          {:cljs-version "0.0-2913",
                           :cljs-date "2015-02-21",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}
                          {:cljs-version "0.0-2985",
                           :cljs-date "2015-03-04",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.10"}
                          {:cljs-version "0.0-3030",
                           :cljs-date "2015-03-07",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.16"}
                          {:cljs-version "0.0-3053",
                           :cljs-date "2015-03-09",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.16"}
                          {:cljs-version "0.0-3058",
                           :cljs-date "2015-03-09",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.16"}
                          {:cljs-version "0.0-3115",
                           :cljs-date "2015-03-15",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.16"}
                          {:cljs-version "0.0-3117",
                           :cljs-date "2015-03-16",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.16"}
                          {:cljs-version "0.0-3119",
                           :cljs-date "2015-03-16",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.16"}
                          {:cljs-version "0.0-3123",
                           :cljs-date "2015-03-16",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.16"}
                          {:cljs-version "0.0-3126",
                           :cljs-date "2015-03-18",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.16"}
                          {:cljs-version "0.0-3148",
                           :cljs-date "2015-03-23",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.16"}
                          {:cljs-version "0.0-3149",
                           :cljs-date "2015-03-23",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.16"}
                          {:cljs-version "0.0-3153",
                           :cljs-date "2015-03-25",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.16"}
                          {:cljs-version "0.0-3165",
                           :cljs-date "2015-03-27",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.16"}
                          {:cljs-version "0.0-3169",
                           :cljs-date "2015-03-31",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.16"}
                          {:cljs-version "0.0-3178",
                           :cljs-date "2015-04-06",
                           :clj-version "1.6.0",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.8.16"}
                          {:cljs-version "0.0-3190",
                           :cljs-date "2015-04-09",
                           :clj-version "1.7.0-alpha6",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.9.0",
                           :added #{"syntax/cond"
                                    "syntax/cond-splicing"}}
                          {:cljs-version "0.0-3191",
                           :cljs-date "2015-04-09",
                           :clj-version "1.7.0-alpha6",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.9.1"}
                          {:cljs-version "0.0-3195",
                           :cljs-date "2015-04-10",
                           :clj-version "1.7.0-alpha6",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.9.1"}
                          {:cljs-version "0.0-3196",
                           :cljs-date "2015-04-10",
                           :clj-version "1.7.0-beta1",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.9.1"}
                          {:cljs-version "0.0-3208",
                           :cljs-date "2015-04-16",
                           :clj-version "1.7.0-beta1",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.9.1"}
                          {:cljs-version "0.0-3211",
                           :cljs-date "2015-04-23",
                           :clj-version "1.7.0-beta1",
                           :gclosure-lib "0.0-20140718-946a7d39",
                           :treader-version "0.9.1"}
                          {:cljs-version "0.0-3255",
                           :cljs-date "2015-05-08",
                           :clj-version "1.7.0-beta2",
                           :gclosure-lib "0.0-20150505-021ed5b3",
                           :treader-version "0.9.2"}
                          {:cljs-version "0.0-3263",
                           :cljs-date "2015-05-09",
                           :clj-version "1.7.0-beta2",
                           :gclosure-lib "0.0-20150505-021ed5b3",
                           :treader-version "0.9.2"}
                          {:cljs-version "0.0-3264",
                           :cljs-date "2015-05-09",
                           :clj-version "1.7.0-beta2",
                           :gclosure-lib "0.0-20150505-021ed5b3",
                           :treader-version "0.9.2"}
                          {:cljs-version "0.0-3269",
                           :cljs-date "2015-05-10",
                           :clj-version "1.7.0-beta2",
                           :gclosure-lib "0.0-20150505-021ed5b3",
                           :treader-version "0.9.2"}
                          {:cljs-version "0.0-3291",
                           :cljs-date "2015-05-18",
                           :clj-version "1.7.0-beta2",
                           :gclosure-lib "0.0-20150505-021ed5b3",
                           :treader-version "0.9.2"}
                          {:cljs-version "0.0-3297",
                           :cljs-date "2015-05-23",
                           :clj-version "1.7.0-beta2",
                           :gclosure-lib "0.0-20150505-021ed5b3",
                           :treader-version "0.9.2"}
                          {:cljs-version "0.0-3308",
                           :cljs-date "2015-06-01",
                           :clj-version "1.7.0-RC1",
                           :gclosure-lib "0.0-20150505-021ed5b3",
                           :treader-version "0.9.2"}
                          {:cljs-version "1.7.10",
                           :cljs-date "2015-07-29",
                           :clj-version "1.7.0",
                           :gclosure-lib "0.0-20150505-021ed5b3",
                           :treader-version "0.10.0-alpha3"}
                          {:cljs-version "1.7.28",
                           :cljs-date "2015-07-31",
                           :clj-version "1.7.0",
                           :gclosure-lib "0.0-20150505-021ed5b3",
                           :treader-version "0.10.0-alpha3"}
                          {:cljs-version "1.7.48",
                           :cljs-date "2015-08-05",
                           :clj-version "1.7.0",
                           :gclosure-lib "0.0-20150805-acd8b553",
                           :treader-version "0.10.0-alpha3"}
                          {:cljs-version "1.7.58",
                           :cljs-date "2015-08-06",
                           :clj-version "1.7.0",
                           :gclosure-lib "0.0-20150805-acd8b553",
                           :treader-version "0.10.0-alpha3"}
                          {:cljs-version "1.7.107",
                           :cljs-date "2015-08-11",
                           :clj-version "1.7.0",
                           :gclosure-lib "0.0-20150805-acd8b553",
                           :treader-version "0.10.0-alpha3"}
                          {:cljs-version "1.7.122",
                           :cljs-date "2015-08-29",
                           :clj-version "1.7.0",
                           :gclosure-lib "0.0-20150805-acd8b553",
                           :treader-version "0.10.0-alpha3"}
                          {:cljs-version "1.7.145",
                           :cljs-date "2015-10-13",
                           :clj-version "1.7.0",
                           :gclosure-lib "0.0-20150805-acd8b553",
                           :treader-version "0.10.0-alpha3"}
                          {:cljs-version "1.7.166",
                           :cljs-date "2015-11-04",
                           :clj-version "1.7.0",
                           :gclosure-lib "0.0-20151016-61277aea",
                           :treader-version "0.10.0-alpha3"}
                          {:cljs-version "1.7.170",
                           :cljs-date "2015-11-06",
                           :clj-version "1.7.0",
                           :gclosure-lib "0.0-20151016-61277aea",
                           :treader-version "0.10.0-alpha3"}
                          {:cljs-version "1.7.189",
                           :cljs-date "2015-12-01",
                           :clj-version "1.7.0",
                           :gclosure-lib "0.0-20151016-61277aea",
                           :treader-version "0.10.0-alpha3"}
                          {:cljs-version "1.7.228",
                           :cljs-date "2016-01-08",
                           :clj-version "1.7.0",
                           :gclosure-lib "0.0-20151016-61277aea",
                           :treader-version "1.0.0-alpha1"}],
                :symbol-names #{"syntax/symbol"
                                "syntax/vector"
                                "syntax/inst-literal"
                                "syntax/whitespace"
                                "syntax/earmuffs"
                                "syntax/cond"
                                "syntax/Math-namespace"
                                "syntax/comma"
                                "syntax/string"
                                "syntax/comment"
                                "syntax/js-namespace"
                                "syntax/Infinity"
                                "syntax/quote"
                                "syntax/namespace"
                                "syntax/keyword-qualify"
                                "syntax/meta"
                                "syntax/regex"
                                "syntax/eval"
                                "syntax/dot"
                                "syntax/unused"
                                "syntax/unquote-splicing"
                                "syntax/cond-splicing"
                                "syntax/rest"
                                "syntax/keyword"
                                "syntax/character"
                                "syntax/unreadable"
                                "syntax/auto-gensym"
                                "syntax/arg"
                                "syntax/set"
                                "syntax/tagged-literal"
                                "syntax/destructure-map"
                                "syntax/syntax-quote"
                                "syntax/dispatch"
                                "syntax/queue-literal"
                                "syntax/shebang"
                                "syntax/function"
                                "syntax/nil"
                                "syntax/map"
                                "syntax/number"
                                "syntax/js-literal"
                                "syntax/list"
                                "syntax/uuid-literal"
                                "syntax/impure"
                                "syntax/deref"
                                "syntax/unquote"
                                "syntax/NaN"
                                "syntax/predicate"
                                "syntax/ignore"
                                "syntax/destructure-vector"
                                "syntax/var"
                                "syntax/boolean"},
                :namespace-names #{"syntax"}},
       :library {:changes [{:cljs-version "0.0-927",
                            :cljs-date "2012-01-20",
                            :clj-version "1.3.0",
                            :gclosure-lib "20110323-r790",
                            :added #{"cljs.core/keys"
                                     "cljs.core/reset!"
                                     "clojure.set/select"
                                     "cljs.core/delay"
                                     "cljs.core/bit-not"
                                     "cljs.core/partition"
                                     "cljs.core/parents"
                                     "cljs.core/aclone"
                                     "cljs.core/reset-meta!"
                                     "special/defrecord*"
                                     "cljs.reader/dispatch-macros"
                                     "cljs.core/ICollection"
                                     "cljs.core/every?"
                                     "clojure.zip/node"
                                     "cljs.core/IEmptyableCollection"
                                     "clojure.zip/right"
                                     "cljs.core/=="
                                     "special/."
                                     "clojure.browser.net/*timeout*"
                                     "cljs.core/remove-method"
                                     "cljs.core/frequencies"
                                     "cljs.core/pop"
                                     "cljs.core/not-every?"
                                     "cljs.core/some-fn"
                                     "clojure.browser.event/remove-all"
                                     "cljs.core/doto"
                                     "cljs.core/take-while"
                                     "cljs.reader/escape-char-map"
                                     "clojure.browser.event/all-listeners"
                                     "cljs.core/vals"
                                     "cljs.core/IDeref"
                                     "clojure.browser.dom/log-obj"
                                     "cljs.core/for"
                                     "cljs.core/instance?"
                                     "cljs.reader/read-comment"
                                     "cljs.reader/read-number"
                                     "cljs.core/ILookup"
                                     "cljs.core/when"
                                     "clojure.browser.dom/set-value"
                                     "cljs.reader/read-past"
                                     "cljs.core/to-array"
                                     "cljs.core/interpose"
                                     "clojure.browser.net/ICrossPageChannel"
                                     "special/finally"
                                     "cljs.core/Cons"
                                     "cljs.core/re-find"
                                     "cljs.core/IMeta"
                                     "cljs.core/assoc-in"
                                     "clojure.string/join"
                                     "clojure.zip/rights"
                                     "cljs.core/split-at"
                                     "clojure.zip/append-child"
                                     "cljs.core/binding"
                                     "cljs.core/Set"
                                     "cljs.reader/macro-terminating?"
                                     "cljs.core/prefers"
                                     "cljs.core/vary-meta"
                                     "cljs.core/when-let"
                                     "cljs.core/drop"
                                     "cljs.core/while"
                                     "cljs.core/import-macros"
                                     "cljs.core/string-print"
                                     "cljs.core/-"
                                     "clojure.zip/vector-zip"
                                     "cljs.core/js->clj"
                                     "cljs.core/List"
                                     "cljs.core/identical?"
                                     "cljs.core/*main-cli-fn*"
                                     "clojure.browser.dom/html->dom"
                                     "cljs.core/some"
                                     "cljs.core/doall"
                                     "cljs.core/condp"
                                     "clojure.zip/down"
                                     "cljs.core/IPending"
                                     "cljs.core/count"
                                     "cljs.core/bit-test"
                                     "cljs.core/loop"
                                     "cljs.core/subvec"
                                     "cljs.core/bit-clear"
                                     "cljs.core/gensym"
                                     "special/recur"
                                     "cljs.core/+"
                                     "cljs.core/comp"
                                     "cljs.reader/desugar-meta"
                                     "cljs.core/pr"
                                     "clojure.string/upper-case"
                                     "clojure.browser.event/expose"
                                     "clojure.browser.event/listen-once"
                                     "cljs.core/empty?"
                                     "cljs.core/newline"
                                     "cljs.core/replace"
                                     "cljs.core/rand"
                                     "cljs.core/add-watch"
                                     "clojure.string/capitalize"
                                     "cljs.core/replicate"
                                     "special/do"
                                     "cljs.core/sequential?"
                                     "cljs.core/underive"
                                     "cljs.core/get-method"
                                     "cljs.core/="
                                     "cljs.core/defn-"
                                     "cljs.reader/read-symbol"
                                     "cljs.reader/push-back-reader"
                                     "cljs.core/deftype"
                                     "cljs.core/Subvec"
                                     "special/ns"
                                     "cljs.core/extend-protocol"
                                     "cljs.reader/read"
                                     "cljs.core/EmptyList"
                                     "clojure.walk/postwalk"
                                     "clojure.zip/edit"
                                     "cljs.core/re-seq"
                                     "cljs.reader/read-list"
                                     "cljs.core/Atom"
                                     "cljs.core/IMap"
                                     "cljs.reader/read-vector"
                                     "clojure.set/join"
                                     "cljs.core/HashMap"
                                     "cljs.reader/int-pattern"
                                     "cljs.core/swap!"
                                     "cljs.core/dec"
                                     "clojure.browser.dom/remove-children"
                                     "cljs.core/get-validator"
                                     "cljs.core/coll?"
                                     "cljs.core/bit-or"
                                     "cljs.core/nfirst"
                                     "cljs.core/keep"
                                     "cljs.core/take"
                                     "cljs.core/cond"
                                     "cljs.core/bit-and"
                                     "cljs.core/ObjMap.fromObject"
                                     "clojure.browser.event/unique-event-id"
                                     "clojure.set/project"
                                     "special/js*"
                                     "clojure.string/trim-newline"
                                     "specialrepl/in-ns"
                                     "special/let*"
                                     "special/throw"
                                     "clojure.zip/insert-left"
                                     "cljs.core/true?"
                                     "clojure.browser.net/xpc-connection"
                                     "cljs.core/not"
                                     "cljs.core/js-obj"
                                     "cljs.core/complement"
                                     "cljs.core/spread"
                                     "cljs.core/keyword"
                                     "cljs.core/sort"
                                     "clojure.string/trim"
                                     "cljs.core/meta"
                                     "cljs.core/time"
                                     "cljs.core/boolean"
                                     "cljs.reader/read-token"
                                     "cljs.core/update-in"
                                     "cljs.core/map-indexed"
                                     "cljs.core/IStack"
                                     "cljs.core/IIndexed"
                                     "clojure.browser.repl/repl-print"
                                     "clojure.browser.net/xpc-config-fields"
                                     "cljs.core/nnext"
                                     "cljs.core/*print-meta*"
                                     "cljs.reader/read-dispatch"
                                     "cljs.core/distinct"
                                     "cljs.reader/wrapping-reader"
                                     "cljs.core/prn"
                                     "clojure.zip/leftmost"
                                     "cljs.core/>="
                                     "cljs.reader/macros"
                                     "cljs.core/doseq"
                                     "cljs.core/*"
                                     "cljs.core/into"
                                     "cljs.core/defmethod"
                                     "cljs.core/rest"
                                     "cljs.core/dotimes"
                                     "clojure.zip/lefts"
                                     "clojure.browser.dom/ensure-element"
                                     "cljs.core/defmacro"
                                     "cljs.core/remove"
                                     "cljs.core/if-not"
                                     "clojure.zip/path"
                                     "cljs.core/mapcat"
                                     "cljs.core/IWatchable"
                                     "clojure.zip/rightmost"
                                     "cljs.core/->"
                                     "cljs.core/remove-all-methods"
                                     "clojure.string/replace-first"
                                     "clojure.browser.dom/get-value"
                                     "cljs.nodejs/process"
                                     "cljs.core/not="
                                     "cljs.core/js-keys"
                                     "clojure.zip/seq-zip"
                                     "cljs.core/IVector"
                                     "cljs.core/empty"
                                     "cljs.core/re-matches"
                                     "clojure.browser.dom/DOMBuilder"
                                     "cljs.core/extend-type"
                                     "cljs.core/ISeqable"
                                     "cljs.core/assoc"
                                     "clojure.browser.repl/xpc-connection"
                                     "cljs.core/IDerefWithTimeout"
                                     "clojure.browser.repl/start-evaluator"
                                     "clojure.browser.event/unlisten"
                                     "cljs.core/fnil"
                                     "cljs.core/this-as"
                                     "cljs.core/PersistentQueueSeq"
                                     "cljs.core/counted?"
                                     "clojure.string/trimr"
                                     "cljs.core/force"
                                     "cljs.core/compare-and-set!"
                                     "cljs.core/set?"
                                     "clojure.string/escape"
                                     "cljs.core/remove-watch"
                                     "cljs.core/IMultiFn"
                                     "clojure.zip/end?"
                                     "clojure.set/superset?"
                                     "clojure.browser.net/IConnection"
                                     "cljs.core/let"
                                     "cljs.core/dorun"
                                     "cljs.core/pr-str"
                                     "cljs.core/IPrintable"
                                     "cljs.core/defprotocol"
                                     "cljs.core/assert"
                                     "cljs.core/declare"
                                     "cljs.core/fn?"
                                     "cljs.core/associative?"
                                     "cljs.core/list*"
                                     "cljs.core/reduce"
                                     "clojure.browser.event/has-listener"
                                     "cljs.core/compare"
                                     "cljs.core/contains?"
                                     "cljs.core/prefer-method"
                                     "cljs.core/array-seq"
                                     "cljs.core/PersistentQueue"
                                     "cljs.core/drop-last"
                                     "cljs.reader/read-string"
                                     "cljs.core/vector?"
                                     "cljs.core/defmulti"
                                     "cljs.core/List.EMPTY"
                                     "clojure.browser.event/dispatch-event"
                                     "clojure.string/split-lines"
                                     "cljs.core/areduce"
                                     "cljs.core/disj"
                                     "clojure.browser.net/event-types"
                                     "clojure.string/lower-case"
                                     "cljs.core/*print-fn*"
                                     "cljs.core/str"
                                     "cljs.core/ISequential"
                                     "cljs.core/set"
                                     "special/def"
                                     "cljs.core/print"
                                     "clojure.string/blank?"
                                     "clojure.browser.dom/append"
                                     "cljs.core/take-last"
                                     "clojure.set/intersection"
                                     "cljs.core/fnext"
                                     "cljs.core/apply"
                                     "clojure.walk/prewalk"
                                     "cljs.core/flatten"
                                     "cljs.core/get"
                                     "cljs.core/.."
                                     "cljs.core/Range"
                                     "cljs.core/zero?"
                                     "cljs.core/identity"
                                     "cljs.core/first"
                                     "cljs.reader/ratio-pattern"
                                     "cljs.core/>"
                                     "cljs.core/juxt"
                                     "cljs.core/max"
                                     "cljs.core/*3"
                                     "cljs.core/number?"
                                     "cljs.core/array"
                                     "cljs.core/nthnext"
                                     "cljs.core/re-pattern"
                                     "cljs.core/missing-protocol"
                                     "clojure.browser.dom/set-text"
                                     "clojure.zip/up"
                                     "cljs.core/IWithMeta"
                                     "cljs.core/bit-and-not"
                                     "clojure.string/triml"
                                     "clojure.string/split"
                                     "cljs.core/hash-map"
                                     "cljs.core/rem"
                                     "cljs.core/IRecord"
                                     "cljs.core/constantly"
                                     "clojure.browser.dom/get-element"
                                     "cljs.core/and"
                                     "clojure.browser.repl/wrap-message"
                                     "clojure.browser.event/unlisten-by-key"
                                     "cljs.core/try"
                                     "cljs.core/iterate"
                                     "cljs.core/lazy-seq"
                                     "specialrepl/load-file"
                                     "cljs.core/IndexedSeq"
                                     "cljs.core/next"
                                     "cljs.core/*print-readably*"
                                     "cljs.core/last"
                                     "cljs.core/bit-shift-left"
                                     "clojure.string/reverse"
                                     "cljs.core/min"
                                     "cljs.reader/escape-char"
                                     "cljs.reader/read-map"
                                     "cljs.core/seq"
                                     "cljs.core/not-empty"
                                     "cljs.core/println"
                                     "clojure.browser.repl/connect"
                                     "clojure.browser.dom/insert-at"
                                     "cljs.core/quot"
                                     "clojure.browser.event/get-listener"
                                     "cljs.core/filter"
                                     "clojure.zip/branch?"
                                     "special/if"
                                     "cljs.core/ObjMap"
                                     "cljs.core/zipmap"
                                     "cljs.core/hash-combine"
                                     "cljs.core/max-key"
                                     "clojure.zip/insert-child"
                                     "cljs.core/defrecord"
                                     "cljs.core/butlast"
                                     "cljs.core/hash"
                                     "cljs.core/bit-set"
                                     "cljs.core/concat"
                                     "cljs.core/conj"
                                     "clojure.set/difference"
                                     "cljs.core/when-first"
                                     "cljs.core/distinct?"
                                     "cljs.core/pos?"
                                     "cljs.core/IHash"
                                     "cljs.core/is_proto_"
                                     "cljs.core/keep-indexed"
                                     "cljs.core/bit-shift-right"
                                     "clojure.zip/insert-right"
                                     "cljs.core/make-hierarchy"
                                     "cljs.core/repeat"
                                     "cljs.core/MultiFn"
                                     "cljs.core/not-any?"
                                     "cljs.reader/read-regex"
                                     "clojure.zip/next"
                                     "cljs.core/aget"
                                     "cljs.core/if-let"
                                     "cljs.core//"
                                     "cljs.core/min-key"
                                     "clojure.zip/root"
                                     "cljs.core/drop-while"
                                     "clojure.browser.repl/evaluate-javascript"
                                     "cljs.core/set-validator!"
                                     "cljs.core/<"
                                     "cljs.core/fn"
                                     "cljs.core/split-with"
                                     "cljs.core/IReduce"
                                     "cljs.reader/symbol-pattern"
                                     "cljs.core/repeatedly"
                                     "cljs.reader/read-delimited-list"
                                     "cljs.core/undefined?"
                                     "clojure.zip/prev"
                                     "cljs.core/seq?"
                                     "cljs.core/odd?"
                                     "cljs.core/cons"
                                     "special/deftype*"
                                     "cljs.reader/read-set"
                                     "cljs.core/descendants"
                                     "special/new"
                                     "cljs.core/take-nth"
                                     "cljs.reader/throwing-reader"
                                     "cljs.core/even?"
                                     "special/fn*"
                                     "clojure.set/subset?"
                                     "cljs.core/flush"
                                     "cljs.reader/reader-error"
                                     "clojure.walk/prewalk-replace"
                                     "cljs.core/*1"
                                     "cljs.core/Set.EMPTY"
                                     "cljs.reader/read-unicode-char"
                                     "cljs.core/dissoc"
                                     "cljs.core/ffirst"
                                     "clojure.zip/replace"
                                     "cljs.core/vec"
                                     "cljs.core/or"
                                     "cljs.core/mod"
                                     "cljs.core/aset"
                                     "cljs.core/second"
                                     "clojure.set/rename"
                                     "cljs.core/delay?"
                                     "clojure.zip/left"
                                     "cljs.reader/not-implemented"
                                     "cljs.core/IAssociative"
                                     "cljs.core/ObjMap.EMPTY"
                                     "cljs.core/group-by"
                                     "cljs.core/symbol"
                                     "cljs.core/Delay"
                                     "cljs.core/methods"
                                     "cljs.core/vector"
                                     "cljs.core/rand-int"
                                     "cljs.core/PersistentQueue.EMPTY"
                                     "cljs.core/letfn"
                                     "cljs.reader/read-discard"
                                     "cljs.core/inc"
                                     "cljs.core/name"
                                     "cljs.core/cycle"
                                     "cljs.core/map"
                                     "cljs.core/amap"
                                     "clojure.zip/children"
                                     "special/set!"
                                     "cljs.core/when-not"
                                     "clojure.set/index"
                                     "clojure.browser.dom/log"
                                     "cljs.core/Vector.fromArray"
                                     "cljs.core/partition-by"
                                     "cljs.core/sort-by"
                                     "cljs.core/with-meta"
                                     "cljs.core/NeverEquiv"
                                     "cljs.core/select-keys"
                                     "special/loop*"
                                     "cljs.core/ISeq"
                                     "clojure.walk/postwalk-replace"
                                     "cljs.core/pr-with-opts"
                                     "cljs.core/->>"
                                     "cljs.core/nil?"
                                     "clojure.walk/stringify-keys"
                                     "clojure.browser.repl/order"
                                     "cljs.core/memoize"
                                     "cljs.core/pr-sequential"
                                     "clojure.zip/make-node"
                                     "specialrepl/load-namespace"
                                     "cljs.reader/float-pattern"
                                     "cljs.core/ancestors"
                                     "cljs.core/integer?"
                                     "cljs.core/HashMap.EMPTY"
                                     "cljs.core/Vector.EMPTY"
                                     "clojure.zip/xml-zip"
                                     "clojure.walk/walk"
                                     "cljs.core/bit-xor"
                                     "clojure.set/union"
                                     "cljs.reader/PushbackReader"
                                     "cljs.core/isa?"
                                     "clojure.browser.net/xhr-connection"
                                     "cljs.core/subs"
                                     "cljs.core/symbol?"
                                     "clojure.string/replace"
                                     "cljs.core/string?"
                                     "cljs.core/partition-all"
                                     "cljs.core/merge-with"
                                     "clojure.browser.dom/set-properties"
                                     "cljs.core/trampoline"
                                     "clojure.browser.repl/send-print"
                                     "cljs.core/ICounted"
                                     "cljs.core/IEquiv"
                                     "cljs.core/js-delete"
                                     "cljs.core/comment"
                                     "cljs.reader/special-symbols"
                                     "cljs.core/alength"
                                     "special/quote"
                                     "cljs.core/tree-seq"
                                     "cljs.reader/read-unmatched-delimiter"
                                     "cljs.core/every-pred"
                                     "clojure.set/rename-keys"
                                     "cljs.core/peek"
                                     "cljs.core/pr-str-with-opts"
                                     "cljs.core/map?"
                                     "cljs.reader/StringPushbackReader"
                                     "cljs.core/HashMap.fromArrays"
                                     "cljs.core/deref"
                                     "cljs.core/reductions"
                                     "cljs.core/false?"
                                     "cljs.core/bit-flip"
                                     "cljs.core/ISet"
                                     "cljs.core/LazySeq"
                                     "cljs.core/*2"
                                     "clojure.browser.event/total-listener-count"
                                     "cljs.core/alter-meta!"
                                     "clojure.browser.dom/click-element"
                                     "cljs.reader/read-meta"
                                     "special/try*"
                                     "cljs.core/range"
                                     "cljs.core/reify"
                                     "cljs.core/satisfies?"
                                     "cljs.core/nth"
                                     "cljs.core/list"
                                     "cljs.core/defn"
                                     "cljs.core/rand-nth"
                                     "cljs.core/atom"
                                     "cljs.reader/read-keyword"
                                     "cljs.core/Vector"
                                     "cljs.reader/skip-line"
                                     "cljs.core/namespace"
                                     "cljs.nodejs/require"
                                     "clojure.browser.event/EventType"
                                     "cljs.core/merge"
                                     "clojure.browser.repl/send-result"
                                     "clojure.walk/keywordize-keys"
                                     "cljs.core/derive"
                                     "clojure.zip/zipper"
                                     "clojure.zip/remove"
                                     "cljs.core/find"
                                     "cljs.core/*print-dup*"
                                     "cljs.core/partial"
                                     "cljs.core/keyword?"
                                     "clojure.browser.event/fire-listeners"
                                     "cljs.core/interleave"
                                     "cljs.core/*flush-on-newline*"
                                     "cljs.core/get-in"
                                     "clojure.browser.dom/element"
                                     "cljs.core/prim-seq"
                                     "cljs.core/<="
                                     "clojure.set/map-invert"
                                     "clojure.browser.event/listen"
                                     "cljs.core/neg?"
                                     "clojure.browser.dom/replace-node"
                                     "special/catch"
                                     "cljs.core/reverse"
                                     "cljs.core/realized?"}}
                           {:cljs-version "0.0-971",
                            :cljs-date "2012-01-27",
                            :clj-version "1.3.0",
                            :gclosure-lib "20110323-r790",
                            :added #{"cljs.core/type" "cljs.core/IFn"}}
                           {:cljs-version "0.0-993",
                            :cljs-date "2012-02-27",
                            :clj-version "1.3.0",
                            :gclosure-lib "20110323-r790"}
                           {:cljs-version "0.0-1006",
                            :cljs-date "2012-03-30",
                            :clj-version "1.3.0",
                            :gclosure-lib "20110323-r790",
                            :added #{"cljs.core/PersistentVector.EMPTY_NODE"
                                     "cljs.core/PersistentVector.fromArray"
                                     "cljs.core/PersistentVector"
                                     "cljs.core/PersistentVector.EMPTY"}}
                           {:cljs-version "0.0-1011",
                            :cljs-date "2012-04-02",
                            :clj-version "1.3.0",
                            :gclosure-lib "20110323-r790",
                            :added #{"cljs.core/println-str"
                                     "cljs.core/print-str"
                                     "cljs.core/prn-str-with-opts"
                                     "cljs.core/prn-str"}}
                           {:cljs-version "0.0-1211",
                            :cljs-date "2012-05-09",
                            :clj-version "1.4.0",
                            :gclosure-lib "20111110-r1376",
                            :added #{"cljs.core/ITransientCollection"
                                     "cljs.core/transient"
                                     "cljs.core/dissoc!"
                                     "cljs.core/PersistentArrayMap.fromArrays"
                                     "cljs.core/ITransientSet"
                                     "cljs.core/array-map"
                                     "cljs.core/rseq"
                                     "cljs.core/ITransientMap"
                                     "cljs.core/ArrayNodeSeq"
                                     "cljs.core/list?"
                                     "cljs.core/val"
                                     "cljs.core/BitmapIndexedNode"
                                     "cljs.core/IMapEntry"
                                     "cljs.core/*unchecked-if*"
                                     "cljs.core/seqable?"
                                     "cljs.core/sorted-map"
                                     "cljs.core/ASeq"
                                     "cljs.core/reduceable?"
                                     "cljs.core/vector-seq"
                                     "cljs.core/conj!"
                                     "cljs.core/PersistentHashMap"
                                     "cljs.core/IReversible"
                                     "cljs.core/IKVReduce"
                                     "cljs.core/BlackNode"
                                     "cljs.core/PersistentHashSet.EMPTY"
                                     "cljs.core/PersistentArrayMap"
                                     "cljs.core/ObjMap.HASHMAP_THRESHOLD"
                                     "cljs.core/int"
                                     "cljs.core/ISorted"
                                     "cljs.core/double-array"
                                     "cljs.core/PersistentArrayMap.HASHMAP_THRESHOLD"
                                     "cljs.core/PersistentArrayMap.EMPTY"
                                     "cljs.core/reduced?"
                                     "cljs.core/PersistentTreeMapSeq"
                                     "cljs.core/persistent!"
                                     "cljs.core/PersistentHashMap.fromArrays"
                                     "cljs.core/sorted-set"
                                     "cljs.core/PersistentTreeMap.EMPTY"
                                     "cljs.core/IList"
                                     "cljs.core/PersistentHashMap.EMPTY"
                                     "cljs.core/to-array-2d"
                                     "cljs.core/filterv"
                                     "cljs.core/IEditableCollection"
                                     "cljs.core/ArrayNode"
                                     "cljs.core/TransientHashMap"
                                     "cljs.core/TransientArrayMap"
                                     "cljs.core/mapv"
                                     "cljs.core/long"
                                     "cljs.core/reversible?"
                                     "cljs.core/HashCollisionNode"
                                     "cljs.core/into-array"
                                     "cljs.core/TransientVector"
                                     "cljs.core/PersistentTreeSet"
                                     "cljs.core/Reduced"
                                     "cljs.core/long-array"
                                     "cljs.core/subseq"
                                     "cljs.core/bit-count"
                                     "cljs.core/assoc!"
                                     "cljs.core/sorted-map-by"
                                     "cljs.core/NodeSeq"
                                     "cljs.core/gen-apply-to"
                                     "cljs.core/rsubseq"
                                     "cljs.core/make-array"
                                     "cljs.core/sorted-set-by"
                                     "cljs.core/disj!"
                                     "cljs.core/ifn?"
                                     "cljs.core/case"
                                     "cljs.core/RedNode"
                                     "cljs.core/key"
                                     "cljs.core/ITransientAssociative"
                                     "cljs.core/reduce-kv"
                                     "cljs.core/PersistentTreeSet.EMPTY"
                                     "cljs.core/BitmapIndexedNode.EMPTY"
                                     "cljs.core/mk-bound-fn"
                                     "cljs.core/VectorNode"
                                     "cljs.core/PersistentHashSet"
                                     "cljs.core/ITransientVector"
                                     "cljs.core/PersistentTreeMap"
                                     "cljs.core/pop!"
                                     "cljs.core/bit-shift-right-zero-fill"
                                     "cljs.core/reduced"
                                     "cljs.core/object-array"
                                     "cljs.core/indexed?"
                                     "cljs.core/TransientHashSet"},
                            :removed #{"cljs.core/Set"
                                       "cljs.core/Set.EMPTY"}}
                           {:cljs-version "0.0-1236",
                            :cljs-date "2012-05-16",
                            :clj-version "1.4.0",
                            :gclosure-lib "20111110-r1376",
                            :added #{"clojure.core.reducers/drop"
                                     "special/letfn*"
                                     "clojure.core.reducers/folder"
                                     "clojure.core.reducers/Cat"
                                     "clojure.core.reducers/foldcat"
                                     "clojure.core.reducers/fold"
                                     "clojure.core.reducers/monoid"
                                     "clojure.core.reducers/map"
                                     "clojure.core.reducers/cat"
                                     "clojure.core.reducers/take"
                                     "cljs.reader/maybe-read-tagged-type"
                                     "clojure.core.reducers/reduce"
                                     "clojure.core.reducers/flatten"
                                     "cljs.reader/*tag-table*"
                                     "clojure.core.reducers/filter"
                                     "cljs.core/simple-benchmark"
                                     "clojure.core.reducers/append!"
                                     "clojure.core.reducers/reducer"
                                     "clojure.core.reducers/take-while"
                                     "cljs.reader/register-tag-parser!"
                                     "clojure.core.reducers/remove"
                                     "cljs.reader/read-string*"
                                     "clojure.core.reducers/mapcat"}}
                           {:cljs-version "0.0-1424",
                            :cljs-date "2012-06-16",
                            :clj-version "1.4.0",
                            :gclosure-lib "20111110-r1376",
                            :added #{"cljs.core/Box"
                                     "cljs.core/array-chunk"
                                     "cljs.core/string-hash-cache"
                                     "cljs.reader/read-2-chars"
                                     "cljs.core/chunk"
                                     "cljs.core/chunk-next"
                                     "cljs.reader/make-unicode-char"
                                     "cljs.core/shuffle"
                                     "cljs.core/ArrayChunk"
                                     "cljs.core/chunk-cons"
                                     "cljs.core/chunked-seq"
                                     "cljs.reader/unicode-4-pattern"
                                     "cljs.core/IComparable"
                                     "cljs.reader/unicode-2-pattern"
                                     "cljs.core/check-string-hash-cache"
                                     "cljs.core/Keyword"
                                     "cljs.core/key-test"
                                     "cljs.core/IChunkedSeq"
                                     "cljs.core/chunk-append"
                                     "cljs.core/regexp?"
                                     "cljs.reader/read-4-chars"
                                     "cljs.core/UUID"
                                     "cljs.reader/deregister-tag-parser!"
                                     "cljs.core/INext"
                                     "cljs.core/RSeq"
                                     "cljs.core/add-to-string-hash-cache"
                                     "cljs.core/chunk-buffer"
                                     "cljs.core/IChunkedNext"
                                     "cljs.core/ChunkBuffer"
                                     "cljs.core/chunked-seq?"
                                     "cljs.reader/validate-unicode-escape"
                                     "cljs.core/string-hash-cache-count"
                                     "cljs.core/IChunk"
                                     "cljs.reader/parse-timestamp"
                                     "cljs.core/chunk-first"
                                     "cljs.core/ChunkedSeq"
                                     "cljs.core/chunk-rest"
                                     "cljs.core/ChunkedCons"},
                            :removed #{"cljs.core/vector-seq"
                                       "cljs.reader/read-unicode-char"}}
                           {:cljs-version "0.0-1443",
                            :cljs-date "2012-07-06",
                            :clj-version "1.4.0",
                            :gclosure-lib "20111110-r1376",
                            :added #{"cljs.core/printf"
                                     "cljs.core/format"
                                     "cljs.core/obj-map"
                                     "cljs.core/memfn"
                                     "cljs.core/PersistentHashSet.fromArray"
                                     "cljs.core/hash-set"}}
                           {:cljs-version "0.0-1449",
                            :cljs-date "2012-07-24",
                            :clj-version "1.4.0",
                            :gclosure-lib "20111110-r1376"}
                           {:cljs-version "0.0-1450",
                            :cljs-date "2012-07-25",
                            :clj-version "1.4.0",
                            :gclosure-lib "20111110-r1376"}
                           {:cljs-version "0.0-1503",
                            :cljs-date "2012-10-12",
                            :clj-version "1.4.0",
                            :gclosure-lib "20111110-r1376",
                            :added #{"clojure.data/EqualityPartition"
                                     "clojure.reflect/meta"
                                     "cljs.core/write-all"
                                     "cljs.core/pr-sequential-writer"
                                     "cljs.core/StringBufferWriter"
                                     "clojure.reflect/macroexpand"
                                     "cljs.core/pr-seq-writer"
                                     "clojure.reflect/print-doc"
                                     "clojure.reflect/doc"
                                     "cljs.core/IWriter"
                                     "clojure.data/Diff"
                                     "clojure.data/diff"
                                     "cljs.core/IPrintWithWriter"},
                            :removed #{"cljs.core/pr-with-opts"}}
                           {:cljs-version "0.0-1513",
                            :cljs-date "2012-10-19",
                            :clj-version "1.4.0",
                            :gclosure-lib "20111110-r1376"}
                           {:cljs-version "0.0-1535",
                            :cljs-date "2012-11-08",
                            :clj-version "1.4.0",
                            :gclosure-lib "20120710-r2029",
                            :added #{"cljs.core/with-out-str"}}
                           {:cljs-version "0.0-1552",
                            :cljs-date "2012-12-03",
                            :clj-version "1.4.0",
                            :gclosure-lib "20120710-r2029",
                            :added #{"cljs.core/Fn"
                                     "cljs.core/IEncodeJS"
                                     "cljs.core/js-mod"
                                     "cljs.core/IEncodeClojure"
                                     "cljs.core/clj->js"}}
                           {:cljs-version "0.0-1576",
                            :cljs-date "2013-01-27",
                            :clj-version "1.4.0",
                            :gclosure-lib "20120710-r2029",
                            :added #{"cljs.core/ex-message"
                                     "cljs.reader/deregister-default-tag-parser!"
                                     "cljs.core/ex-data"
                                     "cljs.core/ex-info"
                                     "cljs.reader/*default-data-reader-fn*"
                                     "cljs.core/ExceptionInfo"
                                     "cljs.reader/register-default-tag-parser!"
                                     "cljs.core/ex-cause"}}
                           {:cljs-version "0.0-1586",
                            :cljs-date "2013-02-16",
                            :clj-version "1.4.0",
                            :gclosure-lib "20120710-r2029",
                            :added #{"cljs.core/comparator"}}
                           {:cljs-version "0.0-1798",
                            :cljs-date "2013-05-03",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-2029-2",
                            :added #{"cljs.core/unchecked-negate"
                                     "cljs.core/float"
                                     "cljs.core/int-array"
                                     "cljs.core/unchecked-multiply-int"
                                     "cljs.core/cond->"
                                     "cljs.core/unchecked-add"
                                     "cljs.core/Symbol"
                                     "cljs.core/chars"
                                     "cljs.core/short"
                                     "cljs.core/longs"
                                     "cljs.core/unchecked-multiply"
                                     "cljs.core/some->"
                                     "cljs.core/unchecked-negate-int"
                                     "cljs.core/unchecked-substract-int"
                                     "cljs.core/unchecked-double"
                                     "cljs.core/set-print-fn!"
                                     "cljs.core/unchecked-inc-int"
                                     "cljs.core/unchecked-subtract"
                                     "cljs.core/unchecked-add-int"
                                     "cljs.core/some->>"
                                     "cljs.core/unchecked-inc"
                                     "cljs.core/unchecked-subtract-int"
                                     "cljs.core/unchecked-substract"
                                     "cljs.core/unchecked-dec"
                                     "cljs.core/unchecked-divide-int"
                                     "cljs.core/ints"
                                     "cljs.core/PersistentArrayMap.fromArray"
                                     "cljs.core/unchecked-dec-int"
                                     "cljs.core/array?"
                                     "cljs.core/unchecked-char"
                                     "cljs.core/key->js"
                                     "cljs.core/char"
                                     "cljs.core/floats"
                                     "cljs.core/cond->>"
                                     "cljs.core/booleans"
                                     "cljs.core/not-native"
                                     "cljs.core/bytes"
                                     "cljs.core/unchecked-byte"
                                     "cljs.core/unchecked-short"
                                     "cljs.core/byte"
                                     "cljs.core/INamed"
                                     "cljs.core/shorts"
                                     "cljs.core/unchecked-int"
                                     "cljs.core/double"
                                     "cljs.core/exists?"
                                     "cljs.core/doubles"
                                     "cljs.core/unchecked-float"
                                     "cljs.core/divide"
                                     "cljs.core/as->"
                                     "cljs.core/unchecked-remainder-int"
                                     "cljs.core/unchecked-long"},
                            :removed #{"cljs.core/PersistentArrayMap.fromArrays"
                                       "cljs.core/HashMap"
                                       "cljs.core/IPrintable"
                                       "cljs.core/Vector.fromArray"
                                       "cljs.core/pr-sequential"
                                       "cljs.core/HashMap.EMPTY"
                                       "cljs.core/Vector.EMPTY"
                                       "cljs.core/HashMap.fromArrays"
                                       "cljs.core/Vector"}}
                           {:cljs-version "0.0-1803",
                            :cljs-date "2013-05-06",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-2029-2",
                            :added #{"cljs.core/special-symbol?"
                                     "cljs.core/lazy-cat"}}
                           {:cljs-version "0.0-1806",
                            :cljs-date "2013-05-10",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-2029-2",
                            :added #{"cljs.core/with-redefs"
                                     "cljs.core/pr-str*"}}
                           {:cljs-version "0.0-1820",
                            :cljs-date "2013-06-07",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-2029-2",
                            :added #{"cljs.core/ValSeq"
                                     "cljs.core/PersistentArrayMapSeq"
                                     "cljs.core/KeySeq"
                                     "cljs.core/persistent-array-map-seq"}}
                           {:cljs-version "0.0-1835",
                            :cljs-date "2013-06-21",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-2029-2"}
                           {:cljs-version "0.0-1843",
                            :cljs-date "2013-07-16",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-2029-2"}
                           {:cljs-version "0.0-1844",
                            :cljs-date "2013-07-19",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-2029-2"}
                           {:cljs-version "0.0-1847",
                            :cljs-date "2013-07-23",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f"}
                           {:cljs-version "0.0-1853",
                            :cljs-date "2013-08-05",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.7.5",
                            :added #{"cljs.reader/parse-and-validate-timestamp"}}
                           {:cljs-version "0.0-1859",
                            :cljs-date "2013-08-19",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.7.6",
                            :added #{"cljs.core/type->str"}}
                           {:cljs-version "0.0-1877",
                            :cljs-date "2013-09-08",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.7.6",
                            :added #{"cljs.core/keyword-identical?"
                                     "cljs.core/set-from-indexed-seq"}}
                           {:cljs-version "0.0-1878",
                            :cljs-date "2013-09-11",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.7.6"}
                           {:cljs-version "0.0-1885",
                            :cljs-date "2013-09-15",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.7.6",
                            :removed #{"cljs.core/printf"
                                       "cljs.core/format"}}
                           {:cljs-version "0.0-1886",
                            :cljs-date "2013-09-15",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.7.6"}
                           {:cljs-version "0.0-1889",
                            :cljs-date "2013-09-15",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.7.6"}
                           {:cljs-version "0.0-1895",
                            :cljs-date "2013-09-24",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.7.6"}
                           {:cljs-version "0.0-1896",
                            :cljs-date "2013-09-24",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.7.6"}
                           {:cljs-version "0.0-1909",
                            :cljs-date "2013-09-27",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.7.8"}
                           {:cljs-version "0.0-1913",
                            :cljs-date "2013-10-05",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.7.8"}
                           {:cljs-version "0.0-1933",
                            :cljs-date "2013-10-11",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.7.9",
                            :added #{"special/try"},
                            :removed #{"cljs.core/try" "special/try*"}}
                           {:cljs-version "0.0-1934",
                            :cljs-date "2013-10-11",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.7.9"}
                           {:cljs-version "0.0-1978",
                            :cljs-date "2013-10-28",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.7.10"}
                           {:cljs-version "0.0-2014",
                            :cljs-date "2013-11-06",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.7.10",
                            :added #{"cljs.core/*clojurescript-version*"
                                     "cljs.core/implements?"}}
                           {:cljs-version "0.0-2024",
                            :cljs-date "2013-11-08",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.7.10"}
                           {:cljs-version "0.0-2027",
                            :cljs-date "2013-11-08",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.7.10"}
                           {:cljs-version "0.0-2030",
                            :cljs-date "2013-11-08",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.7.10"}
                           {:cljs-version "0.0-2060",
                            :cljs-date "2013-11-21",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.7.10",
                            :added #{"cljs.core/enable-console-print!"
                                     "cljs.core/*print-length*"
                                     "cljs.core/*print-newline*"}}
                           {:cljs-version "0.0-2067",
                            :cljs-date "2013-11-22",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.8.0"}
                           {:cljs-version "0.0-2069",
                            :cljs-date "2013-11-22",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.8.0"}
                           {:cljs-version "0.0-2075",
                            :cljs-date "2013-11-23",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.8.0"}
                           {:cljs-version "0.0-2080",
                            :cljs-date "2013-11-23",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.8.0",
                            :added #{"cljs.core/unsigned-bit-shift-right"}}
                           {:cljs-version "0.0-2120",
                            :cljs-date "2013-12-13",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.8.0",
                            :added #{"cljs.core/print-map"
                                     "cljs.core/sorted?"
                                     "cljs.core/*print-level*"
                                     "clojure.core.reducers/CollFold"
                                     "cljs.core/sequence"
                                     "cljs.core/object?"}}
                           {:cljs-version "0.0-2127",
                            :cljs-date "2013-12-20",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.8.0"}
                           {:cljs-version "0.0-2134",
                            :cljs-date "2013-12-30",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.8.0",
                            :added #{"cljs.core/clone"
                                     "cljs.core/ICloneable"}}
                           {:cljs-version "0.0-2138",
                            :cljs-date "2013-12-31",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.8.0",
                            :added #{"cljs.core/specify"}}
                           {:cljs-version "0.0-2156",
                            :cljs-date "2014-01-29",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.8.3",
                            :added #{"cljs.nodejs/enable-util-print!"
                                     "cljs.core/cloneable?"
                                     "cljs.core/specify!"
                                     "cljs.core/defonce"}}
                           {:cljs-version "0.0-2173",
                            :cljs-date "2014-02-22",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.8.3",
                            :added #{"cljs.core/IReset"
                                     "cljs.core/IAtom"
                                     "cljs.core/ISwap"}}
                           {:cljs-version "0.0-2197",
                            :cljs-date "2014-03-26",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.8.3"}
                           {:cljs-version "0.0-2199",
                            :cljs-date "2014-04-01",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.8.3"}
                           {:cljs-version "0.0-2202",
                            :cljs-date "2014-04-02",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.8.3"}
                           {:cljs-version "0.0-2227",
                            :cljs-date "2014-05-22",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.8.3",
                            :added #{"special/case*"}}
                           {:cljs-version "0.0-2234",
                            :cljs-date "2014-06-13",
                            :clj-version "1.5.1",
                            :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                            :treader-version "0.8.3",
                            :added #{"cljs.core/MetaFn"}}
                           {:cljs-version "0.0-2261",
                            :cljs-date "2014-07-02",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140226-71326067",
                            :treader-version "0.8.4",
                            :added #{"cljs.core/hash-unordered-coll"
                                     "cljs.core/int-rotate-left"
                                     "cljs.core/some?"
                                     "cljs.core/hash-string*"
                                     "cljs.core/m3-C1"
                                     "cljs.core/m3-fmix"
                                     "cljs.core/if-some"
                                     "cljs.core/m3-mix-H1"
                                     "cljs.core/m3-C2"
                                     "cljs.core/hash-string"
                                     "cljs.core/m3-hash-unencoded-chars"
                                     "cljs.reader/read-raw-string*"
                                     "cljs.core/m3-mix-K1"
                                     "cljs.core/hash-keyword"
                                     "cljs.core/m3-hash-int"
                                     "cljs.core/m3-seed"
                                     "cljs.core/hash-ordered-coll"
                                     "cljs.core/when-some"
                                     "cljs.core/mix-collection-hash"},
                            :removed #{"cljs.core/check-string-hash-cache"}}
                           {:cljs-version "0.0-2268",
                            :cljs-date "2014-07-06",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140226-71326067",
                            :treader-version "0.8.4",
                            :added #{"cljs.core/iterator"
                                     "cljs.core/SetEntriesIterator"
                                     "cljs.core/EntriesIterator"
                                     "cljs.core/set-entries-iterator"
                                     "cljs.core/entries-iterator"
                                     "cljs.core/Iterator"}}
                           {:cljs-version "0.0-2277",
                            :cljs-date "2014-07-25",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140226-71326067",
                            :treader-version "0.8.4",
                            :removed #{"cljs.core/unchecked-substract-int"
                                       "cljs.core/unchecked-substract"}}
                           {:cljs-version "0.0-2280",
                            :cljs-date "2014-08-01",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.4"}
                           {:cljs-version "0.0-2301",
                            :cljs-date "2014-08-07",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.4",
                            :added #{"cljs.core/LazyTransformer.createMulti"
                                     "cljs.core/flatmap"
                                     "cljs.core/ArrayList"
                                     "cljs.core/stepper"
                                     "cljs.core/LazyTransformer.create"
                                     "cljs.core/ArrayIter"
                                     "cljs.core/PersistentArrayMap.HASHMAP-THRESHOLD"
                                     "cljs.core/LazyTransformer"
                                     "cljs.core/dedupe"
                                     "cljs.core/string-iter"
                                     "cljs.core/run!"
                                     "cljs.core/lazy-transformer"
                                     "cljs.core/random-sample"
                                     "cljs.core/iter"
                                     "cljs.core/multi-stepper"
                                     "cljs.core/Iteration"
                                     "cljs.core/PersistentVector.EMPTY-NODE"
                                     "clojure.browser.event/IEventType"
                                     "cljs.core/SeqIter"
                                     "cljs.core/Stepper"
                                     "cljs.core/transduce"
                                     "cljs.core/iteration"
                                     "cljs.core/array-iter"
                                     "cljs.core/array-list"
                                     "cljs.core/nil-iter"
                                     "cljs.core/StringIter"
                                     "cljs.core/MultiStepper"
                                     "cljs.core/seq-iter"},
                            :removed #{"cljs.core/PersistentVector.EMPTY_NODE"
                                       "cljs.core/PersistentArrayMap.HASHMAP_THRESHOLD"
                                       "clojure.browser.event/EventType"}}
                           {:cljs-version "0.0-2307",
                            :cljs-date "2014-08-07",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.4"}
                           {:cljs-version "0.0-2311",
                            :cljs-date "2014-08-09",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.4"}
                           {:cljs-version "0.0-2322",
                            :cljs-date "2014-08-27",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.4"}
                           {:cljs-version "0.0-2341",
                            :cljs-date "2014-09-18",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.4",
                            :added #{"cljs.core/js-str"
                                     "cljs.core/cat"
                                     "cljs.core/completing"},
                            :removed #{"cljs.core/flatmap"}}
                           {:cljs-version "0.0-2342",
                            :cljs-date "2014-09-18",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.9"}
                           {:cljs-version "0.0-2356",
                            :cljs-date "2014-09-26",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.9",
                            :added #{"cljs.core/IIterable"
                                     "cljs.core/iterable?"}}
                           {:cljs-version "0.0-2371",
                            :cljs-date "2014-10-10",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.9",
                            :added #{"cljs.core/RangeIterator"
                                     "cljs.core/es6-set-entries-iterator"
                                     "cljs.core/es6-entries-iterator"
                                     "cljs.core/PersistentArrayMapIterator"
                                     "cljs.core/ES6EntriesIterator"
                                     "cljs.core/IndexedSeqIterator"
                                     "cljs.core/RangedIterator"
                                     "cljs.core/es6-iterator"
                                     "cljs.core/eduction"
                                     "cljs.core/ES6Iterator"
                                     "cljs.core/Eduction"
                                     "cljs.core/ES6SetEntriesIterator"
                                     "cljs.core/ranged-iterator"},
                            :removed #{"cljs.core/iterator"
                                       "cljs.core/SetEntriesIterator"
                                       "cljs.core/EntriesIterator"
                                       "cljs.core/Iteration"
                                       "cljs.core/iteration"
                                       "cljs.core/set-entries-iterator"
                                       "cljs.core/entries-iterator"
                                       "cljs.core/Iterator"}}
                           {:cljs-version "0.0-2411",
                            :cljs-date "2014-12-05",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10",
                            :added #{"cljs.core/js-invoke"
                                     "cljs.core/ES6IteratorSeq"
                                     "cljs.core/unreduced"
                                     "cljs.core/es6-iterable"
                                     "cljs.core/nthrest"
                                     "cljs.core/js-in"
                                     "cljs.core/update"
                                     "cljs.core/es6-iterator-seq"
                                     "cljs.core/ensure-reduced"}}
                           {:cljs-version "0.0-2496",
                            :cljs-date "2014-12-17",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10",
                            :added #{"cljs.test/report"
                                     "cljs.test/get-current-env"
                                     "cljs.test/join-fixtures"
                                     "cljs.test/testing-contexts-str"
                                     "cljs.test/do-report"
                                     "cljs.test/set-env!"
                                     "cljs.test/run-tests"
                                     "cljs.repl/print-doc"
                                     "cljs.test/js-filename"
                                     "cljs.core/vswap!"
                                     "cljs.core/IVolatile"
                                     "cljs.test/file-and-line"
                                     "cljs.test/test-all-vars"
                                     "cljs.test/testing-vars-str"
                                     "cljs.test/compose-fixtures"
                                     "cljs.test/is"
                                     "cljs.core/js-debugger"
                                     "cljs.test/clear-env!"
                                     "cljs.core/Volatile"
                                     "cljs.core/ns-interns"
                                     "cljs.test/mapped-line-and-column"
                                     "cljs.test/test-var"
                                     "cljs.test/js-line-and-column"
                                     "cljs.core/volatile!"
                                     "cljs.test/*current-env*"
                                     "cljs.test/update-current-env!"
                                     "cljs.test/successful?"
                                     "cljs.test/inc-report-counter!"
                                     "cljs.core/volatile?"
                                     "cljs.test/test-vars"
                                     "cljs.test/run-all-tests"
                                     "cljs.test/try-expr"
                                     "cljs.pprint/PrettyFlush"
                                     "cljs.core/Var"
                                     "cljs.test/test-ns"
                                     "special/var"
                                     "cljs.repl/doc"
                                     "cljs.core/test"
                                     "cljs.test/deftest"
                                     "cljs.test/testing"
                                     "cljs.test/empty-env"
                                     "cljs.core/vreset!"}}
                           {:cljs-version "0.0-2498",
                            :cljs-date "2014-12-19",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10",
                            :added #{"cljs.test/use-fixtures"}}
                           {:cljs-version "0.0-2505",
                            :cljs-date "2014-12-21",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10"}
                           {:cljs-version "0.0-2511",
                            :cljs-date "2014-12-22",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10"}
                           {:cljs-version "0.0-2629",
                            :cljs-date "2015-01-01",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10",
                            :added #{"cljs.test/are"
                                     "specialrepl/require"}}
                           {:cljs-version "0.0-2644",
                            :cljs-date "2015-01-02",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10"}
                           {:cljs-version "0.0-2655",
                            :cljs-date "2015-01-03",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10",
                            :added #{"cljs.core/*loaded-libs*"}}
                           {:cljs-version "0.0-2657",
                            :cljs-date "2015-01-03",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10",
                            :added #{"specialrepl/require-macros"}}
                           {:cljs-version "0.0-2665",
                            :cljs-date "2015-01-04",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10"}
                           {:cljs-version "0.0-2719",
                            :cljs-date "2015-01-24",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10",
                            :added #{"cljs.repl/with-read-known"
                                     "cljs.core/PersistentHashMap.fromArray"
                                     "cljs.core/load-file*"}}
                           {:cljs-version "0.0-2723",
                            :cljs-date "2015-01-24",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10"}
                           {:cljs-version "0.0-2725",
                            :cljs-date "2015-01-24",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10"}
                           {:cljs-version "0.0-2727",
                            :cljs-date "2015-01-25",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10"}
                           {:cljs-version "0.0-2740",
                            :cljs-date "2015-01-28",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10"}
                           {:cljs-version "0.0-2755",
                            :cljs-date "2015-02-01",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10"}
                           {:cljs-version "0.0-2758",
                            :cljs-date "2015-02-02",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10"}
                           {:cljs-version "0.0-2760",
                            :cljs-date "2015-02-02",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10"}
                           {:cljs-version "0.0-2814",
                            :cljs-date "2015-02-10",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10",
                            :added #{"cljs.test/test-vars-block"
                                     "cljs.test/run-block"
                                     "cljs.test/test-all-vars-block"
                                     "cljs.test/async?"
                                     "cljs.test/IAsyncTest"
                                     "cljs.test/block"
                                     "cljs.test/run-tests-block"
                                     "cljs.test/async"
                                     "cljs.test/get-and-clear-env!"
                                     "cljs.core/*e"
                                     "cljs.test/test-ns-block"
                                     "cljs.test/test-var-block"}}
                           {:cljs-version "0.0-2816",
                            :cljs-date "2015-02-10",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10"}
                           {:cljs-version "0.0-2843",
                            :cljs-date "2015-02-12",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10"}
                           {:cljs-version "0.0-2850",
                            :cljs-date "2015-02-13",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10"}
                           {:cljs-version "0.0-2911",
                            :cljs-date "2015-02-21",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10",
                            :added #{"clojure.browser.net/IWebSocket"
                                     "clojure.browser.net/websocket-connection"},
                            :removed #{"cljs.repl/with-read-known"}}
                           {:cljs-version "0.0-2913",
                            :cljs-date "2015-02-21",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10"}
                           {:cljs-version "0.0-2985",
                            :cljs-date "2015-03-04",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.10",
                            :added #{"cljs.repl/source"
                                     "cljs.repl/apropos"
                                     "specialrepl/import"
                                     "cljs.repl/pst"
                                     "cljs.repl/dir"
                                     "cljs.core/*target*"
                                     "cljs.repl/find-doc"}}
                           {:cljs-version "0.0-3030",
                            :cljs-date "2015-03-07",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.16"}
                           {:cljs-version "0.0-3053",
                            :cljs-date "2015-03-09",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.16"}
                           {:cljs-version "0.0-3058",
                            :cljs-date "2015-03-09",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.16",
                            :added #{"clojure.browser.repl/get-ua-product"}}
                           {:cljs-version "0.0-3115",
                            :cljs-date "2015-03-15",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.16",
                            :added #{"clojure.browser.repl/bootstrap"
                                     "clojure.browser.repl/load-queue"},
                            :removed #{"cljs.core/load-file*"}}
                           {:cljs-version "0.0-3117",
                            :cljs-date "2015-03-16",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.16"}
                           {:cljs-version "0.0-3119",
                            :cljs-date "2015-03-16",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.16"}
                           {:cljs-version "0.0-3123",
                            :cljs-date "2015-03-16",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.16"}
                           {:cljs-version "0.0-3126",
                            :cljs-date "2015-03-18",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.16"}
                           {:cljs-version "0.0-3148",
                            :cljs-date "2015-03-23",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.16",
                            :added #{"cljs.repl/err-out"}}
                           {:cljs-version "0.0-3149",
                            :cljs-date "2015-03-23",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.16"}
                           {:cljs-version "0.0-3153",
                            :cljs-date "2015-03-25",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.16"}
                           {:cljs-version "0.0-3165",
                            :cljs-date "2015-03-27",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.16",
                            :added #{"cljs.core/dispatch-fn"
                                     "cljs.core/macroexpand"
                                     "cljs.core/macroexpand-1"
                                     "cljs.core/default-dispatch-val"}}
                           {:cljs-version "0.0-3169",
                            :cljs-date "2015-03-31",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.16",
                            :added #{"cljs.core/ns-unmap"}}
                           {:cljs-version "0.0-3178",
                            :cljs-date "2015-04-06",
                            :clj-version "1.6.0",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.8.16",
                            :added #{"cljs.core/array-index-of"}}
                           {:cljs-version "0.0-3190",
                            :cljs-date "2015-04-09",
                            :clj-version "1.7.0-alpha6",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.9.0"}
                           {:cljs-version "0.0-3191",
                            :cljs-date "2015-04-09",
                            :clj-version "1.7.0-alpha6",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.9.1"}
                           {:cljs-version "0.0-3195",
                            :cljs-date "2015-04-10",
                            :clj-version "1.7.0-alpha6",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.9.1"}
                           {:cljs-version "0.0-3196",
                            :cljs-date "2015-04-10",
                            :clj-version "1.7.0-beta1",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.9.1"}
                           {:cljs-version "0.0-3208",
                            :cljs-date "2015-04-16",
                            :clj-version "1.7.0-beta1",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.9.1"}
                           {:cljs-version "0.0-3211",
                            :cljs-date "2015-04-23",
                            :clj-version "1.7.0-beta1",
                            :gclosure-lib "0.0-20140718-946a7d39",
                            :treader-version "0.9.1"}
                           {:cljs-version "0.0-3255",
                            :cljs-date "2015-05-08",
                            :clj-version "1.7.0-beta2",
                            :gclosure-lib "0.0-20150505-021ed5b3",
                            :treader-version "0.9.2",
                            :added #{"cljs.pprint/write-out"
                                     "cljs.pprint/cl-format"
                                     "cljs.core/tagged-literal?"
                                     "cljs.pprint/get-pretty-writer"
                                     "cljs.pprint/write"
                                     "cljs.pprint/char-code"
                                     "cljs.pprint/simple-dispatch"
                                     "cljs.core/var?"
                                     "cljs.pprint/fresh-line"
                                     "cljs.pprint/pprint-set"
                                     "cljs.pprint/deftype"
                                     "cljs.pprint/with-pretty-writer"
                                     "cljs.pprint/setf"
                                     "cljs.pprint/float?"
                                     "cljs.pprint/*print-base*"
                                     "cljs.pprint/pprint-newline"
                                     "cljs.core/tagged-literal"
                                     "cljs.pprint/*print-suppress-namespaces*"
                                     "cljs.pprint/set-pprint-dispatch"
                                     "cljs.pprint/with-pprint-dispatch"
                                     "cljs.pprint/*print-radix*"
                                     "cljs.pprint/pprint"
                                     "cljs.pprint/getf"
                                     "cljs.pprint/formatter-out"
                                     "cljs.pprint/pp"
                                     "cljs.pprint/formatter"
                                     "cljs.pprint/*print-pretty*"
                                     "cljs.pprint/pprint-tab"
                                     "cljs.pprint/*print-pprint-dispatch*"
                                     "cljs.pprint/pprint-indent"
                                     "cljs.pprint/print-length-loop"
                                     "cljs.core/record?"
                                     "cljs.pprint/code-dispatch"
                                     "cljs.pprint/IPrettyFlush"
                                     "cljs.pprint/print-table"
                                     "cljs.pprint/*print-miser-width*"
                                     "cljs.pprint/*print-right-margin*"
                                     "cljs.pprint/pprint-logical-block"
                                     "cljs.core/TaggedLiteral"
                                     "cljs.pprint/*out*"},
                            :removed #{"cljs.pprint/PrettyFlush"}}
                           {:cljs-version "0.0-3263",
                            :cljs-date "2015-05-09",
                            :clj-version "1.7.0-beta2",
                            :gclosure-lib "0.0-20150505-021ed5b3",
                            :treader-version "0.9.2"}
                           {:cljs-version "0.0-3264",
                            :cljs-date "2015-05-09",
                            :clj-version "1.7.0-beta2",
                            :gclosure-lib "0.0-20150505-021ed5b3",
                            :treader-version "0.9.2"}
                           {:cljs-version "0.0-3269",
                            :cljs-date "2015-05-10",
                            :clj-version "1.7.0-beta2",
                            :gclosure-lib "0.0-20150505-021ed5b3",
                            :treader-version "0.9.2"}
                           {:cljs-version "0.0-3291",
                            :cljs-date "2015-05-18",
                            :clj-version "1.7.0-beta2",
                            :gclosure-lib "0.0-20150505-021ed5b3",
                            :treader-version "0.9.2",
                            :added #{"cljs.core/uuid"}}
                           {:cljs-version "0.0-3297",
                            :cljs-date "2015-05-23",
                            :clj-version "1.7.0-beta2",
                            :gclosure-lib "0.0-20150505-021ed5b3",
                            :treader-version "0.9.2"}
                           {:cljs-version "0.0-3308",
                            :cljs-date "2015-06-01",
                            :clj-version "1.7.0-RC1",
                            :gclosure-lib "0.0-20150505-021ed5b3",
                            :treader-version "0.9.2",
                            :added #{"cljs.core/random-uuid"}}
                           {:cljs-version "1.7.10",
                            :cljs-date "2015-07-29",
                            :clj-version "1.7.0",
                            :gclosure-lib "0.0-20150505-021ed5b3",
                            :treader-version "0.10.0-alpha3",
                            :added #{"cljs.core/js-reserved"
                                     "cljs.core/demunge"
                                     "cljs.js/*loaded*"
                                     "cljs.js/require"
                                     "cljs.js/debug-prn"
                                     "cljs.core/*out*"
                                     "cljs.js/sm-data"
                                     "cljs.core/symbol-identical?"
                                     "cljs.js/append-source-map"
                                     "cljs.core/DEMUNGE_MAP"
                                     "cljs.js/dump-core"
                                     "cljs.js/analyze"
                                     "cljs.js/compile*"
                                     "cljs.core/*print-err-fn*"
                                     "cljs.core/set-print-err-fn!"
                                     "cljs.js/analyze*"
                                     "cljs.js/load-macros"
                                     "cljs.js/load-deps"
                                     "cljs.core/ns-interns*"
                                     "cljs.js/*eval-fn*"
                                     "cljs.core/munge"
                                     "cljs.core/find-macros-ns"
                                     "cljs.core/CHAR_MAP"
                                     "cljs.js/valid-opts?"
                                     "cljs.core/*ns*"
                                     "cljs.js/*load-fn*"
                                     "cljs.js/atom?"
                                     "cljs.js/valid-name?"
                                     "cljs.js/eval-str*"
                                     "cljs.core/copy-arguments"
                                     "cljs.core/print-meta?"
                                     "cljs.js/js-eval"
                                     "cljs.core/NS_CACHE"
                                     "cljs.core/char?"
                                     "cljs.js/empty-state"
                                     "cljs.js/load-analysis-cache!"
                                     "cljs.core/find-ns"
                                     "cljs.js/eval-str"
                                     "cljs.js/ns-side-effects"
                                     "cljs.js/eval"
                                     "cljs.js/wrap-error"
                                     "cljs.js/eval*"
                                     "cljs.js/ns->relpath"
                                     "cljs.js/load-source-map!"
                                     "cljs.core/find-ns-obj"
                                     "cljs.js/compile"
                                     "cljs.core/Namespace"
                                     "cljs.js/prefix"
                                     "cljs.js/analyze-deps"
                                     "cljs.core/*assert*"
                                     "cljs.core/ns-name"
                                     "cljs.js/file->ns"
                                     "cljs.core/create-ns"
                                     "cljs.js/with-state"
                                     "cljs.core/DEMUNGE_PATTERN"},
                            :removed #{"cljs.pprint/*out*"}}
                           {:cljs-version "1.7.28",
                            :cljs-date "2015-07-31",
                            :clj-version "1.7.0",
                            :gclosure-lib "0.0-20150505-021ed5b3",
                            :treader-version "0.10.0-alpha3",
                            :added #{"cljs.core/RecordIter"
                                     "cljs.core/HashMapIter"
                                     "cljs.core/HashSetIter"
                                     "cljs.core/PersistentQueueIter"
                                     "cljs.core/NodeIterator"
                                     "cljs.js/compile-str"
                                     "cljs.js/analyze-str"
                                     "cljs.core/ArrayNodeIterator"},
                            :removed #{"cljs.js/sm-data"
                                       "cljs.js/append-source-map"
                                       "cljs.js/analyze"
                                       "cljs.js/compile*"
                                       "cljs.js/analyze*"
                                       "cljs.js/load-macros"
                                       "cljs.js/load-deps"
                                       "cljs.js/eval-str*"
                                       "cljs.js/ns-side-effects"
                                       "cljs.js/wrap-error"
                                       "cljs.js/eval*"
                                       "cljs.js/compile"
                                       "cljs.js/prefix"
                                       "cljs.js/analyze-deps"}}
                           {:cljs-version "1.7.48",
                            :cljs-date "2015-08-05",
                            :clj-version "1.7.0",
                            :gclosure-lib "0.0-20150805-acd8b553",
                            :treader-version "0.10.0-alpha3",
                            :added #{"clojure.browser.repl/print-queue"
                                     "clojure.browser.repl/flush-print-queue!"
                                     "cljs.core/goog-define"},
                            :removed #{"cljs.js/debug-prn"
                                       "cljs.js/valid-opts?"
                                       "cljs.js/atom?"
                                       "cljs.js/valid-name?"}}
                           {:cljs-version "1.7.58",
                            :cljs-date "2015-08-06",
                            :clj-version "1.7.0",
                            :gclosure-lib "0.0-20150805-acd8b553",
                            :treader-version "0.10.0-alpha3"}
                           {:cljs-version "1.7.107",
                            :cljs-date "2015-08-11",
                            :clj-version "1.7.0",
                            :gclosure-lib "0.0-20150805-acd8b553",
                            :treader-version "0.10.0-alpha3",
                            :added #{"cljs.reader/read-literal"
                                     "cljs.core/js-comment"
                                     "cljs.core/js-inline-comment"
                                     "cljs.core/unsafe-cast"}}
                           {:cljs-version "1.7.122",
                            :cljs-date "2015-08-29",
                            :clj-version "1.7.0",
                            :gclosure-lib "0.0-20150805-acd8b553",
                            :treader-version "0.10.0-alpha3"}
                           {:cljs-version "1.7.145",
                            :cljs-date "2015-10-13",
                            :clj-version "1.7.0",
                            :gclosure-lib "0.0-20150805-acd8b553",
                            :treader-version "0.10.0-alpha3",
                            :added #{"clojure.string/index-of"
                                     "clojure.string/last-index-of"
                                     "cljs.core/system-time"
                                     "clojure.string/starts-with?"
                                     "clojure.string/ends-with?"
                                     "clojure.string/includes?"}}
                           {:cljs-version "1.7.166",
                            :cljs-date "2015-11-04",
                            :clj-version "1.7.0",
                            :gclosure-lib "0.0-20151016-61277aea",
                            :treader-version "0.10.0-alpha3"}
                           {:cljs-version "1.7.170",
                            :cljs-date "2015-11-06",
                            :clj-version "1.7.0",
                            :gclosure-lib "0.0-20151016-61277aea",
                            :treader-version "0.10.0-alpha3"}
                           {:cljs-version "1.7.189",
                            :cljs-date "2015-12-01",
                            :clj-version "1.7.0",
                            :gclosure-lib "0.0-20151016-61277aea",
                            :treader-version "0.10.0-alpha3"}
                           {:cljs-version "1.7.228",
                            :cljs-date "2016-01-08",
                            :clj-version "1.7.0",
                            :gclosure-lib "0.0-20151016-61277aea",
                            :treader-version "1.0.0-alpha1"}],
                 :symbol-names #{"cljs.core/keys"
                                 "cljs.core/unchecked-negate"
                                 "cljs.core/reset!"
                                 "cljs.core/ITransientCollection"
                                 "cljs.core/transient"
                                 "cljs.core/Fn"
                                 "clojure.data/EqualityPartition"
                                 "cljs.core/ex-message"
                                 "cljs.core/js-reserved"
                                 "cljs.pprint/write-out"
                                 "cljs.test/test-vars-block"
                                 "clojure.set/select"
                                 "cljs.core/hash-unordered-coll"
                                 "cljs.core/delay"
                                 "cljs.core/float"
                                 "cljs.core/bit-not"
                                 "cljs.core/partition"
                                 "cljs.core/IEncodeJS"
                                 "cljs.core/parents"
                                 "cljs.core/aclone"
                                 "cljs.core/reset-meta!"
                                 "cljs.core/IReset"
                                 "special/defrecord*"
                                 "cljs.core/Box"
                                 "cljs.pprint/cl-format"
                                 "cljs.core/tagged-literal?"
                                 "cljs.reader/dispatch-macros"
                                 "cljs.core/demunge"
                                 "cljs.pprint/get-pretty-writer"
                                 "cljs.core/int-rotate-left"
                                 "cljs.core/ICollection"
                                 "cljs.core/every?"
                                 "clojure.zip/node"
                                 "cljs.core/RecordIter"
                                 "clojure.string/index-of"
                                 "cljs.core/IEmptyableCollection"
                                 "clojure.zip/right"
                                 "cljs.core/int-array"
                                 "cljs.core/LazyTransformer.createMulti"
                                 "cljs.core/=="
                                 "cljs.core/dissoc!"
                                 "special/."
                                 "clojure.reflect/meta"
                                 "cljs.reader/read-literal"
                                 "clojure.browser.net/*timeout*"
                                 "cljs.js/*loaded*"
                                 "cljs.core/remove-method"
                                 "cljs.core/array-chunk"
                                 "clojure.core.reducers/drop"
                                 "clojure.browser.net/IWebSocket"
                                 "cljs.core/PersistentArrayMap.fromArrays"
                                 "cljs.core/frequencies"
                                 "cljs.core/pop"
                                 "cljs.repl/with-read-known"
                                 "cljs.core/flatmap"
                                 "cljs.core/not-every?"
                                 "cljs.core/js-invoke"
                                 "cljs.core/some-fn"
                                 "clojure.browser.event/remove-all"
                                 "cljs.core/doto"
                                 "cljs.core/take-while"
                                 "cljs.reader/escape-char-map"
                                 "clojure.browser.event/all-listeners"
                                 "cljs.core/ITransientSet"
                                 "cljs.core/vals"
                                 "cljs.core/IDeref"
                                 "cljs.js/require"
                                 "cljs.core/string-hash-cache"
                                 "cljs.core/array-map"
                                 "cljs.test/report"
                                 "clojure.browser.dom/log-obj"
                                 "cljs.nodejs/enable-util-print!"
                                 "cljs.repl/source"
                                 "cljs.core/for"
                                 "cljs.js/debug-prn"
                                 "cljs.core/unchecked-multiply-int"
                                 "cljs.core/cond->"
                                 "cljs.core/instance?"
                                 "cljs.core/ValSeq"
                                 "clojure.browser.repl/print-queue"
                                 "clojure.string/last-index-of"
                                 "cljs.core/rseq"
                                 "cljs.core/PersistentVector.EMPTY_NODE"
                                 "cljs.reader/read-comment"
                                 "cljs.core/ITransientMap"
                                 "cljs.core/*loaded-libs*"
                                 "cljs.reader/read-number"
                                 "cljs.core/ILookup"
                                 "cljs.core/when"
                                 "cljs.core/ArrayNodeSeq"
                                 "cljs.core/list?"
                                 "cljs.core/val"
                                 "clojure.browser.dom/set-value"
                                 "cljs.core/BitmapIndexedNode"
                                 "cljs.reader/read-past"
                                 "cljs.core/to-array"
                                 "cljs.core/interpose"
                                 "cljs.core/IMapEntry"
                                 "clojure.browser.net/ICrossPageChannel"
                                 "special/finally"
                                 "cljs.core/Cons"
                                 "cljs.core/re-find"
                                 "cljs.core/IMeta"
                                 "cljs.core/js-str"
                                 "cljs.test/are"
                                 "cljs.core/RangeIterator"
                                 "cljs.core/iterator"
                                 "cljs.core/assoc-in"
                                 "special/letfn*"
                                 "clojure.string/join"
                                 "cljs.core/*unchecked-if*"
                                 "cljs.core/some?"
                                 "cljs.core/seqable?"
                                 "clojure.browser.repl/flush-print-queue!"
                                 "clojure.zip/rights"
                                 "cljs.core/split-at"
                                 "clojure.zip/append-child"
                                 "cljs.core/binding"
                                 "cljs.test/get-current-env"
                                 "cljs.core/Set"
                                 "cljs.core/sorted-map"
                                 "cljs.reader/macro-terminating?"
                                 "cljs.pprint/write"
                                 "cljs.test/join-fixtures"
                                 "cljs.core/prefers"
                                 "cljs.core/vary-meta"
                                 "cljs.core/unchecked-add"
                                 "cljs.core/when-let"
                                 "clojure.core.reducers/folder"
                                 "cljs.core/ASeq"
                                 "cljs.core/drop"
                                 "cljs.core/ArrayList"
                                 "cljs.core/stepper"
                                 "cljs.pprint/char-code"
                                 "cljs.core/IAtom"
                                 "cljs.core/reduceable?"
                                 "cljs.core/while"
                                 "cljs.core/dispatch-fn"
                                 "cljs.core/*out*"
                                 "cljs.core/import-macros"
                                 "cljs.core/string-print"
                                 "cljs.core/ES6IteratorSeq"
                                 "cljs.js/sm-data"
                                 "cljs.repl/err-out"
                                 "cljs.core/-"
                                 "cljs.core/vector-seq"
                                 "cljs.core/IIterable"
                                 "cljs.test/testing-contexts-str"
                                 "clojure.zip/vector-zip"
                                 "cljs.reader/read-2-chars"
                                 "cljs.core/chunk"
                                 "cljs.core/conj!"
                                 "cljs.test/do-report"
                                 "cljs.core/print-map"
                                 "cljs.core/js->clj"
                                 "cljs.core/List"
                                 "cljs.core/identical?"
                                 "cljs.core/*main-cli-fn*"
                                 "clojure.browser.dom/html->dom"
                                 "cljs.core/symbol-identical?"
                                 "cljs.core/LazyTransformer.create"
                                 "cljs.core/chunk-next"
                                 "cljs.core/enable-console-print!"
                                 "cljs.core/sorted?"
                                 "cljs.core/some"
                                 "cljs.core/PersistentArrayMapSeq"
                                 "cljs.reader/make-unicode-char"
                                 "clojure.core.reducers/Cat"
                                 "cljs.core/write-all"
                                 "cljs.core/doall"
                                 "cljs.core/condp"
                                 "clojure.zip/down"
                                 "cljs.pprint/simple-dispatch"
                                 "cljs.core/IPending"
                                 "cljs.core/count"
                                 "cljs.core/bit-test"
                                 "cljs.core/js-mod"
                                 "cljs.core/es6-set-entries-iterator"
                                 "cljs.test/set-env!"
                                 "cljs.core/SetEntriesIterator"
                                 "cljs.core/loop"
                                 "cljs.core/subvec"
                                 "cljs.core/bit-clear"
                                 "cljs.repl/apropos"
                                 "cljs.core/gensym"
                                 "special/recur"
                                 "cljs.core/Symbol"
                                 "cljs.core/hash-string*"
                                 "cljs.core/shuffle"
                                 "cljs.core/+"
                                 "cljs.core/clone"
                                 "cljs.core/comp"
                                 "cljs.core/ArrayIter"
                                 "cljs.core/var?"
                                 "cljs.reader/desugar-meta"
                                 "cljs.pprint/fresh-line"
                                 "cljs.core/pr"
                                 "cljs.test/run-tests"
                                 "clojure.string/upper-case"
                                 "cljs.core/chars"
                                 "clojure.browser.event/expose"
                                 "clojure.browser.event/listen-once"
                                 "cljs.core/m3-C1"
                                 "cljs.core/empty?"
                                 "cljs.core/m3-fmix"
                                 "cljs.core/newline"
                                 "cljs.core/PersistentHashMap"
                                 "cljs.pprint/pprint-set"
                                 "cljs.pprint/deftype"
                                 "cljs.core/replace"
                                 "cljs.core/rand"
                                 "cljs.core/add-watch"
                                 "cljs.core/cloneable?"
                                 "clojure.string/capitalize"
                                 "cljs.core/short"
                                 "cljs.core/replicate"
                                 "cljs.core/es6-entries-iterator"
                                 "special/do"
                                 "cljs.core/ArrayChunk"
                                 "cljs.core/sequential?"
                                 "cljs.core/underive"
                                 "cljs.core/PersistentArrayMapIterator"
                                 "cljs.core/ns-unmap"
                                 "cljs.core/macroexpand"
                                 "clojure.browser.repl/get-ua-product"
                                 "cljs.core/get-method"
                                 "cljs.core/="
                                 "cljs.reader/deregister-default-tag-parser!"
                                 "cljs.core/system-time"
                                 "cljs.core/defn-"
                                 "specialrepl/import"
                                 "cljs.js/append-source-map"
                                 "cljs.reader/read-symbol"
                                 "cljs.reader/push-back-reader"
                                 "cljs.core/deftype"
                                 "cljs.repl/print-doc"
                                 "cljs.core/longs"
                                 "cljs.core/Subvec"
                                 "cljs.core/macroexpand-1"
                                 "cljs.core/if-some"
                                 "cljs.test/js-filename"
                                 "special/ns"
                                 "cljs.core/IReversible"
                                 "cljs.core/extend-protocol"
                                 "cljs.reader/read"
                                 "cljs.core/EmptyList"
                                 "cljs.core/specify!"
                                 "cljs.core/DEMUNGE_MAP"
                                 "cljs.core/cat"
                                 "clojure.walk/postwalk"
                                 "cljs.core/PersistentArrayMap.HASHMAP-THRESHOLD"
                                 "clojure.zip/edit"
                                 "cljs.core/unreduced"
                                 "cljs.core/re-seq"
                                 "cljs.reader/read-list"
                                 "cljs.core/IKVReduce"
                                 "cljs.core/Atom"
                                 "clojure.core.reducers/foldcat"
                                 "cljs.core/specify"
                                 "cljs.core/IMap"
                                 "cljs.core/pr-sequential-writer"
                                 "cljs.core/unchecked-multiply"
                                 "cljs.reader/read-vector"
                                 "clojure.set/join"
                                 "cljs.core/HashMap"
                                 "cljs.core/es6-iterable"
                                 "cljs.reader/int-pattern"
                                 "cljs.core/swap!"
                                 "cljs.core/dec"
                                 "cljs.core/EntriesIterator"
                                 "cljs.core/*clojurescript-version*"
                                 "cljs.js/dump-core"
                                 "clojure.core.reducers/fold"
                                 "cljs.core/StringBufferWriter"
                                 "cljs.js/analyze"
                                 "clojure.browser.dom/remove-children"
                                 "cljs.core/BlackNode"
                                 "cljs.core/some->"
                                 "cljs.core/get-validator"
                                 "cljs.core/coll?"
                                 "cljs.core/unchecked-negate-int"
                                 "cljs.core/bit-or"
                                 "cljs.core/nfirst"
                                 "cljs.core/keep"
                                 "cljs.core/take"
                                 "cljs.core/PersistentHashSet.EMPTY"
                                 "cljs.core/cond"
                                 "cljs.core/bit-and"
                                 "cljs.core/MetaFn"
                                 "cljs.core/ObjMap.fromObject"
                                 "cljs.core/PersistentArrayMap"
                                 "cljs.core/HashMapIter"
                                 "clojure.browser.event/unique-event-id"
                                 "cljs.core/vswap!"
                                 "cljs.core/ObjMap.HASHMAP_THRESHOLD"
                                 "clojure.set/project"
                                 "cljs.core/int"
                                 "special/js*"
                                 "clojure.reflect/macroexpand"
                                 "cljs.pprint/with-pretty-writer"
                                 "clojure.string/trim-newline"
                                 "specialrepl/in-ns"
                                 "special/let*"
                                 "cljs.core/pr-seq-writer"
                                 "special/throw"
                                 "cljs.core/chunk-cons"
                                 "clojure.zip/insert-left"
                                 "cljs.core/*print-level*"
                                 "cljs.core/true?"
                                 "cljs.core/unchecked-substract-int"
                                 "clojure.browser.net/xpc-connection"
                                 "cljs.core/ES6EntriesIterator"
                                 "cljs.core/not"
                                 "cljs.core/js-obj"
                                 "cljs.core/complement"
                                 "cljs.core/spread"
                                 "cljs.core/unchecked-double"
                                 "cljs.core/keyword"
                                 "cljs.core/sort"
                                 "clojure.string/trim"
                                 "cljs.core/meta"
                                 "clojure.core.reducers/monoid"
                                 "cljs.core/time"
                                 "cljs.core/boolean"
                                 "cljs.reader/read-token"
                                 "cljs.core/update-in"
                                 "cljs.core/map-indexed"
                                 "cljs.core/IVolatile"
                                 "cljs.core/printf"
                                 "clojure.core.reducers/map"
                                 "cljs.core/IStack"
                                 "cljs.repl/pst"
                                 "cljs.reader/parse-and-validate-timestamp"
                                 "cljs.core/ISorted"
                                 "cljs.test/file-and-line"
                                 "cljs.core/IIndexed"
                                 "clojure.browser.repl/repl-print"
                                 "clojure.browser.net/xpc-config-fields"
                                 "cljs.js/compile*"
                                 "cljs.core/ISwap"
                                 "cljs.core/nnext"
                                 "cljs.core/*print-meta*"
                                 "cljs.reader/read-dispatch"
                                 "cljs.test/run-block"
                                 "cljs.core/*print-err-fn*"
                                 "cljs.core/distinct"
                                 "cljs.reader/wrapping-reader"
                                 "cljs.core/LazyTransformer"
                                 "cljs.core/double-array"
                                 "cljs.core/prn"
                                 "cljs.core/chunked-seq"
                                 "clojure.zip/leftmost"
                                 "cljs.core/nthrest"
                                 "cljs.core/js-in"
                                 "cljs.core/>="
                                 "clojure.browser.net/websocket-connection"
                                 "cljs.core/default-dispatch-val"
                                 "cljs.reader/macros"
                                 "cljs.core/doseq"
                                 "cljs.core/*"
                                 "cljs.core/into"
                                 "cljs.core/defmethod"
                                 "cljs.core/rest"
                                 "cljs.reader/unicode-4-pattern"
                                 "clojure.browser.repl/bootstrap"
                                 "cljs.core/dotimes"
                                 "cljs.core/dedupe"
                                 "clojure.zip/lefts"
                                 "clojure.browser.dom/ensure-element"
                                 "cljs.core/defmacro"
                                 "cljs.core/remove"
                                 "cljs.test/test-all-vars"
                                 "cljs.core/set-print-fn!"
                                 "cljs.core/PersistentArrayMap.HASHMAP_THRESHOLD"
                                 "cljs.core/if-not"
                                 "cljs.core/string-iter"
                                 "cljs.core/set-print-err-fn!"
                                 "cljs.js/analyze*"
                                 "specialrepl/require"
                                 "clojure.zip/path"
                                 "cljs.core/mapcat"
                                 "cljs.core/m3-mix-H1"
                                 "cljs.core/IWatchable"
                                 "cljs.core/PersistentHashMap.fromArray"
                                 "cljs.core/run!"
                                 "cljs.core/IndexedSeqIterator"
                                 "cljs.core/unchecked-inc-int"
                                 "cljs.test/testing-vars-str"
                                 "clojure.zip/rightmost"
                                 "cljs.core/PersistentArrayMap.EMPTY"
                                 "cljs.core/m3-C2"
                                 "cljs.test/compose-fixtures"
                                 "cljs.core/unchecked-subtract"
                                 "cljs.js/load-macros"
                                 "cljs.core/->"
                                 "cljs.core/remove-all-methods"
                                 "cljs.core/unchecked-add-int"
                                 "clojure.string/replace-first"
                                 "cljs.core/reduced?"
                                 "clojure.browser.dom/get-value"
                                 "clojure.core.reducers/CollFold"
                                 "cljs.nodejs/process"
                                 "cljs.core/some->>"
                                 "cljs.core/unchecked-inc"
                                 "cljs.core/not="
                                 "cljs.core/unchecked-subtract-int"
                                 "cljs.core/ex-data"
                                 "cljs.core/PersistentTreeMapSeq"
                                 "cljs.core/js-keys"
                                 "clojure.zip/seq-zip"
                                 "cljs.core/lazy-transformer"
                                 "cljs.core/random-sample"
                                 "cljs.core/IVector"
                                 "cljs.core/iter"
                                 "cljs.core/persistent!"
                                 "cljs.core/empty"
                                 "cljs.core/re-matches"
                                 "clojure.browser.dom/DOMBuilder"
                                 "cljs.core/extend-type"
                                 "cljs.core/ISeqable"
                                 "cljs.core/assoc"
                                 "clojure.browser.repl/xpc-connection"
                                 "cljs.core/IDerefWithTimeout"
                                 "cljs.core/multi-stepper"
                                 "clojure.core.reducers/cat"
                                 "cljs.core/unchecked-substract"
                                 "cljs.core/Iteration"
                                 "clojure.browser.repl/start-evaluator"
                                 "cljs.pprint/setf"
                                 "clojure.browser.event/unlisten"
                                 "cljs.test/is"
                                 "cljs.test/use-fixtures"
                                 "cljs.pprint/float?"
                                 "cljs.core/PersistentHashMap.fromArrays"
                                 "cljs.core/special-symbol?"
                                 "cljs.js/load-deps"
                                 "cljs.core/js-debugger"
                                 "cljs.core/ns-interns*"
                                 "cljs.core/format"
                                 "cljs.core/sorted-set"
                                 "cljs.core/fnil"
                                 "cljs.core/update"
                                 "cljs.core/this-as"
                                 "cljs.core/PersistentQueueSeq"
                                 "cljs.core/counted?"
                                 "clojure.string/trimr"
                                 "clojure.core.reducers/take"
                                 "cljs.core/force"
                                 "cljs.core/compare-and-set!"
                                 "cljs.core/set?"
                                 "cljs.core/hash-string"
                                 "cljs.core/unchecked-dec"
                                 "cljs.core/PersistentVector.EMPTY-NODE"
                                 "clojure.string/escape"
                                 "cljs.core/remove-watch"
                                 "cljs.core/m3-hash-unencoded-chars"
                                 "cljs.core/es6-iterator-seq"
                                 "cljs.js/*eval-fn*"
                                 "cljs.core/IMultiFn"
                                 "clojure.browser.event/IEventType"
                                 "cljs.core/HashSetIter"
                                 "clojure.zip/end?"
                                 "clojure.string/starts-with?"
                                 "cljs.test/clear-env!"
                                 "special/try"
                                 "cljs.test/test-all-vars-block"
                                 "clojure.set/superset?"
                                 "clojure.browser.net/IConnection"
                                 "cljs.core/let"
                                 "cljs.core/unchecked-divide-int"
                                 "cljs.core/dorun"
                                 "cljs.core/with-redefs"
                                 "cljs.core/SeqIter"
                                 "cljs.core/munge"
                                 "cljs.core/unsigned-bit-shift-right"
                                 "cljs.core/iterable?"
                                 "cljs.core/pr-str"
                                 "cljs.core/IPrintable"
                                 "cljs.core/defprotocol"
                                 "cljs.core/ints"
                                 "cljs.core/assert"
                                 "cljs.core/declare"
                                 "cljs.core/PersistentTreeMap.EMPTY"
                                 "cljs.core/fn?"
                                 "cljs.core/associative?"
                                 "cljs.core/IList"
                                 "cljs.core/list*"
                                 "cljs.core/PersistentArrayMap.fromArray"
                                 "cljs.core/js-comment"
                                 "cljs.core/reduce"
                                 "clojure.browser.event/has-listener"
                                 "cljs.core/unchecked-dec-int"
                                 "cljs.core/PersistentHashMap.EMPTY"
                                 "cljs.pprint/*print-base*"
                                 "cljs.core/compare"
                                 "cljs.core/contains?"
                                 "cljs.core/Stepper"
                                 "cljs.core/prefer-method"
                                 "cljs.core/array-seq"
                                 "cljs.core/to-array-2d"
                                 "cljs.core/find-macros-ns"
                                 "cljs.core/ICloneable"
                                 "cljs.core/*print-length*"
                                 "cljs.core/PersistentQueue"
                                 "cljs.core/drop-last"
                                 "cljs.core/array?"
                                 "cljs.core/PersistentVector.fromArray"
                                 "cljs.core/filterv"
                                 "cljs.core/IComparable"
                                 "cljs.reader/read-string"
                                 "cljs.reader/unicode-2-pattern"
                                 "cljs.core/CHAR_MAP"
                                 "cljs.core/Volatile"
                                 "cljs.core/check-string-hash-cache"
                                 "cljs.core/vector?"
                                 "cljs.core/defmulti"
                                 "cljs.core/Keyword"
                                 "cljs.core/List.EMPTY"
                                 "clojure.browser.event/dispatch-event"
                                 "cljs.core/ns-interns"
                                 "clojure.string/split-lines"
                                 "cljs.test/mapped-line-and-column"
                                 "cljs.js/valid-opts?"
                                 "cljs.core/*ns*"
                                 "cljs.core/areduce"
                                 "cljs.core/disj"
                                 "cljs.js/*load-fn*"
                                 "cljs.core/IEditableCollection"
                                 "cljs.core/unchecked-char"
                                 "cljs.core/keyword-identical?"
                                 "clojure.browser.net/event-types"
                                 "clojure.string/lower-case"
                                 "cljs.core/*print-fn*"
                                 "cljs.core/str"
                                 "cljs.core/ISequential"
                                 "cljs.pprint/pprint-newline"
                                 "cljs.core/key-test"
                                 "cljs.core/set"
                                 "cljs.core/obj-map"
                                 "special/def"
                                 "clojure.browser.repl/load-queue"
                                 "cljs.core/print"
                                 "cljs.core/ArrayNode"
                                 "cljs.core/type"
                                 "clojure.string/blank?"
                                 "cljs.reader/maybe-read-tagged-type"
                                 "cljs.core/js-inline-comment"
                                 "cljs.core/IChunkedSeq"
                                 "clojure.browser.dom/append"
                                 "cljs.core/take-last"
                                 "cljs.core/key->js"
                                 "cljs.core/TransientHashMap"
                                 "clojure.set/intersection"
                                 "cljs.js/atom?"
                                 "cljs.test/async?"
                                 "cljs.core/fnext"
                                 "cljs.core/apply"
                                 "clojure.walk/prewalk"
                                 "cljs.core/flatten"
                                 "cljs.js/valid-name?"
                                 "cljs.core/get"
                                 "cljs.core/char"
                                 "cljs.core/tagged-literal"
                                 "cljs.core/.."
                                 "cljs.core/floats"
                                 "specialrepl/require-macros"
                                 "cljs.core/Range"
                                 "cljs.core/zero?"
                                 "cljs.core/identity"
                                 "cljs.core/first"
                                 "cljs.reader/ratio-pattern"
                                 "cljs.core/println-str"
                                 "cljs.core/>"
                                 "cljs.core/juxt"
                                 "cljs.pprint/*print-suppress-namespaces*"
                                 "cljs.core/max"
                                 "cljs.core/completing"
                                 "cljs.core/transduce"
                                 "cljs.pprint/set-pprint-dispatch"
                                 "cljs.test/test-var"
                                 "cljs.core/with-out-str"
                                 "cljs.core/*3"
                                 "cljs.core/memfn"
                                 "cljs.core/IEncodeClojure"
                                 "cljs.js/eval-str*"
                                 "cljs.core/TransientArrayMap"
                                 "cljs.core/cond->>"
                                 "cljs.core/number?"
                                 "cljs.core/array"
                                 "cljs.core/nthnext"
                                 "cljs.core/re-pattern"
                                 "cljs.core/missing-protocol"
                                 "clojure.browser.dom/set-text"
                                 "cljs.test/js-line-and-column"
                                 "cljs.core/copy-arguments"
                                 "clojure.zip/up"
                                 "cljs.core/IWithMeta"
                                 "cljs.core/bit-and-not"
                                 "clojure.string/triml"
                                 "cljs.core/chunk-append"
                                 "clojure.string/ends-with?"
                                 "cljs.core/print-meta?"
                                 "cljs.core/regexp?"
                                 "clojure.string/split"
                                 "cljs.reader/read-4-chars"
                                 "cljs.pprint/with-pprint-dispatch"
                                 "cljs.core/iteration"
                                 "cljs.core/hash-map"
                                 "cljs.core/mapv"
                                 "cljs.core/rem"
                                 "cljs.core/IRecord"
                                 "cljs.core/unsafe-cast"
                                 "cljs.core/RangedIterator"
                                 "cljs.core/volatile!"
                                 "cljs.core/constantly"
                                 "cljs.test/*current-env*"
                                 "clojure.browser.dom/get-element"
                                 "cljs.core/PersistentQueueIter"
                                 "cljs.core/UUID"
                                 "clojure.core.reducers/reduce"
                                 "cljs.core/and"
                                 "cljs.js/js-eval"
                                 "clojure.browser.repl/wrap-message"
                                 "cljs.reader/deregister-tag-parser!"
                                 "clojure.reflect/print-doc"
                                 "clojure.browser.event/unlisten-by-key"
                                 "cljs.core/try"
                                 "cljs.core/iterate"
                                 "cljs.core/lazy-seq"
                                 "cljs.test/update-current-env!"
                                 "specialrepl/load-file"
                                 "cljs.core/IndexedSeq"
                                 "cljs.core/KeySeq"
                                 "cljs.core/next"
                                 "cljs.core/*print-readably*"
                                 "cljs.core/booleans"
                                 "cljs.core/not-native"
                                 "cljs.core/last"
                                 "cljs.core/pr-str*"
                                 "cljs.core/random-uuid"
                                 "cljs.core/bit-shift-left"
                                 "clojure.string/reverse"
                                 "cljs.core/min"
                                 "cljs.reader/escape-char"
                                 "cljs.reader/read-raw-string*"
                                 "cljs.core/INext"
                                 "cljs.reader/read-map"
                                 "cljs.core/seq"
                                 "cljs.core/*print-newline*"
                                 "cljs.core/long"
                                 "cljs.core/es6-iterator"
                                 "cljs.core/not-empty"
                                 "cljs.core/println"
                                 "cljs.core/NS_CACHE"
                                 "clojure.browser.repl/connect"
                                 "cljs.core/bytes"
                                 "cljs.core/unchecked-byte"
                                 "clojure.browser.dom/insert-at"
                                 "cljs.core/quot"
                                 "clojure.browser.event/get-listener"
                                 "cljs.core/filter"
                                 "cljs.core/RSeq"
                                 "clojure.zip/branch?"
                                 "special/if"
                                 "cljs.pprint/*print-radix*"
                                 "cljs.core/ObjMap"
                                 "cljs.core/sequence"
                                 "cljs.core/zipmap"
                                 "cljs.core/char?"
                                 "cljs.core/hash-combine"
                                 "cljs.core/reversible?"
                                 "clojure.core.reducers/flatten"
                                 "cljs.core/max-key"
                                 "clojure.zip/insert-child"
                                 "cljs.core/defrecord"
                                 "cljs.core/eduction"
                                 "cljs.core/ex-info"
                                 "cljs.js/empty-state"
                                 "cljs.core/butlast"
                                 "cljs.core/array-iter"
                                 "cljs.core/print-str"
                                 "cljs.core/hash"
                                 "cljs.core/bit-set"
                                 "cljs.core/clj->js"
                                 "cljs.js/load-analysis-cache!"
                                 "cljs.core/concat"
                                 "cljs.test/IAsyncTest"
                                 "cljs.core/conj"
                                 "cljs.core/unchecked-short"
                                 "clojure.set/difference"
                                 "cljs.core/byte"
                                 "cljs.core/when-first"
                                 "cljs.reader/*tag-table*"
                                 "cljs.core/distinct?"
                                 "cljs.pprint/pprint"
                                 "clojure.core.reducers/filter"
                                 "cljs.core/INamed"
                                 "cljs.core/add-to-string-hash-cache"
                                 "cljs.core/HashCollisionNode"
                                 "cljs.core/m3-mix-K1"
                                 "cljs.core/object?"
                                 "cljs.core/pos?"
                                 "cljs.test/block"
                                 "cljs.core/into-array"
                                 "cljs.core/PersistentVector"
                                 "cljs.core/IHash"
                                 "clojure.reflect/doc"
                                 "cljs.core/is_proto_"
                                 "cljs.core/shorts"
                                 "cljs.core/TransientVector"
                                 "cljs.core/keep-indexed"
                                 "cljs.core/bit-shift-right"
                                 "cljs.core/comparator"
                                 "cljs.core/ES6Iterator"
                                 "cljs.pprint/getf"
                                 "cljs.repl/dir"
                                 "cljs.core/PersistentTreeSet"
                                 "clojure.zip/insert-right"
                                 "cljs.core/make-hierarchy"
                                 "cljs.core/repeat"
                                 "cljs.core/array-list"
                                 "cljs.core/prn-str-with-opts"
                                 "cljs.core/MultiFn"
                                 "cljs.test/successful?"
                                 "cljs.core/hash-keyword"
                                 "cljs.test/run-tests-block"
                                 "cljs.core/Reduced"
                                 "cljs.core/not-any?"
                                 "cljs.reader/read-regex"
                                 "clojure.zip/next"
                                 "cljs.test/async"
                                 "cljs.core/find-ns"
                                 "cljs.core/IFn"
                                 "cljs.core/aget"
                                 "cljs.core/if-let"
                                 "cljs.core//"
                                 "cljs.core/unchecked-int"
                                 "cljs.core/min-key"
                                 "clojure.zip/root"
                                 "cljs.core/drop-while"
                                 "clojure.browser.repl/evaluate-javascript"
                                 "cljs.core/set-validator!"
                                 "cljs.core/<"
                                 "cljs.core/fn"
                                 "cljs.core/split-with"
                                 "cljs.pprint/formatter-out"
                                 "cljs.js/eval-str"
                                 "cljs.pprint/pp"
                                 "cljs.core/IWriter"
                                 "cljs.core/IReduce"
                                 "cljs.reader/symbol-pattern"
                                 "cljs.core/PersistentHashSet.fromArray"
                                 "cljs.core/repeatedly"
                                 "cljs.js/ns-side-effects"
                                 "cljs.reader/read-delimited-list"
                                 "cljs.test/inc-report-counter!"
                                 "cljs.core/undefined?"
                                 "clojure.zip/prev"
                                 "cljs.core/seq?"
                                 "cljs.pprint/formatter"
                                 "cljs.core/prn-str"
                                 "cljs.core/chunk-buffer"
                                 "cljs.core/odd?"
                                 "cljs.core/cons"
                                 "special/deftype*"
                                 "cljs.reader/read-set"
                                 "cljs.core/descendants"
                                 "special/new"
                                 "cljs.core/take-nth"
                                 "cljs.reader/throwing-reader"
                                 "cljs.core/double"
                                 "cljs.core/even?"
                                 "cljs.core/simple-benchmark"
                                 "cljs.core/persistent-array-map-seq"
                                 "special/fn*"
                                 "clojure.set/subset?"
                                 "cljs.core/flush"
                                 "cljs.core/long-array"
                                 "cljs.reader/reader-error"
                                 "clojure.walk/prewalk-replace"
                                 "cljs.core/*1"
                                 "cljs.core/subseq"
                                 "cljs.core/Eduction"
                                 "cljs.core/Set.EMPTY"
                                 "cljs.reader/read-unicode-char"
                                 "cljs.core/dissoc"
                                 "cljs.pprint/*print-pretty*"
                                 "cljs.core/exists?"
                                 "cljs.core/ffirst"
                                 "clojure.zip/replace"
                                 "cljs.core/vec"
                                 "cljs.core/or"
                                 "cljs.core/doubles"
                                 "cljs.core/mod"
                                 "cljs.core/aset"
                                 "cljs.js/eval"
                                 "cljs.core/second"
                                 "cljs.core/IChunkedNext"
                                 "cljs.core/bit-count"
                                 "clojure.set/rename"
                                 "cljs.core/m3-hash-int"
                                 "cljs.core/assoc!"
                                 "cljs.test/get-and-clear-env!"
                                 "cljs.core/delay?"
                                 "clojure.zip/left"
                                 "cljs.reader/not-implemented"
                                 "cljs.core/IAssociative"
                                 "cljs.pprint/pprint-tab"
                                 "cljs.core/ObjMap.EMPTY"
                                 "cljs.core/group-by"
                                 "special/case*"
                                 "cljs.reader/*default-data-reader-fn*"
                                 "cljs.core/array-index-of"
                                 "cljs.core/*e"
                                 "cljs.core/sorted-map-by"
                                 "cljs.core/symbol"
                                 "cljs.core/volatile?"
                                 "cljs.core/Delay"
                                 "cljs.core/methods"
                                 "cljs.test/test-vars"
                                 "cljs.core/lazy-cat"
                                 "cljs.core/vector"
                                 "cljs.core/rand-int"
                                 "cljs.core/m3-seed"
                                 "cljs.core/PersistentQueue.EMPTY"
                                 "cljs.core/unchecked-float"
                                 "clojure.core.reducers/append!"
                                 "cljs.core/NodeSeq"
                                 "cljs.core/letfn"
                                 "cljs.reader/read-discard"
                                 "cljs.js/wrap-error"
                                 "cljs.core/gen-apply-to"
                                 "cljs.core/inc"
                                 "cljs.core/NodeIterator"
                                 "cljs.core/name"
                                 "cljs.test/test-ns-block"
                                 "cljs.core/cycle"
                                 "cljs.core/rsubseq"
                                 "cljs.core/divide"
                                 "cljs.core/hash-ordered-coll"
                                 "cljs.core/nil-iter"
                                 "cljs.test/run-all-tests"
                                 "cljs.core/map"
                                 "cljs.core/ChunkBuffer"
                                 "cljs.js/eval*"
                                 "cljs.js/ns->relpath"
                                 "cljs.core/amap"
                                 "clojure.zip/children"
                                 "special/set!"
                                 "cljs.core/when-not"
                                 "clojure.set/index"
                                 "cljs.core/chunked-seq?"
                                 "clojure.browser.dom/log"
                                 "cljs.core/Vector.fromArray"
                                 "cljs.core/make-array"
                                 "cljs.core/sorted-set-by"
                                 "cljs.pprint/*print-pprint-dispatch*"
                                 "cljs.core/partition-by"
                                 "cljs.core/sort-by"
                                 "cljs.core/with-meta"
                                 "cljs.core/NeverEquiv"
                                 "cljs.core/select-keys"
                                 "special/loop*"
                                 "cljs.core/ISeq"
                                 "cljs.core/disj!"
                                 "cljs.test/try-expr"
                                 "cljs.pprint/pprint-indent"
                                 "cljs.core/type->str"
                                 "clojure.walk/postwalk-replace"
                                 "cljs.core/ES6SetEntriesIterator"
                                 "cljs.core/pr-with-opts"
                                 "cljs.core/->>"
                                 "cljs.core/defonce"
                                 "cljs.core/nil?"
                                 "cljs.core/load-file*"
                                 "clojure.walk/stringify-keys"
                                 "clojure.browser.repl/order"
                                 "cljs.core/memoize"
                                 "cljs.core/pr-sequential"
                                 "cljs.js/load-source-map!"
                                 "clojure.zip/make-node"
                                 "cljs.core/PersistentVector.EMPTY"
                                 "specialrepl/load-namespace"
                                 "cljs.reader/float-pattern"
                                 "cljs.core/find-ns-obj"
                                 "cljs.core/ancestors"
                                 "cljs.js/compile-str"
                                 "cljs.core/integer?"
                                 "cljs.js/compile"
                                 "cljs.core/HashMap.EMPTY"
                                 "cljs.core/Vector.EMPTY"
                                 "clojure.zip/xml-zip"
                                 "clojure.walk/walk"
                                 "cljs.core/ifn?"
                                 "cljs.core/bit-xor"
                                 "clojure.set/union"
                                 "cljs.core/case"
                                 "cljs.reader/PushbackReader"
                                 "cljs.core/isa?"
                                 "cljs.pprint/PrettyFlush"
                                 "clojure.browser.net/xhr-connection"
                                 "cljs.core/as->"
                                 "clojure.core.reducers/reducer"
                                 "cljs.core/uuid"
                                 "cljs.core/subs"
                                 "cljs.core/symbol?"
                                 "clojure.data/Diff"
                                 "clojure.string/replace"
                                 "cljs.core/string?"
                                 "cljs.core/*target*"
                                 "cljs.core/Namespace"
                                 "cljs.core/partition-all"
                                 "cljs.core/Var"
                                 "cljs.core/RedNode"
                                 "cljs.core/ExceptionInfo"
                                 "cljs.core/merge-with"
                                 "cljs.core/key"
                                 "clojure.browser.dom/set-properties"
                                 "clojure.data/diff"
                                 "cljs.core/ITransientAssociative"
                                 "cljs.core/trampoline"
                                 "cljs.test/test-ns"
                                 "cljs.core/implements?"
                                 "cljs.js/prefix"
                                 "clojure.browser.repl/send-print"
                                 "cljs.core/ICounted"
                                 "cljs.core/IEquiv"
                                 "cljs.pprint/print-length-loop"
                                 "cljs.core/reduce-kv"
                                 "cljs.core/js-delete"
                                 "cljs.core/PersistentTreeSet.EMPTY"
                                 "cljs.core/comment"
                                 "cljs.reader/special-symbols"
                                 "cljs.js/analyze-str"
                                 "cljs.core/record?"
                                 "cljs.core/BitmapIndexedNode.EMPTY"
                                 "cljs.reader/register-default-tag-parser!"
                                 "cljs.core/alength"
                                 "cljs.core/mk-bound-fn"
                                 "cljs.reader/validate-unicode-escape"
                                 "special/quote"
                                 "cljs.js/analyze-deps"
                                 "cljs.core/VectorNode"
                                 "cljs.core/string-hash-cache-count"
                                 "cljs.core/tree-seq"
                                 "cljs.reader/read-unmatched-delimiter"
                                 "clojure.core.reducers/take-while"
                                 "cljs.reader/register-tag-parser!"
                                 "cljs.core/every-pred"
                                 "special/var"
                                 "cljs.core/PersistentHashSet"
                                 "cljs.repl/doc"
                                 "clojure.set/rename-keys"
                                 "cljs.core/peek"
                                 "cljs.core/pr-str-with-opts"
                                 "cljs.core/IChunk"
                                 "cljs.core/ITransientVector"
                                 "cljs.core/IPrintWithWriter"
                                 "cljs.core/test"
                                 "cljs.core/map?"
                                 "cljs.reader/StringPushbackReader"
                                 "cljs.pprint/code-dispatch"
                                 "cljs.core/PersistentTreeMap"
                                 "cljs.core/HashMap.fromArrays"
                                 "cljs.core/deref"
                                 "cljs.core/reductions"
                                 "cljs.core/false?"
                                 "cljs.core/bit-flip"
                                 "cljs.test/deftest"
                                 "cljs.core/ISet"
                                 "cljs.core/StringIter"
                                 "cljs.core/LazySeq"
                                 "cljs.core/pop!"
                                 "cljs.reader/parse-timestamp"
                                 "cljs.core/chunk-first"
                                 "cljs.core/ChunkedSeq"
                                 "cljs.test/testing"
                                 "cljs.core/*2"
                                 "clojure.browser.event/total-listener-count"
                                 "cljs.core/goog-define"
                                 "cljs.core/MultiStepper"
                                 "cljs.core/alter-meta!"
                                 "clojure.browser.dom/click-element"
                                 "cljs.core/*assert*"
                                 "cljs.core/seq-iter"
                                 "clojure.string/includes?"
                                 "cljs.core/unchecked-remainder-int"
                                 "cljs.core/bit-shift-right-zero-fill"
                                 "cljs.core/when-some"
                                 "cljs.reader/read-meta"
                                 "special/try*"
                                 "cljs.test/test-var-block"
                                 "cljs.core/range"
                                 "cljs.core/reify"
                                 "cljs.core/satisfies?"
                                 "cljs.core/nth"
                                 "cljs.core/list"
                                 "cljs.core/defn"
                                 "cljs.core/rand-nth"
                                 "cljs.core/ex-cause"
                                 "cljs.core/atom"
                                 "cljs.reader/read-keyword"
                                 "cljs.core/Vector"
                                 "cljs.reader/skip-line"
                                 "cljs.core/namespace"
                                 "cljs.core/ns-name"
                                 "cljs.nodejs/require"
                                 "cljs.core/chunk-rest"
                                 "cljs.core/unchecked-long"
                                 "clojure.browser.event/EventType"
                                 "cljs.pprint/IPrettyFlush"
                                 "cljs.js/file->ns"
                                 "cljs.core/ranged-iterator"
                                 "cljs.pprint/print-table"
                                 "cljs.core/create-ns"
                                 "cljs.core/merge"
                                 "clojure.core.reducers/remove"
                                 "cljs.core/set-entries-iterator"
                                 "clojure.browser.repl/send-result"
                                 "cljs.js/with-state"
                                 "clojure.walk/keywordize-keys"
                                 "cljs.pprint/*print-miser-width*"
                                 "cljs.core/entries-iterator"
                                 "cljs.core/reduced"
                                 "cljs.reader/read-string*"
                                 "cljs.core/ArrayNodeIterator"
                                 "cljs.core/ChunkedCons"
                                 "cljs.core/derive"
                                 "clojure.zip/zipper"
                                 "cljs.test/empty-env"
                                 "clojure.core.reducers/mapcat"
                                 "clojure.zip/remove"
                                 "cljs.repl/find-doc"
                                 "cljs.core/find"
                                 "cljs.core/hash-set"
                                 "cljs.core/*print-dup*"
                                 "cljs.core/set-from-indexed-seq"
                                 "cljs.core/object-array"
                                 "cljs.core/indexed?"
                                 "cljs.core/partial"
                                 "cljs.core/keyword?"
                                 "clojure.browser.event/fire-listeners"
                                 "cljs.core/Iterator"
                                 "cljs.core/vreset!"
                                 "cljs.pprint/*print-right-margin*"
                                 "cljs.core/interleave"
                                 "cljs.core/TransientHashSet"
                                 "cljs.core/*flush-on-newline*"
                                 "cljs.core/get-in"
                                 "clojure.browser.dom/element"
                                 "cljs.core/prim-seq"
                                 "cljs.pprint/pprint-logical-block"
                                 "cljs.core/<="
                                 "clojure.set/map-invert"
                                 "clojure.browser.event/listen"
                                 "cljs.core/neg?"
                                 "cljs.core/mix-collection-hash"
                                 "clojure.browser.dom/replace-node"
                                 "cljs.core/TaggedLiteral"
                                 "cljs.core/DEMUNGE_PATTERN"
                                 "special/catch"
                                 "cljs.core/reverse"
                                 "cljs.pprint/*out*"
                                 "cljs.core/realized?"
                                 "cljs.core/ensure-reduced"},
                 :namespace-names #{"clojure.zip"
                                    "clojure.reflect"
                                    "cljs.test"
                                    "specialrepl"
                                    "clojure.browser.dom"
                                    "clojure.set"
                                    "cljs.nodejs"
                                    "clojure.walk"
                                    "cljs.js"
                                    "special"
                                    "clojure.browser.event"
                                    "cljs.reader"
                                    "clojure.string"
                                    "cljs.repl"
                                    "clojure.browser.net"
                                    "cljs.core"
                                    "cljs.pprint"
                                    "clojure.data"
                                    "clojure.core.reducers"
                                    "clojure.browser.repl"}},
       :compiler {:changes [{:cljs-version "0.0-927",
                             :cljs-date "2012-01-20",
                             :clj-version "1.3.0",
                             :gclosure-lib "20110323-r790",
                             :added #{"cljs.repl.rhino/current-repl-env"
                                      "cljs.repl/evaluate-form"
                                      "cljs.repl/load-stream"
                                      "cljs.repl.rhino/eval-result"
                                      "cljs.repl.browser/read-get"
                                      "cljs.repl.browser/load-javascript"
                                      "cljs.repl.browser/add-in-order"
                                      "cljs.repl/load-namespace"
                                      "cljs.repl.rhino/loaded-libs"
                                      "cljs.repl.browser/run-in-order"
                                      "cljs.repl.browser/compile-client-js"
                                      "cljs.repl.browser/handle-get"
                                      "cljs.repl.browser/stop-server"
                                      "cljs.repl.browser/read-request"
                                      "cljs.repl/load-file"
                                      "cljs.repl.browser/browser-eval"
                                      "cljs.repl.browser/server-state"
                                      "cljs.repl.browser/send-for-eval"
                                      "cljs.repl.browser/constrain-order"
                                      "cljs.repl.rhino/rhino-eval"
                                      "cljs.repl.browser/read-headers"
                                      "cljs.repl/repl"
                                      "cljs.repl.rhino/load-javascript"
                                      "cljs.repl.browser/create-client-js-file"
                                      "cljs.repl/*cljs-verbose*"
                                      "cljs.repl.browser/loaded-libs"
                                      "cljs.repl.browser/repl-client-js"
                                      "cljs.repl.browser/parse-headers"
                                      "cljs.repl.browser/send-404"
                                      "cljs.repl.browser/repl-env"
                                      "cljs.repl.rhino/repl-env"
                                      "cljs.repl.rhino/goog-require"
                                      "cljs.repl.browser/send-repl-client-page"
                                      "cljs.repl.browser/send-and-close"
                                      "cljs.repl.rhino/bootjs"
                                      "cljs.repl/IJavaScriptEnv"
                                      "cljs.repl.browser/handle-connection"
                                      "cljs.repl.rhino/IEval"
                                      "cljs.repl.browser/start-server"
                                      "cljs.repl.browser/server-loop"
                                      "cljs.repl.browser/read-post"
                                      "cljs.repl.rhino/rhino-setup"
                                      "cljs.repl.browser/handle-post"
                                      "cljs.repl.rhino/stacktrace"
                                      "cljs.repl.browser/ordering"}}
                            {:cljs-version "0.0-971",
                             :cljs-date "2012-01-27",
                             :clj-version "1.3.0",
                             :gclosure-lib "20110323-r790"}
                            {:cljs-version "0.0-993",
                             :cljs-date "2012-02-27",
                             :clj-version "1.3.0",
                             :gclosure-lib "20110323-r790",
                             :added #{"cljs.repl/default-special-fns"}}
                            {:cljs-version "0.0-1006",
                             :cljs-date "2012-03-30",
                             :clj-version "1.3.0",
                             :gclosure-lib "20110323-r790"}
                            {:cljs-version "0.0-1011",
                             :cljs-date "2012-04-02",
                             :clj-version "1.3.0",
                             :gclosure-lib "20110323-r790"}
                            {:cljs-version "0.0-1211",
                             :cljs-date "2012-05-09",
                             :clj-version "1.4.0",
                             :gclosure-lib "20111110-r1376",
                             :added #{"cljs.repl.browser/send-static"}}
                            {:cljs-version "0.0-1236",
                             :cljs-date "2012-05-16",
                             :clj-version "1.4.0",
                             :gclosure-lib "20111110-r1376"}
                            {:cljs-version "0.0-1424",
                             :cljs-date "2012-06-16",
                             :clj-version "1.4.0",
                             :gclosure-lib "20111110-r1376",
                             :added #{"cljs.repl.browser/preloaded-libs"}}
                            {:cljs-version "0.0-1443",
                             :cljs-date "2012-07-06",
                             :clj-version "1.4.0",
                             :gclosure-lib "20111110-r1376"}
                            {:cljs-version "0.0-1449",
                             :cljs-date "2012-07-24",
                             :clj-version "1.4.0",
                             :gclosure-lib "20111110-r1376"}
                            {:cljs-version "0.0-1450",
                             :cljs-date "2012-07-25",
                             :clj-version "1.4.0",
                             :gclosure-lib "20111110-r1376"}
                            {:cljs-version "0.0-1503",
                             :cljs-date "2012-10-12",
                             :clj-version "1.4.0",
                             :gclosure-lib "20111110-r1376",
                             :added #{"cljs.repl.server/handlers"
                                      "cljs.repl.server/dispatch-on"
                                      "cljs.repl.server/start"
                                      "cljs.repl.reflect/parse-param"
                                      "cljs.repl/analyze-source"
                                      "cljs.repl.server/state"
                                      "cljs.repl.reflect/macroexpand"
                                      "cljs.repl.server/read-request"
                                      "cljs.repl.server/set-connection"
                                      "cljs.repl.server/read-post"
                                      "cljs.repl.server/parse-headers"
                                      "cljs.repl.reflect/handle-reflect-query"
                                      "cljs.repl.server/stop"
                                      "cljs.repl.server/read-get"
                                      "cljs.repl.reflect/read-url-string"
                                      "cljs.repl.browser/browser-state"
                                      "cljs.repl.server/read-headers"
                                      "cljs.repl.server/send-and-close"
                                      "cljs.repl.server/send-404"
                                      "cljs.repl.server/connection"},
                             :removed #{"cljs.repl.browser/read-get"
                                        "cljs.repl.browser/handle-get"
                                        "cljs.repl.browser/stop-server"
                                        "cljs.repl.browser/read-request"
                                        "cljs.repl.browser/server-state"
                                        "cljs.repl.browser/read-headers"
                                        "cljs.repl.browser/parse-headers"
                                        "cljs.repl.browser/send-404"
                                        "cljs.repl.browser/send-and-close"
                                        "cljs.repl.browser/handle-connection"
                                        "cljs.repl.browser/start-server"
                                        "cljs.repl.browser/server-loop"
                                        "cljs.repl.browser/read-post"}}
                            {:cljs-version "0.0-1513",
                             :cljs-date "2012-10-19",
                             :clj-version "1.4.0",
                             :gclosure-lib "20111110-r1376"}
                            {:cljs-version "0.0-1535",
                             :cljs-date "2012-11-08",
                             :clj-version "1.4.0",
                             :gclosure-lib "20120710-r2029"}
                            {:cljs-version "0.0-1552",
                             :cljs-date "2012-12-03",
                             :clj-version "1.4.0",
                             :gclosure-lib "20120710-r2029"}
                            {:cljs-version "0.0-1576",
                             :cljs-date "2013-01-27",
                             :clj-version "1.4.0",
                             :gclosure-lib "20120710-r2029",
                             :removed #{"cljs.repl.rhino/loaded-libs"}}
                            {:cljs-version "0.0-1586",
                             :cljs-date "2013-02-16",
                             :clj-version "1.4.0",
                             :gclosure-lib "20120710-r2029"}
                            {:cljs-version "0.0-1798",
                             :cljs-date "2013-05-03",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-2029-2"}
                            {:cljs-version "0.0-1803",
                             :cljs-date "2013-05-06",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-2029-2"}
                            {:cljs-version "0.0-1806",
                             :cljs-date "2013-05-10",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-2029-2"}
                            {:cljs-version "0.0-1820",
                             :cljs-date "2013-06-07",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-2029-2"}
                            {:cljs-version "0.0-1835",
                             :cljs-date "2013-06-21",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-2029-2"}
                            {:cljs-version "0.0-1843",
                             :cljs-date "2013-07-16",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-2029-2"}
                            {:cljs-version "0.0-1844",
                             :cljs-date "2013-07-19",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-2029-2"}
                            {:cljs-version "0.0-1847",
                             :cljs-date "2013-07-23",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f"}
                            {:cljs-version "0.0-1853",
                             :cljs-date "2013-08-05",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.7.5"}
                            {:cljs-version "0.0-1859",
                             :cljs-date "2013-08-19",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.7.6"}
                            {:cljs-version "0.0-1877",
                             :cljs-date "2013-09-08",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.7.6"}
                            {:cljs-version "0.0-1878",
                             :cljs-date "2013-09-11",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.7.6"}
                            {:cljs-version "0.0-1885",
                             :cljs-date "2013-09-15",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.7.6"}
                            {:cljs-version "0.0-1886",
                             :cljs-date "2013-09-15",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.7.6"}
                            {:cljs-version "0.0-1889",
                             :cljs-date "2013-09-15",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.7.6"}
                            {:cljs-version "0.0-1895",
                             :cljs-date "2013-09-24",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.7.6"}
                            {:cljs-version "0.0-1896",
                             :cljs-date "2013-09-24",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.7.6"}
                            {:cljs-version "0.0-1909",
                             :cljs-date "2013-09-27",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.7.8"}
                            {:cljs-version "0.0-1913",
                             :cljs-date "2013-10-05",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.7.8"}
                            {:cljs-version "0.0-1933",
                             :cljs-date "2013-10-11",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.7.9"}
                            {:cljs-version "0.0-1934",
                             :cljs-date "2013-10-11",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.7.9"}
                            {:cljs-version "0.0-1978",
                             :cljs-date "2013-10-28",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.7.10"}
                            {:cljs-version "0.0-2014",
                             :cljs-date "2013-11-06",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.7.10"}
                            {:cljs-version "0.0-2024",
                             :cljs-date "2013-11-08",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.7.10"}
                            {:cljs-version "0.0-2027",
                             :cljs-date "2013-11-08",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.7.10"}
                            {:cljs-version "0.0-2030",
                             :cljs-date "2013-11-08",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.7.10"}
                            {:cljs-version "0.0-2060",
                             :cljs-date "2013-11-21",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.7.10"}
                            {:cljs-version "0.0-2067",
                             :cljs-date "2013-11-22",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.8.0"}
                            {:cljs-version "0.0-2069",
                             :cljs-date "2013-11-22",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.8.0"}
                            {:cljs-version "0.0-2075",
                             :cljs-date "2013-11-23",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.8.0"}
                            {:cljs-version "0.0-2080",
                             :cljs-date "2013-11-23",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.8.0"}
                            {:cljs-version "0.0-2120",
                             :cljs-date "2013-12-13",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.8.0"}
                            {:cljs-version "0.0-2127",
                             :cljs-date "2013-12-20",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.8.0"}
                            {:cljs-version "0.0-2134",
                             :cljs-date "2013-12-30",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.8.0"}
                            {:cljs-version "0.0-2138",
                             :cljs-date "2013-12-31",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.8.0"}
                            {:cljs-version "0.0-2156",
                             :cljs-date "2014-01-29",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.8.3"}
                            {:cljs-version "0.0-2173",
                             :cljs-date "2014-02-22",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.8.3"}
                            {:cljs-version "0.0-2197",
                             :cljs-date "2014-03-26",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.8.3"}
                            {:cljs-version "0.0-2199",
                             :cljs-date "2014-04-01",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.8.3"}
                            {:cljs-version "0.0-2202",
                             :cljs-date "2014-04-02",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.8.3"}
                            {:cljs-version "0.0-2227",
                             :cljs-date "2014-05-22",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.8.3"}
                            {:cljs-version "0.0-2234",
                             :cljs-date "2014-06-13",
                             :clj-version "1.5.1",
                             :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                             :treader-version "0.8.3"}
                            {:cljs-version "0.0-2261",
                             :cljs-date "2014-07-02",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140226-71326067",
                             :treader-version "0.8.4"}
                            {:cljs-version "0.0-2268",
                             :cljs-date "2014-07-06",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140226-71326067",
                             :treader-version "0.8.4"}
                            {:cljs-version "0.0-2277",
                             :cljs-date "2014-07-25",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140226-71326067",
                             :treader-version "0.8.4"}
                            {:cljs-version "0.0-2280",
                             :cljs-date "2014-08-01",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.4"}
                            {:cljs-version "0.0-2301",
                             :cljs-date "2014-08-07",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.4"}
                            {:cljs-version "0.0-2307",
                             :cljs-date "2014-08-07",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.4"}
                            {:cljs-version "0.0-2311",
                             :cljs-date "2014-08-09",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.4"}
                            {:cljs-version "0.0-2322",
                             :cljs-date "2014-08-27",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.4"}
                            {:cljs-version "0.0-2341",
                             :cljs-date "2014-09-18",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.4"}
                            {:cljs-version "0.0-2342",
                             :cljs-date "2014-09-18",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.9"}
                            {:cljs-version "0.0-2356",
                             :cljs-date "2014-09-26",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.9"}
                            {:cljs-version "0.0-2371",
                             :cljs-date "2014-10-10",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.9"}
                            {:cljs-version "0.0-2411",
                             :cljs-date "2014-12-05",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10"}
                            {:cljs-version "0.0-2496",
                             :cljs-date "2014-12-17",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10",
                             :added #{"cljs.build.api/cljs-dependents-for-macro-namespaces"
                                      "cljs.analyzer.api/find-ns"
                                      "cljs.build.api/target-file-for-cljs-ns"
                                      "cljs.analyzer.api/ns-resolve"
                                      "cljs.build.api/mark-cljs-ns-for-recompile!"
                                      "cljs.analyzer.api/all-ns"
                                      "cljs.repl/doc"
                                      "cljs.analyzer.api/resolve"
                                      "cljs.analyzer.api/ns-interns"}}
                            {:cljs-version "0.0-2498",
                             :cljs-date "2014-12-19",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10"}
                            {:cljs-version "0.0-2505",
                             :cljs-date "2014-12-21",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10"}
                            {:cljs-version "0.0-2511",
                             :cljs-date "2014-12-22",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10"}
                            {:cljs-version "0.0-2629",
                             :cljs-date "2015-01-01",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10",
                             :added #{"cljs.build.api/parse-js-ns"
                                      "cljs.repl.node/socket"
                                      "cljs.repl.node/close-socket"
                                      "cljs.repl/repl*"
                                      "cljs.repl.node/load-javascript"
                                      "cljs.repl/update-require-spec"
                                      "cljs.build.api/src-file->target-file"
                                      "cljs.repl/merge-require"
                                      "cljs.repl.node/read-response"
                                      "cljs.repl/merge-spec"
                                      "cljs.repl/spec-sort"
                                      "cljs.build.api/cljs-ns-dependents"
                                      "cljs.analyzer.api/ns-specs"
                                      "cljs.repl.node/repl-env"
                                      "cljs.analyzer.api/in-cljs-user"
                                      "cljs.repl.node/setup"
                                      "cljs.repl.node/node-eval"
                                      "cljs.build.api/src-file->goog-require"
                                      "cljs.repl.node/write"
                                      "cljs.repl.node/repl-env*"},
                             :removed #{"cljs.repl.rhino/current-repl-env"}}
                            {:cljs-version "0.0-2644",
                             :cljs-date "2015-01-02",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10"}
                            {:cljs-version "0.0-2655",
                             :cljs-date "2015-01-03",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10",
                             :removed #{"cljs.repl/update-require-spec"
                                        "cljs.repl/merge-require"
                                        "cljs.repl/merge-spec"
                                        "cljs.repl/spec-sort"
                                        "cljs.analyzer.api/ns-specs"}}
                            {:cljs-version "0.0-2657",
                             :cljs-date "2015-01-03",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10"}
                            {:cljs-version "0.0-2665",
                             :cljs-date "2015-01-04",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10",
                             :added #{"cljs.repl.browser/setup"}}
                            {:cljs-version "0.0-2719",
                             :cljs-date "2015-01-24",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10",
                             :added #{"cljs.repl/with-read-known"
                                      "cljs.repl/IReplEnvOptions"
                                      "cljs.repl/skip-whitespace"
                                      "cljs.repl/repl-read"
                                      "cljs.repl/skip-if-eol"}}
                            {:cljs-version "0.0-2723",
                             :cljs-date "2015-01-24",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10"}
                            {:cljs-version "0.0-2725",
                             :cljs-date "2015-01-24",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10"}
                            {:cljs-version "0.0-2727",
                             :cljs-date "2015-01-25",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10"}
                            {:cljs-version "0.0-2740",
                             :cljs-date "2015-01-28",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10"}
                            {:cljs-version "0.0-2755",
                             :cljs-date "2015-02-01",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10"}
                            {:cljs-version "0.0-2758",
                             :cljs-date "2015-02-02",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10"}
                            {:cljs-version "0.0-2760",
                             :cljs-date "2015-02-02",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10"}
                            {:cljs-version "0.0-2814",
                             :cljs-date "2015-02-10",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10",
                             :added #{"cljs.repl.nashorn/repl-filename"
                                      "cljs.repl.nashorn/eval-resource"
                                      "cljs.repl/js-src->cljs-src"
                                      "cljs.repl/print-mapped-stacktrace"
                                      "cljs.repl.node/platform-path"
                                      "cljs.repl.nashorn/eval-str"
                                      "cljs.repl.nashorn/create-engine"
                                      "cljs.repl.nashorn/load-ns"
                                      "cljs.repl.nashorn/load-js-file"
                                      "cljs.repl.nashorn/init-engine"
                                      "cljs.repl.nashorn/bootstrap-repl"
                                      "cljs.repl.node/seq->js-array"
                                      "cljs.repl.nashorn/repl-env"
                                      "cljs.repl/mapped-line-and-column"
                                      "cljs.repl/ns-info"
                                      "cljs.repl/read-source-map"}}
                            {:cljs-version "0.0-2816",
                             :cljs-date "2015-02-10",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10"}
                            {:cljs-version "0.0-2843",
                             :cljs-date "2015-02-12",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10",
                             :added #{"cljs.repl/IPrintStacktrace"
                                      "cljs.repl/IParseStacktrace"
                                      "cljs.repl/mapped-stacktrace"}}
                            {:cljs-version "0.0-2850",
                             :cljs-date "2015-02-13",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10"}
                            {:cljs-version "0.0-2911",
                             :cljs-date "2015-02-21",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10",
                             :added #{"cljs.repl/self-require?"
                                      "cljs.repl/repl-prompt"
                                      "cljs.repl/*repl-opts*"
                                      "cljs.repl/repl-caught"},
                             :removed #{"cljs.repl/with-read-known"}}
                            {:cljs-version "0.0-2913",
                             :cljs-date "2015-02-21",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10"}
                            {:cljs-version "0.0-2985",
                             :cljs-date "2015-03-04",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.10",
                             :added #{"cljs.repl/source"
                                      "cljs.repl/apropos"
                                      "cljs.repl.rhino/wrap-fn"
                                      "cljs.repl/pst"
                                      "cljs.repl/IParseErrorMessage"
                                      "cljs.analyzer.api/ns-publics"
                                      "cljs.repl/IGetError"
                                      "cljs.repl.rhino/load-file"
                                      "cljs.repl/dir"
                                      "cljs.repl/special-doc-map"
                                      "cljs.repl/source-fn"
                                      "cljs.repl/find-doc"},
                             :removed #{"cljs.repl.rhino/goog-require"}}
                            {:cljs-version "0.0-3030",
                             :cljs-date "2015-03-07",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.16",
                             :added #{"cljs.repl.browser/repl-env*"
                                      "cljs.repl/IParseError"
                                      "cljs.repl.nashorn/repl-env*"
                                      "cljs.repl.rhino/repl-env*"},
                             :removed #{"cljs.repl/IParseErrorMessage"}}
                            {:cljs-version "0.0-3053",
                             :cljs-date "2015-03-09",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.16",
                             :added #{"cljs.repl.browser/safari-st-el->frame"
                                      "cljs.repl.browser/firefox-st-el->frame"
                                      "cljs.repl.browser/chrome-st-el->frame"
                                      "cljs.repl.browser/parse-file"
                                      "cljs.repl.browser/parse-stacktrace"
                                      "cljs.repl.browser/parse-file-line-column"
                                      "cljs.repl.browser/firefox-clean-function"}}
                            {:cljs-version "0.0-3058",
                             :cljs-date "2015-03-09",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.16",
                             :added #{"cljs.repl/repl-special-doc-map"}}
                            {:cljs-version "0.0-3115",
                             :cljs-date "2015-03-15",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.16",
                             :removed #{"cljs.repl.browser/loaded-libs"
                                        "cljs.repl.browser/preloaded-libs"}}
                            {:cljs-version "0.0-3117",
                             :cljs-date "2015-03-16",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.16"}
                            {:cljs-version "0.0-3119",
                             :cljs-date "2015-03-16",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.16"}
                            {:cljs-version "0.0-3123",
                             :cljs-date "2015-03-16",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.16"}
                            {:cljs-version "0.0-3126",
                             :cljs-date "2015-03-18",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.16"}
                            {:cljs-version "0.0-3148",
                             :cljs-date "2015-03-23",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.16",
                             :added #{"cljs.repl/err-out"
                                      "cljs.repl.browser/es"
                                      "cljs.repl/canonicalize-specs"
                                      "cljs.repl/decorate-specs"
                                      "cljs.repl/repl-quit-prompt"},
                             :removed #{"cljs.repl/mapped-line-and-column"}}
                            {:cljs-version "0.0-3149",
                             :cljs-date "2015-03-23",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.16"}
                            {:cljs-version "0.0-3153",
                             :cljs-date "2015-03-25",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.16"}
                            {:cljs-version "0.0-3165",
                             :cljs-date "2015-03-27",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.16",
                             :added #{"cljs.repl.nashorn/-main"
                                      "cljs.repl.browser/-main"
                                      "cljs.repl.rhino/-main"
                                      "cljs.repl.node/-main"}}
                            {:cljs-version "0.0-3169",
                             :cljs-date "2015-03-31",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.16"}
                            {:cljs-version "0.0-3178",
                             :cljs-date "2015-04-06",
                             :clj-version "1.6.0",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.8.16"}
                            {:cljs-version "0.0-3190",
                             :cljs-date "2015-04-09",
                             :clj-version "1.7.0-alpha6",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.9.0"}
                            {:cljs-version "0.0-3191",
                             :cljs-date "2015-04-09",
                             :clj-version "1.7.0-alpha6",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.9.1"}
                            {:cljs-version "0.0-3195",
                             :cljs-date "2015-04-10",
                             :clj-version "1.7.0-alpha6",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.9.1"}
                            {:cljs-version "0.0-3196",
                             :cljs-date "2015-04-10",
                             :clj-version "1.7.0-beta1",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.9.1"}
                            {:cljs-version "0.0-3208",
                             :cljs-date "2015-04-16",
                             :clj-version "1.7.0-beta1",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.9.1",
                             :added #{"cljs.build.api/build"
                                      "cljs.analyzer.api/remove-ns"
                                      "cljs.analyzer.api/parse-ns"
                                      "cljs.analyzer.api/forms-seq"
                                      "cljs.analyzer.api/analyze-file"
                                      "cljs.build.api/watch"
                                      "cljs.build.api/inputs"
                                      "cljs.analyzer.api/empty-env"
                                      "cljs.analyzer.api/analyze"}}
                            {:cljs-version "0.0-3211",
                             :cljs-date "2015-04-23",
                             :clj-version "1.7.0-beta1",
                             :gclosure-lib "0.0-20140718-946a7d39",
                             :treader-version "0.9.1"}
                            {:cljs-version "0.0-3255",
                             :cljs-date "2015-05-08",
                             :clj-version "1.7.0-beta2",
                             :gclosure-lib "0.0-20150505-021ed5b3",
                             :treader-version "0.9.2",
                             :added #{"cljs.compiler.api/cljs-files-in"
                                      "cljs.compiler.api/with-core-cljs"
                                      "cljs.compiler.api/emit"
                                      "cljs.compiler.api/compile-file"
                                      "cljs.compiler.api/requires-compilation?"
                                      "cljs.compiler.api/compile-root"}}
                            {:cljs-version "0.0-3263",
                             :cljs-date "2015-05-09",
                             :clj-version "1.7.0-beta2",
                             :gclosure-lib "0.0-20150505-021ed5b3",
                             :treader-version "0.9.2"}
                            {:cljs-version "0.0-3264",
                             :cljs-date "2015-05-09",
                             :clj-version "1.7.0-beta2",
                             :gclosure-lib "0.0-20150505-021ed5b3",
                             :treader-version "0.9.2"}
                            {:cljs-version "0.0-3269",
                             :cljs-date "2015-05-10",
                             :clj-version "1.7.0-beta2",
                             :gclosure-lib "0.0-20150505-021ed5b3",
                             :treader-version "0.9.2"}
                            {:cljs-version "0.0-3291",
                             :cljs-date "2015-05-18",
                             :clj-version "1.7.0-beta2",
                             :gclosure-lib "0.0-20150505-021ed5b3",
                             :treader-version "0.9.2",
                             :added #{"cljs.build.api/ns->source"
                                      "cljs.build.api/output-unoptimized"
                                      "cljs.build.api/add-implicit-options"
                                      "cljs.repl.browser/ext->mime-type"
                                      "cljs.build.api/goog-dep-string"
                                      "cljs.analyzer.api/no-warn"
                                      "cljs.build.api/compile"
                                      "cljs.build.api/add-dependencies"
                                      "cljs.build.api/source-on-disk"
                                      "cljs.build.api/ns->location"}}
                            {:cljs-version "0.0-3297",
                             :cljs-date "2015-05-23",
                             :clj-version "1.7.0-beta2",
                             :gclosure-lib "0.0-20150505-021ed5b3",
                             :treader-version "0.9.2",
                             :added #{"cljs.repl.browser/mime-type->encoding"}}
                            {:cljs-version "0.0-3308",
                             :cljs-date "2015-06-01",
                             :clj-version "1.7.0-RC1",
                             :gclosure-lib "0.0-20150505-021ed5b3",
                             :treader-version "0.9.2"}
                            {:cljs-version "1.7.10",
                             :cljs-date "2015-07-29",
                             :clj-version "1.7.0",
                             :gclosure-lib "0.0-20150505-021ed5b3",
                             :treader-version "0.10.0-alpha3",
                             :added #{"cljs.analyzer.api/get-options"
                                      "cljs.analyzer.api/warning-enabled?"
                                      "cljs.analyzer.api/default-warning-handler"
                                      "cljs.analyzer.api/empty-state"
                                      "cljs.analyzer.api/with-state"},
                             :removed #{"cljs.repl.browser/safari-st-el->frame"
                                        "cljs.repl.browser/firefox-st-el->frame"
                                        "cljs.repl.browser/chrome-st-el->frame"
                                        "cljs.repl.browser/parse-file"
                                        "cljs.repl.browser/parse-stacktrace"
                                        "cljs.repl.browser/parse-file-line-column"
                                        "cljs.repl.browser/firefox-clean-function"}}
                            {:cljs-version "1.7.28",
                             :cljs-date "2015-07-31",
                             :clj-version "1.7.0",
                             :gclosure-lib "0.0-20150505-021ed5b3",
                             :treader-version "0.10.0-alpha3"}
                            {:cljs-version "1.7.48",
                             :cljs-date "2015-08-05",
                             :clj-version "1.7.0",
                             :gclosure-lib "0.0-20150805-acd8b553",
                             :treader-version "0.10.0-alpha3"}
                            {:cljs-version "1.7.58",
                             :cljs-date "2015-08-06",
                             :clj-version "1.7.0",
                             :gclosure-lib "0.0-20150805-acd8b553",
                             :treader-version "0.10.0-alpha3"}
                            {:cljs-version "1.7.107",
                             :cljs-date "2015-08-11",
                             :clj-version "1.7.0",
                             :gclosure-lib "0.0-20150805-acd8b553",
                             :treader-version "0.10.0-alpha3"}
                            {:cljs-version "1.7.122",
                             :cljs-date "2015-08-29",
                             :clj-version "1.7.0",
                             :gclosure-lib "0.0-20150805-acd8b553",
                             :treader-version "0.10.0-alpha3",
                             :added #{"cljs.analyzer.api/get-js-index"}}
                            {:cljs-version "1.7.145",
                             :cljs-date "2015-10-13",
                             :clj-version "1.7.0",
                             :gclosure-lib "0.0-20150805-acd8b553",
                             :treader-version "0.10.0-alpha3"}
                            {:cljs-version "1.7.166",
                             :cljs-date "2015-11-04",
                             :clj-version "1.7.0",
                             :gclosure-lib "0.0-20151016-61277aea",
                             :treader-version "0.10.0-alpha3",
                             :removed #{"cljs.build.api/cljs-ns-dependents"}}
                            {:cljs-version "1.7.170",
                             :cljs-date "2015-11-06",
                             :clj-version "1.7.0",
                             :gclosure-lib "0.0-20151016-61277aea",
                             :treader-version "0.10.0-alpha3"}
                            {:cljs-version "1.7.189",
                             :cljs-date "2015-12-01",
                             :clj-version "1.7.0",
                             :gclosure-lib "0.0-20151016-61277aea",
                             :treader-version "0.10.0-alpha3"}
                            {:cljs-version "1.7.228",
                             :cljs-date "2016-01-08",
                             :clj-version "1.7.0",
                             :gclosure-lib "0.0-20151016-61277aea",
                             :treader-version "1.0.0-alpha1"}],
                  :symbol-names #{"cljs.repl.nashorn/repl-filename"
                                  "cljs.repl.rhino/current-repl-env"
                                  "cljs.build.api/cljs-dependents-for-macro-namespaces"
                                  "cljs.build.api/build"
                                  "cljs.repl/self-require?"
                                  "cljs.build.api/ns->source"
                                  "cljs.repl/with-read-known"
                                  "cljs.repl/evaluate-form"
                                  "cljs.build.api/parse-js-ns"
                                  "cljs.repl.browser/repl-env*"
                                  "cljs.repl/source"
                                  "cljs.repl/load-stream"
                                  "cljs.repl/repl-prompt"
                                  "cljs.repl.rhino/eval-result"
                                  "cljs.repl.node/socket"
                                  "cljs.repl.browser/read-get"
                                  "cljs.repl.node/close-socket"
                                  "cljs.repl.browser/load-javascript"
                                  "cljs.repl/repl*"
                                  "cljs.build.api/output-unoptimized"
                                  "cljs.repl.browser/add-in-order"
                                  "cljs.repl.nashorn/-main"
                                  "cljs.repl/err-out"
                                  "cljs.repl.server/handlers"
                                  "cljs.repl.node/load-javascript"
                                  "cljs.build.api/add-implicit-options"
                                  "cljs.compiler.api/cljs-files-in"
                                  "cljs.repl.browser/safari-st-el->frame"
                                  "cljs.repl.browser/mime-type->encoding"
                                  "cljs.repl/apropos"
                                  "cljs.repl/load-namespace"
                                  "cljs.repl.rhino/wrap-fn"
                                  "cljs.analyzer.api/find-ns"
                                  "cljs.repl.rhino/loaded-libs"
                                  "cljs.repl.server/dispatch-on"
                                  "cljs.repl.browser/firefox-st-el->frame"
                                  "cljs.repl.browser/run-in-order"
                                  "cljs.repl.browser/compile-client-js"
                                  "cljs.repl.server/start"
                                  "cljs.repl.browser/handle-get"
                                  "cljs.repl.nashorn/eval-resource"
                                  "cljs.repl.browser/ext->mime-type"
                                  "cljs.repl/js-src->cljs-src"
                                  "cljs.repl.reflect/parse-param"
                                  "cljs.repl/print-mapped-stacktrace"
                                  "cljs.repl/analyze-source"
                                  "cljs.repl.browser/stop-server"
                                  "cljs.repl/*repl-opts*"
                                  "cljs.repl.browser/chrome-st-el->frame"
                                  "cljs.repl/IParseError"
                                  "cljs.repl/pst"
                                  "cljs.analyzer.api/get-options"
                                  "cljs.repl.browser/read-request"
                                  "cljs.analyzer.api/remove-ns"
                                  "cljs.build.api/target-file-for-cljs-ns"
                                  "cljs.repl.server/state"
                                  "cljs.repl.reflect/macroexpand"
                                  "cljs.repl.browser/-main"
                                  "cljs.repl.node/platform-path"
                                  "cljs.repl.browser/es"
                                  "cljs.repl.server/read-request"
                                  "cljs.repl/load-file"
                                  "cljs.repl/IParseErrorMessage"
                                  "cljs.repl.nashorn/eval-str"
                                  "cljs.repl.browser/browser-eval"
                                  "cljs.repl.browser/server-state"
                                  "cljs.repl.browser/send-for-eval"
                                  "cljs.repl.browser/constrain-order"
                                  "cljs.repl/default-special-fns"
                                  "cljs.repl.rhino/rhino-eval"
                                  "cljs.repl.browser/read-headers"
                                  "cljs.analyzer.api/warning-enabled?"
                                  "cljs.repl/IReplEnvOptions"
                                  "cljs.repl.server/set-connection"
                                  "cljs.analyzer.api/ns-resolve"
                                  "cljs.repl/update-require-spec"
                                  "cljs.repl/repl"
                                  "cljs.repl.nashorn/create-engine"
                                  "cljs.build.api/src-file->target-file"
                                  "cljs.compiler.api/with-core-cljs"
                                  "cljs.repl/canonicalize-specs"
                                  "cljs.repl.rhino/load-javascript"
                                  "cljs.repl/merge-require"
                                  "cljs.analyzer.api/ns-publics"
                                  "cljs.repl.nashorn/load-ns"
                                  "cljs.repl.browser/create-client-js-file"
                                  "cljs.repl/*cljs-verbose*"
                                  "cljs.repl.server/read-post"
                                  "cljs.repl/IGetError"
                                  "cljs.repl.browser/loaded-libs"
                                  "cljs.analyzer.api/default-warning-handler"
                                  "cljs.repl.nashorn/load-js-file"
                                  "cljs.repl.browser/setup"
                                  "cljs.repl/skip-whitespace"
                                  "cljs.repl.browser/parse-file"
                                  "cljs.repl/IPrintStacktrace"
                                  "cljs.analyzer.api/parse-ns"
                                  "cljs.repl.nashorn/init-engine"
                                  "cljs.build.api/goog-dep-string"
                                  "cljs.repl.server/parse-headers"
                                  "cljs.repl.node/read-response"
                                  "cljs.repl.browser/repl-client-js"
                                  "cljs.repl.browser/parse-headers"
                                  "cljs.repl.reflect/handle-reflect-query"
                                  "cljs.repl.browser/send-404"
                                  "cljs.repl.browser/repl-env"
                                  "cljs.repl.nashorn/bootstrap-repl"
                                  "cljs.repl.rhino/load-file"
                                  "cljs.repl/merge-spec"
                                  "cljs.repl.rhino/repl-env"
                                  "cljs.repl.node/seq->js-array"
                                  "cljs.repl.server/stop"
                                  "cljs.repl/dir"
                                  "cljs.repl.rhino/goog-require"
                                  "cljs.repl/spec-sort"
                                  "cljs.analyzer.api/no-warn"
                                  "cljs.repl.server/read-get"
                                  "cljs.repl.browser/send-repl-client-page"
                                  "cljs.repl.reflect/read-url-string"
                                  "cljs.repl/repl-special-doc-map"
                                  "cljs.repl.browser/preloaded-libs"
                                  "cljs.build.api/mark-cljs-ns-for-recompile!"
                                  "cljs.repl.browser/parse-stacktrace"
                                  "cljs.repl.browser/browser-state"
                                  "cljs.repl.browser/send-static"
                                  "cljs.analyzer.api/forms-seq"
                                  "cljs.analyzer.api/get-js-index"
                                  "cljs.build.api/cljs-ns-dependents"
                                  "cljs.analyzer.api/ns-specs"
                                  "cljs.repl.nashorn/repl-env"
                                  "cljs.compiler.api/emit"
                                  "cljs.analyzer.api/analyze-file"
                                  "cljs.compiler.api/compile-file"
                                  "cljs.repl/mapped-line-and-column"
                                  "cljs.build.api/watch"
                                  "cljs.repl/special-doc-map"
                                  "cljs.compiler.api/requires-compilation?"
                                  "cljs.repl.server/read-headers"
                                  "cljs.repl/decorate-specs"
                                  "cljs.analyzer.api/all-ns"
                                  "cljs.repl/repl-read"
                                  "cljs.repl/repl-caught"
                                  "cljs.repl.browser/send-and-close"
                                  "cljs.build.api/compile"
                                  "cljs.repl/ns-info"
                                  "cljs.repl.node/repl-env"
                                  "cljs.repl/skip-if-eol"
                                  "cljs.analyzer.api/in-cljs-user"
                                  "cljs.analyzer.api/empty-state"
                                  "cljs.repl.rhino/bootjs"
                                  "cljs.repl/IJavaScriptEnv"
                                  "cljs.repl.rhino/-main"
                                  "cljs.repl.nashorn/repl-env*"
                                  "cljs.repl.node/-main"
                                  "cljs.build.api/add-dependencies"
                                  "cljs.repl/IParseStacktrace"
                                  "cljs.repl/repl-quit-prompt"
                                  "cljs.repl.browser/handle-connection"
                                  "cljs.build.api/inputs"
                                  "cljs.build.api/source-on-disk"
                                  "cljs.repl.node/setup"
                                  "cljs.repl/doc"
                                  "cljs.repl.node/node-eval"
                                  "cljs.analyzer.api/with-state"
                                  "cljs.build.api/ns->location"
                                  "cljs.repl/mapped-stacktrace"
                                  "cljs.repl.rhino/IEval"
                                  "cljs.analyzer.api/resolve"
                                  "cljs.repl.browser/start-server"
                                  "cljs.repl.server/send-and-close"
                                  "cljs.repl.rhino/repl-env*"
                                  "cljs.repl.browser/server-loop"
                                  "cljs.repl.server/send-404"
                                  "cljs.repl.browser/read-post"
                                  "cljs.repl/source-fn"
                                  "cljs.repl.server/connection"
                                  "cljs.repl.rhino/rhino-setup"
                                  "cljs.repl.browser/parse-file-line-column"
                                  "cljs.build.api/src-file->goog-require"
                                  "cljs.repl.node/write"
                                  "cljs.repl/read-source-map"
                                  "cljs.analyzer.api/empty-env"
                                  "cljs.repl.browser/handle-post"
                                  "cljs.repl/find-doc"
                                  "cljs.repl.node/repl-env*"
                                  "cljs.analyzer.api/analyze"
                                  "cljs.repl.rhino/stacktrace"
                                  "cljs.compiler.api/compile-root"
                                  "cljs.analyzer.api/ns-interns"
                                  "cljs.repl.browser/firefox-clean-function"
                                  "cljs.repl.browser/ordering"},
                  :namespace-names #{"cljs.repl.server"
                                     "cljs.compiler.api"
                                     "cljs.repl.browser"
                                     "cljs.repl.rhino"
                                     "cljs.repl.node"
                                     "cljs.repl.reflect"
                                     "cljs.repl.nashorn"
                                     "cljs.build.api"
                                     "cljs.repl"
                                     "cljs.analyzer.api"}}}}
