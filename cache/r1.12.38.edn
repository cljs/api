{:version "1.12.38",
 :history {:versions ("1.12.38"
                      "1.12.35"
                      "1.11.132"
                      "1.11.121"
                      "1.11.60"
                      "1.11.57"
                      "1.11.54"
                      "1.11.51"
                      "1.11.50"
                      "1.11.4"
                      "1.10.914"
                      "1.10.896"
                      "1.10.893"
                      "1.10.891"
                      "1.10.879"
                      "1.10.866"
                      "1.10.844"
                      "1.10.773"
                      "1.10.764"
                      "1.10.758"
                      "1.10.756"
                      "1.10.753"
                      "1.10.748"
                      "1.10.742"
                      "1.10.741"
                      "1.10.740"
                      "1.10.739"
                      "1.10.738"
                      "1.10.597"
                      "1.10.520"
                      "1.10.516"
                      "1.10.514"
                      "1.10.439"
                      "1.10.339"
                      "1.10.335"
                      "1.10.329"
                      "1.10.312"
                      "1.10.238"
                      "1.10.217"
                      "1.10.191"
                      "1.10.145"
                      "1.10.126"
                      "1.10.64"
                      "1.10.63"
                      "1.9.946"
                      "1.9.908"
                      "1.9.854"
                      "1.9.671"
                      "1.9.660"
                      "1.9.655"
                      "1.9.562"
                      "1.9.542"
                      "1.9.521"
                      "1.9.518"
                      "1.9.495"
                      "1.9.494"
                      "1.9.493"
                      "1.9.473"
                      "1.9.456"
                      "1.9.293"
                      "1.9.229"
                      "1.9.227"
                      "1.9.226"
                      "1.9.225"
                      "1.9.216"
                      "1.9.211"
                      "1.9.198"
                      "1.9.183"
                      "1.9.93"
                      "1.9.92"
                      "1.9.90"
                      "1.9.89"
                      "1.9.88"
                      "1.9.85"
                      "1.9.76"
                      "1.9.75"
                      "1.9.36"
                      "1.9.35"
                      "1.9.14"
                      "1.8.51"
                      "1.8.40"
                      "1.8.34"
                      "1.7.228"
                      "1.7.189"
                      "1.7.170"
                      "1.7.166"
                      "1.7.145"
                      "1.7.122"
                      "1.7.107"
                      "1.7.58"
                      "1.7.48"
                      "1.7.28"
                      "1.7.10"
                      "0.0-3308"
                      "0.0-3297"
                      "0.0-3291"
                      "0.0-3269"
                      "0.0-3264"
                      "0.0-3263"
                      "0.0-3255"
                      "0.0-3211"
                      "0.0-3208"
                      "0.0-3196"
                      "0.0-3195"
                      "0.0-3191"
                      "0.0-3190"
                      "0.0-3178"
                      "0.0-3169"
                      "0.0-3165"
                      "0.0-3153"
                      "0.0-3149"
                      "0.0-3148"
                      "0.0-3126"
                      "0.0-3123"
                      "0.0-3119"
                      "0.0-3117"
                      "0.0-3115"
                      "0.0-3058"
                      "0.0-3053"
                      "0.0-3030"
                      "0.0-2985"
                      "0.0-2913"
                      "0.0-2911"
                      "0.0-2850"
                      "0.0-2843"
                      "0.0-2816"
                      "0.0-2814"
                      "0.0-2760"
                      "0.0-2758"
                      "0.0-2755"
                      "0.0-2740"
                      "0.0-2727"
                      "0.0-2725"
                      "0.0-2723"
                      "0.0-2719"
                      "0.0-2665"
                      "0.0-2657"
                      "0.0-2655"
                      "0.0-2644"
                      "0.0-2629"
                      "0.0-2511"
                      "0.0-2505"
                      "0.0-2498"
                      "0.0-2496"
                      "0.0-2411"
                      "0.0-2371"
                      "0.0-2356"
                      "0.0-2342"
                      "0.0-2341"
                      "0.0-2322"
                      "0.0-2311"
                      "0.0-2307"
                      "0.0-2301"
                      "0.0-2280"
                      "0.0-2277"
                      "0.0-2268"
                      "0.0-2261"
                      "0.0-2234"
                      "0.0-2227"
                      "0.0-2202"
                      "0.0-2199"
                      "0.0-2197"
                      "0.0-2173"
                      "0.0-2156"
                      "0.0-2138"
                      "0.0-2134"
                      "0.0-2127"
                      "0.0-2120"
                      "0.0-2080"
                      "0.0-2075"
                      "0.0-2069"
                      "0.0-2067"
                      "0.0-2060"
                      "0.0-2030"
                      "0.0-2027"
                      "0.0-2024"
                      "0.0-2014"
                      "0.0-1978"
                      "0.0-1934"
                      "0.0-1933"
                      "0.0-1913"
                      "0.0-1909"
                      "0.0-1896"
                      "0.0-1895"
                      "0.0-1889"
                      "0.0-1886"
                      "0.0-1885"
                      "0.0-1878"
                      "0.0-1877"
                      "0.0-1859"
                      "0.0-1853"
                      "0.0-1847"
                      "0.0-1844"
                      "0.0-1843"
                      "0.0-1835"
                      "0.0-1820"
                      "0.0-1806"
                      "0.0-1803"
                      "0.0-1798"
                      "0.0-1586"
                      "0.0-1576"
                      "0.0-1552"
                      "0.0-1535"
                      "0.0-1513"
                      "0.0-1503"
                      "0.0-1450"
                      "0.0-1449"
                      "0.0-1443"
                      "0.0-1424"
                      "0.0-1236"
                      "0.0-1211"
                      "0.0-1011"
                      "0.0-1006"
                      "0.0-993"
                      "0.0-971"
                      "0.0-927"),
           :details {"1.10.339" {:tag "r1.10.339",
                                 :date "2018-06-25",
                                 :clj-version "1.8.0",
                                 :clj-tag "clojure-1.8.0",
                                 :treader-version "1.3.0-alpha3",
                                 :treader-tag "tools.reader-1.3.0-alpha3",
                                 :gclosure-lib "0.0-20170809-b9c14c6b",
                                 :gclosure-com "v20180610"},
                     "0.0-2030" {:tag "r2030",
                                 :date "2013-11-08",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.10",
                                 :treader-tag "tools.reader-0.7.10",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-2067" {:tag "r2067",
                                 :date "2013-11-22",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.8.0",
                                 :treader-tag "tools.reader-0.8.0",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "1.9.521" {:tag "r1.9.521",
                                :date "2017-04-14",
                                :clj-version "1.8.0",
                                :clj-tag "clojure-1.8.0",
                                :treader-version "1.0.0-beta3",
                                :treader-tag "tools.reader-1.0.0-beta3",
                                :gclosure-lib "0.0-20160609-f42b4a24",
                                :gclosure-com "v20170409"},
                     "0.0-2134" {:tag "r2134",
                                 :date "2013-12-30",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.8.0",
                                 :treader-tag "tools.reader-0.8.0",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-2322" {:tag "r2322",
                                 :date "2014-08-27",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.4",
                                 :treader-tag "tools.reader-0.8.4",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com nil},
                     "1.10.891" {:tag "r1.10.891",
                                 :date "2021-11-04",
                                 :clj-version "1.8.0",
                                 :clj-tag "clojure-1.8.0",
                                 :treader-version "1.3.3",
                                 :treader-tag "tools.reader-1.3.3",
                                 :gclosure-lib "0.0-20210811-6da97fe1",
                                 :gclosure-com "v20210808"},
                     "1.10.335" {:tag "r1.10.335",
                                 :date "2018-06-25",
                                 :clj-version "1.8.0",
                                 :clj-tag "clojure-1.8.0",
                                 :treader-version "1.3.0-alpha3",
                                 :treader-tag "tools.reader-1.3.0-alpha3",
                                 :gclosure-lib "0.0-20170809-b9c14c6b",
                                 :gclosure-com "v20180610"},
                     "1.10.844" {:tag "r1.10.844",
                                 :date "2021-03-30",
                                 :clj-version "1.8.0",
                                 :clj-tag "clojure-1.8.0",
                                 :treader-version "1.3.3",
                                 :treader-tag "tools.reader-1.3.3",
                                 :gclosure-lib "0.0-20201211-3e6c510d",
                                 :gclosure-com "v20210202"},
                     "0.0-1803" {:tag "r1803",
                                 :date "2013-05-06",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-2029-2",
                                 :gclosure-com nil},
                     "0.0-2371" {:tag "r2371",
                                 :date "2014-10-10",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.9",
                                 :treader-tag "tools.reader-0.8.9",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com nil},
                     "0.0-2307" {:tag "r2307",
                                 :date "2014-08-07",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.4",
                                 :treader-tag "tools.reader-0.8.4",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com nil},
                     "0.0-3148" {:tag "r3148",
                                 :date "2015-03-23",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.16",
                                 :treader-tag "tools.reader-0.8.16",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20150126"},
                     "0.0-1886" {:tag "r1886",
                                 :date "2013-09-15",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.5",
                                 :treader-tag "tools.reader-0.7.5",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-2138" {:tag "r2138",
                                 :date "2013-12-31",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.8.0",
                                 :treader-tag "tools.reader-0.8.0",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "1.11.60" {:tag "r1.11.60",
                                :date "2022-06-23",
                                :clj-version "1.10.0",
                                :clj-tag "clojure-1.10.0",
                                :treader-version "1.3.6",
                                :treader-tag "v1.3.6",
                                :gclosure-lib "0.0-20211011-0726fdeb",
                                :gclosure-com "v20220502"},
                     "0.0-2505" {:tag "r2505",
                                 :date "2014-12-21",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.10",
                                 :treader-tag "tools.reader-0.8.10",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com nil},
                     "0.0-2311" {:tag "r2311",
                                 :date "2014-08-09",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.4",
                                 :treader-tag "tools.reader-0.8.4",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com nil},
                     "1.9.92" {:tag "r1.9.92",
                               :date "2016-06-22",
                               :clj-version "1.8.0",
                               :clj-tag "clojure-1.8.0",
                               :treader-version "1.0.0-beta1",
                               :treader-tag "tools.reader-1.0.0-beta1",
                               :gclosure-lib "0.0-20160609-f42b4a24",
                               :gclosure-com "20160315"},
                     "0.0-2740" {:tag "r2740",
                                 :date "2015-01-28",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.10",
                                 :treader-tag "tools.reader-0.8.10",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20140625"},
                     "1.12.38" {:tag "r1.12.38",
                                :date "2025-04-30",
                                :clj-version "1.10.0",
                                :clj-tag "clojure-1.10.0",
                                :treader-version "1.3.6",
                                :treader-tag "v1.3.6",
                                :gclosure-lib "0.0-20230227-c7c0a541",
                                :gclosure-com "v20240317"},
                     "0.0-2725" {:tag "r2725",
                                 :date "2015-01-24",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.10",
                                 :treader-tag "tools.reader-0.8.10",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20140625"},
                     "1.9.211" {:tag "r1.9.211",
                                :date "2016-08-15",
                                :clj-version "1.8.0",
                                :clj-tag "clojure-1.8.0",
                                :treader-version "1.0.0-beta3",
                                :treader-tag "tools.reader-1.0.0-beta3",
                                :gclosure-lib "0.0-20160609-f42b4a24",
                                :gclosure-com "v20160315"},
                     "1.10.312" {:tag "r1.10.312",
                                 :date "2018-06-15",
                                 :clj-version "1.8.0",
                                 :clj-tag "clojure-1.8.0",
                                 :treader-version "1.3.0-alpha3",
                                 :treader-tag "tools.reader-1.3.0-alpha3",
                                 :gclosure-lib "0.0-20170809-b9c14c6b",
                                 :gclosure-com "v20180610"},
                     "0.0-2127" {:tag "r2127",
                                 :date "2013-12-20",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.8.0",
                                 :treader-tag "tools.reader-0.8.0",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-2843" {:tag "r2843",
                                 :date "2015-02-12",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.10",
                                 :treader-tag "tools.reader-0.8.10",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20140625"},
                     "0.0-2280" {:tag "r2280",
                                 :date "2014-08-01",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.4",
                                 :treader-tag "tools.reader-0.8.4",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com nil},
                     "1.9.518" {:tag "r1.9.518",
                                :date "2017-04-12",
                                :clj-version "1.8.0",
                                :clj-tag "clojure-1.8.0",
                                :treader-version "1.0.0-beta3",
                                :treader-tag "tools.reader-1.0.0-beta3",
                                :gclosure-lib "0.0-20160609-f42b4a24",
                                :gclosure-com "v20170409"},
                     "1.10.191" {:tag "r1.10.191",
                                 :date "2018-03-17",
                                 :clj-version "1.8.0",
                                 :clj-tag "clojure-1.8.0",
                                 :treader-version "1.3.0-alpha3",
                                 :treader-tag "tools.reader-1.3.0-alpha3",
                                 :gclosure-lib "0.0-20170809-b9c14c6b",
                                 :gclosure-com "v20180204"},
                     "1.7.166" {:tag "r1.7.166",
                                :date "2015-11-04",
                                :clj-version "1.7.0",
                                :clj-tag "clojure-1.7.0",
                                :treader-version "0.10.0-alpha3",
                                :treader-tag "tools.reader-0.10.0-alpha3",
                                :gclosure-lib "0.0-20151016-61277aea",
                                :gclosure-com "20151015"},
                     "0.0-2199" {:tag "r2199",
                                 :date "2014-04-01",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.8.3",
                                 :treader-tag "tools.reader-0.8.3",
                                 :gclosure-lib "0.0-20140226-71326067",
                                 :gclosure-com nil},
                     "1.11.54" {:tag "r1.11.54",
                                :date "2022-05-16",
                                :clj-version "1.10.0",
                                :clj-tag "clojure-1.10.0",
                                :treader-version "1.3.6",
                                :treader-tag "tools.reader-1.3.6",
                                :gclosure-lib "0.0-20211011-0726fdeb",
                                :gclosure-com "v20220502"},
                     "1.10.514" {:tag "r1.10.514",
                                 :date "2019-01-31",
                                 :clj-version "1.8.0",
                                 :clj-tag "clojure-1.8.0",
                                 :treader-version "1.3.0",
                                 :treader-tag "tools.reader-1.3.0",
                                 :gclosure-lib "0.0-20170809-b9c14c6b",
                                 :gclosure-com "v20180805"},
                     "0.0-2120" {:tag "r2120",
                                 :date "2013-12-13",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.8.0",
                                 :treader-tag "tools.reader-0.8.0",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "1.9.93" {:tag "r1.9.93",
                               :date "2016-06-23",
                               :clj-version "1.8.0",
                               :clj-tag "clojure-1.8.0",
                               :treader-version "1.0.0-beta1",
                               :treader-tag "tools.reader-1.0.0-beta1",
                               :gclosure-lib "0.0-20160609-f42b4a24",
                               :gclosure-com "20160315"},
                     "1.9.495" {:tag "r1.9.495",
                                :date "2017-03-01",
                                :clj-version "1.8.0",
                                :clj-tag "clojure-1.8.0",
                                :treader-version "1.0.0-beta3",
                                :treader-tag "tools.reader-1.0.0-beta3",
                                :gclosure-lib "0.0-20160609-f42b4a24",
                                :gclosure-com "v20170218"},
                     "1.10.748" {:tag "r1.10.748",
                                 :date "2020-04-26",
                                 :clj-version "1.8.0",
                                 :clj-tag "clojure-1.8.0",
                                 :treader-version "1.3.2",
                                 :treader-tag "tools.reader-1.3.2",
                                 :gclosure-lib "0.0-20191016-6ae1f72f",
                                 :gclosure-com "v20200315"},
                     "0.0-1878" {:tag "r1878",
                                 :date "2013-09-11",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.5",
                                 :treader-tag "tools.reader-0.7.5",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-1236" {:tag "r1236",
                                 :date "2012-05-16",
                                 :clj-version "1.4.0",
                                 :clj-tag "clojure-1.4.0",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-1376",
                                 :gclosure-com nil},
                     "0.0-2060" {:tag "r2060",
                                 :date "2013-11-21",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.10",
                                 :treader-tag "tools.reader-0.7.10",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "1.11.51" {:tag "r1.11.51",
                                :date "2022-05-13",
                                :clj-version "1.10.0",
                                :clj-tag "clojure-1.10.0",
                                :treader-version "1.3.6",
                                :treader-tag "tools.reader-1.3.6",
                                :gclosure-lib "0.0-20211011-0726fdeb",
                                :gclosure-com "v20220502"},
                     "1.10.439" {:tag "r1.10.439",
                                 :date "2018-11-02",
                                 :clj-version "1.8.0",
                                 :clj-tag "clojure-1.8.0",
                                 :treader-version "1.3.0",
                                 :treader-tag "tools.reader-1.3.0",
                                 :gclosure-lib "0.0-20170809-b9c14c6b",
                                 :gclosure-com "v20180805"},
                     "0.0-3178" {:tag "r3178",
                                 :date "2015-04-06",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.16",
                                 :treader-tag "tools.reader-0.8.16",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20150126"},
                     "0.0-3126" {:tag "r3126",
                                 :date "2015-03-18",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.16",
                                 :treader-tag "tools.reader-0.8.16",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20150126"},
                     "0.0-1424" {:tag "r1424",
                                 :date "2012-06-16",
                                 :clj-version "1.4.0",
                                 :clj-tag "clojure-1.4.0",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-1376",
                                 :gclosure-com nil},
                     "1.10.520" {:tag "r1.10.520",
                                 :date "2019-02-13",
                                 :clj-version "1.8.0",
                                 :clj-tag "clojure-1.8.0",
                                 :treader-version "1.3.0",
                                 :treader-tag "tools.reader-1.3.0",
                                 :gclosure-lib "0.0-20170809-b9c14c6b",
                                 :gclosure-com "v20180805"},
                     "0.0-2342" {:tag "r2342",
                                 :date "2014-09-18",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.9",
                                 :treader-tag "tools.reader-0.8.9",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com nil},
                     "0.0-3169" {:tag "r3169",
                                 :date "2015-03-31",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.16",
                                 :treader-tag "tools.reader-0.8.16",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20150126"},
                     "1.8.34" {:tag "r1.8.34",
                               :date "2016-03-18",
                               :clj-version "1.8.0",
                               :clj-tag "clojure-1.8.0",
                               :treader-version "1.0.0-alpha3",
                               :treader-tag "tools.reader-1.0.0-alpha3",
                               :gclosure-lib "0.0-20151016-61277aea",
                               :gclosure-com "20151216"},
                     "0.0-1885" {:tag "r1885",
                                 :date "2013-09-15",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.5",
                                 :treader-tag "tools.reader-0.7.5",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "1.11.132" {:tag "r1.11.132",
                                 :date "2024-01-23",
                                 :clj-version "1.10.0",
                                 :clj-tag "clojure-1.10.0",
                                 :treader-version "1.3.6",
                                 :treader-tag "v1.3.6",
                                 :gclosure-lib "0.0-20230227-c7c0a541",
                                 :gclosure-com "v20220502"},
                     "1.9.227" {:tag "r1.9.227",
                                :date "2016-08-26",
                                :clj-version "1.8.0",
                                :clj-tag "clojure-1.8.0",
                                :treader-version "1.0.0-beta3",
                                :treader-tag "tools.reader-1.0.0-beta3",
                                :gclosure-lib "0.0-20160609-f42b4a24",
                                :gclosure-com "v20160315"},
                     "0.0-1535" {:tag "r1535",
                                 :date "2012-11-08",
                                 :clj-version "1.4.0",
                                 :clj-tag "clojure-1.4.0",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-2029",
                                 :gclosure-com nil},
                     "1.9.90" {:tag "r1.9.90",
                               :date "2016-06-22",
                               :clj-version "1.8.0",
                               :clj-tag "clojure-1.8.0",
                               :treader-version "1.0.0-beta1",
                               :treader-tag "tools.reader-1.0.0-beta1",
                               :gclosure-lib "0.0-20160609-f42b4a24",
                               :gclosure-com "20160315"},
                     "0.0-1859" {:tag "r1859",
                                 :date "2013-08-19",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.5",
                                 :treader-tag "tools.reader-0.7.5",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-3308" {:tag "r3308",
                                 :date "2015-06-01",
                                 :clj-version "1.7.0-RC1",
                                 :clj-tag "clojure-1.7.0-RC1",
                                 :treader-version "0.9.2",
                                 :treader-tag "tools.reader-0.9.2",
                                 :gclosure-lib "0.0-20150505-021ed5b3",
                                 :gclosure-com "20150505"},
                     "1.8.51" {:tag "r1.8.51",
                               :date "2016-04-25",
                               :clj-version "1.8.0",
                               :clj-tag "clojure-1.8.0",
                               :treader-version "1.0.0-beta1",
                               :treader-tag "tools.reader-1.0.0-beta1",
                               :gclosure-lib "0.0-20151016-61277aea",
                               :gclosure-com "20160315"},
                     "0.0-3190" {:tag "r3190",
                                 :date "2015-04-09",
                                 :clj-version "1.7.0-alpha6",
                                 :clj-tag "clojure-1.7.0-alpha6",
                                 :treader-version "0.9.0",
                                 :treader-tag "tools.reader-0.9.0",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20150126"},
                     "1.10.739" {:tag "r1.10.739",
                                 :date "2020-04-24",
                                 :clj-version "1.8.0",
                                 :clj-tag "clojure-1.8.0",
                                 :treader-version "1.3.2",
                                 :treader-tag "tools.reader-1.3.2",
                                 :gclosure-lib "0.0-20191016-6ae1f72f",
                                 :gclosure-com "v20200315"},
                     "0.0-2755" {:tag "r2755",
                                 :date "2015-02-01",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.10",
                                 :treader-tag "tools.reader-0.8.10",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20140625"},
                     "0.0-1853" {:tag "r1853",
                                 :date "2013-08-05",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.5",
                                 :treader-tag "tools.reader-0.7.5",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-2197" {:tag "r2197",
                                 :date "2014-03-26",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.8.3",
                                 :treader-tag "tools.reader-0.8.3",
                                 :gclosure-lib "0.0-20140226-71326067",
                                 :gclosure-com nil},
                     "1.9.225" {:tag "r1.9.225",
                                :date "2016-08-19",
                                :clj-version "1.8.0",
                                :clj-tag "clojure-1.8.0",
                                :treader-version "1.0.0-beta3",
                                :treader-tag "tools.reader-1.0.0-beta3",
                                :gclosure-lib "0.0-20160609-f42b4a24",
                                :gclosure-com "v20160315"},
                     "0.0-3291" {:tag "r3291",
                                 :date "2015-05-18",
                                 :clj-version "1.7.0-beta2",
                                 :clj-tag "clojure-1.7.0-beta2",
                                 :treader-version "0.9.2",
                                 :treader-tag "tools.reader-0.9.2",
                                 :gclosure-lib "0.0-20150505-021ed5b3",
                                 :gclosure-com "20150505"},
                     "1.10.238" {:tag "r1.10.238",
                                 :date "2018-03-25",
                                 :clj-version "1.8.0",
                                 :clj-tag "clojure-1.8.0",
                                 :treader-version "1.3.0-alpha3",
                                 :treader-tag "tools.reader-1.3.0-alpha3",
                                 :gclosure-lib "0.0-20170809-b9c14c6b",
                                 :gclosure-com "v20180204"},
                     "0.0-2075" {:tag "r2075",
                                 :date "2013-11-23",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.8.0",
                                 :treader-tag "tools.reader-0.8.0",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "1.7.28" {:tag "r1.7.28",
                               :date "2015-07-31",
                               :clj-version "1.7.0",
                               :clj-tag "clojure-1.7.0",
                               :treader-version "0.10.0-alpha3",
                               :treader-tag "tools.reader-0.10.0-alpha3",
                               :gclosure-lib "0.0-20150505-021ed5b3",
                               :gclosure-com "20150609"},
                     "0.0-2277" {:tag "r2277",
                                 :date "2014-07-25",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.4",
                                 :treader-tag "tools.reader-0.8.4",
                                 :gclosure-lib "0.0-20140226-71326067",
                                 :gclosure-com nil},
                     "1.9.89" {:tag "r1.9.89",
                               :date "2016-06-22",
                               :clj-version "1.8.0",
                               :clj-tag "clojure-1.8.0",
                               :treader-version "1.0.0-beta1",
                               :treader-tag "tools.reader-1.0.0-beta1",
                               :gclosure-lib "0.0-20160609-f42b4a24",
                               :gclosure-com "20160315"},
                     "1.10.896" {:tag "r1.10.896",
                                 :date "2021-12-01",
                                 :clj-version "1.8.0",
                                 :clj-tag "clojure-1.8.0",
                                 :treader-version "1.3.3",
                                 :treader-tag "tools.reader-1.3.3",
                                 :gclosure-lib "0.0-20211011-0726fdeb",
                                 :gclosure-com "v20210808"},
                     "0.0-2301" {:tag "r2301",
                                 :date "2014-08-07",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.4",
                                 :treader-tag "tools.reader-0.8.4",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com nil},
                     "0.0-1909" {:tag "r1909",
                                 :date "2013-09-27",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.8",
                                 :treader-tag "tools.reader-0.7.8",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "1.10.63" {:tag "r1.10.63",
                                :date "2018-02-27",
                                :clj-version "1.9.0",
                                :clj-tag "clojure-1.9.0",
                                :treader-version "1.3.0-alpha3",
                                :treader-tag "tools.reader-1.3.0-alpha3",
                                :gclosure-lib "0.0-20170809-b9c14c6b",
                                :gclosure-com "v20180204"},
                     "0.0-3115" {:tag "r3115",
                                 :date "2015-03-15",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.16",
                                 :treader-tag "tools.reader-0.8.16",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20150126"},
                     "0.0-3195" {:tag "r3195",
                                 :date "2015-04-10",
                                 :clj-version "1.7.0-alpha6",
                                 :clj-tag "clojure-1.7.0-alpha6",
                                 :treader-version "0.9.1",
                                 :treader-tag "tools.reader-0.9.1",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20150126"},
                     "1.9.35" {:tag "r1.9.35",
                               :date "2016-06-03",
                               :clj-version "1.8.0",
                               :clj-tag "clojure-1.8.0",
                               :treader-version "1.0.0-beta1",
                               :treader-tag "tools.reader-1.0.0-beta1",
                               :gclosure-lib "0.0-20151016-61277aea",
                               :gclosure-com "20160315"},
                     "1.10.753" {:tag "r1.10.753",
                                 :date "2020-05-01",
                                 :clj-version "1.8.0",
                                 :clj-tag "clojure-1.8.0",
                                 :treader-version "1.3.2",
                                 :treader-tag "tools.reader-1.3.2",
                                 :gclosure-lib "0.0-20191016-6ae1f72f",
                                 :gclosure-com "v20200315"},
                     "0.0-3153" {:tag "r3153",
                                 :date "2015-03-25",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.16",
                                 :treader-tag "tools.reader-0.8.16",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20150126"},
                     "1.9.226" {:tag "r1.9.226",
                                :date "2016-08-26",
                                :clj-version "1.8.0",
                                :clj-tag "clojure-1.8.0",
                                :treader-version "1.0.0-beta3",
                                :treader-tag "tools.reader-1.0.0-beta3",
                                :gclosure-lib "0.0-20160609-f42b4a24",
                                :gclosure-com "v20160315"},
                     "1.10.866" {:tag "r1.10.866",
                                 :date "2021-05-21",
                                 :clj-version "1.8.0",
                                 :clj-tag "clojure-1.8.0",
                                 :treader-version "1.3.3",
                                 :treader-tag "tools.reader-1.3.3",
                                 :gclosure-lib "0.0-20201211-3e6c510d",
                                 :gclosure-com "v20210505"},
                     "0.0-3119" {:tag "r3119",
                                 :date "2015-03-16",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.16",
                                 :treader-tag "tools.reader-0.8.16",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20150126"},
                     "1.9.85" {:tag "r1.9.85",
                               :date "2016-06-21",
                               :clj-version "1.8.0",
                               :clj-tag "clojure-1.8.0",
                               :treader-version "1.0.0-beta1",
                               :treader-tag "tools.reader-1.0.0-beta1",
                               :gclosure-lib "0.0-20160609-f42b4a24",
                               :gclosure-com "20160315"},
                     "0.0-2723" {:tag "r2723",
                                 :date "2015-01-24",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.10",
                                 :treader-tag "tools.reader-0.8.10",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20140625"},
                     "1.9.75" {:tag "r1.9.75",
                               :date "2016-06-17",
                               :clj-version "1.8.0",
                               :clj-tag "clojure-1.8.0",
                               :treader-version "1.0.0-beta1",
                               :treader-tag "tools.reader-1.0.0-beta1",
                               :gclosure-lib "0.0-20160609-f42b4a24",
                               :gclosure-com "20160315"},
                     "1.10.741" {:tag "r1.10.741",
                                 :date "2020-04-24",
                                 :clj-version "1.8.0",
                                 :clj-tag "clojure-1.8.0",
                                 :treader-version "1.3.2",
                                 :treader-tag "tools.reader-1.3.2",
                                 :gclosure-lib "0.0-20191016-6ae1f72f",
                                 :gclosure-com "v20200315"},
                     "1.9.229" {:tag "r1.9.229",
                                :date "2016-09-06",
                                :clj-version "1.8.0",
                                :clj-tag "clojure-1.8.0",
                                :treader-version "1.0.0-beta3",
                                :treader-tag "tools.reader-1.0.0-beta3",
                                :gclosure-lib "0.0-20160609-f42b4a24",
                                :gclosure-com "v20160315"},
                     "0.0-2727" {:tag "r2727",
                                 :date "2015-01-25",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.10",
                                 :treader-tag "tools.reader-0.8.10",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20140625"},
                     "0.0-3255" {:tag "r3255",
                                 :date "2015-05-08",
                                 :clj-version "1.7.0-beta2",
                                 :clj-tag "clojure-1.7.0-beta2",
                                 :treader-version "0.9.2",
                                 :treader-tag "tools.reader-0.9.2",
                                 :gclosure-lib "0.0-20150505-021ed5b3",
                                 :gclosure-com "20150505"},
                     "1.10.914" {:tag "r1.10.914",
                                 :date "2021-12-20",
                                 :clj-version "1.8.0",
                                 :clj-tag "clojure-1.8.0",
                                 :treader-version "1.3.3",
                                 :treader-tag "tools.reader-1.3.3",
                                 :gclosure-lib "0.0-20211011-0726fdeb",
                                 :gclosure-com "v20210808"},
                     "1.9.854" {:tag "r1.9.854",
                                :date "2017-07-28",
                                :clj-version "1.8.0",
                                :clj-tag "clojure-1.8.0",
                                :treader-version "1.0.3",
                                :treader-tag "tools.reader-1.0.3",
                                :gclosure-lib "0.0-20170519-fa0499ef",
                                :gclosure-com "v20170626"},
                     "0.0-1552" {:tag "r1552",
                                 :date "2012-12-03",
                                 :clj-version "1.4.0",
                                 :clj-tag "clojure-1.4.0",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-2029",
                                 :gclosure-com nil},
                     "0.0-2080" {:tag "r2080",
                                 :date "2013-11-23",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.8.0",
                                 :treader-tag "tools.reader-0.8.0",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-2234" {:tag "r2234",
                                 :date "2014-06-13",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.8.3",
                                 :treader-tag "tools.reader-0.8.3",
                                 :gclosure-lib "0.0-20140226-71326067",
                                 :gclosure-com nil},
                     "0.0-2644" {:tag "r2644",
                                 :date "2015-01-02",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.10",
                                 :treader-tag "tools.reader-0.8.10",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20140625"},
                     "1.10.742" {:tag "r1.10.742",
                                 :date "2020-04-25",
                                 :clj-version "1.8.0",
                                 :clj-tag "clojure-1.8.0",
                                 :treader-version "1.3.2",
                                 :treader-tag "tools.reader-1.3.2",
                                 :gclosure-lib "0.0-20191016-6ae1f72f",
                                 :gclosure-com "v20200315"},
                     "1.10.217" {:tag "r1.10.217",
                                 :date "2018-03-20",
                                 :clj-version "1.8.0",
                                 :clj-tag "clojure-1.8.0",
                                 :treader-version "1.3.0-alpha3",
                                 :treader-tag "tools.reader-1.3.0-alpha3",
                                 :gclosure-lib "0.0-20170809-b9c14c6b",
                                 :gclosure-com "v20180204"},
                     "1.8.40" {:tag "r1.8.40",
                               :date "2016-03-28",
                               :clj-version "1.8.0",
                               :clj-tag "clojure-1.8.0",
                               :treader-version "1.0.0-alpha3",
                               :treader-tag "tools.reader-1.0.0-alpha3",
                               :gclosure-lib "0.0-20151016-61277aea",
                               :gclosure-com "20151216"},
                     "0.0-3191" {:tag "r3191",
                                 :date "2015-04-09",
                                 :clj-version "1.7.0-alpha6",
                                 :clj-tag "clojure-1.7.0-alpha6",
                                 :treader-version "0.9.1",
                                 :treader-tag "tools.reader-0.9.1",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20150126"},
                     "1.11.50" {:tag "r1.11.50",
                                :date "2022-05-12",
                                :clj-version "1.10.0",
                                :clj-tag "clojure-1.10.0",
                                :treader-version "1.3.6",
                                :treader-tag "tools.reader-1.3.6",
                                :gclosure-lib "0.0-20211011-0726fdeb",
                                :gclosure-com "v20220502"},
                     "0.0-2268" {:tag "r2268",
                                 :date "2014-07-06",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.4",
                                 :treader-tag "tools.reader-0.8.4",
                                 :gclosure-lib "0.0-20140226-71326067",
                                 :gclosure-com nil},
                     "0.0-3269" {:tag "r3269",
                                 :date "2015-05-10",
                                 :clj-version "1.7.0-beta2",
                                 :clj-tag "clojure-1.7.0-beta2",
                                 :treader-version "0.9.2",
                                 :treader-tag "tools.reader-0.9.2",
                                 :gclosure-lib "0.0-20150505-021ed5b3",
                                 :gclosure-com "20150505"},
                     "0.0-2511" {:tag "r2511",
                                 :date "2014-12-22",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.10",
                                 :treader-tag "tools.reader-0.8.10",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com nil},
                     "0.0-1806" {:tag "r1806",
                                 :date "2013-05-10",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-2029-2",
                                 :gclosure-com nil},
                     "0.0-3030" {:tag "r3030",
                                 :date "2015-03-07",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.16",
                                 :treader-tag "tools.reader-0.8.16",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20150126"},
                     "0.0-2341" {:tag "r2341",
                                 :date "2014-09-18",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.4",
                                 :treader-tag "tools.reader-0.8.4",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com nil},
                     "1.10.64" {:tag "r1.10.64",
                                :date "2018-02-27",
                                :clj-version "1.9.0",
                                :clj-tag "clojure-1.9.0",
                                :treader-version "1.3.0-alpha3",
                                :treader-tag "tools.reader-1.3.0-alpha3",
                                :gclosure-lib "0.0-20170809-b9c14c6b",
                                :gclosure-com "v20180204"},
                     "1.9.36" {:tag "r1.9.36",
                               :date "2016-06-03",
                               :clj-version "1.8.0",
                               :clj-tag "clojure-1.8.0",
                               :treader-version "1.0.0-beta1",
                               :treader-tag "tools.reader-1.0.0-beta1",
                               :gclosure-lib "0.0-20151016-61277aea",
                               :gclosure-com "20160315"},
                     "0.0-3058" {:tag "r3058",
                                 :date "2015-03-09",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.16",
                                 :treader-tag "tools.reader-0.8.16",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20150126"},
                     "1.9.216" {:tag "r1.9.216",
                                :date "2016-08-15",
                                :clj-version "1.8.0",
                                :clj-tag "clojure-1.8.0",
                                :treader-version "1.0.0-beta3",
                                :treader-tag "tools.reader-1.0.0-beta3",
                                :gclosure-lib "0.0-20160609-f42b4a24",
                                :gclosure-com "v20160315"},
                     "1.7.58" {:tag "r1.7.58",
                               :date "2015-08-06",
                               :clj-version "1.7.0",
                               :clj-tag "clojure-1.7.0",
                               :treader-version "0.10.0-alpha3",
                               :treader-tag "tools.reader-0.10.0-alpha3",
                               :gclosure-lib "0.0-20150805-acd8b553",
                               :gclosure-com "20150729"},
                     "0.0-2629" {:tag "r2629",
                                 :date "2015-01-01",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.10",
                                 :treader-tag "tools.reader-0.8.10",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20140625"},
                     "1.11.4" {:tag "r1.11.4",
                               :date "2021-12-28",
                               :clj-version "1.8.0",
                               :clj-tag "clojure-1.8.0",
                               :treader-version "1.3.3",
                               :treader-tag "tools.reader-1.3.3",
                               :gclosure-lib "0.0-20211011-0726fdeb",
                               :gclosure-com "v20210808"},
                     "0.0-2719" {:tag "r2719",
                                 :date "2015-01-24",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.10",
                                 :treader-tag "tools.reader-0.8.10",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20140625"},
                     "1.12.35" {:tag "r1.12.35",
                                :date "2025-04-23",
                                :clj-version "1.10.0",
                                :clj-tag "clojure-1.10.0",
                                :treader-version "1.3.6",
                                :treader-tag "v1.3.6",
                                :gclosure-lib "0.0-20230227-c7c0a541",
                                :gclosure-com "v20240317"},
                     "0.0-2816" {:tag "r2816",
                                 :date "2015-02-10",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.10",
                                 :treader-tag "tools.reader-0.8.10",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20140625"},
                     "1.7.228" {:tag "r1.7.228",
                                :date "2016-01-08",
                                :clj-version "1.7.0",
                                :clj-tag "clojure-1.7.0",
                                :treader-version "1.0.0-alpha1",
                                :treader-tag "tools.reader-1.0.0-alpha1",
                                :gclosure-lib "0.0-20151016-61277aea",
                                :gclosure-com "20151216"},
                     "0.0-2227" {:tag "r2227",
                                 :date "2014-05-22",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.8.3",
                                 :treader-tag "tools.reader-0.8.3",
                                 :gclosure-lib "0.0-20140226-71326067",
                                 :gclosure-com nil},
                     "0.0-1576" {:tag "r1576",
                                 :date "2013-01-27",
                                 :clj-version "1.4.0",
                                 :clj-tag "clojure-1.4.0",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-2029",
                                 :gclosure-com nil},
                     "0.0-3297" {:tag "r3297",
                                 :date "2015-05-23",
                                 :clj-version "1.7.0-beta2",
                                 :clj-tag "clojure-1.7.0-beta2",
                                 :treader-version "0.9.2",
                                 :treader-tag "tools.reader-0.9.2",
                                 :gclosure-lib "0.0-20150505-021ed5b3",
                                 :gclosure-com "20150505"},
                     "1.10.516" {:tag "r1.10.516",
                                 :date "2019-01-31",
                                 :clj-version "1.8.0",
                                 :clj-tag "clojure-1.8.0",
                                 :treader-version "1.3.0",
                                 :treader-tag "tools.reader-1.3.0",
                                 :gclosure-lib "0.0-20170809-b9c14c6b",
                                 :gclosure-com "v20180805"},
                     "0.0-1844" {:tag "r1844",
                                 :date "2013-07-19",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-2029-2",
                                 :gclosure-com nil},
                     "1.9.493" {:tag "r1.9.493",
                                :date "2017-02-24",
                                :clj-version "1.8.0",
                                :clj-tag "clojure-1.8.0",
                                :treader-version "1.0.0-beta3",
                                :treader-tag "tools.reader-1.0.0-beta3",
                                :gclosure-lib "0.0-20160609-f42b4a24",
                                :gclosure-com "v20170218"},
                     "0.0-1586" {:tag "r1586",
                                 :date "2013-02-16",
                                 :clj-version "1.4.0",
                                 :clj-tag "clojure-1.4.0",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-2029-2",
                                 :gclosure-com nil},
                     "1.9.671" {:tag "r1.9.671",
                                :date "2017-06-30",
                                :clj-version "1.8.0",
                                :clj-tag "clojure-1.8.0",
                                :treader-version "1.0.0",
                                :treader-tag "tools.reader-1.0.0",
                                :gclosure-lib "0.0-20170519-fa0499ef",
                                :gclosure-com "v20170521"},
                     "0.0-3123" {:tag "r3123",
                                 :date "2015-03-16",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.16",
                                 :treader-tag "tools.reader-0.8.16",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20150126"},
                     "1.10.597" {:tag "r1.10.597",
                                 :date "2019-11-19",
                                 :clj-version "1.8.0",
                                 :clj-tag "clojure-1.8.0",
                                 :treader-version "1.3.2",
                                 :treader-tag "tools.reader-1.3.2",
                                 :gclosure-lib "0.0-20170809-b9c14c6b",
                                 :gclosure-com "v20180805"},
                     "1.10.893" {:tag "r1.10.893",
                                 :date "2021-11-08",
                                 :clj-version "1.8.0",
                                 :clj-tag "clojure-1.8.0",
                                 :treader-version "1.3.3",
                                 :treader-tag "tools.reader-1.3.3",
                                 :gclosure-lib "0.0-20210811-6da97fe1",
                                 :gclosure-com "v20210808"},
                     "1.7.107" {:tag "r1.7.107",
                                :date "2015-08-11",
                                :clj-version "1.7.0",
                                :clj-tag "clojure-1.7.0",
                                :treader-version "0.10.0-alpha3",
                                :treader-tag "tools.reader-0.10.0-alpha3",
                                :gclosure-lib "0.0-20150805-acd8b553",
                                :gclosure-com "20150729"},
                     "0.0-2498" {:tag "r2498",
                                 :date "2014-12-19",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.10",
                                 :treader-tag "tools.reader-0.8.10",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com nil},
                     "1.7.48" {:tag "r1.7.48",
                               :date "2015-08-05",
                               :clj-version "1.7.0",
                               :clj-tag "clojure-1.7.0",
                               :treader-version "0.10.0-alpha3",
                               :treader-tag "tools.reader-0.10.0-alpha3",
                               :gclosure-lib "0.0-20150805-acd8b553",
                               :gclosure-com "20150729"},
                     "1.10.738" {:tag "r1.10.738",
                                 :date "2020-04-24",
                                 :clj-version "1.8.0",
                                 :clj-tag "clojure-1.8.0",
                                 :treader-version "1.3.2",
                                 :treader-tag "tools.reader-1.3.2",
                                 :gclosure-lib "0.0-20191016-6ae1f72f",
                                 :gclosure-com "v20200315"},
                     "0.0-3117" {:tag "r3117",
                                 :date "2015-03-16",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.16",
                                 :treader-tag "tools.reader-0.8.16",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20150126"},
                     "0.0-2850" {:tag "r2850",
                                 :date "2015-02-13",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.10",
                                 :treader-tag "tools.reader-0.8.10",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20140625"},
                     "0.0-1443" {:tag "r1443",
                                 :date "2012-07-06",
                                 :clj-version "1.4.0",
                                 :clj-tag "clojure-1.4.0",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-1376",
                                 :gclosure-com nil},
                     "0.0-1006" {:tag "r1006",
                                 :date "2012-03-30",
                                 :clj-version "1.3.0",
                                 :clj-tag "clojure-1.3.0",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-790",
                                 :gclosure-com nil},
                     "1.9.494" {:tag "r1.9.494",
                                :date "2017-02-25",
                                :clj-version "1.8.0",
                                :clj-tag "clojure-1.8.0",
                                :treader-version "1.0.0-beta3",
                                :treader-tag "tools.reader-1.0.0-beta3",
                                :gclosure-lib "0.0-20160609-f42b4a24",
                                :gclosure-com "v20170218"},
                     "1.9.660" {:tag "r1.9.660",
                                :date "2017-06-27",
                                :clj-version "1.8.0",
                                :clj-tag "clojure-1.8.0",
                                :treader-version "1.0.0",
                                :treader-tag "tools.reader-1.0.0",
                                :gclosure-lib "0.0-20170519-fa0499ef",
                                :gclosure-com "v20170521"},
                     "1.10.773" {:tag "r1.10.773",
                                 :date "2020-05-26",
                                 :clj-version "1.8.0",
                                 :clj-tag "clojure-1.8.0",
                                 :treader-version "1.3.2",
                                 :treader-tag "tools.reader-1.3.2",
                                 :gclosure-lib "0.0-20191016-6ae1f72f",
                                 :gclosure-com "v20200315"},
                     "0.0-1913" {:tag "r1913",
                                 :date "2013-10-05",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.8",
                                 :treader-tag "tools.reader-0.7.8",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-2069" {:tag "r2069",
                                 :date "2013-11-22",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.8.0",
                                 :treader-tag "tools.reader-0.8.0",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-2814" {:tag "r2814",
                                 :date "2015-02-10",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.10",
                                 :treader-tag "tools.reader-0.8.10",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20140625"},
                     "0.0-2655" {:tag "r2655",
                                 :date "2015-01-03",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.10",
                                 :treader-tag "tools.reader-0.8.10",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20140625"},
                     "1.7.145" {:tag "r1.7.145",
                                :date "2015-10-13",
                                :clj-version "1.7.0",
                                :clj-tag "clojure-1.7.0",
                                :treader-version "0.10.0-alpha3",
                                :treader-tag "tools.reader-0.10.0-alpha3",
                                :gclosure-lib "0.0-20150805-acd8b553",
                                :gclosure-com "20150920"},
                     "0.0-1513" {:tag "r1513",
                                 :date "2012-10-19",
                                 :clj-version "1.4.0",
                                 :clj-tag "clojure-1.4.0",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-1376-2",
                                 :gclosure-com nil},
                     "1.11.57" {:tag "r1.11.57",
                                :date "2022-06-11",
                                :clj-version "1.10.0",
                                :clj-tag "clojure-1.10.0",
                                :treader-version "1.3.6",
                                :treader-tag "tools.reader-1.3.6",
                                :gclosure-lib "0.0-20211011-0726fdeb",
                                :gclosure-com "v20220502"},
                     "0.0-1503" {:tag "r1503",
                                 :date "2012-10-12",
                                 :clj-version "1.4.0",
                                 :clj-tag "clojure-1.4.0",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-1376-2",
                                 :gclosure-com nil},
                     "1.9.946" {:tag "r1.9.946",
                                :date "2017-10-03",
                                :clj-version "1.8.0",
                                :clj-tag "clojure-1.8.0",
                                :treader-version "1.1.0",
                                :treader-tag "tools.reader-1.1.0",
                                :gclosure-lib "0.0-20170809-b9c14c6b",
                                :gclosure-com "v20170910"},
                     "0.0-1933" {:tag "r1933",
                                 :date "2013-10-11",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.9",
                                 :treader-tag "tools.reader-0.7.9",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "1.9.14" {:tag "r1.9.14",
                               :date "2016-06-01",
                               :clj-version "1.8.0",
                               :clj-tag "clojure-1.8.0",
                               :treader-version "1.0.0-beta1",
                               :treader-tag "tools.reader-1.0.0-beta1",
                               :gclosure-lib "0.0-20151016-61277aea",
                               :gclosure-com "20160315"},
                     "0.0-1895" {:tag "r1895",
                                 :date "2013-09-24",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.5",
                                 :treader-tag "tools.reader-0.7.5",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-971" {:tag "r971",
                                :date "2012-01-27",
                                :clj-version "1.3.0",
                                :clj-tag "clojure-1.3.0",
                                :treader-version nil,
                                :treader-tag nil,
                                :gclosure-lib "0.0-790",
                                :gclosure-com nil},
                     "0.0-2027" {:tag "r2027",
                                 :date "2013-11-08",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.10",
                                 :treader-tag "tools.reader-0.7.10",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-1978" {:tag "r1978",
                                 :date "2013-10-28",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.10",
                                 :treader-tag "tools.reader-0.7.10",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-1843" {:tag "r1843",
                                 :date "2013-07-16",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-2029-2",
                                 :gclosure-com nil},
                     "0.0-2758" {:tag "r2758",
                                 :date "2015-02-02",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.10",
                                 :treader-tag "tools.reader-0.8.10",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20140625"},
                     "0.0-2913" {:tag "r2913",
                                 :date "2015-02-21",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.10",
                                 :treader-tag "tools.reader-0.8.10",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20140625"},
                     "0.0-1835" {:tag "r1835",
                                 :date "2013-06-21",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-2029-2",
                                 :gclosure-com nil},
                     "1.10.740" {:tag "r1.10.740",
                                 :date "2020-04-24",
                                 :clj-version "1.8.0",
                                 :clj-tag "clojure-1.8.0",
                                 :treader-version "1.3.2",
                                 :treader-tag "tools.reader-1.3.2",
                                 :gclosure-lib "0.0-20191016-6ae1f72f",
                                 :gclosure-com "v20200315"},
                     "0.0-3264" {:tag "r3264",
                                 :date "2015-05-09",
                                 :clj-version "1.7.0-beta2",
                                 :clj-tag "clojure-1.7.0-beta2",
                                 :treader-version "0.9.2",
                                 :treader-tag "tools.reader-0.9.2",
                                 :gclosure-lib "0.0-20150505-021ed5b3",
                                 :gclosure-com "20150505"},
                     "1.9.655" {:tag "r1.9.655",
                                :date "2017-06-27",
                                :clj-version "1.8.0",
                                :clj-tag "clojure-1.8.0",
                                :treader-version "1.0.0",
                                :treader-tag "tools.reader-1.0.0",
                                :gclosure-lib "0.0-20170519-fa0499ef",
                                :gclosure-com "v20170521"},
                     "0.0-3149" {:tag "r3149",
                                 :date "2015-03-23",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.16",
                                 :treader-tag "tools.reader-0.8.16",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20150126"},
                     "1.9.198" {:tag "r1.9.198",
                                :date "2016-08-12",
                                :clj-version "1.8.0",
                                :clj-tag "clojure-1.8.0",
                                :treader-version "1.0.0-beta3",
                                :treader-tag "tools.reader-1.0.0-beta3",
                                :gclosure-lib "0.0-20160609-f42b4a24",
                                :gclosure-com "v20160315"},
                     "1.11.121" {:tag "r1.11.121",
                                 :date "2023-09-01",
                                 :clj-version "1.10.0",
                                 :clj-tag "clojure-1.10.0",
                                 :treader-version "1.3.6",
                                 :treader-tag "v1.3.6",
                                 :gclosure-lib "0.0-20230227-c7c0a541",
                                 :gclosure-com "v20220502"},
                     "0.0-1450" {:tag "r1450",
                                 :date "2012-07-25",
                                 :clj-version "1.4.0",
                                 :clj-tag "clojure-1.4.0",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-1376",
                                 :gclosure-com nil},
                     "0.0-2173" {:tag "r2173",
                                 :date "2014-02-22",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.8.3",
                                 :treader-tag "tools.reader-0.8.3",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-3208" {:tag "r3208",
                                 :date "2015-04-16",
                                 :clj-version "1.7.0-beta1",
                                 :clj-tag "clojure-1.7.0-beta1",
                                 :treader-version "0.9.1",
                                 :treader-tag "tools.reader-0.9.1",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20150126"},
                     "1.10.764" {:tag "r1.10.764",
                                 :date "2020-05-13",
                                 :clj-version "1.8.0",
                                 :clj-tag "clojure-1.8.0",
                                 :treader-version "1.3.2",
                                 :treader-tag "tools.reader-1.3.2",
                                 :gclosure-lib "0.0-20191016-6ae1f72f",
                                 :gclosure-com "v20200315"},
                     "0.0-3263" {:tag "r3263",
                                 :date "2015-05-09",
                                 :clj-version "1.7.0-beta2",
                                 :clj-tag "clojure-1.7.0-beta2",
                                 :treader-version "0.9.2",
                                 :treader-tag "tools.reader-0.9.2",
                                 :gclosure-lib "0.0-20150505-021ed5b3",
                                 :gclosure-com "20150505"},
                     "1.9.473" {:tag "r1.9.473",
                                :date "2017-02-10",
                                :clj-version "1.8.0",
                                :clj-tag "clojure-1.8.0",
                                :treader-version "1.0.0-beta3",
                                :treader-tag "tools.reader-1.0.0-beta3",
                                :gclosure-lib "0.0-20160609-f42b4a24",
                                :gclosure-com "v20161201"},
                     "1.7.170" {:tag "r1.7.170",
                                :date "2015-11-06",
                                :clj-version "1.7.0",
                                :clj-tag "clojure-1.7.0",
                                :treader-version "0.10.0-alpha3",
                                :treader-tag "tools.reader-0.10.0-alpha3",
                                :gclosure-lib "0.0-20151016-61277aea",
                                :gclosure-com "20151015"},
                     "0.0-1798" {:tag "r1798",
                                 :date "2013-05-03",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-2029-2",
                                 :gclosure-com nil},
                     "0.0-1877" {:tag "r1877",
                                 :date "2013-09-08",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.5",
                                 :treader-tag "tools.reader-0.7.5",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-1211" {:tag "r1211",
                                 :date "2012-05-09",
                                 :clj-version "1.4.0",
                                 :clj-tag "clojure-1.4.0",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-790",
                                 :gclosure-com nil},
                     "1.10.145" {:tag "r1.10.145",
                                 :date "2018-03-08",
                                 :clj-version "1.8.0",
                                 :clj-tag "clojure-1.8.0",
                                 :treader-version "1.3.0-alpha3",
                                 :treader-tag "tools.reader-1.3.0-alpha3",
                                 :gclosure-lib "0.0-20170809-b9c14c6b",
                                 :gclosure-com "v20180204"},
                     "0.0-1449" {:tag "r1449",
                                 :date "2012-07-24",
                                 :clj-version "1.4.0",
                                 :clj-tag "clojure-1.4.0",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-1376",
                                 :gclosure-com nil},
                     "0.0-2911" {:tag "r2911",
                                 :date "2015-02-21",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.10",
                                 :treader-tag "tools.reader-0.8.10",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20140625"},
                     "1.9.908" {:tag "r1.9.908",
                                :date "2017-08-16",
                                :clj-version "1.8.0",
                                :clj-tag "clojure-1.8.0",
                                :treader-version "1.0.5",
                                :treader-tag "tools.reader-1.0.5",
                                :gclosure-lib "0.0-20170809-b9c14c6b",
                                :gclosure-com "v20170806"},
                     "0.0-993" {:tag "r993",
                                :date "2012-02-27",
                                :clj-version "1.3.0",
                                :clj-tag "clojure-1.3.0",
                                :treader-version nil,
                                :treader-tag nil,
                                :gclosure-lib "0.0-790",
                                :gclosure-com nil},
                     "0.0-1011" {:tag "r1011",
                                 :date "2012-04-02",
                                 :clj-version "1.3.0",
                                 :clj-tag "clojure-1.3.0",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-790",
                                 :gclosure-com nil},
                     "0.0-2356" {:tag "r2356",
                                 :date "2014-09-26",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.9",
                                 :treader-tag "tools.reader-0.8.9",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com nil},
                     "1.7.122" {:tag "r1.7.122",
                                :date "2015-08-29",
                                :clj-version "1.7.0",
                                :clj-tag "clojure-1.7.0",
                                :treader-version "0.10.0-alpha3",
                                :treader-tag "tools.reader-0.10.0-alpha3",
                                :gclosure-lib "0.0-20150805-acd8b553",
                                :gclosure-com "20150729"},
                     "1.10.329" {:tag "r1.10.329",
                                 :date "2018-06-22",
                                 :clj-version "1.8.0",
                                 :clj-tag "clojure-1.8.0",
                                 :treader-version "1.3.0-alpha3",
                                 :treader-tag "tools.reader-1.3.0-alpha3",
                                 :gclosure-lib "0.0-20170809-b9c14c6b",
                                 :gclosure-com "v20180610"},
                     "0.0-3211" {:tag "r3211",
                                 :date "2015-04-23",
                                 :clj-version "1.7.0-beta1",
                                 :clj-tag "clojure-1.7.0-beta1",
                                 :treader-version "0.9.1",
                                 :treader-tag "tools.reader-0.9.1",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20150126"},
                     "0.0-3053" {:tag "r3053",
                                 :date "2015-03-09",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.16",
                                 :treader-tag "tools.reader-0.8.16",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20150126"},
                     "0.0-2985" {:tag "r2985",
                                 :date "2015-03-04",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.10",
                                 :treader-tag "tools.reader-0.8.10",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20150126"},
                     "1.9.183" {:tag "r1.9.183",
                                :date "2016-08-10",
                                :clj-version "1.8.0",
                                :clj-tag "clojure-1.8.0",
                                :treader-version "1.0.0-beta3",
                                :treader-tag "tools.reader-1.0.0-beta3",
                                :gclosure-lib "0.0-20160609-f42b4a24",
                                :gclosure-com "v20160315"},
                     "0.0-2156" {:tag "r2156",
                                 :date "2014-01-29",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.8.3",
                                 :treader-tag "tools.reader-0.8.3",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-1847" {:tag "r1847",
                                 :date "2013-07-23",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "1.9.293" {:tag "r1.9.293",
                                :date "2016-10-19",
                                :clj-version "1.8.0",
                                :clj-tag "clojure-1.8.0",
                                :treader-version "1.0.0-beta3",
                                :treader-tag "tools.reader-1.0.0-beta3",
                                :gclosure-lib "0.0-20160609-f42b4a24",
                                :gclosure-com "v20160911"},
                     "1.9.542" {:tag "r1.9.542",
                                :date "2017-05-12",
                                :clj-version "1.8.0",
                                :clj-tag "clojure-1.8.0",
                                :treader-version "1.0.0-beta3",
                                :treader-tag "tools.reader-1.0.0-beta3",
                                :gclosure-lib "0.0-20160609-f42b4a24",
                                :gclosure-com "v20170423"},
                     "1.7.189" {:tag "r1.7.189",
                                :date "2015-12-01",
                                :clj-version "1.7.0",
                                :clj-tag "clojure-1.7.0",
                                :treader-version "0.10.0-alpha3",
                                :treader-tag "tools.reader-0.10.0-alpha3",
                                :gclosure-lib "0.0-20151016-61277aea",
                                :gclosure-com "20151015"},
                     "0.0-2496" {:tag "r2496",
                                 :date "2014-12-17",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.10",
                                 :treader-tag "tools.reader-0.8.10",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com nil},
                     "0.0-3196" {:tag "r3196",
                                 :date "2015-04-10",
                                 :clj-version "1.7.0-beta1",
                                 :clj-tag "clojure-1.7.0-beta1",
                                 :treader-version "0.9.1",
                                 :treader-tag "tools.reader-0.9.1",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20150126"},
                     "1.10.879" {:tag "r1.10.879",
                                 :date "2021-07-19",
                                 :clj-version "1.8.0",
                                 :clj-tag "clojure-1.8.0",
                                 :treader-version "1.3.3",
                                 :treader-tag "tools.reader-1.3.3",
                                 :gclosure-lib "0.0-20201211-3e6c510d",
                                 :gclosure-com "v20210505"},
                     "1.10.758" {:tag "r1.10.758",
                                 :date "2020-05-04",
                                 :clj-version "1.8.0",
                                 :clj-tag "clojure-1.8.0",
                                 :treader-version "1.3.2",
                                 :treader-tag "tools.reader-1.3.2",
                                 :gclosure-lib "0.0-20191016-6ae1f72f",
                                 :gclosure-com "v20200315"},
                     "0.0-927" {:tag "r927",
                                :date "2012-01-20",
                                :clj-version "1.3.0",
                                :clj-tag "clojure-1.3.0",
                                :treader-version nil,
                                :treader-tag nil,
                                :gclosure-lib "20110323-r790",
                                :gclosure-com nil},
                     "0.0-1934" {:tag "r1934",
                                 :date "2013-10-11",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.9",
                                 :treader-tag "tools.reader-0.7.9",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "1.10.756" {:tag "r1.10.756",
                                 :date "2020-05-04",
                                 :clj-version "1.8.0",
                                 :clj-tag "clojure-1.8.0",
                                 :treader-version "1.3.2",
                                 :treader-tag "tools.reader-1.3.2",
                                 :gclosure-lib "0.0-20191016-6ae1f72f",
                                 :gclosure-com "v20200315"},
                     "1.9.76" {:tag "r1.9.76",
                               :date "2016-06-17",
                               :clj-version "1.8.0",
                               :clj-tag "clojure-1.8.0",
                               :treader-version "1.0.0-beta1",
                               :treader-tag "tools.reader-1.0.0-beta1",
                               :gclosure-lib "0.0-20160609-f42b4a24",
                               :gclosure-com "20160315"},
                     "0.0-3165" {:tag "r3165",
                                 :date "2015-03-27",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.16",
                                 :treader-tag "tools.reader-0.8.16",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20150126"},
                     "0.0-2202" {:tag "r2202",
                                 :date "2014-04-02",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.8.3",
                                 :treader-tag "tools.reader-0.8.3",
                                 :gclosure-lib "0.0-20140226-71326067",
                                 :gclosure-com nil},
                     "1.10.126" {:tag "r1.10.126",
                                 :date "2018-03-04",
                                 :clj-version "1.8.0",
                                 :clj-tag "clojure-1.8.0",
                                 :treader-version "1.3.0-alpha3",
                                 :treader-tag "tools.reader-1.3.0-alpha3",
                                 :gclosure-lib "0.0-20170809-b9c14c6b",
                                 :gclosure-com "v20180204"},
                     "0.0-1820" {:tag "r1820",
                                 :date "2013-06-07",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-2029-2",
                                 :gclosure-com nil},
                     "1.9.456" {:tag "r1.9.456",
                                :date "2017-01-27",
                                :clj-version "1.8.0",
                                :clj-tag "clojure-1.8.0",
                                :treader-version "1.0.0-beta3",
                                :treader-tag "tools.reader-1.0.0-beta3",
                                :gclosure-lib "0.0-20160609-f42b4a24",
                                :gclosure-com "v20161201"},
                     "0.0-2261" {:tag "r2261",
                                 :date "2014-07-02",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.4",
                                 :treader-tag "tools.reader-0.8.4",
                                 :gclosure-lib "0.0-20140226-71326067",
                                 :gclosure-com nil},
                     "0.0-2024" {:tag "r2024",
                                 :date "2013-11-08",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.10",
                                 :treader-tag "tools.reader-0.7.10",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "1.9.88" {:tag "r1.9.88",
                               :date "2016-06-21",
                               :clj-version "1.8.0",
                               :clj-tag "clojure-1.8.0",
                               :treader-version "1.0.0-beta1",
                               :treader-tag "tools.reader-1.0.0-beta1",
                               :gclosure-lib "0.0-20160609-f42b4a24",
                               :gclosure-com "20160315"},
                     "1.7.10" {:tag "r1.7.10",
                               :date "2015-07-29",
                               :clj-version "1.7.0",
                               :clj-tag "clojure-1.7.0",
                               :treader-version "0.10.0-alpha3",
                               :treader-tag "tools.reader-0.10.0-alpha3",
                               :gclosure-lib "0.0-20150505-021ed5b3",
                               :gclosure-com "20150609"},
                     "0.0-1889" {:tag "r1889",
                                 :date "2013-09-15",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.5",
                                 :treader-tag "tools.reader-0.7.5",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-2657" {:tag "r2657",
                                 :date "2015-01-03",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.10",
                                 :treader-tag "tools.reader-0.8.10",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20140625"},
                     "0.0-1896" {:tag "r1896",
                                 :date "2013-09-24",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.5",
                                 :treader-tag "tools.reader-0.7.5",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-2014" {:tag "r2014",
                                 :date "2013-11-06",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.10",
                                 :treader-tag "tools.reader-0.7.10",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "1.9.562" {:tag "r1.9.562",
                                :date "2017-05-26",
                                :clj-version "1.8.0",
                                :clj-tag "clojure-1.8.0",
                                :treader-version "1.0.0-beta3",
                                :treader-tag "tools.reader-1.0.0-beta3",
                                :gclosure-lib "0.0-20170519-fa0499ef",
                                :gclosure-com "v20170521"},
                     "0.0-2411" {:tag "r2411",
                                 :date "2014-12-05",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.10",
                                 :treader-tag "tools.reader-0.8.10",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com nil},
                     "0.0-2665" {:tag "r2665",
                                 :date "2015-01-04",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.10",
                                 :treader-tag "tools.reader-0.8.10",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20140625"},
                     "0.0-2760" {:tag "r2760",
                                 :date "2015-02-02",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.10",
                                 :treader-tag "tools.reader-0.8.10",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20140625"}}},
 :clj-not-cljs #{"clojure.core/the-ns"
                 "clojure.core/create-struct"
                 "clojure.data/diff-similar"
                 "clojure.core/*in*"
                 "clojure.main/demunge"
                 "clojure.core.protocols/kv-reduce"
                 "clojure.core/release-pending-sends"
                 "clojure.reflect/flag-descriptors"
                 "clojure.core/shutdown-agents"
                 "clojure.core/restart-agent"
                 "clojure.java.io/input-stream"
                 "clojure.stacktrace/print-cause-trace"
                 "clojure.java.io/file"
                 "clojure.test/*load-tests*"
                 "clojure.core/->Vec"
                 "clojure.test/deftest-"
                 "clojure.inspector/inspect-tree"
                 "clojure.core/remove-ns"
                 "clojure.repl/thread-stopper"
                 "clojure.core/+'"
                 "clojure.core/rationalize"
                 "clojure.main/repl"
                 "clojure.repl/dir-fn"
                 "clojure.core/proxy-super"
                 "clojure.core/refer"
                 "clojure.stacktrace/print-trace-element"
                 "clojure.core.protocols/CollReduce"
                 "clojure.core/future-call"
                 "clojure.core.protocols/InternalReduce"
                 "clojure.core/loaded-libs"
                 "clojure.core/commute"
                 "clojure.core/agent-errors"
                 "clojure.main/repl-caught"
                 "clojure.core/printf"
                 "clojure.core/ArrayChunk"
                 "clojure.core/load-string"
                 "clojure.core/pmap"
                 "clojure.test/file-position"
                 "clojure.core.protocols/IKVReduce"
                 "clojure.core/send"
                 "clojure.core/ref-history-count"
                 "clojure.core/iterator-seq"
                 "clojure.reflect/map->Field"
                 "clojure.core/find-var"
                 "clojure.core/defstruct"
                 "clojure.core/-'"
                 "clojure.core.server/remote-prepl"
                 "clojure.core/agent-error"
                 "clojure.core.server/start-servers"
                 "clojure.core/->Eduction"
                 "clojure.core/ns-refers"
                 "clojure.core/num"
                 "clojure.reflect/do-reflect"
                 "clojure.core/future-cancelled?"
                 "clojure.java.io/make-writer"
                 "clojure.stacktrace/print-stack-trace"
                 "clojure.core/init-proxy"
                 "clojure.walk/postwalk-demo"
                 "clojure.core/read-line"
                 "clojure.core/alter-var-root"
                 "clojure.core/bases"
                 "clojure.repl/source-fn"
                 "clojure.core/class"
                 "clojure.core/Eduction"
                 "clojure.reflect/ClassResolver"
                 "clojure.reflect/type-reflect"
                 "clojure.core/default-data-readers"
                 "clojure.core/byte-array"
                 "clojure.java.shell/with-sh-dir"
                 "clojure.core/*err*"
                 "clojure.core/await"
                 "clojure.core/supers"
                 "clojure.reflect/Field"
                 "clojure.core/vector-of"
                 "clojure.core/accessor"
                 "clojure.inspector/inspect-table"
                 "clojure.core/class?"
                 "clojure.core/ns-map"
                 "clojure.instant/parse-timestamp"
                 "clojure.java.io/make-output-stream"
                 "clojure.core/aset-boolean"
                 "clojure.reflect/typename"
                 "clojure.walk/prewalk-demo"
                 "clojure.reflect/reflect"
                 "clojure.core/with-bindings"
                 "clojure.core/sync"
                 "clojure.java.javadoc/javadoc"
                 "clojure.reflect/->AsmReflector"
                 "clojure.core/ref-set"
                 "clojure.reflect/->Method"
                 "clojure.core/->ArrayChunk"
                 "clojure.test.tap/with-tap-output"
                 "clojure.java.io/copy"
                 "clojure.core/*data-readers*"
                 "clojure.test.junit/with-junit-output"
                 "clojure.core/future?"
                 "clojure.core/proxy-mappings"
                 "clojure.core/*read-eval*"
                 "clojure.template/do-template"
                 "clojure.core/spit"
                 "clojure.core/Vec"
                 "clojure.core/monitor-enter"
                 "clojure.core/alter"
                 "clojure.java.io/resource"
                 "clojure.repl/root-cause"
                 "clojure.core/inc'"
                 "clojure.java.io/make-parents"
                 "clojure.reflect/->Constructor"
                 "clojure.core/ref-min-history"
                 "clojure.core/get-proxy-class"
                 "clojure.main/repl-requires"
                 "clojure.core/aset-double"
                 "clojure.test/set-test"
                 "clojure.core/ref"
                 "clojure.core/future-cancel"
                 "clojure.core.server/repl-init"
                 "clojure.core/with-local-vars"
                 "clojure.core/agent"
                 "clojure.core/bean"
                 "clojure.core/aset-float"
                 "clojure.core/*file*"
                 "clojure.core/clojure-version"
                 "clojure.core/with-in-str"
                 "clojure.xml/parse"
                 "clojure.core/reader-conditional"
                 "clojure.core/with-bindings*"
                 "clojure.instant/read-instant-timestamp"
                 "clojure.reflect/->Field"
                 "clojure.core/*default-data-reader-fn*"
                 "clojure.core/update-proxy"
                 "clojure.java.io/make-input-stream"
                 "clojure.core.server/stop-servers"
                 "clojure.core/promise"
                 "clojure.instant/validated"
                 "clojure.core/*compile-files*"
                 "clojure.core/*compile-path*"
                 "clojure.core/gen-class"
                 "clojure.test.tap/print-tap-diagnostic"
                 "clojure.core/find-keyword"
                 "clojure.core/bound-fn*"
                 "clojure.core/StackTraceElement->vec"
                 "clojure.reflect/Constructor"
                 "clojure.test/*stack-trace-depth*"
                 "clojure.reflect/resolve-class"
                 "clojure.java.io/as-file"
                 "clojure.core/ns-aliases"
                 "clojure.main/stack-element-str"
                 "clojure.core/extend"
                 "clojure.core/char-name-string"
                 "clojure.reflect/JavaReflector"
                 "clojure.inspector/inspect"
                 "clojure.core/send-via"
                 "clojure.core/set-agent-send-executor!"
                 "clojure.core/aset-int"
                 "clojure.stacktrace/print-throwable"
                 "clojure.reflect/map->Method"
                 "clojure.main/repl-prompt"
                 "clojure.core.server/repl-read"
                 "clojure.test/with-test"
                 "clojure.core/struct-map"
                 "clojure.template/apply-template"
                 "clojure.core/set-agent-send-off-executor!"
                 "clojure.core.server/start-server"
                 "clojure.core/cast"
                 "clojure.java.shell/with-sh-env"
                 "clojure.main/repl-read"
                 "clojure.core/io!"
                 "clojure.core/ensure"
                 "clojure.string/re-quote-replacement"
                 "clojure.core/re-groups"
                 "clojure.core/pvalues"
                 "clojure.core/deliver"
                 "clojure.main/load-script"
                 "clojure.core/numerator"
                 "clojure.core/VecNode"
                 "clojure.core/VecSeq"
                 "clojure.core/var-get"
                 "clojure.core/clear-agent-errors"
                 "clojure.core/var-set"
                 "clojure.core/slurp"
                 "clojure.core/bound-fn"
                 "clojure.core/push-thread-bindings"
                 "clojure.core/*unchecked-math*"
                 "clojure.core/aset-short"
                 "clojure.java.io/make-reader"
                 "clojure.core/ns-resolve"
                 "clojure.core.protocols/coll-reduce"
                 "clojure.core/char-array"
                 "clojure.stacktrace/root-cause"
                 "clojure.core/ratio?"
                 "clojure.core/rational?"
                 "clojure.java.io/as-url"
                 "clojure.core/PrintWriter-on"
                 "clojure.core/future"
                 "clojure.core/aset-byte"
                 "clojure.core/send-off"
                 "clojure.java.io/IOFactory"
                 "clojure.reflect/Method"
                 "clojure.core/float-array"
                 "clojure.core/thread-bound?"
                 "clojure.core/read+string"
                 "clojure.core/with-precision"
                 "clojure.core/proxy"
                 "clojure.core/reader-conditional?"
                 "clojure.core/aset-char"
                 "clojure.java.io/output-stream"
                 "clojure.test/inc-report-counter"
                 "clojure.java.io/delete-file"
                 "clojure.core/compile"
                 "clojure.repl/stack-element-str"
                 "clojure.core/->VecSeq"
                 "clojure.core/->VecNode"
                 "clojure.core/xml-seq"
                 "clojure.test/with-test-out"
                 "clojure.core/file-seq"
                 "clojure.core/short-array"
                 "clojure.core/future-done?"
                 "clojure.core.reducers/->Cat"
                 "clojure.core/get-thread-bindings"
                 "clojure.stacktrace/e"
                 "clojure.core/struct"
                 "clojure.repl/set-break-handler!"
                 "clojure.core/&"
                 "clojure.instant/read-instant-date"
                 "clojure.spec.gen.alpha/bytes"
                 "clojure.java.javadoc/add-remote-javadoc"
                 "clojure.reflect/map->Constructor"
                 "clojure.test.tap/print-tap-pass"
                 "clojure.main/root-cause"
                 "clojure.core/extenders"
                 "clojure.core/construct-proxy"
                 "clojure.core/intern"
                 "clojure.core/error-mode"
                 "clojure.core.server/stop-server"
                 "clojure.core/all-ns"
                 "clojure.walk/macroexpand-all"
                 "clojure.core/char-escape-string"
                 "clojure.repl/demunge"
                 "clojure.core/line-seq"
                 "clojure.core/enumeration-seq"
                 "clojure.core/bigdec"
                 "clojure.java.javadoc/add-local-javadoc"
                 "clojure.core/decimal?"
                 "clojure.core/definterface"
                 "clojure.core/pcalls"
                 "clojure.core/ns-unalias"
                 "clojure.core/error-handler"
                 "clojure.core/biginteger"
                 "clojure.core/ref-max-history"
                 "clojure.reflect/TypeReference"
                 "clojure.spec.gen.alpha/gen-for-name"
                 "clojure.core.server/prepl"
                 "clojure.core/definline"
                 "clojure.core/namespace-munge"
                 "clojure.core/pop-thread-bindings"
                 "clojure.main/main"
                 "clojure.core/aset-long"
                 "clojure.core/dosync"
                 "clojure.core/*'"
                 "clojure.core/seque"
                 "clojure.main/skip-whitespace"
                 "clojure.main/with-bindings"
                 "clojure.core/load-reader"
                 "clojure.core/await-for"
                 "clojure.test.tap/print-tap-plan"
                 "clojure.java.browse/browse-url"
                 "clojure.core/monitor-exit"
                 "clojure.core/re-matcher"
                 "clojure.java.io/as-relative-path"
                 "clojure.core.server/repl"
                 "clojure.core/gen-interface"
                 "clojure.core/with-redefs-fn"
                 "clojure.core/extends?"
                 "clojure.java.io/Coercions"
                 "clojure.core/set-error-mode!"
                 "clojure.core/format"
                 "clojure.core/*agent*"
                 "clojure.core/alias"
                 "clojure.core/bound?"
                 "clojure.instant/read-instant-calendar"
                 "clojure.java.io/writer"
                 "clojure.core/bytes?"
                 "clojure.core.server/io-prepl"
                 "clojure.core/with-open"
                 "clojure.core/set-error-handler!"
                 "clojure.java.shell/sh"
                 "clojure.reflect/->JavaReflector"
                 "clojure.core/*compiler-options*"
                 "clojure.core/denominator"
                 "clojure.main/skip-if-eol"
                 "clojure.core/dec'"
                 "clojure.data/equality-partition"
                 "clojure.main/with-read-known"
                 "clojure.java.io/reader"
                 "clojure.reflect/Reflector"
                 "clojure.main/repl-exception"
                 "clojure.test.tap/print-tap-fail"
                 "clojure.core/bigint"
                 "clojure.core/resultset-seq"
                 "clojure.test/get-possibly-unbound-var"
                 "clojure.core.protocols/internal-reduce"
                 "clojure.reflect/AsmReflector"
                 "clojure.core/boolean-array"
                 "clojure.core/add-classpath"
                 "clojure.core/*warn-on-reflection*"},
 :symbols {"compiler-options/preloads" {:ns "compiler-options",
                                        :name "preloads",
                                        :name-encode "preloads",
                                        :type "option",
                                        :full-name-encode "compiler-options/preloads",
                                        :full-name "compiler-options/preloads",
                                        :history [["+" "1.9.85"]]},
           "cljs.core/keys" {:ns "cljs.core",
                             :name "keys",
                             :signature ["[map]"],
                             :name-encode "keys",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/keys",
                             :source {:code "(defn keys\n  [map]\n  (when-let [mseq (seq map)]\n    (KeySeq. mseq nil)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [9245 9249]},
                             :full-name "cljs.core/keys",
                             :docstring "Returns a sequence of the map's keys, in the same order as (seq map)."},
           "cljs.spec.alpha/tuple" {:ns "cljs.spec.alpha",
                                    :name "tuple",
                                    :signature ["[& preds]"],
                                    :name-encode "tuple",
                                    :history [["+" "1.9.542"]],
                                    :type "macro",
                                    :full-name-encode "cljs.spec.alpha/tuple",
                                    :source {:code "(defmacro tuple\n  [& preds]\n  (clojure.core/assert (not (empty? preds)))\n  `(tuple-impl '~(mapv #(res &env %) preds) ~(vec preds)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/spec/alpha.cljc",
                                             :lines [408 414]},
                                    :full-name "cljs.spec.alpha/tuple",
                                    :docstring "takes one or more preds and returns a spec for a tuple, a vector\nwhere each element conforms to the corresponding pred. Each element\nwill be referred to in paths using its ordinal."},
           "cljs.spec.alpha/get-spec" {:ns "cljs.spec.alpha",
                                       :name "get-spec",
                                       :signature ["[k]"],
                                       :name-encode "get-spec",
                                       :history [["+" "1.9.542"]],
                                       :type "function",
                                       :full-name-encode "cljs.spec.alpha/get-spec",
                                       :source {:code "(defn get-spec\n  [k]\n  (get (registry) (if (keyword? k) k (->sym k))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/spec/alpha.cljs",
                                                :lines [330 333]},
                                       :full-name "cljs.spec.alpha/get-spec",
                                       :docstring "Returns spec registered for keyword/symbol/var k, or nil."},
           "cljs.spec.impl.gen/one-of" {:ns "cljs.spec.impl.gen",
                                        :name "one-of",
                                        :signature ["[& args]"],
                                        :name-encode "one-of",
                                        :history [["+" "1.9.14"]
                                                  ["-" "1.9.542"]],
                                        :type "function",
                                        :full-name-encode "cljs.spec.impl.gen/one-of",
                                        :source {:code "(lazy-combinators hash-map list map not-empty set vector vector-distinct fmap elements\n  bind choose one-of such-that tuple sample return\n  large-integer* double* frequency)",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.9.521",
                                                 :filename "src/main/cljs/cljs/spec/impl/gen.cljs",
                                                 :lines [69 71]},
                                        :full-name "cljs.spec.impl.gen/one-of",
                                        :docstring "Lazy loaded version of clojure.test.check.generators/one-of",
                                        :removed {:in "1.9.542",
                                                  :last-seen "1.9.521"}},
           "cljs.repl/eval-cljs" {:ns "cljs.repl",
                                  :name "eval-cljs",
                                  :signature ["[repl-env env form]"
                                              "[repl-env env form opts]"],
                                  :name-encode "eval-cljs",
                                  :history [["+" "1.10.63"]],
                                  :type "function",
                                  :full-name-encode "cljs.repl/eval-cljs",
                                  :source {:code "(defn eval-cljs\n  ([repl-env env form]\n    (eval-cljs repl-env env form *repl-opts*))\n  ([repl-env env form opts]\n   (evaluate-form repl-env\n     (assoc env :ns (ana/get-namespace ana/*cljs-ns*))\n     \"<cljs repl>\"\n     form\n     ;; the pluggability of :wrap is needed for older JS runtimes like Rhino\n     ;; where catching the error will swallow the original trace\n     ((or (:wrap opts) wrap-fn) form)\n     opts)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/clojure/cljs/repl.cljc",
                                           :lines [685 699]},
                                  :full-name "cljs.repl/eval-cljs",
                                  :docstring "Given a REPL evaluation environment, an analysis environment, and a\nform, evaluate the form and return the result. The result is always the value\nrepresented as a string."},
           "compiler-options/closure-output-charset" {:ns "compiler-options",
                                                      :name "closure-output-charset",
                                                      :name-encode "closure-output-charset",
                                                      :type "option",
                                                      :full-name-encode "compiler-options/closure-output-charset",
                                                      :full-name "compiler-options/closure-output-charset",
                                                      :history [["+"
                                                                 "1.8.34"]]},
           "cljs.spec.impl.gen/char-alpha" {:ns "cljs.spec.impl.gen",
                                            :name "char-alpha",
                                            :signature ["[& args]"],
                                            :name-encode "char-alpha",
                                            :history [["+" "1.9.14"]
                                                      ["-" "1.9.542"]],
                                            :type "function",
                                            :full-name-encode "cljs.spec.impl.gen/char-alpha",
                                            :source {:code "(lazy-prims any any-printable boolean char char-alpha char-alphanumeric char-ascii double\n  int keyword keyword-ns large-integer ratio simple-type simple-type-printable\n  string string-ascii string-alphanumeric symbol symbol-ns uuid)",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.9.521",
                                                     :filename "src/main/cljs/cljs/spec/impl/gen.cljs",
                                                     :lines [73 75]},
                                            :full-name "cljs.spec.impl.gen/char-alpha",
                                            :docstring "Fn returning clojure.test.check.generators/char-alpha",
                                            :removed {:in "1.9.542",
                                                      :last-seen "1.9.521"}},
           "cljs.core/unchecked-negate" {:ns "cljs.core",
                                         :name "unchecked-negate",
                                         :signature ["[x]"],
                                         :name-encode "unchecked-negate",
                                         :history [["+" "0.0-1798"]],
                                         :type "function/macro",
                                         :full-name-encode "cljs.core/unchecked-negate",
                                         :source {:code "(defn unchecked-negate [x]\n  (cljs.core/unchecked-negate x))",
                                                  :title "Function code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/cljs/cljs/core.cljs",
                                                  :lines [2856 2857]},
                                         :extra-sources [{:code "(core/defmacro ^::ana/numeric unchecked-negate\n  ([x] `(- ~x)))",
                                                          :title "Macro code",
                                                          :repo "clojurescript",
                                                          :tag "r1.12.38",
                                                          :filename "src/main/clojure/cljs/core.cljc",
                                                          :lines [1104
                                                                  1105]}],
                                         :full-name "cljs.core/unchecked-negate"},
           "cljs.spec/Specize" {:ns "cljs.spec",
                                :name "Specize",
                                :name-encode "Specize",
                                :history [["+" "1.9.456"]
                                          ["-" "1.9.542"]],
                                :type "protocol",
                                :full-name-encode "cljs.spec/Specize",
                                :source {:code "(defprotocol Specize\n  (specize* [_] [_ form]))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.9.521",
                                         :filename "src/main/cljs/cljs/spec.cljs",
                                         :lines [123 124]},
                                :methods [{:name "specize*",
                                           :signature ["[_]"
                                                       "[_ form]"],
                                           :docstring nil}],
                                :full-name "cljs.spec/Specize",
                                :removed {:in "1.9.542",
                                          :last-seen "1.9.521"}},
           "cljs.core/reset!" {:ns "cljs.core",
                               :name "reset!",
                               :signature ["[a new-value]"],
                               :name-encode "resetBANG",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/resetBANG",
                               :source {:code "(defn reset!\n  [a new-value]\n  (if (instance? Atom a)\n    (let [validate (.-validator a)]\n      (when-not (nil? validate)\n        (when-not (validate new-value)\n          (throw (js/Error. \"Validator rejected reference state\"))))\n      (let [old-value (.-state a)]\n        (set! (.-state a) new-value)\n        (when-not (nil? (.-watches a))\n          (-notify-watches a old-value new-value))\n        new-value))\n    (-reset! a new-value)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [4567 4581]},
                               :full-name "cljs.core/reset!",
                               :docstring "Sets the value of atom to newval without regard for the\ncurrent value. Returns new-value."},
           "cljs.spec.alpha/explain" {:ns "cljs.spec.alpha",
                                      :name "explain",
                                      :signature ["[spec x]"],
                                      :name-encode "explain",
                                      :history [["+" "1.9.542"]],
                                      :type "function",
                                      :full-name-encode "cljs.spec.alpha/explain",
                                      :source {:code "(defn explain\n  [spec x]\n  (explain-out (explain-data spec x)))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/spec/alpha.cljs",
                                               :lines [270 273]},
                                      :full-name "cljs.spec.alpha/explain",
                                      :docstring "Given a spec and a value that fails to conform, prints an explanation to *out*."},
           "cljs.core/ITransientCollection" {:ns "cljs.core",
                                             :name "ITransientCollection",
                                             :name-encode "ITransientCollection",
                                             :implementations #{"TransientArrayMap"
                                                                "TransientVector"
                                                                "TransientHashMap"
                                                                "TransientHashSet"},
                                             :history [["+"
                                                        "0.0-1211"]],
                                             :type "protocol",
                                             :full-name-encode "cljs.core/ITransientCollection",
                                             :source {:code "(defprotocol ITransientCollection\n  (^clj -conj! [tcoll val]\n    \"Adds value val to tcoll and returns tcoll.\")\n  (^clj -persistent! [tcoll]\n    \"Creates a persistent data structure from tcoll and returns it.\"))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.12.38",
                                                      :filename "src/main/cljs/cljs/core.cljs",
                                                      :lines [805 810]},
                                             :methods [{:name "-conj!",
                                                        :signature ["[tcoll val]"],
                                                        :docstring "Adds value val to tcoll and returns tcoll."}
                                                       {:name "-persistent!",
                                                        :signature ["[tcoll]"],
                                                        :docstring "Creates a persistent data structure from tcoll and returns it."}],
                                             :full-name "cljs.core/ITransientCollection",
                                             :docstring "Protocol for adding basic functionality to transient collections."},
           "cljs.core/transient" {:ns "cljs.core",
                                  :name "transient",
                                  :signature ["[coll]"],
                                  :name-encode "transient",
                                  :history [["+" "0.0-1211"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/transient",
                                  :source {:code "(defn transient\n  [coll]\n  (-as-transient coll))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [3903 3906]},
                                  :full-name "cljs.core/transient",
                                  :docstring "Returns a new, transient version of the collection, in constant time."},
           "cljs.core/Fn" {:ns "cljs.core",
                           :name "Fn",
                           :name-encode "Fn",
                           :implementations #{"MetaFn"
                                              "function"
                                              "Var"},
                           :history [["+" "0.0-1552"]],
                           :type "protocol",
                           :full-name-encode "cljs.core/Fn",
                           :source {:code "(defprotocol Fn)",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r1.12.38",
                                    :filename "src/main/cljs/cljs/core.cljs",
                                    :lines [553 554]},
                           :full-name "cljs.core/Fn",
                           :docstring "Marker protocol"},
           "clojure.data/EqualityPartition" {:ns "clojure.data",
                                             :name "EqualityPartition",
                                             :name-encode "EqualityPartition",
                                             :history [["+"
                                                        "0.0-1503"]],
                                             :type "protocol",
                                             :full-name-encode "clojure.data/EqualityPartition",
                                             :source {:code "(defprotocol EqualityPartition\n  (equality-partition [x] \"Implementation detail. Subject to change.\"))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.12.38",
                                                      :filename "src/main/cljs/clojure/data.cljs",
                                                      :lines [75 77]},
                                             :methods [{:name "equality-partition",
                                                        :signature ["[x]"],
                                                        :docstring "Implementation detail. Subject to change."}],
                                             :full-name "clojure.data/EqualityPartition",
                                             :docstring "Implementation detail. Subject to change."},
           "cljs.core/ex-message" {:ns "cljs.core",
                                   :name "ex-message",
                                   :signature ["[ex]"],
                                   :name-encode "ex-message",
                                   :history [["+" "0.0-1576"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/ex-message",
                                   :source {:code "(defn ex-message\n  [ex]\n  (when (instance? js/Error ex)\n    (.-message ex)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [11822 11827]},
                                   :full-name "cljs.core/ex-message",
                                   :docstring "Returns the message attached to the given Error / ExceptionInfo object.\nFor non-Errors returns nil."},
           "cljs.core/js-reserved" {:ns "cljs.core",
                                    :name "js-reserved",
                                    :name-encode "js-reserved",
                                    :type "var",
                                    :full-name-encode "cljs.core/js-reserved",
                                    :source {:code "(def\n  ^{:jsdoc [\"@type {null|Object}\"]}\n  js-reserved nil)",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [11965 11967]},
                                    :full-name "cljs.core/js-reserved",
                                    :history [["+" "1.7.10"]]},
           "cljs.repl.nashorn/repl-filename" {:ns "cljs.repl.nashorn",
                                              :name "repl-filename",
                                              :name-encode "repl-filename",
                                              :history [["+"
                                                         "0.0-2814"]
                                                        ["-"
                                                         "1.10.738"]],
                                              :type "var",
                                              :full-name-encode "cljs.repl.nashorn/repl-filename",
                                              :source {:code "(def repl-filename \"<cljs repl>\")",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.10.597",
                                                       :filename "src/main/clojure/cljs/repl/nashorn.clj",
                                                       :lines [102]},
                                              :full-name "cljs.repl.nashorn/repl-filename",
                                              :removed {:in "1.10.738",
                                                        :last-seen "1.10.597"}},
           "cljs.spec.impl.gen/large-integer" {:ns "cljs.spec.impl.gen",
                                               :name "large-integer",
                                               :signature ["[& args]"],
                                               :name-encode "large-integer",
                                               :history [["+"
                                                          "1.9.14"]
                                                         ["-"
                                                          "1.9.542"]],
                                               :type "function",
                                               :full-name-encode "cljs.spec.impl.gen/large-integer",
                                               :source {:code "(lazy-prims any any-printable boolean char char-alpha char-alphanumeric char-ascii double\n  int keyword keyword-ns large-integer ratio simple-type simple-type-printable\n  string string-ascii string-alphanumeric symbol symbol-ns uuid)",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.9.521",
                                                        :filename "src/main/cljs/cljs/spec/impl/gen.cljs",
                                                        :lines [73 75]},
                                               :full-name "cljs.spec.impl.gen/large-integer",
                                               :docstring "Fn returning clojure.test.check.generators/large-integer",
                                               :removed {:in "1.9.542",
                                                         :last-seen "1.9.521"}},
           "cljs.pprint/write-out" {:ns "cljs.pprint",
                                    :name "write-out",
                                    :signature ["[object]"],
                                    :name-encode "write-out",
                                    :history [["+" "0.0-3255"]],
                                    :type "function",
                                    :full-name-encode "cljs.pprint/write-out",
                                    :source {:code "(defn write-out\n  [object]\n  (let [length-reached (and *current-length*\n                            *print-length*\n                            (>= *current-length* *print-length*))]\n    (if-not *print-pretty*\n      (pr object)\n      (if length-reached\n        (-write *out* \"...\") ;;TODO could this (incorrectly) print ... on the next line?\n        (do\n          (if *current-length* (set! *current-length* (inc *current-length*)))\n          (*print-pprint-dispatch* object))))\n    length-reached))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/pprint.cljs",
                                             :lines [727 749]},
                                    :full-name "cljs.pprint/write-out",
                                    :docstring "Write an object to *out* subject to the current bindings of the printer control\nvariables. Use the kw-args argument to override individual variables for this call (and\nany recursive calls).\n\n*out* must be a PrettyWriter if pretty printing is enabled. This is the responsibility\nof the caller.\n\nThis method is primarily intended for use by pretty print dispatch functions that\nalready know that the pretty printer will have set up their environment appropriately.\nNormal library clients should use the standard \"write\" interface. "},
           "repl-options/reader" {:ns "repl-options",
                                  :name "reader",
                                  :name-encode "reader",
                                  :type "option",
                                  :full-name-encode "repl-options/reader",
                                  :full-name "repl-options/reader",
                                  :history [["+" "0.0-2911"]]},
           "cljs.test/test-vars-block" {:ns "cljs.test",
                                        :name "test-vars-block",
                                        :signature ["[vars]"],
                                        :name-encode "test-vars-block",
                                        :history [["+" "0.0-2814"]],
                                        :type "function",
                                        :full-name-encode "cljs.test/test-vars-block",
                                        :source {:code "(defn test-vars-block\n  [vars]\n  (map\n   (fn [[ns vars]]\n     (fn []\n       (block\n        (let [env (get-current-env)\n              once-fixtures (get-in env [:once-fixtures ns])\n              each-fixtures (get-in env [:each-fixtures ns])]\n          (case (execution-strategy once-fixtures each-fixtures)\n            :async\n            (->> vars\n                 (filter (comp :test meta))\n                 (mapcat (comp (partial wrap-map-fixtures each-fixtures)\n                               test-var-block))\n                 (wrap-map-fixtures once-fixtures))\n            :sync\n            (let [each-fixture-fn (join-fixtures each-fixtures)]\n              [(fn []\n                 ((join-fixtures once-fixtures)\n                  (fn []\n                    (doseq [v vars]\n                      (when-let [t (:test (meta v))]\n                        ;; (alter-meta! v update :test disable-async)\n                        (each-fixture-fn\n                         (fn []\n                           ;; (test-var v)\n                           (run-block\n                            (test-var-block* v (disable-async t))))))))))]))))))\n   (group-by (comp :ns meta) vars)))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/cljs/cljs/test.cljs",
                                                 :lines [556 587]},
                                        :full-name "cljs.test/test-vars-block",
                                        :docstring "Like test-vars, but returns a block for further composition and\nlater execution."},
           "cljs.spec.gen.alpha/fmap" {:ns "cljs.spec.gen.alpha",
                                       :name "fmap",
                                       :signature ["[& args]"],
                                       :name-encode "fmap",
                                       :history [["+" "1.9.542"]],
                                       :type "function",
                                       :full-name-encode "cljs.spec.gen.alpha/fmap",
                                       :source {:code "(lazy-combinators hash-map list map not-empty set vector vector-distinct fmap elements\n  bind choose one-of such-that tuple sample return\n  large-integer* double* frequency shuffle)",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/spec/gen/alpha.cljs",
                                                :lines [70 72]},
                                       :full-name "cljs.spec.gen.alpha/fmap",
                                       :docstring "Lazy loaded version of clojure.test.check.generators/fmap"},
           "clojure.set/select" {:ns "clojure.set",
                                 :name "select",
                                 :signature ["[pred xset]"],
                                 :name-encode "select",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "clojure.set/select",
                                 :source {:code "(defn select\n  [pred xset]\n    (reduce (fn [s k] (if (pred k) s (disj s k)))\n            xset xset))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/clojure/set.cljs",
                                          :lines [61 65]},
                                 :full-name "clojure.set/select",
                                 :docstring "Returns a set of the elements for which pred is true"},
           "cljs.core/hash-unordered-coll" {:return-type number,
                                            :ns "cljs.core",
                                            :name "hash-unordered-coll",
                                            :signature ["[coll]"],
                                            :name-encode "hash-unordered-coll",
                                            :history [["+" "0.0-2261"]],
                                            :type "function",
                                            :full-name-encode "cljs.core/hash-unordered-coll",
                                            :source {:code "(defn ^number hash-unordered-coll\n  [coll]\n  (loop [n 0 hash-code 0 coll (seq coll)]\n    (if-not (nil? coll)\n      (recur (inc n) (bit-or (+ hash-code (hash (first coll))) 0) (next coll))\n      (mix-collection-hash hash-code n))))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/cljs/cljs/core.cljs",
                                                     :lines [1390
                                                             1400]},
                                            :full-name "cljs.core/hash-unordered-coll",
                                            :docstring "Returns the hash code, consistent with =, for an external unordered\ncollection implementing Iterable. For maps, the iterator should\nreturn map entries whose hash is computed as\n  (hash-ordered-coll [k v]).\nSee http://clojure.org/data_structures#hash for full algorithms."},
           "cljs.repl.node/create-socket" {:ns "cljs.repl.node",
                                           :name "create-socket",
                                           :signature ["[host port]"],
                                           :name-encode "create-socket",
                                           :history [["+" "1.10.217"]],
                                           :type "function",
                                           :full-name-encode "cljs.repl.node/create-socket",
                                           :source {:code "(defn create-socket [^String host port]\n  (let [socket (Socket. host (int port))\n        in     (io/reader socket)\n        out    (io/writer socket)]\n    {:socket socket :in in :out out}))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/clojure/cljs/repl/node.clj",
                                                    :lines [35 39]},
                                           :full-name "cljs.repl.node/create-socket"},
           "cljs.core/delay" {:ns "cljs.core",
                              :name "delay",
                              :signature ["[& body]"],
                              :name-encode "delay",
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :full-name-encode "cljs.core/delay",
                              :source {:code "(core/defmacro delay\n  [& body]\n  `(new cljs.core/Delay (fn [] ~@body) nil))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/clojure/cljs/core.cljc",
                                       :lines [2250 2256]},
                              :full-name "cljs.core/delay",
                              :docstring "Takes a body of expressions and yields a Delay object that will\ninvoke the body only the first time it is forced (with force or deref/@), and\nwill cache the result and return it on all subsequent force\ncalls."},
           "cljs.core/float" {:return-type number,
                              :ns "cljs.core",
                              :name "float",
                              :signature ["[x]"],
                              :name-encode "float",
                              :history [["+" "0.0-1798"]],
                              :type "function/macro",
                              :full-name-encode "cljs.core/float",
                              :source {:code "(defn ^number float [x] x)",
                                       :title "Function code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [2796]},
                              :extra-sources [{:code "(core/defmacro float [x] x)",
                                               :title "Macro code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/clojure/cljs/core.cljc",
                                               :lines [1068]}],
                              :full-name "cljs.core/float"},
           "compiler-options/infer-externs" {:ns "compiler-options",
                                             :name "infer-externs",
                                             :name-encode "infer-externs",
                                             :type "option",
                                             :full-name-encode "compiler-options/infer-externs",
                                             :full-name "compiler-options/infer-externs",
                                             :history [["+" "1.9.456"]]},
           "cljs.core/bit-not" {:ns "cljs.core",
                                :name "bit-not",
                                :signature ["[x]"],
                                :name-encode "bit-not",
                                :history [["+" "0.0-927"]],
                                :type "function/macro",
                                :full-name-encode "cljs.core/bit-not",
                                :source {:code "(defn bit-not\n  [x] (cljs.core/bit-not x))",
                                         :title "Function code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [2971 2973]},
                                :extra-sources [{:code "(core/defmacro ^::ana/numeric bit-not [x]\n  (core/list 'js* \"(~ ~{})\" x))",
                                                 :title "Macro code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/clojure/cljs/core.cljc",
                                                 :lines [1195 1196]}],
                                :full-name "cljs.core/bit-not",
                                :docstring "Bitwise complement"},
           "cljs.spec/describe" {:ns "cljs.spec",
                                 :name "describe",
                                 :signature ["[spec]"],
                                 :name-encode "describe",
                                 :history [["+" "1.9.14"]
                                           ["-" "1.9.542"]],
                                 :type "function",
                                 :full-name-encode "cljs.spec/describe",
                                 :source {:code "(defn describe\n  [spec]\n  (abbrev (form spec)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.9.521",
                                          :filename "src/main/cljs/cljs/spec.cljs",
                                          :lines [187 190]},
                                 :full-name "cljs.spec/describe",
                                 :docstring "returns an abbreviated description of the spec as data",
                                 :removed {:in "1.9.542",
                                           :last-seen "1.9.521"}},
           "cljs.core/partition" {:ns "cljs.core",
                                  :name "partition",
                                  :signature ["[n coll]"
                                              "[n step coll]"
                                              "[n step pad coll]"],
                                  :name-encode "partition",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/partition",
                                  :source {:code "(defn partition\n  ([n coll]\n     (partition n n coll))\n  ([n step coll]\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (let [p (take n s)]\n           (when (== n (count p))\n             (cons p (partition n step (drop step s))))))))\n  ([n step pad coll]\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (let [p (take n s)]\n           (if (== n (count p))\n             (cons p (partition n step pad (drop step s)))\n             (list (take n (concat p pad)))))))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [5381 5401]},
                                  :full-name "cljs.core/partition",
                                  :docstring "Returns a lazy sequence of lists of n items each, at offsets step\napart. If step is not supplied, defaults to n, i.e. the partitions\ndo not overlap. If a pad collection is supplied, use its elements as\nnecessary to complete last partition up to n items. In case there are\nnot enough padding elements, return a partition with less than n items."},
           "cljs.core/IEncodeJS" {:ns "cljs.core",
                                  :name "IEncodeJS",
                                  :name-encode "IEncodeJS",
                                  :history [["+" "0.0-1552"]],
                                  :type "protocol",
                                  :full-name-encode "cljs.core/IEncodeJS",
                                  :source {:code "(defprotocol IEncodeJS\n  (-clj->js [x] \"Recursively transforms clj values to JavaScript\")\n  (-key->js [x] \"Transforms map keys to valid JavaScript keys. Arbitrary keys are\n  encoded to their string representation via (pr-str x)\"))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [11156 11159]},
                                  :methods [{:name "-clj->js",
                                             :signature ["[x]"],
                                             :docstring "Recursively transforms clj values to JavaScript"}
                                            {:name "-key->js",
                                             :signature ["[x]"],
                                             :docstring "Transforms map keys to valid JavaScript keys. Arbitrary keys are\n  encoded to their string representation via (pr-str x)"}],
                                  :full-name "cljs.core/IEncodeJS"},
           "cljs.core/parents" {:ns "cljs.core",
                                :name "parents",
                                :signature ["[tag]" "[h tag]"],
                                :name-encode "parents",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/parents",
                                :source {:code "(defn parents\n  ([tag] (parents @(get-global-hierarchy) tag))\n  ([h tag] (not-empty (get (:parents h) tag))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [11337 11343]},
                                :full-name "cljs.core/parents",
                                :docstring "Returns the immediate parents of tag, either via a JavaScript type\ninheritance relationship or a relationship established via derive. h\nmust be a hierarchy obtained from make-hierarchy, if not supplied\ndefaults to the global hierarchy"},
           "cljs.core/aclone" {:ns "cljs.core",
                               :name "aclone",
                               :signature ["[arr]"],
                               :name-encode "aclone",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/aclone",
                               :source {:code "(defn aclone\n  [arr]\n  (let [len (alength arr)\n        new-arr (make-array len)]\n    (dotimes [i len]\n      (aset new-arr i (aget arr i)))\n    new-arr))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [438 445]},
                               :full-name "cljs.core/aclone",
                               :docstring "Returns a javascript array, cloned from the passed in array"},
           "cljs.core/reset-meta!" {:ns "cljs.core",
                                    :name "reset-meta!",
                                    :signature ["[iref m]"],
                                    :name-encode "reset-metaBANG",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/reset-metaBANG",
                                    :source {:code "(defn reset-meta!\n  [iref m]\n  (set! (.-meta iref) m))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [10911 10914]},
                                    :full-name "cljs.core/reset-meta!",
                                    :docstring "Atomically resets the metadata for an atom"},
           "cljs.core/IReset" {:ns "cljs.core",
                               :name "IReset",
                               :name-encode "IReset",
                               :history [["+" "0.0-2173"]],
                               :type "protocol",
                               :full-name-encode "cljs.core/IReset",
                               :source {:code "(defprotocol IReset\n  (-reset! [o new-value]\n    \"Sets the value of o to new-value.\"))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [868 871]},
                               :methods [{:name "-reset!",
                                          :signature ["[o new-value]"],
                                          :docstring "Sets the value of o to new-value."}],
                               :full-name "cljs.core/IReset",
                               :docstring "Protocol for adding resetting functionality."},
           "cljs.spec.test.alpha/enumerate-namespace" {:ns "cljs.spec.test.alpha",
                                                       :name "enumerate-namespace",
                                                       :signature ["[ns-sym-or-syms]"],
                                                       :name-encode "enumerate-namespace",
                                                       :history [["+"
                                                                  "1.10.439"]],
                                                       :type "macro",
                                                       :full-name-encode "cljs.spec.test.alpha/enumerate-namespace",
                                                       :source {:code "(defmacro enumerate-namespace\n  [ns-sym-or-syms]\n  `'~(enumerate-namespace* (eval ns-sym-or-syms)))",
                                                                :title "Source code",
                                                                :repo "clojurescript",
                                                                :tag "r1.12.38",
                                                                :filename "src/main/cljs/cljs/spec/test/alpha.cljc",
                                                                :lines [36
                                                                        40]},
                                                       :full-name "cljs.spec.test.alpha/enumerate-namespace",
                                                       :docstring "Given a symbol naming an ns, or a collection of such symbols,\nreturns the set of all symbols naming vars in those nses."},
           "cljs.core/NaN?" {:return-type boolean,
                             :ns "cljs.core",
                             :name "NaN?",
                             :signature ["[val]"],
                             :name-encode "NaNQMARK",
                             :history [["+" "1.11.50"]],
                             :type "function",
                             :full-name-encode "cljs.core/NaNQMARK",
                             :source {:code "(defn ^boolean NaN?\n  [val]\n  (js/isNaN val))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [12230 12233]},
                             :full-name "cljs.core/NaN?",
                             :docstring "Returns true if num is NaN, else false"},
           "cljs.spec.alpha/spec" {:ns "cljs.spec.alpha",
                                   :name "spec",
                                   :signature ["[form & {:keys [gen]}]"],
                                   :name-encode "spec",
                                   :history [["+" "1.9.542"]],
                                   :type "macro",
                                   :full-name-encode "cljs.spec.alpha/spec",
                                   :source {:code "(defmacro spec\n  [form & {:keys [gen]}]\n  (when form\n    `(spec-impl '~(res &env form) ~form ~gen nil)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/spec/alpha.cljc",
                                            :lines [87 104]},
                                   :full-name "cljs.spec.alpha/spec",
                                   :docstring "Takes a single predicate form, e.g. can be the name of a predicate,\nlike even?, or a fn literal like #(< % 42). Note that it is not\ngenerally necessary to wrap predicates in spec when using the rest\nof the spec macros, only to attach a unique generator\n\nCan also be passed the result of one of the regex ops -\ncat, alt, *, +, ?, in which case it will return a regex-conforming\nspec, useful when nesting an independent regex.\n---\n\nOptionally takes :gen generator-fn, which must be a fn of no args that\nreturns a test.check generator.\n\nReturns a spec."},
           "warnings/invoke-ctor" {:ns "warnings",
                                   :name "invoke-ctor",
                                   :name-encode "invoke-ctor",
                                   :type "warning",
                                   :full-name-encode "warnings/invoke-ctor",
                                   :full-name "warnings/invoke-ctor",
                                   :history [["+" "0.0-2060"]]},
           "cljs.core/Box" {:ns "cljs.core",
                            :name "Box",
                            :signature ["[val]"],
                            :name-encode "Box",
                            :history [["+" "0.0-1424"]],
                            :type "type",
                            :full-name-encode "cljs.core/Box",
                            :source {:code "(deftype Box [^:mutable val])",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [7364]},
                            :full-name "cljs.core/Box"},
           "cljs.pprint/cl-format" {:ns "cljs.pprint",
                                    :name "cl-format",
                                    :signature ["[writer format-in & args]"],
                                    :name-encode "cl-format",
                                    :history [["+" "0.0-3255"]],
                                    :type "function",
                                    :full-name-encode "cljs.pprint/cl-format",
                                    :source {:code "(defn cl-format\n  {:see-also [[\"http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html#SECTION002633000000000000000\"\n               \"Common Lisp the Language\"]\n              [\"http://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm\"\n               \"Common Lisp HyperSpec\"]]}\n  [writer format-in & args]\n  (let [compiled-format (if (string? format-in) (compile-format format-in) format-in)\n        navigator (init-navigator args)]\n    (execute-format writer compiled-format navigator)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/pprint.cljs",
                                             :lines [896 931]},
                                    :full-name "cljs.pprint/cl-format",
                                    :docstring "An implementation of a Common Lisp compatible format function. cl-format formats its\narguments to an output stream or string based on the format control string given. It\nsupports sophisticated formatting of structured data.\n\nWriter satisfies IWriter, true to output via *print-fn* or nil to output\nto a string, format-in is the format control string and the remaining arguments\nare the data to be formatted.\n\nThe format control string is a string to be output with embedded 'format directives'\ndescribing how to format the various arguments passed in.\n\nIf writer is nil, cl-format returns the formatted result string. Otherwise, cl-format\nreturns nil.\n\nFor example:\n (let [results [46 38 22]]\n        (cl-format true \"There ~[are~;is~:;are~]~:* ~d result~:p: ~{~d~^, ~}~%\"\n                   (count results) results))\n\nPrints via *print-fn*:\n There are 3 results: 46, 38, 22\n\nDetailed documentation on format control strings is available in the \"Common Lisp the\nLanguage, 2nd edition\", Chapter 22 (available online at:\nhttp://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html#SECTION002633000000000000000)\nand in the Common Lisp HyperSpec at\nhttp://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm"},
           "cljs.core/tagged-literal?" {:ns "cljs.core",
                                        :name "tagged-literal?",
                                        :signature ["[value]"],
                                        :name-encode "tagged-literalQMARK",
                                        :history [["+" "0.0-3255"]],
                                        :type "function",
                                        :full-name-encode "cljs.core/tagged-literalQMARK",
                                        :source {:code "(defn tagged-literal?\n  [value]\n  (instance? TaggedLiteral value))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/cljs/cljs/core.cljs",
                                                 :lines [11935 11938]},
                                        :full-name "cljs.core/tagged-literal?",
                                        :docstring "Return true if the value is the data representation of a tagged literal"},
           "cljs.reader/dispatch-macros" {:ns "cljs.reader",
                                          :name "dispatch-macros",
                                          :signature ["[s]"],
                                          :name-encode "dispatch-macros",
                                          :history [["+" "0.0-927"]
                                                    ["-" "1.9.854"]],
                                          :type "function",
                                          :full-name-encode "cljs.reader/dispatch-macros",
                                          :source {:code "(defn dispatch-macros [s]\n  (cond\n   (identical? s \"{\") read-set\n   (identical? s \"<\") (throwing-reader \"Unreadable form\")\n   (identical? s \"\\\"\") read-regex\n   (identical? s\"!\") read-comment\n   (identical? s \"_\") read-discard\n   :else nil))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.9.671",
                                                   :filename "src/main/cljs/cljs/reader.cljs",
                                                   :lines [443 450]},
                                          :full-name "cljs.reader/dispatch-macros",
                                          :removed {:in "1.9.854",
                                                    :last-seen "1.9.671"}},
           "cljs.core/demunge" {:ns "cljs.core",
                                :name "demunge",
                                :signature ["[name]"],
                                :name-encode "demunge",
                                :history [["+" "1.7.10"]],
                                :type "function",
                                :full-name-encode "cljs.core/demunge",
                                :source {:code "(defn demunge [name]\n  ((if (symbol? name) symbol str)\n    (let [name' (str name)]\n      (if (identical? name' \"_DOT__DOT_\")\n        \"..\"\n        (demunge-str name')))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [12031 12036]},
                                :full-name "cljs.core/demunge"},
           "closure-warnings/externs-validation" {:ns "closure-warnings",
                                                  :name "externs-validation",
                                                  :name-encode "externs-validation",
                                                  :type "warning",
                                                  :full-name-encode "closure-warnings/externs-validation",
                                                  :full-name "closure-warnings/externs-validation",
                                                  :history [["+"
                                                             "0.0-2120"]]},
           "cljs.repl/file-display" {:ns "cljs.repl",
                                     :name "file-display",
                                     :signature ["[file {:keys [output-dir temp-output-dir?]}]"],
                                     :name-encode "file-display",
                                     :history [["+" "1.10.145"]],
                                     :type "function",
                                     :full-name-encode "cljs.repl/file-display",
                                     :source {:code "(defn file-display\n  [file {:keys [output-dir temp-output-dir?]}]\n  (if temp-output-dir?\n    (let [canonicalize (fn [file] (.getCanonicalPath (io/file file)))\n          can-file (canonicalize file)\n          can-out (canonicalize output-dir)]\n      (if (.startsWith can-file can-out)\n        (subs can-file (inc (count can-out)))\n        (subs can-file (inc (.lastIndexOf can-file java.io.File/separator)))))\n    file))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/clojure/cljs/repl.cljc",
                                              :lines [394 403]},
                                     :full-name "cljs.repl/file-display"},
           "cljs.spec.impl.gen/such-that" {:ns "cljs.spec.impl.gen",
                                           :name "such-that",
                                           :signature ["[& args]"],
                                           :name-encode "such-that",
                                           :history [["+" "1.9.14"]
                                                     ["-" "1.9.542"]],
                                           :type "function",
                                           :full-name-encode "cljs.spec.impl.gen/such-that",
                                           :source {:code "(lazy-combinators hash-map list map not-empty set vector vector-distinct fmap elements\n  bind choose one-of such-that tuple sample return\n  large-integer* double* frequency)",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.9.521",
                                                    :filename "src/main/cljs/cljs/spec/impl/gen.cljs",
                                                    :lines [69 71]},
                                           :full-name "cljs.spec.impl.gen/such-that",
                                           :docstring "Lazy loaded version of clojure.test.check.generators/such-that",
                                           :removed {:in "1.9.542",
                                                     :last-seen "1.9.521"}},
           "cljs.pprint/get-pretty-writer" {:ns "cljs.pprint",
                                            :name "get-pretty-writer",
                                            :signature ["[writer]"],
                                            :name-encode "get-pretty-writer",
                                            :history [["+" "0.0-3255"]],
                                            :type "function",
                                            :full-name-encode "cljs.pprint/get-pretty-writer",
                                            :source {:code "(defn get-pretty-writer\n  [writer]\n  (if (pretty-writer? writer)\n    writer\n    (pretty-writer writer *print-right-margin* *print-miser-width*)))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/cljs/cljs/pprint.cljs",
                                                     :lines [2055
                                                             2090]},
                                            :full-name "cljs.pprint/get-pretty-writer",
                                            :docstring "Returns the IWriter passed in wrapped in a pretty writer proxy, unless it's\nalready a pretty writer. Generally, it is unnecessary to call this function, since pprint,\nwrite, and cl-format all call it if they need to. However if you want the state to be\npreserved across calls, you will want to wrap them with this.\n\nFor example, when you want to generate column-aware output with multiple calls to cl-format,\ndo it like in this example:\n\n    (defn print-table [aseq column-width]\n      (binding [*out* (get-pretty-writer *out*)]\n        (doseq [row aseq]\n          (doseq [col row]\n            (cl-format true \"~4D~7,vT\" col column-width))\n          (prn))))\n\nNow when you run:\n\n    user> (print-table (map #(vector % (* % %) (* % % %)) (range 1 11)) 8)\n\nIt prints a table of squares and cubes for the numbers from 1 to 10:\n\n       1      1       1\n       2      4       8\n       3      9      27\n       4     16      64\n       5     25     125\n       6     36     216\n       7     49     343\n       8     64     512\n       9     81     729\n      10    100    1000"},
           "cljs.spec.alpha/conformer" {:ns "cljs.spec.alpha",
                                        :name "conformer",
                                        :signature ["[f]" "[f unf]"],
                                        :name-encode "conformer",
                                        :history [["+" "1.9.542"]],
                                        :type "macro",
                                        :full-name-encode "cljs.spec.alpha/conformer",
                                        :source {:code "(defmacro conformer\n  ([f] `(spec-impl '(conformer ~(res &env f)) ~f nil true))\n  ([f unf] `(spec-impl '(conformer ~(res &env f) ~(res &env unf)) ~f nil true ~unf)))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/cljs/cljs/spec/alpha.cljc",
                                                 :lines [380 386]},
                                        :full-name "cljs.spec.alpha/conformer",
                                        :docstring "takes a predicate function with the semantics of conform i.e. it should return either a\n(possibly converted) value or :cljs.spec.alpha/invalid, and returns a\nspec that uses it as a predicate/conformer. Optionally takes a\nsecond fn that does unform of result of first"},
           "cljs.repl.rhino/current-repl-env" {:ns "cljs.repl.rhino",
                                               :name "current-repl-env",
                                               :name-encode "current-repl-env",
                                               :history [["+"
                                                          "0.0-927"]
                                                         ["-"
                                                          "0.0-2629"]],
                                               :type "var",
                                               :full-name-encode "cljs.repl.rhino/current-repl-env",
                                               :source {:code "(def current-repl-env (atom nil))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r2511",
                                                        :filename "src/clj/cljs/repl/rhino.clj",
                                                        :lines [18]},
                                               :full-name "cljs.repl.rhino/current-repl-env",
                                               :removed {:in "0.0-2629",
                                                         :last-seen "0.0-2511"}},
           "cljs.core/int-rotate-left" {:return-type number,
                                        :ns "cljs.core",
                                        :name "int-rotate-left",
                                        :signature ["[x n]"],
                                        :name-encode "int-rotate-left",
                                        :history [["+" "0.0-2261"]],
                                        :type "function",
                                        :full-name-encode "cljs.core/int-rotate-left",
                                        :source {:code "(defn ^number int-rotate-left [x n]\n  (bit-or\n    (bit-shift-left x n)\n    (unsigned-bit-shift-right x (- n))))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/cljs/cljs/core.cljs",
                                                 :lines [917 920]},
                                        :full-name "cljs.core/int-rotate-left"},
           "cljs.core/ICollection" {:ns "cljs.core",
                                    :name "ICollection",
                                    :name-encode "ICollection",
                                    :implementations #{"Subvec"
                                                       "Cycle"
                                                       "PersistentQueue"
                                                       "PersistentHashMap"
                                                       "PersistentTreeSet"
                                                       "PersistentArrayMapSeq"
                                                       "RedNode"
                                                       "EmptyList"
                                                       "ObjMap"
                                                       "Iterate"
                                                       "BlackNode"
                                                       "PersistentVector"
                                                       "ValSeq"
                                                       "IntegerRange"
                                                       "ChunkedCons"
                                                       "Range"
                                                       "PersistentQueueSeq"
                                                       "ChunkedSeq"
                                                       "ArrayNodeSeq"
                                                       "KeySeq"
                                                       "IndexedSeq"
                                                       "PersistentTreeMap"
                                                       "PersistentTreeMapSeq"
                                                       "RSeq"
                                                       "PersistentArrayMap"
                                                       "PersistentHashSet"
                                                       "NodeSeq"
                                                       "List"
                                                       "Repeat"
                                                       "Cons"
                                                       "LazySeq"
                                                       "MapEntry"},
                                    :history [["+" "0.0-927"]],
                                    :type "protocol",
                                    :full-name-encode "cljs.core/ICollection",
                                    :source {:code "(defprotocol ICollection\n  (^clj -conj [coll o]\n    \"Returns a new collection of coll with o added to it. The new item\n     should be added to the most efficient place, e.g.\n     (conj [1 2 3 4] 5) => [1 2 3 4 5]\n     (conj '(2 3 4 5) 1) => '(1 2 3 4 5)\"))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [600 606]},
                                    :methods [{:name "-conj",
                                               :signature ["[coll o]"],
                                               :docstring "Returns a new collection of coll with o added to it. The new item\n     should be added to the most efficient place, e.g.\n     (conj [1 2 3 4] 5) => [1 2 3 4 5]\n     (conj '(2 3 4 5) 1) => '(1 2 3 4 5)"}],
                                    :full-name "cljs.core/ICollection",
                                    :docstring "Protocol for adding to a collection."},
           "cljs.build.api/cljs-dependents-for-macro-namespaces" {:ns "cljs.build.api",
                                                                  :name "cljs-dependents-for-macro-namespaces",
                                                                  :signature ["[namespaces]"
                                                                              "[state namespaces]"],
                                                                  :name-encode "cljs-dependents-for-macro-namespaces",
                                                                  :history [["+"
                                                                             "0.0-2496"]],
                                                                  :type "function",
                                                                  :full-name-encode "cljs.build.api/cljs-dependents-for-macro-namespaces",
                                                                  :source {:code "(defn cljs-dependents-for-macro-namespaces\n  ([namespaces]\n   (closure/cljs-dependents-for-macro-namespaces\n     (or (ana-api/current-state) (ana-api/empty-state)) namespaces))\n  ([state namespaces]\n   (closure/cljs-dependents-for-macro-namespaces state namespaces)))",
                                                                           :title "Source code",
                                                                           :repo "clojurescript",
                                                                           :tag "r1.12.38",
                                                                           :filename "src/main/clojure/cljs/build/api.clj",
                                                                           :lines [42
                                                                                   57]},
                                                                  :full-name "cljs.build.api/cljs-dependents-for-macro-namespaces",
                                                                  :docstring "Takes a list of Clojure (.clj) namespaces that define macros and\nreturns a list ClojureScript (.cljs) namespaces that depend on those macro\nnamespaces.\n\nFor example where example.macros is defined in the clojure file\n\"example/macros.clj\" and both 'example.core and 'example.util are\nClojureScript namespaces that require and use the macros from\n'example.macros :\n(cljs-dependents-for-macro-namespaces 'example.macros) ->\n('example.core 'example.util)"},
           "warnings/redef" {:ns "warnings",
                             :name "redef",
                             :name-encode "redef",
                             :type "warning",
                             :full-name-encode "warnings/redef",
                             :full-name "warnings/redef",
                             :history [["+" "0.0-1835"]]},
           "cljs.math/E" {:return-type number,
                          :ns "cljs.math",
                          :name "E",
                          :name-encode "E",
                          :history [["+" "1.11.50"]],
                          :type "var",
                          :full-name-encode "cljs.math/E",
                          :source {:code "(def\n  ^{:added \"1.11.10\"\n    :tag number\n    :const true} E Math/E)",
                                   :title "Source code",
                                   :repo "clojurescript",
                                   :tag "r1.12.38",
                                   :filename "src/main/cljs/cljs/math.cljs",
                                   :lines [5 10]},
                          :full-name "cljs.math/E",
                          :docstring "Constant for Euler's number e, the base for natural logarithms.\nSee: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/E"},
           "cljs.core/every?" {:ns "cljs.core",
                               :name "every?",
                               :signature ["[pred coll]"],
                               :name-encode "everyQMARK",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/everyQMARK",
                               :source {:code "(defn every?\n  [pred coll]\n  (cond\n   (nil? (seq coll)) true\n   (pred (first coll)) (recur pred (next coll))\n   :else false))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [4322 4329]},
                               :full-name "cljs.core/every?",
                               :docstring "Returns true if (pred x) is logical true for every x in coll, else\nfalse."},
           "cljs.repl/evaluate" {:ns "cljs.repl",
                                 :name "evaluate",
                                 :signature ["[repl-env filename line js]"],
                                 :name-encode "evaluate",
                                 :history [["+" "1.10.63"]],
                                 :type "function",
                                 :full-name-encode "cljs.repl/evaluate",
                                 :source {:code "(defn evaluate [repl-env filename line js]\n  (-evaluate repl-env filename line js))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/clojure/cljs/repl.cljc",
                                          :lines [130 131]},
                                 :full-name "cljs.repl/evaluate"},
           "clojure.zip/node" {:ns "clojure.zip",
                               :name "node",
                               :signature ["[loc]"],
                               :name-encode "node",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip/node",
                               :source {:code "(defn node\n  [loc] (loc 0))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/clojure/zip.cljs",
                                        :lines [60 62]},
                               :full-name "clojure.zip/node",
                               :docstring "Returns the node at loc"},
           "cljs.spec/*compile-asserts*" {:ns "cljs.spec",
                                          :name "*compile-asserts*",
                                          :name-encode "STARcompile-assertsSTAR",
                                          :history [["+" "1.9.216"]
                                                    ["-" "1.9.542"]],
                                          :type "dynamic var",
                                          :full-name-encode "cljs.spec/STARcompile-assertsSTAR",
                                          :source {:code "(defonce\n  ^{:dynamic true\n    :doc \"If true, compiler will enable spec asserts, which are then\nsubject to runtime control via check-asserts? If false, compiler\nwill eliminate all spec assert overhead. See 'assert'.\nInitially set to the negation of the ':elide-asserts' compiler option.\nDefaults to true.\"}\n  *compile-asserts*\n  (s/init-compile-asserts))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.9.521",
                                                   :filename "src/main/cljs/cljs/spec.cljs",
                                                   :lines [1408 1416]},
                                          :full-name "cljs.spec/*compile-asserts*",
                                          :docstring "If true, compiler will enable spec asserts, which are then\nsubject to runtime control via check-asserts? If false, compiler\nwill eliminate all spec assert overhead. See 'assert'.\nInitially set to the negation of the ':elide-asserts' compiler option.\nDefaults to true.",
                                          :removed {:in "1.9.542",
                                                    :last-seen "1.9.521"}},
           "cljs.core/RecordIter" {:ns "cljs.core",
                                   :name "RecordIter",
                                   :signature ["[i record base-count fields ext-map-iter]"],
                                   :name-encode "RecordIter",
                                   :history [["+" "1.7.28"]],
                                   :type "type",
                                   :full-name-encode "cljs.core/RecordIter",
                                   :source {:code "(deftype RecordIter [^:mutable i record base-count fields ext-map-iter]\n  Object\n  (hasNext [_]\n    (or (< i base-count) (.hasNext ext-map-iter)))\n  (next [_]\n    (if (< i base-count)\n      (let [k (nth fields i)]\n        (set! i (inc i))\n        (MapEntry. k (-lookup record k) nil))\n      (.next ext-map-iter)))\n  (remove [_] (js/Error. \"Unsupported operation\")))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [6675 6685]},
                                   :full-name "cljs.core/RecordIter"},
           "cljs.core/unchecked-set" {:ns "cljs.core",
                                      :name "unchecked-set",
                                      :signature ["[obj key val]"],
                                      :name-encode "unchecked-set",
                                      :history [["+" "1.9.854"]],
                                      :type "macro",
                                      :full-name-encode "cljs.core/unchecked-set",
                                      :source {:code "(core/defmacro unchecked-set\n  [obj key val]\n  (core/list 'js* \"(~{}[~{}] = ~{})\" obj key val))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/clojure/cljs/core.cljc",
                                               :lines [1053 1058]},
                                      :full-name "cljs.core/unchecked-set",
                                      :docstring "INTERNAL. Compiles to JavaScript property access using bracket notation. Does\nnot distinguish between object and array types and not subject to compiler\nstatic analysis."},
           "clojure.string/index-of" {:ns "clojure.string",
                                      :name "index-of",
                                      :signature ["[s value]"
                                                  "[s value from-index]"],
                                      :name-encode "index-of",
                                      :history [["+" "1.7.145"]],
                                      :type "function",
                                      :full-name-encode "clojure.string/index-of",
                                      :source {:code "(defn index-of\n  ([s value]\n   (let [result (.indexOf s value)]\n     (if (neg? result)\n       nil\n       result)))\n  ([s value from-index]\n   (let [result (.indexOf s value from-index)]\n     (if (neg? result)\n       nil\n       result))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/clojure/string.cljs",
                                               :lines [249 261]},
                                      :full-name "clojure.string/index-of",
                                      :docstring "Return index of value (string or char) in s, optionally searching\nforward from from-index or nil if not found."},
           "cljs.spec.impl.gen/list" {:ns "cljs.spec.impl.gen",
                                      :name "list",
                                      :signature ["[& args]"],
                                      :name-encode "list",
                                      :history [["+" "1.9.14"]
                                                ["-" "1.9.542"]],
                                      :type "function",
                                      :full-name-encode "cljs.spec.impl.gen/list",
                                      :source {:code "(lazy-combinators hash-map list map not-empty set vector vector-distinct fmap elements\n  bind choose one-of such-that tuple sample return\n  large-integer* double* frequency)",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.9.521",
                                               :filename "src/main/cljs/cljs/spec/impl/gen.cljs",
                                               :lines [69 71]},
                                      :full-name "cljs.spec.impl.gen/list",
                                      :docstring "Lazy loaded version of clojure.test.check.generators/list",
                                      :removed {:in "1.9.542",
                                                :last-seen "1.9.521"}},
           "cljs.core/IEmptyableCollection" {:ns "cljs.core",
                                             :name "IEmptyableCollection",
                                             :name-encode "IEmptyableCollection",
                                             :implementations #{"Subvec"
                                                                "Cycle"
                                                                "PersistentQueue"
                                                                "PersistentHashMap"
                                                                "PersistentTreeSet"
                                                                "PersistentArrayMapSeq"
                                                                "RedNode"
                                                                "EmptyList"
                                                                "ObjMap"
                                                                "Iterate"
                                                                "BlackNode"
                                                                "PersistentVector"
                                                                "ValSeq"
                                                                "IntegerRange"
                                                                "ChunkedCons"
                                                                "Range"
                                                                "PersistentQueueSeq"
                                                                "ChunkedSeq"
                                                                "ArrayNodeSeq"
                                                                "KeySeq"
                                                                "IndexedSeq"
                                                                "PersistentTreeMap"
                                                                "PersistentTreeMapSeq"
                                                                "RSeq"
                                                                "PersistentArrayMap"
                                                                "PersistentHashSet"
                                                                "NodeSeq"
                                                                "List"
                                                                "Repeat"
                                                                "Cons"
                                                                "LazySeq"
                                                                "MapEntry"},
                                             :history [["+" "0.0-927"]],
                                             :type "protocol",
                                             :full-name-encode "cljs.core/IEmptyableCollection",
                                             :source {:code "(defprotocol IEmptyableCollection\n  (-empty [coll]\n    \"Returns an empty collection of the same category as coll. Used\n     by cljs.core/empty.\"))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.12.38",
                                                      :filename "src/main/cljs/cljs/core.cljs",
                                                      :lines [594 598]},
                                             :methods [{:name "-empty",
                                                        :signature ["[coll]"],
                                                        :docstring "Returns an empty collection of the same category as coll. Used\n     by cljs.core/empty."}],
                                             :full-name "cljs.core/IEmptyableCollection",
                                             :docstring "Protocol for creating an empty collection."},
           "clojure.zip/right" {:ns "clojure.zip",
                                :name "right",
                                :signature ["[loc]"],
                                :name-encode "right",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "clojure.zip/right",
                                :source {:code "(defn right\n  [loc]\n    (let [[node {l :l  [r & rnext :as rs] :r :as path}] loc]\n      (when (and path rs)\n        (with-meta [r (assoc path :l (conj l node) :r rnext)] (meta loc)))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/clojure/zip.cljs",
                                         :lines [135 140]},
                                :full-name "clojure.zip/right",
                                :docstring "Returns the loc of the right sibling of the node at this loc, or nil"},
           "warnings/preamble-missing" {:ns "warnings",
                                        :name "preamble-missing",
                                        :name-encode "preamble-missing",
                                        :type "warning",
                                        :full-name-encode "warnings/preamble-missing",
                                        :full-name "warnings/preamble-missing",
                                        :history [["+" "0.0-2371"]]},
           "compiler-options/watch-error-fn" {:ns "compiler-options",
                                              :name "watch-error-fn",
                                              :name-encode "watch-error-fn",
                                              :type "option",
                                              :full-name-encode "compiler-options/watch-error-fn",
                                              :full-name "compiler-options/watch-error-fn",
                                              :history [["+"
                                                         "1.9.456"]]},
           "cljs.core/int-array" {:ns "cljs.core",
                                  :name "int-array",
                                  :signature ["[size-or-seq]"
                                              "[size init-val-or-seq]"],
                                  :name-encode "int-array",
                                  :history [["+" "0.0-1798"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/int-array",
                                  :source {:code "(defn int-array\n  ([size-or-seq]\n     (if (number? size-or-seq)\n       (int-array size-or-seq nil)\n       (into-array size-or-seq)))\n  ([size init-val-or-seq]\n     (let [a (make-array size)]\n       (if (seq? init-val-or-seq)\n         (let [s (seq init-val-or-seq)]\n           (loop [i 0 s s]\n             (if (and s (< i size))\n               (do\n                 (aset a i (first s))\n                 (recur (inc i) (next s)))\n               a)))\n         (do\n           (dotimes [i size]\n             (aset a i init-val-or-seq))\n           a)))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [3756 3776]},
                                  :full-name "cljs.core/int-array",
                                  :docstring "Creates an array of ints. Does not coerce array, provided for compatibility\nwith Clojure."},
           "cljs.core/LazyTransformer.createMulti" {:ns "cljs.core",
                                                    :name "LazyTransformer.createMulti",
                                                    :signature ["[xform colls]"],
                                                    :name-encode "LazyTransformerDOTcreateMulti",
                                                    :history [["+"
                                                               "0.0-2301"]
                                                              ["-"
                                                               "1.9.562"]],
                                                    :parent-type "LazyTransformer",
                                                    :type "function",
                                                    :full-name-encode "cljs.core/LazyTransformerDOTcreateMulti",
                                                    :source {:code "(set! (.-createMulti LazyTransformer)\n  (fn [xform colls]\n    (let [iters (array)]\n      (doseq [coll colls]\n        (.push iters (iter coll)))\n      (LazyTransformer.\n        (multi-stepper xform iters (make-array (alength iters)))\n        nil nil nil))))",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r1.9.542",
                                                             :filename "src/main/cljs/cljs/core.cljs",
                                                             :lines [4030
                                                                     4037]},
                                                    :full-name "cljs.core/LazyTransformer.createMulti",
                                                    :removed {:in "1.9.562",
                                                              :last-seen "1.9.542"}},
           "cljs.core/==" {:return-type boolean,
                           :ns "cljs.core",
                           :name "==",
                           :signature ["[x]" "[x y]" "[x y & more]"],
                           :name-encode "EQEQ",
                           :history [["+" "0.0-927"]],
                           :type "function/macro",
                           :full-name-encode "cljs.core/EQEQ",
                           :source {:code "(defn ^boolean ==\n  ([x] true)\n  ([x y] (-equiv x y))\n  ([x y & more]\n   (if (== x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (== y (first more)))\n     false)))",
                                    :title "Function code",
                                    :repo "clojurescript",
                                    :tag "r1.12.38",
                                    :filename "src/main/cljs/cljs/core.cljs",
                                    :lines [3008 3019]},
                           :extra-sources [{:code "(core/defmacro ^::ana/numeric ==\n  ([x] true)\n  ([x y] (bool-expr (core/list 'js* \"(~{} === ~{})\" x y)))\n  ([x y & more] `(and (== ~x ~y) (== ~y ~@more))))",
                                            :title "Macro code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/clojure/cljs/core.cljc",
                                            :lines [1160 1163]}],
                           :full-name "cljs.core/==",
                           :docstring "Returns non-nil if nums all have the equivalent\nvalue, otherwise false. Behavior on non nums is\nundefined."},
           "cljs.build.api/build" {:ns "cljs.build.api",
                                   :name "build",
                                   :signature ["[opts]"
                                               "[source opts]"
                                               "[source opts compiler-env]"],
                                   :name-encode "build",
                                   :history [["+" "0.0-3208"]],
                                   :type "function",
                                   :full-name-encode "cljs.build.api/build",
                                   :source {:code "(defn build\n  ([opts]\n   (build nil opts))\n  ([source opts]\n   (build source opts\n     (or\n       (ana-api/current-state)\n       (ana-api/empty-state\n         ;; need to dissoc :foreign-libs since we won't know what overriding\n         ;; foreign libspecs are referring to until after add-implicit-options\n         ;; - David\n         (closure/add-externs-sources (dissoc opts :foreign-libs))))))\n  ([source opts compiler-env]\n   (doseq [[unknown-opt suggested-opt] (util/unknown-opts (set (keys opts)) closure/known-opts)]\n     (when suggested-opt\n       (println (str \"WARNING: Unknown compiler option '\" unknown-opt \"'. Did you mean '\" suggested-opt \"'?\"))))\n   (binding [ana/*cljs-warning-handlers* (:warning-handlers opts ana/*cljs-warning-handlers*)]\n     (closure/build source opts compiler-env))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/clojure/cljs/build/api.clj",
                                            :lines [212 231]},
                                   :full-name "cljs.build.api/build",
                                   :docstring "Given compiler options, produce runnable JavaScript. An optional source\nparameter may be provided."},
           "cljs.core/dissoc!" {:ns "cljs.core",
                                :name "dissoc!",
                                :signature ["[tcoll key]"
                                            "[tcoll key & ks]"],
                                :name-encode "dissocBANG",
                                :history [["+" "0.0-1211"]],
                                :type "function",
                                :full-name-encode "cljs.core/dissocBANG",
                                :source {:code "(defn dissoc!\n  ([tcoll key]\n    (-dissoc! tcoll key))\n  ([tcoll key & ks]\n    (let [ntcoll (-dissoc! tcoll key)]\n      (if ks\n        (recur ntcoll (first ks) (next ks))\n        ntcoll))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [3940 3948]},
                                :full-name "cljs.core/dissoc!",
                                :docstring "Returns a transient map that doesn't contain a mapping for key(s)."},
           "cljs.repl/self-require?" {:ns "cljs.repl",
                                      :name "self-require?",
                                      :signature ["[specs]"],
                                      :name-encode "self-requireQMARK",
                                      :history [["+" "0.0-2911"]
                                                ["-" "1.9.293"]],
                                      :type "function",
                                      :full-name-encode "cljs.repl/self-requireQMARK",
                                      :source {:code "(defn self-require? [specs]\n  (some\n    (fn [quoted-spec-or-kw]\n      (and (not (keyword? quoted-spec-or-kw))\n           (let [spec (second quoted-spec-or-kw)\n                 ns (if (sequential? spec)\n                      (first spec)\n                      spec)]\n             (= ns ana/*cljs-ns*))))\n    specs))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.9.229",
                                               :filename "src/main/clojure/cljs/repl.cljc",
                                               :lines [623 632]},
                                      :full-name "cljs.repl/self-require?",
                                      :removed {:in "1.9.293",
                                                :last-seen "1.9.229"}},
           "cljs.spec.impl.gen/int" {:ns "cljs.spec.impl.gen",
                                     :name "int",
                                     :signature ["[& args]"],
                                     :name-encode "int",
                                     :history [["+" "1.9.14"]
                                               ["-" "1.9.542"]],
                                     :type "function",
                                     :full-name-encode "cljs.spec.impl.gen/int",
                                     :source {:code "(lazy-prims any any-printable boolean char char-alpha char-alphanumeric char-ascii double\n  int keyword keyword-ns large-integer ratio simple-type simple-type-printable\n  string string-ascii string-alphanumeric symbol symbol-ns uuid)",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.9.521",
                                              :filename "src/main/cljs/cljs/spec/impl/gen.cljs",
                                              :lines [73 75]},
                                     :full-name "cljs.spec.impl.gen/int",
                                     :docstring "Fn returning clojure.test.check.generators/int",
                                     :removed {:in "1.9.542",
                                               :last-seen "1.9.521"}},
           "cljs.repl.server/promiseq" {:ns "cljs.repl.server",
                                        :name "promiseq",
                                        :name-encode "promiseq",
                                        :type "var",
                                        :full-name-encode "cljs.repl.server/promiseq",
                                        :source {:code "(def promiseq (LinkedList.))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/clojure/cljs/repl/server.clj",
                                                 :lines [21]},
                                        :full-name "cljs.repl.server/promiseq",
                                        :history [["+" "1.10.145"]]},
           "cljs.spec.impl.gen/boolean" {:ns "cljs.spec.impl.gen",
                                         :name "boolean",
                                         :signature ["[& args]"],
                                         :name-encode "boolean",
                                         :history [["+" "1.9.14"]
                                                   ["-" "1.9.542"]],
                                         :type "function",
                                         :full-name-encode "cljs.spec.impl.gen/boolean",
                                         :source {:code "(lazy-prims any any-printable boolean char char-alpha char-alphanumeric char-ascii double\n  int keyword keyword-ns large-integer ratio simple-type simple-type-printable\n  string string-ascii string-alphanumeric symbol symbol-ns uuid)",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.9.521",
                                                  :filename "src/main/cljs/cljs/spec/impl/gen.cljs",
                                                  :lines [73 75]},
                                         :full-name "cljs.spec.impl.gen/boolean",
                                         :docstring "Fn returning clojure.test.check.generators/boolean",
                                         :removed {:in "1.9.542",
                                                   :last-seen "1.9.521"}},
           "cljs.build.api/ns->source" {:ns "cljs.build.api",
                                        :name "ns->source",
                                        :signature ["[ns]"],
                                        :name-encode "ns-GTsource",
                                        :history [["+" "0.0-3291"]],
                                        :type "function",
                                        :full-name-encode "cljs.build.api/ns-GTsource",
                                        :source {:code "(defn ns->source\n  [ns]\n  (util/ns->source ns))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/clojure/cljs/build/api.clj",
                                                 :lines [115 118]},
                                        :full-name "cljs.build.api/ns->source",
                                        :docstring "Given a namespace as a symbol return the corresponding resource if it exists."},
           "clojure.reflect/meta" {:ns "clojure.reflect",
                                   :name "meta",
                                   :signature ["[sym cb]"],
                                   :name-encode "meta",
                                   :history [["+" "0.0-1503"]],
                                   :type "function",
                                   :full-name-encode "clojure.reflect/meta",
                                   :source {:code "(defn meta\n  [sym cb]\n  (query-reflection (str \"var=\" (js/encodeURIComponent (str sym)))\n                    #(cb (evaluate-javascript %))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/clojure/reflect.cljs",
                                            :lines [33 39]},
                                   :full-name "clojure.reflect/meta",
                                   :docstring "Queries the reflection api with a fully qualified symbol, then calls\ncallback fn cb with the evaluated cljs map containing that symbol's\nmeta information."},
           "cljs.spec.alpha/fn-sym" {:ns "cljs.spec.alpha",
                                     :name "fn-sym",
                                     :signature ["[f-n]"],
                                     :name-encode "fn-sym",
                                     :history [["+" "1.10.439"]
                                               ["-" "1.10.514"]],
                                     :type "function",
                                     :full-name-encode "cljs.spec.alpha/fn-sym",
                                     :source {:code "(defn fn-sym [f-n]\n  (when-not (str/blank? f-n)\n    (let [xs (map demunge (str/split f-n \"$\"))]\n      (when (c/and (<= 2 (count xs))\n                   (every? #(not (str/blank? %)) xs))\n        (let [[xs y] ((juxt butlast last) xs)]\n          (symbol (str (str/join \".\" xs) \"/\" y)))))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.10.439",
                                              :filename "src/main/cljs/cljs/spec/alpha.cljs",
                                              :lines [123 129]},
                                     :full-name "cljs.spec.alpha/fn-sym",
                                     :removed {:in "1.10.514",
                                               :last-seen "1.10.439"}},
           "cljs.reader/read-literal" {:ns "cljs.reader",
                                       :name "read-literal",
                                       :signature ["[rdr ch]"],
                                       :name-encode "read-literal",
                                       :history [["+" "1.7.107"]
                                                 ["-" "1.9.854"]],
                                       :type "function",
                                       :full-name-encode "cljs.reader/read-literal",
                                       :source {:code "(defn read-literal\n  [rdr ch]\n  (let [token (read-token rdr ch)\n        chars (subs token 1)]\n    (cond (identical? (.-length chars) 1) chars\n          (identical? chars \"tab\")       \"\\t\"\n          (identical? chars \"return\")    \"\\r\"\n          (identical? chars \"newline\")   \"\\n\"\n          (identical? chars \"space\")     \" \"\n          (identical? chars \"backspace\") \"\\b\"\n          (identical? chars \"formfeed\")  \"\\f\"\n          (identical? (.charAt chars 0) \"u\") (make-unicode-char (subs chars 1))\n          (identical? (.charAt chars 0) \"o\") (not-implemented rdr token)\n          :else (reader-error rdr \"Unknown character literal: \" token))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.9.671",
                                                :filename "src/main/cljs/cljs/reader.cljs",
                                                :lines [349 362]},
                                       :full-name "cljs.reader/read-literal",
                                       :removed {:in "1.9.854",
                                                 :last-seen "1.9.671"}},
           "cljs.spec/*fspec-iterations*" {:ns "cljs.spec",
                                           :name "*fspec-iterations*",
                                           :name-encode "STARfspec-iterationsSTAR",
                                           :history [["+" "1.9.14"]
                                                     ["-" "1.9.542"]],
                                           :type "dynamic var",
                                           :full-name-encode "cljs.spec/STARfspec-iterationsSTAR",
                                           :source {:code "(def ^:dynamic *fspec-iterations*\n  \"The number of times an anonymous fn specified by fspec will be (generatively) tested during conform\"\n  21)",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.9.521",
                                                    :filename "src/main/cljs/cljs/spec.cljs",
                                                    :lines [27 29]},
                                           :full-name "cljs.spec/*fspec-iterations*",
                                           :removed {:in "1.9.542",
                                                     :last-seen "1.9.521"}},
           "cljs.spec.impl.gen/tuple" {:ns "cljs.spec.impl.gen",
                                       :name "tuple",
                                       :signature ["[& args]"],
                                       :name-encode "tuple",
                                       :history [["+" "1.9.14"]
                                                 ["-" "1.9.542"]],
                                       :type "function",
                                       :full-name-encode "cljs.spec.impl.gen/tuple",
                                       :source {:code "(lazy-combinators hash-map list map not-empty set vector vector-distinct fmap elements\n  bind choose one-of such-that tuple sample return\n  large-integer* double* frequency)",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.9.521",
                                                :filename "src/main/cljs/cljs/spec/impl/gen.cljs",
                                                :lines [69 71]},
                                       :full-name "cljs.spec.impl.gen/tuple",
                                       :docstring "Lazy loaded version of clojure.test.check.generators/tuple",
                                       :removed {:in "1.9.542",
                                                 :last-seen "1.9.521"}},
           "clojure.browser.net/*timeout*" {:ns "clojure.browser.net",
                                            :name "*timeout*",
                                            :name-encode "STARtimeoutSTAR",
                                            :type "var",
                                            :full-name-encode "clojure.browser.net/STARtimeoutSTAR",
                                            :source {:code "(def *timeout* 10000)",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/cljs/clojure/browser/net.cljs",
                                                     :lines [20]},
                                            :full-name "clojure.browser.net/*timeout*",
                                            :history [["+" "0.0-927"]]},
           "cljs.js/*loaded*" {:ns "cljs.js",
                               :name "*loaded*",
                               :name-encode "STARloadedSTAR",
                               :type "var",
                               :full-name-encode "cljs.js/STARloadedSTAR",
                               :source {:code "(def *loaded* (atom #{}))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/js.cljs",
                                        :lines [199]},
                               :full-name "cljs.js/*loaded*",
                               :history [["+" "1.7.10"]]},
           "cljs.core/let*" {:ns "cljs.core",
                             :name "let*",
                             :name-encode "letSTAR",
                             :history [["+" "0.0-927"]],
                             :type "special form",
                             :full-name-encode "cljs.core/letSTAR",
                             :source {:code "(defmethod parse 'let*\n  [op encl-env form _ _]\n  (analyze-let encl-env form false nil))",
                                      :title "Parser code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/clojure/cljs/analyzer.cljc",
                                      :lines [2523 2525]},
                             :extra-sources ({:code "(defmethod emit* :let [ast]\n  (emit-let ast false))",
                                              :title "Emitting code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/clojure/cljs/compiler.cljc",
                                              :lines [1109 1110]}),
                             :full-name "cljs.core/let*"},
           "cljs.core/remove-tap" {:ns "cljs.core",
                                   :name "remove-tap",
                                   :signature ["[f]"],
                                   :name-encode "remove-tap",
                                   :history [["+" "1.10.63"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/remove-tap",
                                   :source {:code "(defn remove-tap\n  [f]\n  (maybe-init-tapset)\n  (swap! tapset disj f)\n  nil)",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [12053 12058]},
                                   :full-name "cljs.core/remove-tap",
                                   :docstring "Remove f from the tap set."},
           "cljs.core/remove-method" {:ns "cljs.core",
                                      :name "remove-method",
                                      :signature ["[multifn dispatch-val]"],
                                      :name-encode "remove-method",
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "cljs.core/remove-method",
                                      :source {:code "(defn remove-method\n  [multifn dispatch-val]\n (-remove-method multifn dispatch-val))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [11676 11679]},
                                      :full-name "cljs.core/remove-method",
                                      :docstring "Removes the method of multimethod associated with dispatch-value."},
           "cljs.core/array-chunk" {:ns "cljs.core",
                                    :name "array-chunk",
                                    :signature ["[arr]"
                                                "[arr off]"
                                                "[arr off end]"],
                                    :name-encode "array-chunk",
                                    :history [["+" "0.0-1424"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/array-chunk",
                                    :source {:code "(defn array-chunk\n  ([arr]\n     (ArrayChunk. arr 0 (alength arr)))\n  ([arr off]\n     (ArrayChunk. arr off (alength arr)))\n  ([arr off end]\n     (ArrayChunk. arr off end)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [3630 3636]},
                                    :full-name "cljs.core/array-chunk"},
           "cljs.spec.alpha/describe" {:ns "cljs.spec.alpha",
                                       :name "describe",
                                       :signature ["[spec]"],
                                       :name-encode "describe",
                                       :history [["+" "1.9.542"]],
                                       :type "function",
                                       :full-name-encode "cljs.spec.alpha/describe",
                                       :source {:code "(defn describe\n  [spec]\n  (abbrev (form spec)))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/spec/alpha.cljs",
                                                :lines [206 209]},
                                       :full-name "cljs.spec.alpha/describe",
                                       :docstring "returns an abbreviated description of the spec as data"},
           "clojure.core.reducers/drop" {:ns "clojure.core.reducers",
                                         :name "drop",
                                         :signature ["[n]" "[n coll]"],
                                         :name-encode "drop",
                                         :history [["+" "0.0-1236"]],
                                         :type "function",
                                         :full-name-encode "clojure.core.reducers/drop",
                                         :source {:code "(defcurried drop\n  {}\n  [n coll]\n  (reducer coll\n   (fn [f1]\n     (let [cnt (atom n)]\n       (rfn [f1 k]\n         ([ret k v]\n            (swap! cnt dec)\n            (if (neg? @cnt)\n              (f1 ret k v)\n              ret)))))))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/cljs/clojure/core/reducers.cljs",
                                                  :lines [178 190]},
                                         :full-name "clojure.core.reducers/drop",
                                         :docstring "Elides the first n values from the reduction of coll."},
           "syntax/symbol" {:syntax-equiv {:edn-url nil, :clj-url nil},
                            :ns "syntax",
                            :name "symbol",
                            :name-encode "symbol",
                            :history [["+" "0.0-1853"]],
                            :type "syntax",
                            :full-name-encode "syntax/symbol",
                            :extra-sources ({:code "(defn- read-symbol\n  [rdr initch]\n  (let [[line column] (starting-line-col-info rdr)]\n    (when-let [token (read-token rdr :symbol initch)]\n      (case token\n\n        ;; special symbols\n        \"nil\" nil\n        \"true\" true\n        \"false\" false\n        \"/\" '/\n\n        (or (when-let [p (parse-symbol token)]\n              (with-meta (symbol (p 0) (p 1))\n                (when line\n                  (merge\n                   (when-let [file (get-file-name rdr)]\n                     {:file file})\n                   (let [[end-line end-column] (ending-line-col-info rdr)]\n                     {:line line\n                      :column column\n                      :end-line end-line\n                      :end-column end-column})))))\n            (err/throw-invalid rdr :symbol token))))))",
                                             :title "Reader code",
                                             :repo "tools.reader",
                                             :tag "v1.3.6",
                                             :filename "src/main/clojure/clojure/tools/reader.clj",
                                             :lines [304 327]}),
                            :full-name "syntax/symbol"},
           "clojure.browser.net/IWebSocket" {:ns "clojure.browser.net",
                                             :name "IWebSocket",
                                             :name-encode "IWebSocket",
                                             :history [["+"
                                                        "0.0-2911"]],
                                             :type "protocol",
                                             :full-name-encode "clojure.browser.net/IWebSocket",
                                             :source {:code "(defprotocol IWebSocket\n  (open? [this]))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.12.38",
                                                      :filename "src/main/cljs/clojure/browser/net.cljs",
                                                      :lines [144 145]},
                                             :methods [{:name "open?",
                                                        :signature ["[this]"],
                                                        :docstring nil}],
                                             :full-name "clojure.browser.net/IWebSocket"},
           "cljs.core/PersistentArrayMap.fromArrays" {:ns "cljs.core",
                                                      :name "PersistentArrayMap.fromArrays",
                                                      :signature ["[ks vs]"],
                                                      :name-encode "PersistentArrayMapDOTfromArrays",
                                                      :history [["+"
                                                                 "0.0-1211"]
                                                                ["-"
                                                                 "0.0-1798"]],
                                                      :parent-type "PersistentArrayMap",
                                                      :type "function",
                                                      :full-name-encode "cljs.core/PersistentArrayMapDOTfromArrays",
                                                      :source {:code "(set! cljs.core.PersistentArrayMap/fromArrays\n      (fn [ks vs]\n        (let [len (count ks)]\n          (loop [i   0\n                 out (transient cljs.core.PersistentArrayMap/EMPTY)]\n            (if (< i len)\n              (recur (inc i) (assoc! out (aget ks i) (aget vs i)))\n              (persistent! out))))))",
                                                               :title "Source code",
                                                               :repo "clojurescript",
                                                               :tag "r1586",
                                                               :filename "src/cljs/cljs/core.cljs",
                                                               :lines [3976
                                                                       3983]},
                                                      :full-name "cljs.core/PersistentArrayMap.fromArrays",
                                                      :removed {:in "0.0-1798",
                                                                :last-seen "0.0-1586"}},
           "cljs.core/frequencies" {:ns "cljs.core",
                                    :name "frequencies",
                                    :signature ["[coll]"],
                                    :name-encode "frequencies",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/frequencies",
                                    :source {:code "(defn frequencies\n  [coll]\n  (persistent!\n   (reduce (fn [counts x]\n             (assoc! counts x (inc (get counts x 0))))\n           (transient {}) coll)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [10284 10291]},
                                    :full-name "cljs.core/frequencies",
                                    :docstring "Returns a map from distinct items in coll to the number of times\nthey appear."},
           "cljs.core/require-macros" {:ns "cljs.core",
                                       :name "require-macros",
                                       :signature ["[& args]"],
                                       :name-encode "require-macros",
                                       :history [["+" "0.0-2657"]],
                                       :type "macro",
                                       :full-name-encode "cljs.core/require-macros",
                                       :source {:code "(core/defmacro require-macros\n  [& args]\n  `(~'ns* ~(cons :require-macros args)))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/clojure/cljs/core.cljc",
                                                :lines [3047 3050]},
                                       :full-name "cljs.core/require-macros",
                                       :docstring "Similar to require but only for macros."},
           "cljs.core/pop" {:ns "cljs.core",
                            :name "pop",
                            :signature ["[coll]"],
                            :name-encode "pop",
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core/pop",
                            :source {:code "(defn pop\n  [coll]\n  (when-not (nil? coll)\n    (-pop coll)))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [2150 2156]},
                            :full-name "cljs.core/pop",
                            :docstring "For a list or queue, returns a new list/queue without the first\nitem, for a vector, returns a new vector without the last item.\nNote - not the same as next/butlast."},
           "cljs.repl/with-read-known" {:ns "cljs.repl",
                                        :name "with-read-known",
                                        :signature ["[& body]"],
                                        :name-encode "with-read-known",
                                        :history [["+" "0.0-2719"]
                                                  ["-" "0.0-2911"]],
                                        :type "macro",
                                        :full-name-encode "cljs.repl/with-read-known",
                                        :source {:code "(defmacro with-read-known\n  [& body]\n  `(binding [*read-eval* (if (= :unknown *read-eval*) true *read-eval*)]\n     ~@body))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2850",
                                                 :filename "src/clj/cljs/repl.clj",
                                                 :lines [84 89]},
                                        :full-name "cljs.repl/with-read-known",
                                        :docstring "Evaluates body with *read-eval* set to a \"known\" value,\ni.e. substituting true for :unknown if necessary.",
                                        :removed {:in "0.0-2911",
                                                  :last-seen "0.0-2850"}},
           "cljs.core/flatmap" {:ns "cljs.core",
                                :name "flatmap",
                                :signature ["[f]" "[f coll]"],
                                :name-encode "flatmap",
                                :history [["+" "0.0-2301"]
                                          ["-" "0.0-2341"]],
                                :type "function",
                                :full-name-encode "cljs.core/flatmap",
                                :source {:code "(defn flatmap\n  ([f]\n   (fn [f1]\n     (fn\n       ([] (f1))\n       ([result] (f1 result))\n       ([result input]\n          (reduce (preserving-reduced f1) result (f input))))))\n  ([f coll] (sequence (flatmap f) coll)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2322",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [8139 8150]},
                                :full-name "cljs.core/flatmap",
                                :docstring "maps f over coll and concatenates the results.  Thus function f\nshould return a collection.  Returns a transducer when no collection\nis provided.",
                                :removed {:in "0.0-2341",
                                          :last-seen "0.0-2322"}},
           "cljs.core/not-every?" {:ns "cljs.core",
                                   :name "not-every?",
                                   :signature ["[pred coll]"],
                                   :name-encode "not-everyQMARK",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/not-everyQMARK",
                                   :source {:code "(defn not-every?\n  [pred coll] (not (every? pred coll)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [4331 4334]},
                                   :full-name "cljs.core/not-every?",
                                   :docstring "Returns false if (pred x) is logical true for every x in\ncoll, else true."},
           "cljs.core/js-invoke" {:ns "cljs.core",
                                  :name "js-invoke",
                                  :signature ["[obj s & args]"],
                                  :name-encode "js-invoke",
                                  :history [["+" "0.0-2411"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/js-invoke",
                                  :source {:code "(defn js-invoke\n  [obj s & args]\n  (.apply (unchecked-get obj s) obj (into-array args)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [538 542]},
                                  :full-name "cljs.core/js-invoke",
                                  :docstring "Invoke JavaScript object method via string. Needed when the\nstring is not a valid unquoted property name."},
           "cljs.spec.alpha/explain-str" {:ns "cljs.spec.alpha",
                                          :name "explain-str",
                                          :signature ["[spec x]"],
                                          :name-encode "explain-str",
                                          :history [["+" "1.9.542"]],
                                          :type "function",
                                          :full-name-encode "cljs.spec.alpha/explain-str",
                                          :source {:code "(defn explain-str\n  [spec x]\n  (with-out-str (explain spec x)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/cljs/cljs/spec/alpha.cljs",
                                                   :lines [275 278]},
                                          :full-name "cljs.spec.alpha/explain-str",
                                          :docstring "Given a spec and a value that fails to conform, returns an explanation as a string."},
           "repl-options/init" {:ns "repl-options",
                                :name "init",
                                :name-encode "init",
                                :type "option",
                                :full-name-encode "repl-options/init",
                                :full-name "repl-options/init",
                                :history [["+" "0.0-2911"]]},
           "cljs.core/some-fn" {:ns "cljs.core",
                                :name "some-fn",
                                :signature ["[p]"
                                            "[p1 p2]"
                                            "[p1 p2 p3]"
                                            "[p1 p2 p3 & ps]"],
                                :name-encode "some-fn",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/some-fn",
                                :source {:code "(defn some-fn\n  ([p]\n     (fn sp1\n       ([] nil)\n       ([x] (p x))\n       ([x y] (or (p x) (p y)))\n       ([x y z] (or (p x) (p y) (p z)))\n       ([x y z & args] (or (sp1 x y z)\n                           (some p args)))))\n  ([p1 p2]\n     (fn sp2\n       ([] nil)\n       ([x] (or (p1 x) (p2 x)))\n       ([x y] (or (p1 x) (p1 y) (p2 x) (p2 y)))\n       ([x y z] (or (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z)))\n       ([x y z & args] (or (sp2 x y z)\n                           (some #(or (p1 %) (p2 %)) args)))))\n  ([p1 p2 p3]\n     (fn sp3\n       ([] nil)\n       ([x] (or (p1 x) (p2 x) (p3 x)))\n       ([x y] (or (p1 x) (p1 y) (p2 x) (p2 y) (p3 x) (p3 y)))\n       ([x y z] (or (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z) (p3 x) (p3 y) (p3 z)))\n       ([x y z & args] (or (sp3 x y z)\n                           (some #(or (p1 %) (p2 %) (p3 %)) args)))))\n  ([p1 p2 p3 & ps]\n     (let [ps (list* p1 p2 p3 ps)]\n       (fn spn\n         ([] nil)\n         ([x] (some #(% x) ps))\n         ([x y] (some #(or (% x) (% y)) ps))\n         ([x y z] (some #(or (% x) (% y) (% z)) ps))\n         ([x y z & args] (or (spn x y z)\n                             (some #(some % args) ps)))))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [4769 4806]},
                                :full-name "cljs.core/some-fn",
                                :docstring "Takes a set of predicates and returns a function f that returns the first logical true value\nreturned by one of its composing predicates against any of its arguments, else it returns\nlogical false. Note that f is short-circuiting in that it will stop execution on the first\nargument that triggers a logical true result against the original predicates."},
           "syntax/vector" {:syntax-equiv {:edn-url nil, :clj-url nil},
                            :ns "syntax",
                            :name "vector",
                            :name-encode "vector",
                            :history [["+" "0.0-1853"]],
                            :type "syntax",
                            :full-name-encode "syntax/vector",
                            :extra-sources ({:code "(defn- read-vector\n  [rdr _ opts pending-forms]\n  (let [[start-line start-column] (starting-line-col-info rdr)\n        the-vector (read-delimited :vector \\] rdr opts pending-forms)\n        [end-line end-column] (ending-line-col-info rdr)]\n    (with-meta the-vector\n      (when start-line\n        (merge\n         (when-let [file (get-file-name rdr)]\n           {:file file})\n         {:line start-line\n          :column start-column\n          :end-line end-line\n          :end-column end-column})))))",
                                             :title "Reader code",
                                             :repo "tools.reader",
                                             :tag "v1.3.6",
                                             :filename "src/main/clojure/clojure/tools/reader.clj",
                                             :lines [223 237]}
                                            {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                             :title "Reader table",
                                             :repo "tools.reader",
                                             :tag "v1.3.6",
                                             :filename "src/main/clojure/clojure/tools/reader.clj",
                                             :lines [788 807]}),
                            :full-name "syntax/vector"},
           "clojure.browser.event/remove-all" {:ns "clojure.browser.event",
                                               :name "remove-all",
                                               :signature ["[opt_obj opt_type opt_capt]"],
                                               :name-encode "remove-all",
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "clojure.browser.event/remove-all",
                                               :source {:code "(defn remove-all [opt_obj opt_type opt_capt])",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.12.38",
                                                        :filename "src/main/cljs/clojure/browser/event.cljs",
                                                        :lines [100]},
                                               :full-name "clojure.browser.event/remove-all"},
           "cljs.core/doto" {:ns "cljs.core",
                             :name "doto",
                             :signature ["[x & forms]"],
                             :name-encode "doto",
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :full-name-encode "cljs.core/doto",
                             :source {:code "(core/defmacro doto\n  [x & forms]\n  (core/let [gx (gensym)]\n    `(let [~gx ~x]\n       ~@(map (core/fn [f]\n                (if (seq? f)\n                  `(~(first f) ~gx ~@(next f))\n                  `(~f ~gx)))\n           forms)\n       ~gx)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/clojure/cljs/core.cljc",
                                      :lines [178 192]},
                             :full-name "cljs.core/doto",
                             :docstring "Evaluates x then calls all of the methods and functions with the\nvalue of x supplied at the front of the given arguments.  The forms\nare evaluated in order.  Returns x.\n\n(doto (new js/Map) (.set \"a\" 1) (.set \"b\" 2))"},
           "cljs.core/take-while" {:ns "cljs.core",
                                   :name "take-while",
                                   :signature ["[pred]" "[pred coll]"],
                                   :name-encode "take-while",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/take-while",
                                   :source {:code "(defn take-while\n  ([pred]\n     (fn [rf]\n       (fn\n         ([] (rf))\n         ([result] (rf result))\n         ([result input]\n            (if (pred input)\n              (rf result input)\n              (reduced result))))))\n  ([pred coll]\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (when (pred (first s))\n           (cons (first s) (take-while pred (rest s))))))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [9861 9878]},
                                   :full-name "cljs.core/take-while",
                                   :docstring "Returns a lazy sequence of successive items from coll while\n(pred item) returns logical true. pred must be free of side-effects.\nReturns a transducer when no collection is provided."},
           "closure-warnings/duplicate-message" {:ns "closure-warnings",
                                                 :name "duplicate-message",
                                                 :name-encode "duplicate-message",
                                                 :type "warning",
                                                 :full-name-encode "closure-warnings/duplicate-message",
                                                 :full-name "closure-warnings/duplicate-message",
                                                 :history [["+"
                                                            "0.0-2120"]]},
           "cljs.repl/evaluate-form" {:ns "cljs.repl",
                                      :name "evaluate-form",
                                      :signature ["[repl-env env filename form]"
                                                  "[repl-env env filename form wrap]"
                                                  "[repl-env env filename form wrap opts]"],
                                      :name-encode "evaluate-form",
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "cljs.repl/evaluate-form",
                                      :source {:code "(defn evaluate-form\n  ([repl-env env filename form]\n    (evaluate-form repl-env env filename form identity))\n  ([repl-env env filename form wrap]\n    (evaluate-form repl-env env filename form wrap *repl-opts*))\n  ([repl-env env filename form wrap opts]\n   (binding [ana/*cljs-file* filename]\n     (let [env (merge env\n                 {:root-source-info {:source-type :fragment\n                                     :source-form form}\n                  :repl-env repl-env})\n           def-emits-var (:def-emits-var opts)\n           backup-comp @env/*compiler*\n           ->ast (fn [form]\n                   (binding [ana/*analyze-deps* false]\n                     (ana/analyze (assoc env :def-emits-var def-emits-var)\n                       (wrap form) nil opts)))\n           ast (->ast form)\n           ast (if-not (#{:ns :ns*} (:op ast))\n                 ast\n                 (let [ijs (ana/parse-ns [form])]\n                   (cljsc/handle-js-modules opts\n                     (deps/dependency-order\n                       (cljsc/add-dependency-sources [ijs] opts))\n                     env/*compiler*)\n                   (binding [ana/*check-alias-dupes* false]\n                     (ana/no-warn (->ast form))))) ;; need new AST after we know what the modules are - David\n           wrap-js\n           ;; TODO: check opts as well - David\n           (if (:source-map repl-env)\n             (binding [comp/*source-map-data*\n                       (atom {:source-map (sorted-map)\n                              :gen-line 0})\n                       comp/*source-map-data-gen-col* (AtomicLong.)]\n               (let [js (comp/emit-str ast)\n                     t (System/currentTimeMillis)]\n                 (str js\n                   \"\\n//# sourceURL=repl-\" t \".js\"\n                   \"\\n//# sourceMappingURL=data:application/json;base64,\"\n                   (bytes-to-base64-str\n                     (.getBytes\n                       (sm/encode\n                         {(str \"repl-\" t \".cljs\")\n                          (:source-map @comp/*source-map-data*)}\n                         {:lines (+ (:gen-line @comp/*source-map-data*) 3)\n                          :file (str \"repl-\" t \".js\")\n                          :sources-content\n                          [(or (:source (meta form))\n                             ;; handle strings / primitives without metadata\n                             (with-out-str (pr form)))]})\n                       \"UTF-8\")))))\n             (comp/emit-str ast))]\n       ;; NOTE: means macros which expand to ns aren't supported for now\n       ;; when eval'ing individual forms at the REPL - David\n       (when (#{:ns :ns*} (:op ast))\n         (let [ast (try\n                     (ana/no-warn (ana/analyze env form nil opts))\n                     (catch #?(:clj Exception :cljs js/Error) e\n                         (reset! env/*compiler* backup-comp)\n                         (throw e)))\n               sources (load-dependencies repl-env\n                         (into (vals (:requires ast))\n                               (distinct (vals (:uses ast))))\n                         opts)]\n           (load-cljs-loader repl-env sources opts)))\n       (when *cljs-verbose*\n         (err-out (println wrap-js)))\n       (let [ret (-evaluate repl-env filename (:line (meta form)) wrap-js)]\n         (case (:status ret)\n           :error (throw\n                    (ex-info (:value ret)\n                      {:type :js-eval-error\n                       :error ret\n                       :repl-env repl-env\n                       :form form}))\n           :exception (throw\n                        (ex-info (:value ret)\n                          {:type :js-eval-exception\n                           :error ret\n                           :repl-env repl-env\n                           :form form\n                           :js wrap-js}))\n           :success (:value ret)))))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/clojure/cljs/repl.cljc",
                                               :lines [498 583]},
                                      :full-name "cljs.repl/evaluate-form",
                                      :docstring "Evaluate a ClojureScript form in the JavaScript environment. Returns a\nstring which is the ClojureScript return value. This string may or may\nnot be readable by the Clojure reader."},
           "cljs.core/*eval*" {:ns "cljs.core",
                               :name "*eval*",
                               :name-encode "STARevalSTAR",
                               :history [["+" "1.10.191"]],
                               :type "dynamic var",
                               :full-name-encode "cljs.core/STARevalSTAR",
                               :source {:code "(defonce\n  ^{:dynamic true}\n  *eval*\n  (fn [_]\n    (throw (js/Error. \"cljs.core/*eval* not bound\"))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [12312 12318]},
                               :full-name "cljs.core/*eval*",
                               :docstring "Runtime environments may provide a way to evaluate ClojureScript\nforms. Whatever function *eval* is bound to will be passed any forms which\nshould be evaluated."},
           "cljs.reader/escape-char-map" {:ns "cljs.reader",
                                          :name "escape-char-map",
                                          :signature ["[c]"],
                                          :name-encode "escape-char-map",
                                          :history [["+" "0.0-927"]
                                                    ["-" "1.9.854"]],
                                          :type "function",
                                          :full-name-encode "cljs.reader/escape-char-map",
                                          :source {:code "(defn escape-char-map [c]\n  (cond\n   (identical? c \\t) \"\\t\"\n   (identical? c \\r) \"\\r\"\n   (identical? c \\n) \"\\n\"\n   (identical? c \\\\) \\\\\n   (identical? c \\\") \\\"\n   (identical? c \\b) \"\\b\"\n   (identical? c \\f) \"\\f\"\n   :else nil))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.9.671",
                                                   :filename "src/main/cljs/cljs/reader.cljs",
                                                   :lines [153 162]},
                                          :full-name "cljs.reader/escape-char-map",
                                          :removed {:in "1.9.854",
                                                    :last-seen "1.9.671"}},
           "closure-warnings/tweaks" {:ns "closure-warnings",
                                      :name "tweaks",
                                      :name-encode "tweaks",
                                      :type "warning",
                                      :full-name-encode "closure-warnings/tweaks",
                                      :full-name "closure-warnings/tweaks",
                                      :history [["+" "0.0-2120"]]},
           "clojure.browser.event/all-listeners" {:ns "clojure.browser.event",
                                                  :name "all-listeners",
                                                  :signature ["[obj type capture]"],
                                                  :name-encode "all-listeners",
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "clojure.browser.event/all-listeners",
                                                  :source {:code "(defn all-listeners [obj type capture])",
                                                           :title "Source code",
                                                           :repo "clojurescript",
                                                           :tag "r1.12.38",
                                                           :filename "src/main/cljs/clojure/browser/event.cljs",
                                                           :lines [92]},
                                                  :full-name "clojure.browser.event/all-listeners"},
           "cljs.spec/int-in" {:ns "cljs.spec",
                               :name "int-in",
                               :signature ["[start end]"],
                               :name-encode "int-in",
                               :history [["+" "1.9.75"]
                                         ["-" "1.9.542"]],
                               :type "macro",
                               :full-name-encode "cljs.spec/int-in",
                               :source {:code "(defmacro int-in\n  [start end]\n  `(spec (and c/int? #(int-in-range? ~start ~end %))\n     :gen #(gen/large-integer* {:min ~start :max (dec ~end)})))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.9.521",
                                        :filename "src/main/cljs/cljs/spec.cljc",
                                        :lines [474 479]},
                               :full-name "cljs.spec/int-in",
                               :docstring "Returns a spec that validates longs in the range from start\n(inclusive) to end (exclusive).",
                               :removed {:in "1.9.542",
                                         :last-seen "1.9.521"}},
           "cljs.spec.gen.alpha/tuple" {:ns "cljs.spec.gen.alpha",
                                        :name "tuple",
                                        :signature ["[& args]"],
                                        :name-encode "tuple",
                                        :history [["+" "1.9.542"]],
                                        :type "function",
                                        :full-name-encode "cljs.spec.gen.alpha/tuple",
                                        :source {:code "(lazy-combinators hash-map list map not-empty set vector vector-distinct fmap elements\n  bind choose one-of such-that tuple sample return\n  large-integer* double* frequency shuffle)",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/cljs/cljs/spec/gen/alpha.cljs",
                                                 :lines [70 72]},
                                        :full-name "cljs.spec.gen.alpha/tuple",
                                        :docstring "Lazy loaded version of clojure.test.check.generators/tuple"},
           "cljs.core/ITransientSet" {:ns "cljs.core",
                                      :name "ITransientSet",
                                      :name-encode "ITransientSet",
                                      :implementations #{"TransientHashSet"},
                                      :history [["+" "0.0-1211"]],
                                      :type "protocol",
                                      :full-name-encode "cljs.core/ITransientSet",
                                      :source {:code "(defprotocol ITransientSet\n  (^clj -disjoin! [tcoll v]\n    \"Returns tcoll without v.\"))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [830 833]},
                                      :methods [{:name "-disjoin!",
                                                 :signature ["[tcoll v]"],
                                                 :docstring "Returns tcoll without v."}],
                                      :full-name "cljs.core/ITransientSet",
                                      :docstring "Protocol for adding set functionality to a transient collection."},
           "closure-warnings/es5-strict" {:ns "closure-warnings",
                                          :name "es5-strict",
                                          :name-encode "es5-strict",
                                          :type "warning",
                                          :full-name-encode "closure-warnings/es5-strict",
                                          :full-name "closure-warnings/es5-strict",
                                          :history [["+" "0.0-2120"]]},
           "cljs.core/vals" {:ns "cljs.core",
                             :name "vals",
                             :signature ["[map]"],
                             :name-encode "vals",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/vals",
                             :source {:code "(defn vals\n  [map]\n  (when-let [mseq (seq map)]\n    (ValSeq. mseq nil)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [9324 9328]},
                             :full-name "cljs.core/vals",
                             :docstring "Returns a sequence of the map's values, in the same order as (seq map)."},
           "cljs.core/IDeref" {:ns "cljs.core",
                               :name "IDeref",
                               :name-encode "IDeref",
                               :implementations #{"Reduced"
                                                  "Delay"
                                                  "Atom"
                                                  "Var"
                                                  "Volatile"},
                               :history [["+" "0.0-927"]],
                               :type "protocol",
                               :full-name-encode "cljs.core/IDeref",
                               :source {:code "(defprotocol IDeref\n  (-deref [o]\n    \"Returns the value of the reference o.\"))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [690 693]},
                               :methods [{:name "-deref",
                                          :signature ["[o]"],
                                          :docstring "Returns the value of the reference o."}],
                               :full-name "cljs.core/IDeref",
                               :docstring "Protocol for adding dereference functionality to a reference."},
           "cljs.build.api/parse-js-ns" {:ns "cljs.build.api",
                                         :name "parse-js-ns",
                                         :signature ["[f]"],
                                         :name-encode "parse-js-ns",
                                         :history [["+" "0.0-2629"]],
                                         :type "function",
                                         :full-name-encode "cljs.build.api/parse-js-ns",
                                         :source {:code "(defn parse-js-ns\n  [f]\n  (closure/parse-js-ns f))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/clojure/cljs/build/api.clj",
                                                  :lines [59 64]},
                                         :full-name "cljs.build.api/parse-js-ns",
                                         :docstring "Given a Google Closure style JavaScript file or resource return the namespace\ninformation for the given file. Only returns the value extracted from the\nfirst provide statement."},
           "cljs.js/require" {:ns "cljs.js",
                              :name "require",
                              :signature ["[name cb]"
                                          "[name opts cb]"
                                          "[bound-vars name opts cb]"
                                          "[bound-vars name reload opts cb]"],
                              :name-encode "require",
                              :history [["+" "1.7.10"]],
                              :type "function",
                              :full-name-encode "cljs.js/require",
                              :source {:code "(defn require\n  ([name cb]\n    (require name nil cb))\n  ([name opts cb]\n    (require nil name opts cb))\n  ([bound-vars name opts cb]\n   (require bound-vars name nil opts cb))\n  ([bound-vars name reload opts cb]\n   (let [bound-vars (merge\n                      {:*compiler*     (env/default-compiler-env)\n                       :*data-readers* tags/*cljs-data-readers*\n                       :*load-macros*  (:load-macros opts true)\n                       :*analyze-deps* (:analyze-deps opts true)\n                       :*load-fn*      (or (:load opts) *load-fn*)\n                       :*eval-fn*      (or (:eval opts) *eval-fn*)}\n                      bound-vars)\n         aname (cond-> name (:macros-ns opts) ana/macro-ns-name)]\n     (when (= :reload reload)\n       (swap! *loaded* disj aname))\n     (when (= :reload-all reload)\n       (reset! *loaded* #{}))\n     (when (:verbose opts)\n       (debug-prn (str \"Loading \" name (when (:macros-ns opts) \" macros\") \" namespace\")))\n     (if-not (contains? @*loaded* aname)\n       (let [env (:*env* bound-vars)]\n         (try\n           ((:*load-fn* bound-vars)\n             {:name name\n              :macros (:macros-ns opts)\n              :path (ns->relpath name)}\n             (fn [resource]\n               (assert (or (map? resource) (nil? resource))\n                 \"*load-fn* may only return a map or nil\")\n               (if resource\n                 (let [{:keys [lang source cache source-map file]} resource]\n                   (condp keyword-identical? lang\n                     :clj (do\n                            (pre-file-side-effects (:*compiler* bound-vars) aname file opts)\n                            (eval-str* bound-vars source name (assoc opts :cljs-file file)\n                              (fn [res]\n                                (post-file-side-effects file opts)\n                                (if (:error res)\n                                  (cb res)\n                                  (do\n                                    (swap! *loaded* conj aname)\n                                    (cb {:value true}))))))\n                     :js (process-macros-deps bound-vars cache opts\n                           (fn [res]\n                             (if (:error res)\n                               (cb res)\n                               (process-libs-deps bound-vars cache opts\n                                 (fn [res]\n                                   (if (:error res)\n                                     (cb res)\n                                     (let [res (try\n                                                 ((:*eval-fn* bound-vars) resource)\n                                                 (when cache\n                                                   (load-analysis-cache!\n                                                     (:*compiler* bound-vars) aname cache)\n                                                   (ana/register-specs cache))\n                                                 (when source-map\n                                                   (load-source-map!\n                                                     (:*compiler* bound-vars) aname source-map))\n                                                 (catch :default cause\n                                                   (wrap-error\n                                                     (ana/error env\n                                                       (str \"Could not require \" name) cause))))]\n                                       (if (:error res)\n                                         (cb res)\n                                         (do\n                                           (swap! *loaded* conj aname)\n                                           (cb {:value true}))))))))))\n                     (cb (wrap-error\n                           (ana/error env\n                             (str \"Invalid :lang specified \" lang \", only :clj or :js allowed\"))))))\n                 (cb (wrap-error\n                       (ana/error env\n                         (ana/error-message (if (:macros-ns opts)\n                                              :undeclared-macros-ns\n                                              :undeclared-ns)\n                           {:ns-sym name :js-provide (cljs.core/name name)})))))))\n           (catch :default cause\n             (cb (wrap-error\n                   (ana/error env\n                     (str \"Could not require \" name) cause))))))\n       (cb {:value true})))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/js.cljs",
                                       :lines [268 353]},
                              :full-name "cljs.js/require"},
           "cljs.core/string-hash-cache" {:ns "cljs.core",
                                          :name "string-hash-cache",
                                          :name-encode "string-hash-cache",
                                          :type "var",
                                          :full-name-encode "cljs.core/string-hash-cache",
                                          :source {:code "(def string-hash-cache (js-obj))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/cljs/cljs/core.cljs",
                                                   :lines [992]},
                                          :full-name "cljs.core/string-hash-cache",
                                          :history [["+" "0.0-1424"]]},
           "warnings/protocol-deprecated" {:ns "warnings",
                                           :name "protocol-deprecated",
                                           :name-encode "protocol-deprecated",
                                           :type "warning",
                                           :full-name-encode "warnings/protocol-deprecated",
                                           :full-name "warnings/protocol-deprecated",
                                           :history [["+" "0.0-1835"]]},
           "cljs.core/array-map" {:ns "cljs.core",
                                  :name "array-map",
                                  :signature ["[& keyvals]"],
                                  :name-encode "array-map",
                                  :history [["+" "0.0-1211"]],
                                  :type "function/macro",
                                  :full-name-encode "cljs.core/array-map",
                                  :source {:code "(defn array-map\n  [& keyvals]\n  (let [arr (if (and (instance? IndexedSeq keyvals) (zero? (.-i keyvals)))\n              (.-arr keyvals)\n              (into-array keyvals))]\n    (if (odd? (alength arr))\n      (throw (js/Error. (str \"No value supplied for key: \" (last arr))))\n      (.createAsIfByAssoc PersistentArrayMap arr))))",
                                           :title "Function code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [9126 9135]},
                                  :extra-sources [{:code "(core/defmacro array-map\n  ([] '(.-EMPTY cljs.core/PersistentArrayMap))\n  ([& kvs]\n   (core/let [keys (map first (partition 2 kvs))]\n     (if (core/and (every? #(= (:op (cljs.analyzer/unwrap-quote %)) :const)\n                     (map #(cljs.analyzer/no-warn (cljs.analyzer/analyze &env %)) keys))\n           (= (count (into #{} keys)) (count keys)))\n       `(cljs.core/PersistentArrayMap. nil ~(clojure.core// (count kvs) 2) (array ~@kvs) nil)\n       `(.createAsIfByAssoc cljs.core/PersistentArrayMap (array ~@kvs))))))",
                                                   :title "Macro code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/clojure/cljs/core.cljc",
                                                   :lines [2639 2647]}],
                                  :full-name "cljs.core/array-map",
                                  :docstring "keyval => key val\nReturns a new array map with supplied mappings."},
           "cljs.test/report" {:ns "cljs.test",
                               :name "report",
                               :name-encode "report",
                               :history [["+" "0.0-2496"]],
                               :type "multimethod",
                               :full-name-encode "cljs.test/report",
                               :source {:code "(defmulti\n  ^{:dynamic true}\n  report (fn [m] [(:reporter (get-current-env)) (:type m)]))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/test.cljs",
                                        :lines [312 318]},
                               :extra-sources ({:code "(defmethod report :default [m])",
                                                :title "Dispatch method",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/test.cljs",
                                                :lines [320]}
                                               {:code "(defmethod report [::default :pass] [m]\n  (inc-report-counter! :pass))",
                                                :title "Dispatch method",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/test.cljs",
                                                :lines [322 323]}
                                               {:code "(defmethod report [::default :fail] [m]\n  (inc-report-counter! :fail)\n  (println \"\\nFAIL in\" (testing-vars-str m))\n  (when (seq (:testing-contexts (get-current-env)))\n    (println (testing-contexts-str)))\n  (when-let [message (:message m)] (println message))\n  (print-comparison m))",
                                                :title "Dispatch method",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/test.cljs",
                                                :lines [330 336]}
                                               {:code "(defmethod report [::default :error] [m]\n  (inc-report-counter! :error)\n  (println \"\\nERROR in\" (testing-vars-str m))\n  (when (seq (:testing-contexts (get-current-env)))\n    (println (testing-contexts-str)))\n  (when-let [message (:message m)] (println message))\n  (print-comparison m))",
                                                :title "Dispatch method",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/test.cljs",
                                                :lines [338 344]}
                                               {:code "(defmethod report [::default :summary] [m]\n  (println \"\\nRan\" (:test m) \"tests containing\"\n    (+ (:pass m) (:fail m) (:error m)) \"assertions.\")\n  (println (:fail m) \"failures,\" (:error m) \"errors.\"))",
                                                :title "Dispatch method",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/test.cljs",
                                                :lines [346 349]}
                                               {:code "(defmethod report [::default :begin-test-ns] [m]\n  (println \"\\nTesting\" (name (:ns m))))",
                                                :title "Dispatch method",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/test.cljs",
                                                :lines [351 352]}
                                               {:code "(defmethod report [::default :end-test-ns] [m])",
                                                :title "Dispatch method",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/test.cljs",
                                                :lines [355]}
                                               {:code "(defmethod report [::default :begin-test-var] [m]\n  #_(println \":begin-test-var\" (testing-vars-str m)))",
                                                :title "Dispatch method",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/test.cljs",
                                                :lines [356 357]}
                                               {:code "(defmethod report [::default :end-test-var] [m])",
                                                :title "Dispatch method",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/test.cljs",
                                                :lines [358]}
                                               {:code "(defmethod report [::default :end-run-tests] [m])",
                                                :title "Dispatch method",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/test.cljs",
                                                :lines [359]}
                                               {:code "(defmethod report [::default :end-test-all-vars] [m])",
                                                :title "Dispatch method",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/test.cljs",
                                                :lines [360]}
                                               {:code "(defmethod report [::default :end-test-vars] [m])",
                                                :title "Dispatch method",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/test.cljs",
                                                :lines [361]}),
                               :full-name "cljs.test/report",
                               :docstring "Generic reporting function, may be overridden to plug in\n   different report formats (e.g., TAP, JUnit).  Assertions such as\n   'is' call 'report' to indicate results.  The argument given to\n   'report' will be a map with a :type key."},
           "clojure.browser.dom/log-obj" {:ns "clojure.browser.dom",
                                          :name "log-obj",
                                          :signature ["[obj]"],
                                          :name-encode "log-obj",
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "clojure.browser.dom/log-obj",
                                          :source {:code "(defn log-obj [obj]\n  (.log js/console obj))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/cljs/clojure/browser/dom.cljs",
                                                   :lines [23 24]},
                                          :full-name "clojure.browser.dom/log-obj"},
           "cljs.core/import" {:ns "cljs.core",
                               :name "import",
                               :signature ["[& import-symbols-or-lists]"],
                               :name-encode "import",
                               :history [["+" "0.0-2985"]],
                               :type "macro",
                               :full-name-encode "cljs.core/import",
                               :source {:code "(core/defmacro import\n  [& import-symbols-or-lists]\n  `(~'ns* ~(cons :import import-symbols-or-lists)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/clojure/cljs/core.cljc",
                                        :lines [3070 3077]},
                               :full-name "cljs.core/import",
                               :docstring "import-list => (closure-namespace constructor-name-symbols*)\n\nFor each name in constructor-name-symbols, adds a mapping from name to the\nconstructor named by closure-namespace to the current namespace. Use :import in the ns\nmacro in preference to calling this directly."},
           "cljs.repl/initial-prompt" {:ns "cljs.repl",
                                       :name "initial-prompt",
                                       :signature ["[quit-prompt prompt]"],
                                       :name-encode "initial-prompt",
                                       :history [["+" "1.10.439"]],
                                       :type "function",
                                       :full-name-encode "cljs.repl/initial-prompt",
                                       :source {:code "(defn initial-prompt [quit-prompt prompt]\n  (quit-prompt)\n  (prompt)\n  (flush))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/clojure/cljs/repl.cljc",
                                                :lines [1028 1031]},
                                       :full-name "cljs.repl/initial-prompt"},
           "cljs.nodejs/enable-util-print!" {:ns "cljs.nodejs",
                                             :name "enable-util-print!",
                                             :signature ["[]"],
                                             :name-encode "enable-util-printBANG",
                                             :history [["+"
                                                        "0.0-2156"]],
                                             :type "function",
                                             :full-name-encode "cljs.nodejs/enable-util-printBANG",
                                             :source {:code "(defn enable-util-print! []\n  (set! *print-newline* false)\n  (set-print-fn!\n    (fn [& args]\n      (.apply (.-log js/console) js/console (into-array args))))\n  (set-print-err-fn!\n    (fn [& args]\n      (.apply (.-error js/console) js/console (into-array args))))\n  nil)",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.12.38",
                                                      :filename "src/main/cljs/cljs/nodejs.cljs",
                                                      :lines [19 27]},
                                             :full-name "cljs.nodejs/enable-util-print!"},
           "cljs.repl.browser/repl-env*" {:ns "cljs.repl.browser",
                                          :name "repl-env*",
                                          :signature ["[{:keys [output-dir host port], :or {host \"localhost\", port 9000}, :as opts}]"],
                                          :name-encode "repl-envSTAR",
                                          :history [["+" "0.0-3030"]],
                                          :type "function",
                                          :full-name-encode "cljs.repl.browser/repl-envSTAR",
                                          :source {:code "(defn repl-env*\n  [{:keys [output-dir host port] :or {host \"localhost\" port 9000} :as opts}]\n  (merge (BrowserEnv.)\n    {:host host\n     :port port\n     :launch-browser true\n     :working-dir (->> [\".repl\" (util/clojurescript-version)]\n                       (remove empty?) (string/join \"-\"))\n     :static-dir (cond-> [\".\" \"out/\"] output-dir (conj output-dir))\n     :preloaded-libs []\n     :src \"src/\"\n     :browser-state (atom {:return-value-fn nil\n                           :client-js nil})\n     :ordering (agent {:expecting nil :fns {}})\n     :es (Executors/newFixedThreadPool 16)\n     :server-state\n     (atom\n       {:socket nil\n        :listeners 0})}\n    opts))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/clojure/cljs/repl/browser.clj",
                                                   :lines [455 474]},
                                          :full-name "cljs.repl.browser/repl-env*"},
           "cljs.spec.impl.gen/ratio" {:ns "cljs.spec.impl.gen",
                                       :name "ratio",
                                       :signature ["[& args]"],
                                       :name-encode "ratio",
                                       :history [["+" "1.9.14"]
                                                 ["-" "1.9.542"]],
                                       :type "function",
                                       :full-name-encode "cljs.spec.impl.gen/ratio",
                                       :source {:code "(lazy-prims any any-printable boolean char char-alpha char-alphanumeric char-ascii double\n  int keyword keyword-ns large-integer ratio simple-type simple-type-printable\n  string string-ascii string-alphanumeric symbol symbol-ns uuid)",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.9.521",
                                                :filename "src/main/cljs/cljs/spec/impl/gen.cljs",
                                                :lines [73 75]},
                                       :full-name "cljs.spec.impl.gen/ratio",
                                       :docstring "Fn returning clojure.test.check.generators/ratio",
                                       :removed {:in "1.9.542",
                                                 :last-seen "1.9.521"}},
           "cljs.repl/source" {:ns "cljs.repl",
                               :name "source",
                               :signature ["[n]"],
                               :name-encode "source",
                               :history [["+" "0.0-2985"]],
                               :type "macro",
                               :full-name-encode "cljs.repl/source",
                               :source {:code "(defmacro source\n  [n]\n  `(println ~(or (source-fn &env n) (str \"Source not found\"))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/clojure/cljs/repl.cljc",
                                        :lines [1531 1538]},
                               :full-name "cljs.repl/source",
                               :docstring "Prints the source code for the given symbol, if it can find it.\nThis requires that the symbol resolve to a Var defined in a\nnamespace for which the .cljs is in the classpath.\n\nExample: (source filter)"},
           "cljs.core/for" {:ns "cljs.core",
                            :name "for",
                            :signature ["[seq-exprs body-expr]"],
                            :name-encode "for",
                            :history [["+" "0.0-927"]],
                            :type "macro",
                            :full-name-encode "cljs.core/for",
                            :source {:code "(core/defmacro for\n  [seq-exprs body-expr]\n  (assert-args for\n    (vector? seq-exprs) \"a vector for its binding\"\n    (even? (count seq-exprs)) \"an even number of forms in binding vector\")\n  (core/let [to-groups (core/fn [seq-exprs]\n                         (reduce (core/fn [groups [k v]]\n                                   (if (core/keyword? k)\n                                     (conj (pop groups) (conj (peek groups) [k v]))\n                                     (conj groups [k v])))\n                           [] (partition 2 seq-exprs)))\n             err (core/fn [& msg] (throw (ex-info (apply core/str msg) {})))\n             emit-bind (core/fn emit-bind [[[bind expr & mod-pairs]\n                                       & [[_ next-expr] :as next-groups]]]\n                         (core/let [giter (gensym \"iter__\")\n                                    gxs (gensym \"s__\")\n                                    do-mod (core/fn do-mod [[[k v :as pair] & etc]]\n                                             (core/cond\n                                               (= k :let) `(let ~v ~(do-mod etc))\n                                               (= k :while) `(when ~v ~(do-mod etc))\n                                               (= k :when) `(if ~v\n                                                              ~(do-mod etc)\n                                                              (recur (rest ~gxs)))\n                                               (core/keyword? k) (err \"Invalid 'for' keyword \" k)\n                                               next-groups\n                                               `(let [iterys# ~(emit-bind next-groups)\n                                                      fs# (seq (iterys# ~next-expr))]\n                                                  (if fs#\n                                                    (concat fs# (~giter (rest ~gxs)))\n                                                    (recur (rest ~gxs))))\n                                               :else `(cons ~body-expr\n                                                        (~giter (rest ~gxs)))))]\n                           (if next-groups\n                             #_ \"not the inner-most loop\"\n                             `(fn ~giter [~gxs]\n                                (lazy-seq\n                                  (loop [~gxs ~gxs]\n                                    (when-first [~bind ~gxs]\n                                      ~(do-mod mod-pairs)))))\n                             #_\"inner-most loop\"\n                             (core/let [gi (gensym \"i__\")\n                                        gb (gensym \"b__\")\n                                        do-cmod (core/fn do-cmod [[[k v :as pair] & etc]]\n                                                  (core/cond\n                                                    (= k :let) `(let ~v ~(do-cmod etc))\n                                                    (= k :while) `(when ~v ~(do-cmod etc))\n                                                    (= k :when) `(if ~v\n                                                                   ~(do-cmod etc)\n                                                                   (recur\n                                                                     (unchecked-inc ~gi)))\n                                                    (core/keyword? k)\n                                                    (err \"Invalid 'for' keyword \" k)\n                                                    :else\n                                                    `(do (chunk-append ~gb ~body-expr)\n                                                         (recur (unchecked-inc ~gi)))))]\n                               `(fn ~giter [~gxs]\n                                  (lazy-seq\n                                    (loop [~gxs ~gxs]\n                                      (when-let [~gxs (seq ~gxs)]\n                                        (if (chunked-seq? ~gxs)\n                                          (let [c# ^not-native (chunk-first ~gxs)\n                                                size# (count c#)\n                                                ~gb (chunk-buffer size#)]\n                                            (if (coercive-boolean\n                                                  (loop [~gi 0]\n                                                    (if (< ~gi size#)\n                                                      (let [~bind (-nth c# ~gi)]\n                                                        ~(do-cmod mod-pairs))\n                                                      true)))\n                                              (chunk-cons\n                                                (chunk ~gb)\n                                                (~giter (chunk-rest ~gxs)))\n                                              (chunk-cons (chunk ~gb) nil)))\n                                          (let [~bind (first ~gxs)]\n                                            ~(do-mod mod-pairs)))))))))))]\n    `(let [iter# ~(emit-bind (to-groups seq-exprs))]\n       (iter# ~(second seq-exprs)))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/clojure/cljs/core.cljc",
                                     :lines [2449 2534]},
                            :full-name "cljs.core/for",
                            :docstring "List comprehension. Takes a vector of one or more\n binding-form/collection-expr pairs, each followed by zero or more\n modifiers, and yields a lazy sequence of evaluations of expr.\n Collections are iterated in a nested fashion, rightmost fastest,\n and nested coll-exprs can refer to bindings created in prior\n binding-forms.  Supported modifiers are: :let [binding-form expr ...],\n :while test, :when test.\n\n(take 100 (for [x (range 100000000) y (range 1000000) :while (< y x)]  [x y]))"},
           "syntax/inst-literal" {:syntax-equiv {:edn-url nil,
                                                 :clj-url nil},
                                  :ns "syntax",
                                  :name "inst-literal",
                                  :name-encode "inst-literal",
                                  :history [["+" "0.0-1424"]],
                                  :type "tagged literal",
                                  :full-name-encode "syntax/inst-literal",
                                  :extra-sources ({:code "   (defn read-inst\n     [form]\n     (when-not (string? form)\n       (throw (RuntimeException. \"Instance literal expects a string for its timestamp.\")))\n     (try\n       (inst/read-instant-instant form)\n       (catch Throwable e\n         (throw (RuntimeException. (.getMessage e))))))",
                                                   :title "Reader code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/clojure/cljs/tagged_literals.cljc",
                                                   :lines [44 51]}
                                                  {:code "(def ^:dynamic *cljs-data-readers*\n  (merge ;; assumes we can read all data_readers\n    #?(:clj *data-readers*)\n    {'queue read-queue\n     'uuid  read-uuid\n     'inst  read-inst\n     'js    read-js}))",
                                                   :title "Reader table",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/clojure/cljs/tagged_literals.cljc",
                                                   :lines [87 93]}),
                                  :full-name "syntax/inst-literal"},
           "cljs.spec.gen.alpha/map" {:ns "cljs.spec.gen.alpha",
                                      :name "map",
                                      :signature ["[& args]"],
                                      :name-encode "map",
                                      :history [["+" "1.9.542"]],
                                      :type "function",
                                      :full-name-encode "cljs.spec.gen.alpha/map",
                                      :source {:code "(lazy-combinators hash-map list map not-empty set vector vector-distinct fmap elements\n  bind choose one-of such-that tuple sample return\n  large-integer* double* frequency shuffle)",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/spec/gen/alpha.cljs",
                                               :lines [70 72]},
                                      :full-name "cljs.spec.gen.alpha/map",
                                      :docstring "Lazy loaded version of clojure.test.check.generators/map"},
           "cljs.js/debug-prn" {:ns "cljs.js",
                                :name "debug-prn",
                                :signature ["[& args]"],
                                :name-encode "debug-prn",
                                :history [["+" "1.7.10"]
                                          ["-" "1.7.48"]],
                                :type "function",
                                :full-name-encode "cljs.js/debug-prn",
                                :source {:code "(defn debug-prn\n  [& args]\n  (binding [*print-fn* *print-err-fn*]\n    (apply println args)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.28",
                                         :filename "src/main/cljs/cljs/js.cljs",
                                         :lines [25 28]},
                                :full-name "cljs.js/debug-prn",
                                :removed {:in "1.7.48",
                                          :last-seen "1.7.28"}},
           "cljs.spec.impl.gen/large-integer*" {:ns "cljs.spec.impl.gen",
                                                :name "large-integer*",
                                                :signature ["[& args]"],
                                                :name-encode "large-integerSTAR",
                                                :history [["+"
                                                           "1.9.75"]
                                                          ["-"
                                                           "1.9.542"]],
                                                :type "function",
                                                :full-name-encode "cljs.spec.impl.gen/large-integerSTAR",
                                                :source {:code "(lazy-combinators hash-map list map not-empty set vector vector-distinct fmap elements\n  bind choose one-of such-that tuple sample return\n  large-integer* double* frequency)",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1.9.521",
                                                         :filename "src/main/cljs/cljs/spec/impl/gen.cljs",
                                                         :lines [69
                                                                 71]},
                                                :full-name "cljs.spec.impl.gen/large-integer*",
                                                :docstring "Lazy loaded version of clojure.test.check.generators/large-integer*",
                                                :removed {:in "1.9.542",
                                                          :last-seen "1.9.521"}},
           "cljs.core/parse-uuid" {:ns "cljs.core",
                                   :name "parse-uuid",
                                   :signature ["[s]"],
                                   :name-encode "parse-uuid",
                                   :history [["+" "1.11.50"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/parse-uuid",
                                   :source {:code "(defn parse-uuid\n  [s]\n  (if (string? s)\n    (when ^boolean (re-matches uuid-regex s)\n      (uuid s))\n    (throw (js/Error. (parsing-err s)))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [12269 12277]},
                                   :full-name "cljs.core/parse-uuid",
                                   :docstring "Parse a string representing a UUID and return a UUID instance,\nor nil if parse fails.\nGrammar: https://docs.oracle.com/javase/8/docs/api/java/util/UUID.html#toString--"},
           "closure-warnings/msg-conventions" {:ns "closure-warnings",
                                               :name "msg-conventions",
                                               :name-encode "msg-conventions",
                                               :type "warning",
                                               :full-name-encode "closure-warnings/msg-conventions",
                                               :full-name "closure-warnings/msg-conventions",
                                               :history [["+"
                                                          "1.10.217"]]},
           "cljs.core/unchecked-multiply-int" {:return-type number,
                                               :ns "cljs.core",
                                               :name "unchecked-multiply-int",
                                               :signature ["[]"
                                                           "[x]"
                                                           "[x y]"
                                                           "[x y & more]"],
                                               :name-encode "unchecked-multiply-int",
                                               :history [["+"
                                                          "0.0-1798"]],
                                               :type "function/macro",
                                               :full-name-encode "cljs.core/unchecked-multiply-int",
                                               :source {:code "(defn ^number unchecked-multiply-int\n  ([] 1)\n  ([x] x)\n  ([x y] (cljs.core/unchecked-multiply-int x y))\n  ([x y & more] (reduce unchecked-multiply-int (cljs.core/unchecked-multiply-int x y) more)))",
                                                        :title "Function code",
                                                        :repo "clojurescript",
                                                        :tag "r1.12.38",
                                                        :filename "src/main/cljs/cljs/core.cljs",
                                                        :lines [2849
                                                                2854]},
                                               :extra-sources [{:code "(core/defmacro ^::ana/numeric unchecked-multiply-int\n  ([& xs] `(* ~@xs)))",
                                                                :title "Macro code",
                                                                :repo "clojurescript",
                                                                :tag "r1.12.38",
                                                                :filename "src/main/clojure/cljs/core.cljc",
                                                                :lines [1101
                                                                        1102]}],
                                               :full-name "cljs.core/unchecked-multiply-int",
                                               :docstring "Returns the product of nums. (*) returns 1."},
           "cljs.spec/exercise" {:ns "cljs.spec",
                                 :name "exercise",
                                 :signature ["[spec]"
                                             "[spec n]"
                                             "[spec n overrides]"],
                                 :name-encode "exercise",
                                 :history [["+" "1.9.14"]
                                           ["-" "1.9.542"]],
                                 :type "function",
                                 :full-name-encode "cljs.spec/exercise",
                                 :source {:code "(defn exercise\n  ([spec] (exercise spec 10))\n  ([spec n] (exercise spec n nil))\n  ([spec n overrides]\n   (map #(vector % (conform spec %)) (gen/sample (gen spec overrides) n))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.9.521",
                                          :filename "src/main/cljs/cljs/spec.cljs",
                                          :lines [1375 1382]},
                                 :full-name "cljs.spec/exercise",
                                 :docstring "generates a number (default 10) of values compatible with spec and maps conform over them,\nreturning a sequence of [val conformed-val] tuples. Optionally takes\na generator overrides map as per gen",
                                 :removed {:in "1.9.542",
                                           :last-seen "1.9.521"}},
           "cljs.core/cond->" {:ns "cljs.core",
                               :name "cond->",
                               :signature ["[expr & clauses]"],
                               :name-encode "cond-GT",
                               :history [["+" "0.0-1798"]],
                               :type "macro",
                               :full-name-encode "cljs.core/cond-GT",
                               :source {:code "(defmacro cond->\n  {:added \"1.5\"}\n  [expr & clauses]\n  (assert (even? (count clauses)))\n  (let [g (gensym)\n        steps (map (fn [[test step]] `(if ~test (-> ~g ~step) ~g))\n                   (partition 2 clauses))]\n    `(let [~g ~expr\n           ~@(interleave (repeat g) (butlast steps))]\n       ~(if (empty? steps)\n          g\n          (last steps)))))",
                                        :title "Source code",
                                        :repo "clojure",
                                        :tag "clojure-1.10.0",
                                        :filename "src/clj/clojure/core.clj",
                                        :lines [7538 7553]},
                               :full-name "cljs.core/cond->",
                               :docstring "Takes an expression and a set of test/form pairs. Threads expr (via ->)\nthrough each form for which the corresponding test\nexpression is true. Note that, unlike cond branching, cond-> threading does\nnot short circuit after the first true test expression."},
           "cljs.spec.test.alpha/validate-check-opts" {:ns "cljs.spec.test.alpha",
                                                       :name "validate-check-opts",
                                                       :signature ["[opts]"],
                                                       :name-encode "validate-check-opts",
                                                       :history [["+"
                                                                  "1.10.514"]],
                                                       :type "function",
                                                       :full-name-encode "cljs.spec.test.alpha/validate-check-opts",
                                                       :source {:code "(defn validate-check-opts\n  [opts]\n  (assert (every? ident? (keys (:gen opts))) \"check :gen expects ident keys\"))",
                                                                :title "Source code",
                                                                :repo "clojurescript",
                                                                :tag "r1.12.38",
                                                                :filename "src/main/cljs/cljs/spec/test/alpha.cljs",
                                                                :lines [249
                                                                        251]},
                                                       :full-name "cljs.spec.test.alpha/validate-check-opts"},
           "cljs.repl/load-stream" {:ns "cljs.repl",
                                    :name "load-stream",
                                    :signature ["[repl-env filename res]"],
                                    :name-encode "load-stream",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.repl/load-stream",
                                    :source {:code "(defn load-stream [repl-env filename res]\n  (let [env (ana/empty-env)]\n    (with-open [rdr (io/reader res)]\n      (doseq [form (ana/forms-seq* rdr filename)]\n        (let [env (assoc env :ns (ana/get-namespace ana/*cljs-ns*))]\n          (evaluate-form repl-env env filename form))))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/clojure/cljs/repl.cljc",
                                             :lines [585 590]},
                                    :full-name "cljs.repl/load-stream"},
           "cljs.math/next-after" {:return-type number,
                                   :ns "cljs.math",
                                   :name "next-after",
                                   :signature ["[start direction]"],
                                   :name-encode "next-after",
                                   :history [["+" "1.11.50"]],
                                   :type "function",
                                   :full-name-encode "cljs.math/next-after",
                                   :source {:code "(defn ^number next-after\n  {:added \"1.11.10\"}\n  [start direction]\n  ; Branch to descending case first as it is more costly than ascending\n  ; case due to start != 0.0f conditional.\n  (let [a (js/ArrayBuffer. 8)\n        f (js/Float64Array. a)\n        i (js/Uint32Array. a)]\n    (cond\n      (> start direction) (if-not (zero? start)\n                            (let [_ (aset f 0 start)\n                                  ht (aget i HI)\n                                  lt (aget i LO)\n                                  ;; ht&lt != 0 since start != 0.0\n                                  ;; So long as the top bit is not set, then whole number is > 0\n                                  [hr lr] (if (zero? (bit-and ht INT32-NON-SIGN-BIT))\n                                            (add64 ht lt 0xFFFFFFFF 0xFFFFFFFF)\n                                            (add64 ht lt 0 1))]\n                              (aset i HI hr)\n                              (aset i LO lr)\n                              (aget f 0))\n                            ;; start == 0.0 && direction < 0.0\n                            (- js/Number.MIN_VALUE))\n      ;; Add +0.0 to get rid of a -0.0 (+0.0 + -0.0 => +0.0)\n      ;; then bitwise convert start to integer\n      (< start direction) (let [_ (aset f 0 (+ start 0.0))\n                                ht (aget i HI)\n                                lt (aget i LO)\n                                [hr lr] (if (zero? (bit-and ht INT32-NON-SIGN-BIT))\n                                          (add64 ht lt 0 1)\n                                          (add64 ht lt 0xFFFFFFFF 0xFFFFFFFF))]\n                            (aset i HI hr)\n                            (aset i LO lr)\n                            (aget f 0))\n      (== start direction) direction\n      :default (+ start direction))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/math.cljs",
                                            :lines [742 788]},
                                   :full-name "cljs.math/next-after",
                                   :docstring "Returns the adjacent floating point number to start in the direction of\nthe second argument. If the arguments are equal, the second is returned.\nIf either arg is #NaN => #NaN\nIf both arguments are signed zeros => direction\nIf start is +-Number/MIN_VALUE and direction would cause a smaller magnitude\n  => zero with sign matching start\nIf start is ##Inf or ##-Inf and direction would cause a smaller magnitude\n  => Number/MAX_VALUE with same sign as start\nIf start is equal to +=Number/MAX_VALUE and direction would cause a larger magnitude\n  => ##Inf or ##-Inf with sign matching start\nSee: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#nextAfter-double-double-"},
           "cljs.core/instance?" {:return-type boolean,
                                  :ns "cljs.core",
                                  :name "instance?",
                                  :signature ["[c x]"],
                                  :name-encode "instanceQMARK",
                                  :history [["+" "0.0-927"]],
                                  :type "function/macro",
                                  :full-name-encode "cljs.core/instanceQMARK",
                                  :source {:code "(defn ^boolean instance?\n  [c x]\n  (cljs.core/instance? c x))",
                                           :title "Function code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [1069 1073]},
                                  :extra-sources [{:code "(core/defmacro instance? [c x]\n  ;; Google Closure warns about some references to RegExp, so\n  ;; (instance? RegExp ...) needs to be inlined, but the expansion\n  ;; should preserve the order of argument evaluation.\n  (bool-expr (if (clojure.core/symbol? c)\n               (core/list 'js* \"(~{} instanceof ~{})\" x c)\n               `(let [c# ~c x# ~x]\n                  (~'js* \"(~{} instanceof ~{})\" x# c#)))))",
                                                   :title "Macro code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/clojure/cljs/core.cljc",
                                                   :lines [1001 1008]}],
                                  :full-name "cljs.core/instance?",
                                  :docstring "Evaluates x and tests if it is an instance of the type\nc. Returns true or false"},
           "cljs.core/ValSeq" {:protocols #{"ISeqable"
                                            "IMeta"
                                            "IWithMeta"
                                            "IEmptyableCollection"
                                            "IReduce"
                                            "ISequential"
                                            "ISeq"
                                            "ICollection"
                                            "IHash"
                                            "IPrintWithWriter"
                                            "INext"
                                            "IEquiv"},
                               :ns "cljs.core",
                               :name "ValSeq",
                               :signature ["[mseq _meta]"],
                               :name-encode "ValSeq",
                               :history [["+" "0.0-1820"]],
                               :type "type",
                               :full-name-encode "cljs.core/ValSeq",
                               :source {:code "(deftype ValSeq [^not-native mseq _meta]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IMeta\n  (-meta [coll] _meta)\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta _meta)\n      coll\n      (ValSeq. mseq new-meta)))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ICollection\n  (-conj [coll o]\n    (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (.-EMPTY List))\n\n  IHash\n  (-hash [coll] (hash-ordered-coll coll))\n\n  ISeq\n  (-first [coll]\n    (let [^not-native me (-first mseq)]\n      (-val me)))\n\n  (-rest [coll]\n    (let [nseq (if (satisfies? INext mseq)\n                 (-next mseq)\n                 (next mseq))]\n      (if-not (nil? nseq)\n        (ValSeq. nseq nil)\n        ())))\n\n  INext\n  (-next [coll]\n    (let [nseq (if (satisfies? INext mseq)\n                 (-next mseq)\n                 (next mseq))]\n      (when-not (nil? nseq)\n        (ValSeq. nseq nil))))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [9256 9320]},
                               :full-name "cljs.core/ValSeq"},
           "clojure.browser.repl/print-queue" {:ns "clojure.browser.repl",
                                               :name "print-queue",
                                               :name-encode "print-queue",
                                               :type "var",
                                               :full-name-encode "clojure.browser.repl/print-queue",
                                               :source {:code "(def print-queue (array))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.12.38",
                                                        :filename "src/main/cljs/clojure/browser/repl.cljs",
                                                        :lines [41]},
                                               :full-name "clojure.browser.repl/print-queue",
                                               :history [["+"
                                                          "1.7.48"]]},
           "clojure.string/last-index-of" {:ns "clojure.string",
                                           :name "last-index-of",
                                           :signature ["[s value]"
                                                       "[s value from-index]"],
                                           :name-encode "last-index-of",
                                           :history [["+" "1.7.145"]],
                                           :type "function",
                                           :full-name-encode "clojure.string/last-index-of",
                                           :source {:code "(defn last-index-of\n  ([s value]\n   (let [result (.lastIndexOf s value)]\n     (if (neg? result)\n       nil\n       result)))\n  ([s value from-index]\n   (let [result (.lastIndexOf s value from-index)]\n     (if (neg? result)\n       nil\n       result))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/cljs/clojure/string.cljs",
                                                    :lines [263 275]},
                                           :full-name "clojure.string/last-index-of",
                                           :docstring "Return last index of value (string or char) in s, optionally\nsearching backward from from-index or nil if not found."},
           "cljs.spec.alpha/abbrev" {:ns "cljs.spec.alpha",
                                     :name "abbrev",
                                     :signature ["[form]"],
                                     :name-encode "abbrev",
                                     :history [["+" "1.9.542"]],
                                     :type "function",
                                     :full-name-encode "cljs.spec.alpha/abbrev",
                                     :source {:code "(defn abbrev [form]\n  (cond\n    (seq? form)\n    (walk/postwalk (fn [form]\n                     (cond\n                       (c/and (symbol? form) (namespace form))\n                       (-> form name symbol)\n\n                       (c/and (seq? form) (= 'fn (first form)) (= '[%] (second form)))\n                       (last form)\n\n                       :else form))\n                   form)\n\n    (c/and (symbol? form) (namespace form))\n    (-> form name symbol)\n\n    :else form))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/cljs/cljs/spec/alpha.cljs",
                                              :lines [187 204]},
                                     :full-name "cljs.spec.alpha/abbrev"},
           "cljs.core/rseq" {:return-type seq,
                             :ns "cljs.core",
                             :name "rseq",
                             :signature ["[rev]"],
                             :name-encode "rseq",
                             :history [["+" "0.0-1211"]],
                             :type "function",
                             :full-name-encode "cljs.core/rseq",
                             :source {:code "(defn ^seq rseq\n  [rev]\n  (-rseq rev))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [3283 3287]},
                             :full-name "cljs.core/rseq",
                             :docstring "Returns, in constant time, a seq of the items in rev (which\ncan be a vector or sorted-map), in reverse order. If rev is empty returns nil"},
           "cljs.core/PersistentVector.EMPTY_NODE" {:ns "cljs.core",
                                                    :name "PersistentVector.EMPTY_NODE",
                                                    :name-encode "PersistentVectorDOTEMPTY_NODE",
                                                    :history [["+"
                                                               "0.0-1006"]
                                                              ["-"
                                                               "0.0-2301"]],
                                                    :parent-type "PersistentVector",
                                                    :type "var",
                                                    :full-name-encode "cljs.core/PersistentVectorDOTEMPTY_NODE",
                                                    :source {:code "(set! cljs.core.PersistentVector.EMPTY_NODE (VectorNode. nil (make-array 32)))",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r2280",
                                                             :filename "src/cljs/cljs/core.cljs",
                                                             :lines [3667]},
                                                    :full-name "cljs.core/PersistentVector.EMPTY_NODE",
                                                    :removed {:in "0.0-2301",
                                                              :last-seen "0.0-2280"}},
           "cljs.spec/cat" {:ns "cljs.spec",
                            :name "cat",
                            :signature ["[& key-pred-forms]"],
                            :name-encode "cat",
                            :history [["+" "1.9.14"] ["-" "1.9.542"]],
                            :type "macro",
                            :full-name-encode "cljs.spec/cat",
                            :source {:code "(defmacro cat\n  [& key-pred-forms]\n  (let [pairs (partition 2 key-pred-forms)\n        keys (mapv first pairs)\n        pred-forms (mapv second pairs)\n        pf (mapv #(res &env %) pred-forms)]\n    ;;(prn key-pred-forms)\n    (clojure.core/assert (clojure.core/and (even? (count key-pred-forms)) (every? keyword? keys)) \"cat expects k1 p1 k2 p2..., where ks are keywords\")\n    `(cat-impl ~keys ~pred-forms '~pf)))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.9.521",
                                     :filename "src/main/cljs/cljs/spec.cljc",
                                     :lines [336 350]},
                            :full-name "cljs.spec/cat",
                            :docstring "Takes key+pred pairs, e.g.\n\n(s/cat :e even? :o odd?)\n\nReturns a regex op that matches (all) values in sequence, returning a map\ncontaining the keys of each pred and the corresponding value.",
                            :removed {:in "1.9.542",
                                      :last-seen "1.9.521"}},
           "cljs.repl/repl-prompt" {:ns "cljs.repl",
                                    :name "repl-prompt",
                                    :signature ["[]"],
                                    :name-encode "repl-prompt",
                                    :history [["+" "0.0-2911"]],
                                    :type "function",
                                    :full-name-encode "cljs.repl/repl-prompt",
                                    :source {:code "(defn repl-prompt []\n  (print (str ana/*cljs-ns* \"=> \")))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/clojure/cljs/repl.cljc",
                                             :lines [811 812]},
                                    :full-name "cljs.repl/repl-prompt"},
           "cljs.reader/read-comment" {:ns "cljs.reader",
                                       :name "read-comment",
                                       :name-encode "read-comment",
                                       :history [["+" "0.0-927"]
                                                 ["-" "1.9.854"]],
                                       :type "var",
                                       :full-name-encode "cljs.reader/read-comment",
                                       :source {:code "(def read-comment skip-line)",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.9.671",
                                                :filename "src/main/cljs/cljs/reader.cljs",
                                                :lines [277]},
                                       :full-name "cljs.reader/read-comment",
                                       :removed {:in "1.9.854",
                                                 :last-seen "1.9.671"}},
           "closure-warnings/use-of-goog-base" {:ns "closure-warnings",
                                                :name "use-of-goog-base",
                                                :name-encode "use-of-goog-base",
                                                :type "warning",
                                                :full-name-encode "closure-warnings/use-of-goog-base",
                                                :full-name "closure-warnings/use-of-goog-base",
                                                :history [["+"
                                                           "1.9.473"]
                                                          ["-"
                                                           "1.10.738"]],
                                                :removed {:in "1.10.738",
                                                          :last-seen "1.10.597"}},
           "cljs.repl.rhino/eval-result" {:ns "cljs.repl.rhino",
                                          :name "eval-result",
                                          :name-encode "eval-result",
                                          :history [["+" "0.0-927"]
                                                    ["-" "1.10.738"]],
                                          :type "multimethod",
                                          :full-name-encode "cljs.repl.rhino/eval-result",
                                          :source {:code "(defmulti eval-result class)",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.10.597",
                                                   :filename "src/main/clojure/cljs/repl/rhino.clj",
                                                   :lines [64]},
                                          :extra-sources ({:code "(defmethod eval-result :default [r]\n  (.toString r))",
                                                           :title "Dispatch method",
                                                           :repo "clojurescript",
                                                           :tag "r1.10.597",
                                                           :filename "src/main/clojure/cljs/repl/rhino.clj",
                                                           :lines [66
                                                                   67]}
                                                          {:code "(defmethod eval-result nil [_] \"\")",
                                                           :title "Dispatch method",
                                                           :repo "clojurescript",
                                                           :tag "r1.10.597",
                                                           :filename "src/main/clojure/cljs/repl/rhino.clj",
                                                           :lines [69]}
                                                          {:code "(defmethod eval-result Undefined [_] \"\")",
                                                           :title "Dispatch method",
                                                           :repo "clojurescript",
                                                           :tag "r1.10.597",
                                                           :filename "src/main/clojure/cljs/repl/rhino.clj",
                                                           :lines [71]}),
                                          :full-name "cljs.repl.rhino/eval-result",
                                          :removed {:in "1.10.738",
                                                    :last-seen "1.10.597"}},
           "closure-warnings/visibility" {:ns "closure-warnings",
                                          :name "visibility",
                                          :name-encode "visibility",
                                          :type "warning",
                                          :full-name-encode "closure-warnings/visibility",
                                          :full-name "closure-warnings/visibility",
                                          :history [["+" "1.10.866"]]},
           "cljs.spec.alpha/fdef" {:ns "cljs.spec.alpha",
                                   :name "fdef",
                                   :signature ["[fn-sym & specs]"],
                                   :name-encode "fdef",
                                   :history [["+" "1.9.542"]],
                                   :type "macro",
                                   :full-name-encode "cljs.spec.alpha/fdef",
                                   :source {:code "(defmacro fdef\n  [fn-sym & specs]\n  `(cljs.spec.alpha/def ~fn-sym (fspec ~@specs)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/spec/alpha.cljc",
                                            :lines [416 449]},
                                   :full-name "cljs.spec.alpha/fdef",
                                   :docstring "Takes a symbol naming a function, and one or more of the following:\n\n:args A regex spec for the function arguments as they were a list to be\n  passed to apply - in this way, a single spec can handle functions with\n  multiple arities\n:ret A spec for the function's return value\n:fn A spec of the relationship between args and ret - the\n  value passed is {:args conformed-args :ret conformed-ret} and is\n  expected to contain predicates that relate those values\n\nQualifies fn-sym with resolve, or using *ns* if no resolution found.\nRegisters an fspec in the global registry, where it can be retrieved\nby calling get-spec with the var or fully-qualified symbol.\n\nOnce registered, function specs are included in doc, checked by\ninstrument, tested by the runner cljs.spec.test.alpha/check, and (if\na macro) used to explain errors during macroexpansion.\n\nNote that :fn specs require the presence of :args and :ret specs to\nconform values, and so :fn specs will be ignored if :args or :ret\nare missing.\n\nReturns the qualified fn-sym.\n\nFor example, to register function specs for the symbol function:\n\n(s/fdef cljs.core/symbol\n  :args (s/alt :separate (s/cat :ns string? :n string?)\n               :str string?\n               :sym symbol?)\n  :ret symbol?)"},
           "cljs.core/TransformerIterator.create" {:ns "cljs.core",
                                                   :name "TransformerIterator.create",
                                                   :signature ["[xform source]"],
                                                   :name-encode "TransformerIteratorDOTcreate",
                                                   :history [["+"
                                                              "1.9.562"]],
                                                   :parent-type "TransformerIterator",
                                                   :type "function",
                                                   :full-name-encode "cljs.core/TransformerIteratorDOTcreate",
                                                   :source {:code "(set! (.-create TransformerIterator)\n  (fn [xform source]\n    (transformer-iterator xform source false)))",
                                                            :title "Source code",
                                                            :repo "clojurescript",
                                                            :tag "r1.12.38",
                                                            :filename "src/main/cljs/cljs/core.cljs",
                                                            :lines [4292
                                                                    4294]},
                                                   :full-name "cljs.core/TransformerIterator.create"},
           "clojure.datafy/nav" {:ns "clojure.datafy",
                                 :name "nav",
                                 :signature ["[coll k v]"],
                                 :name-encode "nav",
                                 :history [["+" "1.10.514"]],
                                 :type "function",
                                 :full-name-encode "clojure.datafy/nav",
                                 :source {:code "(defn nav\n  [coll k v]\n  (p/nav coll k v))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/clojure/datafy.cljs",
                                          :lines [31 38]},
                                 :full-name "clojure.datafy/nav",
                                 :docstring "Returns (possibly transformed) v in the context of coll and k (a\nkey/index or nil). Callers should attempt to provide the key/index\ncontext k for Indexed/Associative/ILookup colls if possible, but not\nto fabricate one e.g. for sequences (pass nil). nav will return the\nvalue of clojure.core.protocols/nav."},
           "cljs.repl.node/socket" {:ns "cljs.repl.node",
                                    :name "socket",
                                    :signature ["[host port]"],
                                    :name-encode "socket",
                                    :history [["+" "0.0-2629"]
                                              ["-" "1.10.217"]],
                                    :type "function",
                                    :full-name-encode "cljs.repl.node/socket",
                                    :source {:code "(defn socket [host port]\n  (let [socket (Socket. host port)\n        in     (io/reader socket)\n        out    (io/writer socket)]\n    {:socket socket :in in :out out}))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.10.191",
                                             :filename "src/main/clojure/cljs/repl/node.clj",
                                             :lines [25 29]},
                                    :full-name "cljs.repl.node/socket",
                                    :removed {:in "1.10.217",
                                              :last-seen "1.10.191"}},
           "cljs.core/ITransientMap" {:ns "cljs.core",
                                      :name "ITransientMap",
                                      :name-encode "ITransientMap",
                                      :implementations #{"TransientArrayMap"
                                                         "TransientHashMap"},
                                      :history [["+" "0.0-1211"]],
                                      :type "protocol",
                                      :full-name-encode "cljs.core/ITransientMap",
                                      :source {:code "(defprotocol ITransientMap\n  (^clj -dissoc! [tcoll key]\n    \"Returns a new transient collection of tcoll without the mapping for key.\"))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [818 821]},
                                      :methods [{:name "-dissoc!",
                                                 :signature ["[tcoll key]"],
                                                 :docstring "Returns a new transient collection of tcoll without the mapping for key."}],
                                      :full-name "cljs.core/ITransientMap",
                                      :docstring "Protocol for adding mapping functionality to transient collections."},
           "closure-warnings/check-types" {:ns "closure-warnings",
                                           :name "check-types",
                                           :name-encode "check-types",
                                           :type "warning",
                                           :full-name-encode "closure-warnings/check-types",
                                           :full-name "closure-warnings/check-types",
                                           :history [["+" "0.0-2120"]]},
           "cljs.core/pos-int?" {:ns "cljs.core",
                                 :name "pos-int?",
                                 :signature ["[x]"],
                                 :name-encode "pos-intQMARK",
                                 :history [["+" "1.9.75"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/pos-intQMARK",
                                 :source {:code "(defn pos-int?\n  [x]\n  (cond\n    (integer? x) (pos? x)\n\n    (instance? goog.math.Integer x)\n    (and (not (.isNegative x))\n         (not (.isZero x)))\n\n    (instance? goog.math.Long x)\n    (and (not (.isNegative x))\n         (not (.isZero x)))\n\n    :else false))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [2349 2363]},
                                 :full-name "cljs.core/pos-int?",
                                 :docstring "Return true if x satisfies int? and is positive."},
           "cljs.core/*loaded-libs*" {:ns "cljs.core",
                                      :name "*loaded-libs*",
                                      :name-encode "STARloaded-libsSTAR",
                                      :type "dynamic var",
                                      :full-name-encode "cljs.core/STARloaded-libsSTAR",
                                      :source {:code "(defonce\n  ^{:dynamic true\n    :jsdoc [\"@type {*}\"]}\n  *loaded-libs* nil)",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [179 182]},
                                      :full-name "cljs.core/*loaded-libs*",
                                      :history [["+" "0.0-2655"]]},
           "syntax/whitespace" {:syntax-equiv {:edn-url nil,
                                               :clj-url nil},
                                :ns "syntax",
                                :name "whitespace",
                                :name-encode "whitespace",
                                :type "special character",
                                :full-name-encode "syntax/whitespace",
                                :full-name "syntax/whitespace",
                                :history [["+" "0.0-927"]]},
           "cljs.repl/add-url" {:ns "cljs.repl",
                                :name "add-url",
                                :signature ["[ijs]"],
                                :name-encode "add-url",
                                :history [["+" "1.10.191"]],
                                :type "function",
                                :full-name-encode "cljs.repl/add-url",
                                :source {:code "(defn add-url [ijs]\n  (cond-> ijs\n    (not (contains? ijs :url))\n    (assoc :url (io/resource (:file ijs)))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/clojure/cljs/repl.cljc",
                                         :lines [193 196]},
                                :full-name "cljs.repl/add-url"},
           "closure-warnings/extra-require" {:ns "closure-warnings",
                                             :name "extra-require",
                                             :name-encode "extra-require",
                                             :type "warning",
                                             :full-name-encode "closure-warnings/extra-require",
                                             :full-name "closure-warnings/extra-require",
                                             :history [["+" "1.9.473"]]},
           "cljs.analyzer.api/current-state" {:ns "cljs.analyzer.api",
                                              :name "current-state",
                                              :signature ["[]"],
                                              :name-encode "current-state",
                                              :history [["+"
                                                         "1.10.738"]],
                                              :type "function",
                                              :full-name-encode "cljs.analyzer.api/current-state",
                                              :source {:code "(defn current-state\n  []\n  env/*compiler*)",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.12.38",
                                                       :filename "src/main/clojure/cljs/analyzer/api.cljc",
                                                       :lines [36 39]},
                                              :full-name "cljs.analyzer.api/current-state",
                                              :docstring "Return the current compiler state atom."},
           "cljs.reader/read-number" {:ns "cljs.reader",
                                      :name "read-number",
                                      :signature ["[reader initch]"],
                                      :name-encode "read-number",
                                      :history [["+" "0.0-927"]
                                                ["-" "1.9.854"]],
                                      :type "function",
                                      :full-name-encode "cljs.reader/read-number",
                                      :source {:code "(defn read-number\n  [reader initch]\n  (loop [buffer (gstring/StringBuffer. initch)\n         ch (read-char reader)]\n    (if (or (nil? ch) (whitespace? ch) (macros ch))\n      (do\n        (unread reader ch)\n        (let [s (.toString buffer)]\n          (or (match-number s)\n              (reader-error reader \"Invalid number format [\" s \"]\"))))\n      (recur (do (.append buffer ch) buffer) (read-char reader)))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.9.671",
                                               :filename "src/main/cljs/cljs/reader.cljs",
                                               :lines [293 303]},
                                      :full-name "cljs.reader/read-number",
                                      :removed {:in "1.9.854",
                                                :last-seen "1.9.671"}},
           "cljs.core/ILookup" {:ns "cljs.core",
                                :name "ILookup",
                                :name-encode "ILookup",
                                :implementations #{"Subvec"
                                                   "TaggedLiteral"
                                                   "PersistentHashMap"
                                                   "PersistentTreeSet"
                                                   "RedNode"
                                                   "TransientArrayMap"
                                                   "ObjMap"
                                                   "BlackNode"
                                                   "PersistentVector"
                                                   "TransientVector"
                                                   "PersistentTreeMap"
                                                   "PersistentArrayMap"
                                                   "PersistentHashSet"
                                                   "TransientHashMap"
                                                   "MapEntry"
                                                   "TransientHashSet"},
                                :history [["+" "0.0-927"]],
                                :type "protocol",
                                :full-name-encode "cljs.core/ILookup",
                                :source {:code "(defprotocol ILookup\n  (-lookup [o k] [o k not-found]\n    \"Use k to look up a value in o. If not-found is supplied and k is not\n     a valid value that can be used for look up, not-found is returned.\"))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [638 642]},
                                :methods [{:name "-lookup",
                                           :signature ["[o k]"
                                                       "[o k not-found]"],
                                           :docstring "Use k to look up a value in o. If not-found is supplied and k is not\n     a valid value that can be used for look up, not-found is returned."}],
                                :full-name "cljs.core/ILookup",
                                :docstring "Protocol for looking up a value in a data structure."},
           "cljs.core/when" {:ns "cljs.core",
                             :name "when",
                             :signature ["[test & body]"],
                             :name-encode "when",
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :full-name-encode "cljs.core/when",
                             :source {:code "(defmacro when\n  {:added \"1.0\"}\n  [test & body]\n  (list 'if test (cons 'do body)))",
                                      :title "Source code",
                                      :repo "clojure",
                                      :tag "clojure-1.10.0",
                                      :filename "src/clj/clojure/core.clj",
                                      :lines [493 497]},
                             :full-name "cljs.core/when",
                             :docstring "Evaluates test. If logical true, evaluates body in an implicit do."},
           "cljs.core/ArrayNodeSeq" {:protocols #{"ISeqable"
                                                  "IMeta"
                                                  "IWithMeta"
                                                  "IEmptyableCollection"
                                                  "IReduce"
                                                  "ISequential"
                                                  "ISeq"
                                                  "ICollection"
                                                  "IHash"
                                                  "IPrintWithWriter"
                                                  "INext"
                                                  "IEquiv"},
                                     :ns "cljs.core",
                                     :name "ArrayNodeSeq",
                                     :signature ["[meta nodes i s __hash]"],
                                     :name-encode "ArrayNodeSeq",
                                     :history [["+" "0.0-1211"]],
                                     :type "type",
                                     :full-name-encode "cljs.core/ArrayNodeSeq",
                                     :source {:code "(deftype ArrayNodeSeq [meta nodes i s ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (ArrayNodeSeq. new-meta nodes i s __hash)))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (.-EMPTY List))\n\n  ISequential\n  ISeq\n  (-first [coll] (first s))\n  (-rest  [coll]\n    (let [ret (create-array-node-seq nodes i (next s))]\n      (if-not (nil? ret) ret ())))\n\n  INext\n  (-next [coll]\n    (create-array-node-seq nodes i (next s)))\n\n  ISeqable\n  (-seq [this] this)\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/cljs/cljs/core.cljs",
                                              :lines [8005 8057]},
                                     :full-name "cljs.core/ArrayNodeSeq"},
           "cljs.core/list?" {:ns "cljs.core",
                              :name "list?",
                              :signature ["[x]"],
                              :name-encode "listQMARK",
                              :history [["+" "0.0-1211"]],
                              :type "function",
                              :full-name-encode "cljs.core/listQMARK",
                              :source {:code "(defn list?\n  [x]\n  (satisfies? IList x))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [3200 3203]},
                              :full-name "cljs.core/list?",
                              :docstring "Returns true if x implements IList"},
           "cljs.core/val" {:ns "cljs.core",
                            :name "val",
                            :signature ["[map-entry]"],
                            :name-encode "val",
                            :history [["+" "0.0-1211"]],
                            :type "function",
                            :full-name-encode "cljs.core/val",
                            :source {:code "(defn val\n  [map-entry]\n  (-val map-entry))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [9330 9333]},
                            :full-name "cljs.core/val",
                            :docstring "Returns the value in the map entry."},
           "clojure.browser.dom/set-value" {:ns "clojure.browser.dom",
                                            :name "set-value",
                                            :signature ["[e v]"],
                                            :name-encode "set-value",
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "clojure.browser.dom/set-value",
                                            :source {:code "(defn set-value\n  [e v]\n  (set-properties e {\"value\" v}))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/cljs/clojure/browser/dom.cljs",
                                                     :lines [142 145]},
                                            :full-name "clojure.browser.dom/set-value",
                                            :docstring "Set the value property for an element."},
           "cljs.repl.browser/read-get" {:ns "cljs.repl.browser",
                                         :name "read-get",
                                         :signature ["[line rdr]"],
                                         :name-encode "read-get",
                                         :history [["+" "0.0-927"]
                                                   ["-" "0.0-1503"]],
                                         :type "function",
                                         :full-name-encode "cljs.repl.browser/read-get",
                                         :source {:code "(defn read-get [line rdr]\n  (let [[_ path _] (str/split line #\" \")\n        headers (parse-headers (read-headers rdr))]\n    {:method :get\n     :path path\n     :headers headers}))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1450",
                                                  :filename "src/clj/cljs/repl/browser.clj",
                                                  :lines [154 159]},
                                         :full-name "cljs.repl.browser/read-get",
                                         :removed {:in "0.0-1503",
                                                   :last-seen "0.0-1450"}},
           "cljs.core/BitmapIndexedNode" {:protocols #{"IIterable"},
                                          :ns "cljs.core",
                                          :name "BitmapIndexedNode",
                                          :signature ["[edit bitmap arr]"],
                                          :name-encode "BitmapIndexedNode",
                                          :history [["+" "0.0-1211"]],
                                          :type "type",
                                          :full-name-encode "cljs.core/BitmapIndexedNode",
                                          :source {:code "(deftype BitmapIndexedNode [edit ^:mutable bitmap ^:mutable arr]\n  Object\n  (inode-assoc [inode shift hash key val added-leaf?]\n    (let [bit (bitpos hash shift)\n          idx (bitmap-indexed-node-index bitmap bit)]\n      (if (zero? (bit-and bitmap bit))\n        (let [n (bit-count bitmap)]\n          (if (>= n 16)\n            (let [nodes (make-array 32)\n                  jdx   (mask hash shift)]\n              (aset nodes jdx (.inode-assoc (.-EMPTY BitmapIndexedNode) (+ shift 5) hash key val added-leaf?))\n              (loop [i 0 j 0]\n                (if (< i 32)\n                  (if (zero? (bit-and (bit-shift-right-zero-fill bitmap i) 1))\n                    (recur (inc i) j)\n                    (do (aset nodes i\n                              (if-not (nil? (aget arr j))\n                                (.inode-assoc (.-EMPTY BitmapIndexedNode)\n                                              (+ shift 5) (cljs.core/hash (aget arr j)) (aget arr j) (aget arr (inc j)) added-leaf?)\n                                (aget arr (inc j))))\n                        (recur (inc i) (+ j 2))))))\n              (ArrayNode. nil (inc n) nodes))\n            (let [new-arr (make-array (* 2 (inc n)))]\n              (array-copy arr 0 new-arr 0 (* 2 idx))\n              (aset new-arr (* 2 idx) key)\n              (aset new-arr (inc (* 2 idx)) val)\n              (array-copy arr (* 2 idx) new-arr (* 2 (inc idx)) (* 2 (- n idx)))\n              (set! (.-val added-leaf?) true)\n              (BitmapIndexedNode. nil (bit-or bitmap bit) new-arr))))\n        (let [key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil)\n                (let [n (.inode-assoc val-or-node (+ shift 5) hash key val added-leaf?)]\n                  (if (identical? n val-or-node)\n                    inode\n                    (BitmapIndexedNode. nil bitmap (clone-and-set arr (inc (* 2 idx)) n))))\n\n                (key-test key key-or-nil)\n                (if (identical? val val-or-node)\n                  inode\n                  (BitmapIndexedNode. nil bitmap (clone-and-set arr (inc (* 2 idx)) val)))\n\n                :else\n                (do (set! (.-val added-leaf?) true)\n                    (BitmapIndexedNode. nil bitmap\n                                        (clone-and-set arr (* 2 idx) nil (inc (* 2 idx))\n                                                       (create-node (+ shift 5) key-or-nil val-or-node hash key val)))))))))\n\n  (inode-without [inode shift hash key]\n    (let [bit (bitpos hash shift)]\n      (if (zero? (bit-and bitmap bit))\n        inode\n        (let [idx         (bitmap-indexed-node-index bitmap bit)\n              key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil)\n                (let [n (.inode-without val-or-node (+ shift 5) hash key)]\n                  (cond (identical? n val-or-node) inode\n                        (not (nil? n)) (BitmapIndexedNode. nil bitmap (clone-and-set arr (inc (* 2 idx)) n))\n                        (== bitmap bit) nil\n                        :else (BitmapIndexedNode. nil (bit-xor bitmap bit) (remove-pair arr idx))))\n                (key-test key key-or-nil)\n                (if (== bitmap bit)\n                  nil\n                  (BitmapIndexedNode. nil (bit-xor bitmap bit) (remove-pair arr idx)))\n                :else inode)))))\n\n  (inode-lookup [inode shift hash key not-found]\n    (let [bit (bitpos hash shift)]\n      (if (zero? (bit-and bitmap bit))\n        not-found\n        (let [idx         (bitmap-indexed-node-index bitmap bit)\n              key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil)  (.inode-lookup val-or-node (+ shift 5) hash key not-found)\n                (key-test key key-or-nil) val-or-node\n                :else not-found)))))\n\n  (inode-find [inode shift hash key not-found]\n    (let [bit (bitpos hash shift)]\n      (if (zero? (bit-and bitmap bit))\n        not-found\n        (let [idx         (bitmap-indexed-node-index bitmap bit)\n              key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil) (.inode-find val-or-node (+ shift 5) hash key not-found)\n                (key-test key key-or-nil)          (MapEntry. key-or-nil val-or-node nil)\n                :else not-found)))))\n\n  (inode-seq [inode]\n    (create-inode-seq arr))\n\n  (ensure-editable [inode e]\n    (if (identical? e edit)\n      inode\n      (let [n       (bit-count bitmap)\n            new-arr (make-array (if (neg? n) 4 (* 2 (inc n))))]\n        (array-copy arr 0 new-arr 0 (* 2 n))\n        (BitmapIndexedNode. e bitmap new-arr))))\n\n  (edit-and-remove-pair [inode e bit i]\n    (if (== bitmap bit)\n      nil\n      (let [editable (.ensure-editable inode e)\n            earr     (.-arr editable)\n            len      (alength earr)]\n        (set! (.-bitmap editable) (bit-xor bit (.-bitmap editable)))\n        (array-copy earr (* 2 (inc i))\n                    earr (* 2 i)\n                    (- len (* 2 (inc i))))\n        (aset earr (- len 2) nil)\n        (aset earr (dec len) nil)\n        editable)))\n\n  (inode-assoc! [inode edit shift hash key val added-leaf?]\n    (let [bit (bitpos hash shift)\n          idx (bitmap-indexed-node-index bitmap bit)]\n      (if (zero? (bit-and bitmap bit))\n        (let [n (bit-count bitmap)]\n          (cond\n            (< (* 2 n) (alength arr))\n            (let [editable (.ensure-editable inode edit)\n                  earr     (.-arr editable)]\n              (set! (.-val added-leaf?) true)\n              (array-copy-downward earr (* 2 idx)\n                                   earr (* 2 (inc idx))\n                                   (* 2 (- n idx)))\n              (aset earr (* 2 idx) key)\n              (aset earr (inc (* 2 idx)) val)\n              (set! (.-bitmap editable) (bit-or (.-bitmap editable) bit))\n              editable)\n\n            (>= n 16)\n            (let [nodes (make-array 32)\n                  jdx   (mask hash shift)]\n              (aset nodes jdx (.inode-assoc! (.-EMPTY BitmapIndexedNode) edit (+ shift 5) hash key val added-leaf?))\n              (loop [i 0 j 0]\n                (if (< i 32)\n                  (if (zero? (bit-and (bit-shift-right-zero-fill bitmap i) 1))\n                    (recur (inc i) j)\n                    (do (aset nodes i\n                              (if-not (nil? (aget arr j))\n                                (.inode-assoc! (.-EMPTY BitmapIndexedNode)\n                                               edit (+ shift 5) (cljs.core/hash (aget arr j)) (aget arr j) (aget arr (inc j)) added-leaf?)\n                                (aget arr (inc j))))\n                        (recur (inc i) (+ j 2))))))\n              (ArrayNode. edit (inc n) nodes))\n\n            :else\n            (let [new-arr (make-array (* 2 (+ n 4)))]\n              (array-copy arr 0 new-arr 0 (* 2 idx))\n              (aset new-arr (* 2 idx) key)\n              (aset new-arr (inc (* 2 idx)) val)\n              (array-copy arr (* 2 idx) new-arr (* 2 (inc idx)) (* 2 (- n idx)))\n              (set! (.-val added-leaf?) true)\n              (let [editable (.ensure-editable inode edit)]\n                (set! (.-arr editable) new-arr)\n                (set! (.-bitmap editable) (bit-or (.-bitmap editable) bit))\n                editable))))\n        (let [key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil)\n                (let [n (.inode-assoc! val-or-node edit (+ shift 5) hash key val added-leaf?)]\n                  (if (identical? n val-or-node)\n                    inode\n                    (edit-and-set inode edit (inc (* 2 idx)) n)))\n\n                (key-test key key-or-nil)\n                (if (identical? val val-or-node)\n                  inode\n                  (edit-and-set inode edit (inc (* 2 idx)) val))\n\n                :else\n                (do (set! (.-val added-leaf?) true)\n                    (edit-and-set inode edit (* 2 idx) nil (inc (* 2 idx))\n                                  (create-node edit (+ shift 5) key-or-nil val-or-node hash key val))))))))\n\n  (inode-without! [inode edit shift hash key removed-leaf?]\n    (let [bit (bitpos hash shift)]\n      (if (zero? (bit-and bitmap bit))\n        inode\n        (let [idx         (bitmap-indexed-node-index bitmap bit)\n              key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil)\n                (let [n (.inode-without! val-or-node edit (+ shift 5) hash key removed-leaf?)]\n                  (cond (identical? n val-or-node) inode\n                        (not (nil? n)) (edit-and-set inode edit (inc (* 2 idx)) n)\n                        (== bitmap bit) nil\n                        :else (.edit-and-remove-pair inode edit bit idx)))\n                (key-test key key-or-nil)\n                (do (set! (.-val removed-leaf?) true)\n                    (.edit-and-remove-pair inode edit bit idx))\n                :else inode)))))\n\n  (kv-reduce [inode f init]\n    (inode-kv-reduce arr f init))\n\n  IIterable\n  (-iterator [coll]\n    (NodeIterator. arr 0 nil nil)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/cljs/cljs/core.cljs",
                                                   :lines [7459 7659]},
                                          :full-name "cljs.core/BitmapIndexedNode"},
           "warnings/protocol-multiple-impls" {:ns "warnings",
                                               :name "protocol-multiple-impls",
                                               :name-encode "protocol-multiple-impls",
                                               :type "warning",
                                               :full-name-encode "warnings/protocol-multiple-impls",
                                               :full-name "warnings/protocol-multiple-impls",
                                               :history [["+"
                                                          "0.0-2341"]]},
           "cljs.repl.node/close-socket" {:ns "cljs.repl.node",
                                          :name "close-socket",
                                          :signature ["[s]"],
                                          :name-encode "close-socket",
                                          :history [["+" "0.0-2629"]],
                                          :type "function",
                                          :full-name-encode "cljs.repl.node/close-socket",
                                          :source {:code "(defn close-socket [s]\n  (.close (:in s))\n  (.close (:out s))\n  (.close (:socket s)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/clojure/cljs/repl/node.clj",
                                                   :lines [41 44]},
                                          :full-name "cljs.repl.node/close-socket"},
           "cljs.spec/unstrument" {:ns "cljs.spec",
                                   :name "unstrument",
                                   :signature ["[v]"],
                                   :name-encode "unstrument",
                                   :history [["+" "1.9.14"]
                                             ["-" "1.9.183"]],
                                   :type "macro",
                                   :full-name-encode "cljs.spec/unstrument",
                                   :source {:code "(defmacro unstrument\n  [v]\n  (let [v   (if-not (seq? v) (list 'var v) v)\n        sym (second v)]\n    `(do\n       (when-let [raw# (cljs.spec/unstrument* ~v)]\n         (set! ~sym raw#))\n       ~v)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.9.93",
                                            :filename "src/main/cljs/cljs/spec.cljc",
                                            :lines [450 458]},
                                   :full-name "cljs.spec/unstrument",
                                   :docstring "Undoes instrument on the var at v, a var or symbol. Idempotent.",
                                   :removed {:in "1.9.183",
                                             :last-seen "1.9.93"}},
           "cljs.spec.impl.gen/elements" {:ns "cljs.spec.impl.gen",
                                          :name "elements",
                                          :signature ["[& args]"],
                                          :name-encode "elements",
                                          :history [["+" "1.9.14"]
                                                    ["-" "1.9.542"]],
                                          :type "function",
                                          :full-name-encode "cljs.spec.impl.gen/elements",
                                          :source {:code "(lazy-combinators hash-map list map not-empty set vector vector-distinct fmap elements\n  bind choose one-of such-that tuple sample return\n  large-integer* double* frequency)",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.9.521",
                                                   :filename "src/main/cljs/cljs/spec/impl/gen.cljs",
                                                   :lines [69 71]},
                                          :full-name "cljs.spec.impl.gen/elements",
                                          :docstring "Lazy loaded version of clojure.test.check.generators/elements",
                                          :removed {:in "1.9.542",
                                                    :last-seen "1.9.521"}},
           "cljs.reader/read-past" {:ns "cljs.reader",
                                    :name "read-past",
                                    :signature ["[pred rdr]"],
                                    :name-encode "read-past",
                                    :history [["+" "0.0-927"]
                                              ["-" "1.9.854"]],
                                    :type "function",
                                    :full-name-encode "cljs.reader/read-past",
                                    :source {:code "(defn read-past\n  [pred rdr]\n  (loop [ch (read-char rdr)]\n    (if (pred ch)\n      (recur (read-char rdr))\n      ch)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.9.671",
                                             :filename "src/main/cljs/cljs/reader.cljs",
                                             :lines [217 224]},
                                    :full-name "cljs.reader/read-past",
                                    :docstring "Read until first character that doesn't match pred, returning\nchar.",
                                    :removed {:in "1.9.854",
                                              :last-seen "1.9.671"}},
           "cljs.repl.browser/load-javascript" {:ns "cljs.repl.browser",
                                                :name "load-javascript",
                                                :signature ["[repl-env provides url]"],
                                                :name-encode "load-javascript",
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.repl.browser/load-javascript",
                                                :source {:code "(defn load-javascript\n  [repl-env provides url]\n  (browser-eval (slurp url)))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1.12.38",
                                                         :filename "src/main/clojure/cljs/repl/browser.clj",
                                                         :lines [325
                                                                 332]},
                                                :full-name "cljs.repl.browser/load-javascript",
                                                :docstring "Accepts a REPL environment, a list of namespaces, and a URL for a\nJavaScript file which contains the implementation for the list of\nnamespaces. Will load the JavaScript file into the REPL environment\nif any of the namespaces have not already been loaded from the\nClojureScript REPL."},
           "cljs.core/to-array" {:ns "cljs.core",
                                 :name "to-array",
                                 :signature ["[coll]"],
                                 :name-encode "to-array",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/to-array",
                                 :source {:code "(defn to-array\n  [coll]\n  (let [ary (array)]\n    (loop [s (seq coll)]\n      (if-not (nil? s)\n        (do (. ary push (first s))\n            (recur (next s)))\n        ary))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [3735 3743]},
                                 :full-name "cljs.core/to-array",
                                 :docstring "Returns an array containing the contents of coll."},
           "cljs.core/interpose" {:ns "cljs.core",
                                  :name "interpose",
                                  :signature ["[sep]" "[sep coll]"],
                                  :name-encode "interpose",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/interpose",
                                  :source {:code "(defn interpose\n  ([sep]\n    (fn [rf]\n      (let [started (volatile! false)]\n        (fn\n          ([] (rf))\n          ([result] (rf result))\n          ([result input]\n            (if @started\n              (let [sepr (rf result sep)]\n                (if (reduced? sepr)\n                  sepr\n                  (rf sepr input)))\n              (do\n                (vreset! started true)\n                (rf result input))))))))\n  ([sep coll] (drop 1 (interleave (repeat sep) coll))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [5230 5248]},
                                  :full-name "cljs.core/interpose",
                                  :docstring "Returns a lazy seq of the elements of coll separated by sep.\nReturns a stateful transducer when no collection is provided."},
           "cljs.core/IMapEntry" {:ns "cljs.core",
                                  :name "IMapEntry",
                                  :name-encode "IMapEntry",
                                  :implementations #{"RedNode"
                                                     "BlackNode"
                                                     "MapEntry"},
                                  :history [["+" "0.0-1211"]],
                                  :type "protocol",
                                  :full-name-encode "cljs.core/IMapEntry",
                                  :source {:code "(defprotocol IMapEntry\n  (-key [coll]\n    \"Returns the key of the map entry.\")\n  (-val [coll]\n    \"Returns the value of the map entry.\"))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [663 668]},
                                  :methods [{:name "-key",
                                             :signature ["[coll]"],
                                             :docstring "Returns the key of the map entry."}
                                            {:name "-val",
                                             :signature ["[coll]"],
                                             :docstring "Returns the value of the map entry."}],
                                  :full-name "cljs.core/IMapEntry",
                                  :docstring "Protocol for examining a map entry."},
           "clojure.browser.net/ICrossPageChannel" {:ns "clojure.browser.net",
                                                    :name "ICrossPageChannel",
                                                    :name-encode "ICrossPageChannel",
                                                    :history [["+"
                                                               "0.0-927"]],
                                                    :type "protocol",
                                                    :full-name-encode "clojure.browser.net/ICrossPageChannel",
                                                    :source {:code "(defprotocol ICrossPageChannel\n  (register-service [this service-name fn] [this service-name fn encode-json?]))",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r1.12.38",
                                                             :filename "src/main/cljs/clojure/browser/net.cljs",
                                                             :lines [87
                                                                     88]},
                                                    :methods [{:name "register-service",
                                                               :signature ["[this service-name fn]"
                                                                           "[this service-name fn encode-json?]"],
                                                               :docstring nil}],
                                                    :full-name "clojure.browser.net/ICrossPageChannel"},
           "cljs.core/Cons" {:protocols #{"ISeqable"
                                          "IMeta"
                                          "IWithMeta"
                                          "IEmptyableCollection"
                                          "IReduce"
                                          "ISequential"
                                          "ISeq"
                                          "ICollection"
                                          "IHash"
                                          "ASeq"
                                          "IPrintWithWriter"
                                          "INext"
                                          "IEquiv"
                                          "ICloneable"
                                          "IList"},
                             :ns "cljs.core",
                             :name "Cons",
                             :signature ["[meta first rest __hash]"],
                             :name-encode "Cons",
                             :history [["+" "0.0-927"]],
                             :type "type",
                             :full-name-encode "cljs.core/Cons",
                             :source {:code "(deftype Cons [meta first rest ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IList\n\n  ICloneable\n  (-clone [_] (Cons. meta first rest __hash))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (Cons. new-meta first rest __hash)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ASeq\n  ISeq\n  (-first [coll] first)\n  (-rest [coll] (if (nil? rest) () rest))\n\n  INext\n  (-next [coll]\n    (if (nil? rest) nil (seq rest)))\n\n  ICollection\n  (-conj [coll o] (Cons. nil o coll nil))\n\n  IEmptyableCollection\n  (-empty [coll] (.-EMPTY List))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [3313 3369]},
                             :full-name "cljs.core/Cons"},
           "cljs.spec.alpha/cat" {:ns "cljs.spec.alpha",
                                  :name "cat",
                                  :signature ["[& key-pred-forms]"],
                                  :name-encode "cat",
                                  :history [["+" "1.9.542"]],
                                  :type "macro",
                                  :full-name-encode "cljs.spec.alpha/cat",
                                  :source {:code "(defmacro cat\n  [& key-pred-forms]\n  (let [pairs (partition 2 key-pred-forms)\n        keys (mapv first pairs)\n        pred-forms (mapv second pairs)\n        pf (mapv #(res &env %) pred-forms)]\n    ;;(prn key-pred-forms)\n    (clojure.core/assert (clojure.core/and (even? (count key-pred-forms)) (every? keyword? keys)) \"cat expects k1 p1 k2 p2..., where ks are keywords\")\n    `(cat-impl ~keys ~pred-forms '~pf)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/spec/alpha.cljc",
                                           :lines [356 370]},
                                  :full-name "cljs.spec.alpha/cat",
                                  :docstring "Takes key+pred pairs, e.g.\n\n(s/cat :e even? :o odd?)\n\nReturns a regex op that matches (all) values in sequence, returning a map\ncontaining the keys of each pred and the corresponding value."},
           "cljs.core/re-find" {:ns "cljs.core",
                                :name "re-find",
                                :signature ["[re s]"],
                                :name-encode "re-find",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/re-find",
                                :source {:code "(defn re-find\n  [re s]\n  (if (string? s)\n    (let [matches (.exec re s)]\n      (when-not (nil? matches)\n        (if (== (count ^array matches) 1)\n          (aget matches 0)\n          (vec matches))))\n    (throw (js/TypeError. \"re-find must match against a string.\"))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [10392 10404]},
                                :full-name "cljs.core/re-find",
                                :docstring "Returns the first regex match, if any, of s to re, using\nre.exec(s). Returns a vector, containing first the matching\nsubstring, then any capturing groups if the regular expression contains\ncapturing groups."},
           "cljs.core/IMeta" {:ns "cljs.core",
                              :name "IMeta",
                              :name-encode "IMeta",
                              :implementations #{"Subvec"
                                                 "Symbol"
                                                 "Cycle"
                                                 "PersistentQueue"
                                                 "PersistentHashMap"
                                                 "PersistentTreeSet"
                                                 "PersistentArrayMapSeq"
                                                 "RedNode"
                                                 "EmptyList"
                                                 "ObjMap"
                                                 "MetaFn"
                                                 "Iterate"
                                                 "BlackNode"
                                                 "PersistentVector"
                                                 "ValSeq"
                                                 "IntegerRange"
                                                 "ChunkedCons"
                                                 "Range"
                                                 "PersistentQueueSeq"
                                                 "ChunkedSeq"
                                                 "ArrayNodeSeq"
                                                 "KeySeq"
                                                 "IndexedSeq"
                                                 "PersistentTreeMap"
                                                 "PersistentTreeMapSeq"
                                                 "RSeq"
                                                 "function"
                                                 "PersistentArrayMap"
                                                 "PersistentHashSet"
                                                 "NodeSeq"
                                                 "List"
                                                 "Atom"
                                                 "Repeat"
                                                 "Cons"
                                                 "Var"
                                                 "LazySeq"
                                                 "MapEntry"},
                              :history [["+" "0.0-927"]],
                              :type "protocol",
                              :full-name-encode "cljs.core/IMeta",
                              :source {:code "(defprotocol IMeta\n  (^clj-or-nil -meta [o]\n    \"Returns the metadata of object o.\"))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [698 701]},
                              :methods [{:name "-meta",
                                         :signature ["[o]"],
                                         :docstring "Returns the metadata of object o."}],
                              :full-name "cljs.core/IMeta",
                              :docstring "Protocol for accessing the metadata of an object."},
           "cljs.core/js-str" {:ns "cljs.core",
                               :name "js-str",
                               :signature ["[s]"],
                               :name-encode "js-str",
                               :history [["+" "0.0-2341"]],
                               :type "macro",
                               :full-name-encode "cljs.core/js-str",
                               :source {:code "(core/defmacro js-str [s]\n  (core/list 'js* \"''+~{}\" s))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/clojure/cljs/core.cljc",
                                        :lines [2913 2914]},
                               :full-name "cljs.core/js-str"},
           "cljs.spec.test/abbrev-result" {:ns "cljs.spec.test",
                                           :name "abbrev-result",
                                           :signature ["[x]"],
                                           :name-encode "abbrev-result",
                                           :history [["+" "1.9.183"]
                                                     ["-" "1.9.542"]],
                                           :type "function",
                                           :full-name-encode "cljs.spec.test/abbrev-result",
                                           :source {:code "(defn abbrev-result\n  [x]\n  (if (:failure x)\n    (-> (dissoc x ::stc/ret)\n      (update :spec s/describe)\n      (update :failure unwrap-failure))\n    (dissoc x :spec ::stc/ret)))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.9.521",
                                                    :filename "src/main/cljs/cljs/spec/test.cljs",
                                                    :lines [259 267]},
                                           :full-name "cljs.spec.test/abbrev-result",
                                           :docstring "Given a check result, returns an abbreviated version\nsuitable for summary use.",
                                           :removed {:in "1.9.542",
                                                     :last-seen "1.9.521"}},
           "cljs.analyzer.api/warning-message" {:ns "cljs.analyzer.api",
                                                :name "warning-message",
                                                :signature ["[warn-type warn-info]"],
                                                :name-encode "warning-message",
                                                :history [["+"
                                                           "1.10.738"]],
                                                :type "function",
                                                :full-name-encode "cljs.analyzer.api/warning-message",
                                                :source {:code "(defn warning-message\n  [warn-type warn-info]\n  (ana/error-message warn-type warn-info))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1.12.38",
                                                         :filename "src/main/clojure/cljs/analyzer/api.cljc",
                                                         :lines [91
                                                                 95]},
                                                :full-name "cljs.analyzer.api/warning-message",
                                                :docstring "Helper for generating the standard analyzer messages for warnings. Should be\npassed warn-type and warn-info. See with-warning-handlers."},
           "cljs.repl/repl*" {:ns "cljs.repl",
                              :name "repl*",
                              :signature ["[repl-env {:keys [init inits need-prompt quit-prompt prompt flush read eval print caught reader print-no-newline source-map-inline wrap repl-requires :user/fast-initial-prompt? compiler-env bind-err], :or {caught repl-caught, quit-prompt repl-title, eval eval-cljs, print-no-newline print, flush flush, fast-initial-prompt? false, read repl-read, bind-err true, print println, source-map-inline true, prompt repl-prompt, repl-requires (quote [[cljs.repl :refer-macros [source doc find-doc apropos dir pst]] [cljs.pprint :refer [pprint] :refer-macros [pp]]]), reader (fn* [] (readers/source-logging-push-back-reader *in* 1 \"<NO_SOURCE_FILE>\")), need-prompt (fn* [] (if (readers/indexing-reader? *in*) (== (readers/get-column-number *in*) 1) (identity true)))}, :as opts}]"],
                              :name-encode "replSTAR",
                              :history [["+" "0.0-2629"]],
                              :type "function",
                              :full-name-encode "cljs.repl/replSTAR",
                              :source {:code "(defn repl*\n  [repl-env {:keys [init inits need-prompt quit-prompt prompt flush read eval print caught reader\n                    print-no-newline source-map-inline wrap repl-requires ::fast-initial-prompt?\n                    compiler-env bind-err]\n             :or {need-prompt #(if (readers/indexing-reader? *in*)\n                                (== (readers/get-column-number *in*) 1)\n                                (identity true))\n                  fast-initial-prompt? false\n                  quit-prompt repl-title\n                  prompt repl-prompt\n                  flush flush\n                  read repl-read\n                  eval eval-cljs\n                  print println\n                  caught repl-caught\n                  reader #(readers/source-logging-push-back-reader\n                           *in*\n                           1 \"<NO_SOURCE_FILE>\")\n                  print-no-newline print\n                  source-map-inline true\n                  repl-requires '[[cljs.repl :refer-macros [source doc find-doc apropos dir pst]]\n                                  [cljs.pprint :refer [pprint] :refer-macros [pp]]]\n                  bind-err true}\n             :as opts}]\n  ;; bridge clojure.tools.reader to satisfy the old contract\n  (when (and (find-ns 'clojure.tools.reader)\n             (not (find-ns 'cljs.vendor.bridge)))\n    (require 'cljs.vendor.bridge))\n  (doseq [[unknown-opt suggested-opt] (util/unknown-opts (set (keys opts)) (set/union known-repl-opts cljsc/known-opts))]\n    (when suggested-opt\n      (println (str \"WARNING: Unknown option '\" unknown-opt \"'. Did you mean '\" suggested-opt \"'?\"))))\n  (when (true? fast-initial-prompt?)\n    (initial-prompt quit-prompt prompt))\n  (let [repl-opts (-repl-options repl-env)\n        repl-requires (into repl-requires (:repl-requires repl-opts))\n        {:keys [analyze-path repl-verbose warn-on-undeclared special-fns\n                checked-arrays static-fns fn-invoke-direct]\n         :as opts\n         :or   {warn-on-undeclared true}}\n        (merge\n          {:def-emits-var true}\n          (cljsc/add-implicit-options\n            (merge-with (fn [a b] (if (nil? b) a b))\n              repl-opts\n              opts\n              {:prompt prompt\n               :need-prompt need-prompt\n               :flush flush\n               :read read\n               :print print\n               :caught caught\n               :reader reader\n               :print-no-newline print-no-newline\n               :source-map-inline source-map-inline})))\n        done? (atom false)]\n    (env/with-compiler-env (or compiler-env env/*compiler* (env/default-compiler-env opts))\n     (when (:source-map opts)\n       (.start (Thread. (bound-fn [] (read-source-map \"cljs/core.aot.js\")))))\n     (binding [*repl-env* repl-env\n               ana/*unchecked-if* false\n               ana/*unchecked-arrays* false\n               *err* (if bind-err\n                       (cond-> *out*\n                         (not (instance? PrintWriter *out*)) (PrintWriter.))\n                       *err*)\n               ana/*cljs-ns* ana/*cljs-ns*\n               *cljs-verbose* repl-verbose\n               ana/*cljs-warnings*\n               (let [warnings (opts :warnings)]\n                 (merge\n                   ana/*cljs-warnings*\n                   (if (or (true? warnings)\n                           (false? warnings))\n                     (zipmap (keys ana/*cljs-warnings*) (repeat warnings))\n                     warnings)\n                   (zipmap\n                     [:unprovided :undeclared-var\n                      :undeclared-ns :undeclared-ns-form]\n                     (repeat (if (false? warnings)\n                               false\n                               warn-on-undeclared)))\n                   {:infer-warning false}))\n               ana/*checked-arrays* checked-arrays\n               ana/*cljs-static-fns* static-fns\n               ana/*fn-invoke-direct* (and static-fns fn-invoke-direct)\n               *repl-opts* opts]\n       (try\n         (let [env (assoc (ana/empty-env) :context :expr)\n               special-fns (merge default-special-fns special-fns)\n               is-special-fn? (set (keys special-fns))\n               request-prompt (Object.)\n               request-exit (Object.)\n               opts (comp/with-core-cljs opts\n                      (fn []\n                        (if-let [merge-opts (:merge-opts (-setup repl-env opts))]\n                          (merge opts merge-opts)\n                          opts)))\n               _    (when (= :after-setup fast-initial-prompt?)\n                      (initial-prompt quit-prompt prompt))\n               init (do\n                      (evaluate-form repl-env env \"<cljs repl>\"\n                        `(~'set! ~'cljs.core/*print-namespace-maps* true)\n                        identity opts)\n                      (or init\n                        #(evaluate-form repl-env env \"<cljs repl>\"\n                           (with-meta\n                             `(~'ns ~'cljs.user\n                                (:require ~@repl-requires))\n                             {:line 1 :column 1})\n                           identity opts)))\n               maybe-load-user-file #(when-let [user-resource (util/ns->source 'user)]\n                                       (when (= \"file\" (.getProtocol ^URL user-resource))\n                                         (load-file repl-env (io/file user-resource) opts)))\n               read-eval-print\n               (fn []\n                 (let [input (binding [*ns* (create-ns ana/*cljs-ns*)\n                                       reader/resolve-symbol ana/resolve-symbol\n                                       reader/*data-readers* (merge tags/*cljs-data-readers*\n                                                               (ana/load-data-readers))\n                                       reader/*alias-map* (ana/get-aliases ana/*cljs-ns*)]\n                               (try\n                                 (read request-prompt request-exit)\n                                 (catch Throwable e\n                                   (throw (ex-info nil {:clojure.error/phase :read-source} e)))))]\n                   (or ({request-exit request-exit\n                         :cljs/quit request-exit\n                         request-prompt request-prompt} input)\n                     (if (and (seq? input) (is-special-fn? (first input)))\n                       (do\n                         ((get special-fns (first input)) repl-env env input opts)\n                         (print nil))\n                       (let [value (eval repl-env env input opts)]\n                         (try\n                           (print value)\n                           (catch Throwable e\n                             (throw (ex-info nil {:clojure.error/phase :print-eval-result} e)))))))))]\n           (maybe-install-npm-deps opts)\n           (comp/with-core-cljs opts\n             (fn []\n               (binding [*repl-opts* opts]\n                 (try\n                   (when analyze-path\n                     (if (vector? analyze-path)\n                       (run! #(analyze-source % opts) analyze-path)\n                       (analyze-source analyze-path opts)))\n                   (when-let [main-ns (:main opts)]\n                     (.start\n                       (Thread.\n                         (bound-fn [] (ana/analyze-file (util/ns->source main-ns))))))\n                   (init)\n                   (run-inits repl-env inits)\n                   (maybe-load-user-file)\n                   (catch Throwable e\n                     (caught e repl-env opts)))\n                 (when-let [src (:watch opts)]\n                   (.start\n                     (Thread.\n                       ((ns-resolve 'clojure.core 'binding-conveyor-fn)\n                         (fn []\n                           (let [log-file (io/file (util/output-directory opts) \"watch.log\")]\n                             (err-out (println \"Watch compilation log available at:\" (str log-file)))\n                             (try\n                               (let [log-out (FileWriter. log-file)]\n                                 (binding [*err* log-out\n                                           *out* log-out]\n                                   (cljsc/watch src (dissoc opts :watch)\n                                     env/*compiler* done?)))\n                               (catch Throwable e\n                                 (caught e repl-env opts)))))))))\n                 ;; let any setup async messages flush\n                 (Thread/sleep 50)\n                 (binding [*in* (if (true? (:source-map-inline opts))\n                                  *in*\n                                  (reader))]\n                   (when-not fast-initial-prompt?\n                     (initial-prompt quit-prompt prompt))\n                   (loop []\n                     (when-not\n                       (try\n                         (identical? (read-eval-print) request-exit)\n                         (catch Throwable e\n                           (caught e repl-env opts)\n                           nil))\n                       (when (need-prompt)\n                         (prompt)\n                         (flush))\n                       (recur))))))))\n         (catch Throwable t\n           (throw\n             (ex-info \"Unexpected error during REPL initialization\"\n               {::error :init-failed} t)))\n         (finally\n           (reset! done? true)\n           (-tear-down repl-env)))))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/clojure/cljs/repl.cljc",
                                       :lines [1033 1226]},
                              :full-name "cljs.repl/repl*"},
           "cljs.spec.impl.gen/symbol" {:ns "cljs.spec.impl.gen",
                                        :name "symbol",
                                        :signature ["[& args]"],
                                        :name-encode "symbol",
                                        :history [["+" "1.9.14"]
                                                  ["-" "1.9.542"]],
                                        :type "function",
                                        :full-name-encode "cljs.spec.impl.gen/symbol",
                                        :source {:code "(lazy-prims any any-printable boolean char char-alpha char-alphanumeric char-ascii double\n  int keyword keyword-ns large-integer ratio simple-type simple-type-printable\n  string string-ascii string-alphanumeric symbol symbol-ns uuid)",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.9.521",
                                                 :filename "src/main/cljs/cljs/spec/impl/gen.cljs",
                                                 :lines [73 75]},
                                        :full-name "cljs.spec.impl.gen/symbol",
                                        :docstring "Fn returning clojure.test.check.generators/symbol",
                                        :removed {:in "1.9.542",
                                                  :last-seen "1.9.521"}},
           "cljs.test/are" {:ns "cljs.test",
                            :name "are",
                            :signature ["[argv expr & args]"],
                            :name-encode "are",
                            :history [["+" "0.0-2629"]],
                            :type "macro",
                            :full-name-encode "cljs.test/are",
                            :source {:code "(defmacro are\n  [argv expr & args]\n  (if (or\n        ;; (are [] true) is meaningless but ok\n        (and (empty? argv) (empty? args))\n        ;; Catch wrong number of args\n        (and (pos? (count argv))\n          (pos? (count args))\n          (zero? (mod (count args) (count argv)))))\n    `(clojure.template/do-template ~argv (is ~expr) ~@args)\n    (throw (#?(:clj Exception. :cljs js/Error.) \"The number of args doesn't match are's argv.\"))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/cljs/cljs/test.cljc",
                                     :lines [192 214]},
                            :full-name "cljs.test/are",
                            :docstring "Checks multiple assertions with a template expression.\nSee clojure.template/do-template for an explanation of\ntemplates.\n\nExample: (are [x y] (= x y)  \n              2 (+ 1 1)\n              4 (* 2 2))\nExpands to: \n         (do (is (= 2 (+ 1 1)))\n             (is (= 4 (* 2 2))))\n\nNote: This breaks some reporting features, such as line numbers."},
           "cljs.spec/or" {:ns "cljs.spec",
                           :name "or",
                           :signature ["[& key-pred-forms]"],
                           :name-encode "or",
                           :history [["+" "1.9.14"] ["-" "1.9.542"]],
                           :type "macro",
                           :full-name-encode "cljs.spec/or",
                           :source {:code "(defmacro or\n  [& key-pred-forms]\n  (let [pairs (partition 2 key-pred-forms)\n        keys (mapv first pairs)\n        pred-forms (mapv second pairs)\n        pf (mapv #(res &env %) pred-forms)]\n    (clojure.core/assert (clojure.core/and (even? (count key-pred-forms)) (every? keyword? keys)) \"spec/or expects k1 p1 k2 p2..., where ks are keywords\")\n    `(or-spec-impl ~keys '~pf ~pred-forms nil)))",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r1.9.521",
                                    :filename "src/main/cljs/cljs/spec.cljc",
                                    :lines [177 192]},
                           :full-name "cljs.spec/or",
                           :docstring "Takes key+pred pairs, e.g.\n\n(s/or :even even? :small #(< % 42))\n\nReturns a destructuring spec that returns a map entry containing the\nkey of the first matching pred and the corresponding value. Thus the\n'key' and 'val' functions can be used to refer generically to the\ncomponents of the tagged return.",
                           :removed {:in "1.9.542",
                                     :last-seen "1.9.521"}},
           "cljs.core/RangeIterator" {:ns "cljs.core",
                                      :name "RangeIterator",
                                      :signature ["[i end step]"],
                                      :name-encode "RangeIterator",
                                      :history [["+" "0.0-2371"]],
                                      :type "type",
                                      :full-name-encode "cljs.core/RangeIterator",
                                      :source {:code "(deftype RangeIterator [^:mutable i end step]\n  Object\n  (hasNext [_]\n    (if (pos? step)\n      (< i end)\n      (> i end)))\n  (next [_]\n    (let [ret i]\n      (set! i (+ i step))\n      ret)))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [9937 9946]},
                                      :full-name "cljs.core/RangeIterator"},
           "cljs.core/iterator" {:ns "cljs.core",
                                 :name "iterator",
                                 :signature ["[coll]"],
                                 :name-encode "iterator",
                                 :history [["+" "0.0-2268"]
                                           ["-" "0.0-2371"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/iterator",
                                 :source {:code "(defn iterator [coll]\n  (Iterator. (seq coll)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2356",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [4870 4871]},
                                 :full-name "cljs.core/iterator",
                                 :removed {:in "0.0-2371",
                                           :last-seen "0.0-2356"}},
           "cljs.core/assoc-in" {:ns "cljs.core",
                                 :name "assoc-in",
                                 :signature ["[m [k & ks] v]"],
                                 :name-encode "assoc-in",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/assoc-in",
                                 :source {:code "(defn assoc-in\n  [m [k & ks] v]\n  (if ks\n    (assoc m k (assoc-in (get m k) ks v))\n    (assoc m k v)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [5427 5434]},
                                 :full-name "cljs.core/assoc-in",
                                 :docstring "Associates a value in a nested associative structure, where ks is a\nsequence of keys and v is the new value and returns a new nested structure.\nIf any levels do not exist, hash-maps will be created."},
           "compiler-options/verbose" {:ns "compiler-options",
                                       :name "verbose",
                                       :name-encode "verbose",
                                       :type "option",
                                       :full-name-encode "compiler-options/verbose",
                                       :full-name "compiler-options/verbose",
                                       :history [["+" "0.0-971"]]},
           "closure-warnings/misplaced-msg-annotation" {:ns "closure-warnings",
                                                        :name "misplaced-msg-annotation",
                                                        :name-encode "misplaced-msg-annotation",
                                                        :type "warning",
                                                        :full-name-encode "closure-warnings/misplaced-msg-annotation",
                                                        :full-name "closure-warnings/misplaced-msg-annotation",
                                                        :history [["+"
                                                                   "1.10.217"]]},
           "closure-warnings/undefined-variables" {:ns "closure-warnings",
                                                   :name "undefined-variables",
                                                   :name-encode "undefined-variables",
                                                   :type "warning",
                                                   :full-name-encode "closure-warnings/undefined-variables",
                                                   :full-name "closure-warnings/undefined-variables",
                                                   :history [["+"
                                                              "0.0-2120"]]},
           "clojure.string/join" {:ns "clojure.string",
                                  :name "join",
                                  :signature ["[coll]"
                                              "[separator coll]"],
                                  :name-encode "join",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.string/join",
                                  :source {:code "(defn join\n  ([coll]\n   (loop [sb (StringBuffer.) coll (seq coll)]\n     (if-not (nil? coll)\n       (recur (. sb (append (str (first coll)))) (next coll))\n       ^string (.toString sb))))\n  ([separator coll]\n   (loop [sb (StringBuffer.) coll (seq coll)]\n     (if-not (nil? coll)\n       (do\n         (. sb (append (str (first coll))))\n         (let [coll (next coll)]\n           (when-not (nil? coll)\n             (. sb (append separator)))\n           (recur sb coll)))\n       ^string (.toString sb)))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/clojure/string.cljs",
                                           :lines [100 117]},
                                  :full-name "clojure.string/join",
                                  :docstring "Returns a string of all elements in coll, as returned by (seq coll),\nseparated by an optional separator."},
           "cljs.core/*unchecked-if*" {:ns "cljs.core",
                                       :name "*unchecked-if*",
                                       :name-encode "STARunchecked-ifSTAR",
                                       :type "var",
                                       :full-name-encode "cljs.core/STARunchecked-ifSTAR",
                                       :source {:code "(def *unchecked-if* false)",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/core.cljs",
                                                :lines [26]},
                                       :full-name "cljs.core/*unchecked-if*",
                                       :history [["+" "0.0-1211"]]},
           "cljs.build.api/output-unoptimized" {:ns "cljs.build.api",
                                                :name "output-unoptimized",
                                                :signature ["[opts & sources]"],
                                                :name-encode "output-unoptimized",
                                                :history [["+"
                                                           "0.0-3291"]],
                                                :type "function",
                                                :full-name-encode "cljs.build.api/output-unoptimized",
                                                :source {:code "(defn output-unoptimized\n  [opts & sources]\n  (apply closure/output-unoptimized opts sources))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1.12.38",
                                                         :filename "src/main/clojure/cljs/build/api.clj",
                                                         :lines [202
                                                                 210]},
                                                :full-name "cljs.build.api/output-unoptimized",
                                                :docstring "Ensure that all JavaScript source files are on disk (not in jars),\nwrite the goog deps file including only the libraries that are being\nused and write the deps file for the current project.\n\nThe deps file for the current project will include third-party\nlibraries."},
           "cljs.core/some?" {:return-type boolean,
                              :ns "cljs.core",
                              :name "some?",
                              :signature ["[x]"],
                              :name-encode "someQMARK",
                              :history [["+" "0.0-2261"]],
                              :type "function/macro",
                              :full-name-encode "cljs.core/someQMARK",
                              :source {:code "(defn ^boolean some?\n  [x] (not (nil? x)))",
                                       :title "Function code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [266 268]},
                              :extra-sources [{:code "(core/defmacro some? [x]\n  `(not (nil? ~x)))",
                                               :title "Macro code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/clojure/cljs/core.cljc",
                                               :lines [902 903]}],
                              :full-name "cljs.core/some?",
                              :docstring "Returns true if x is not nil, false otherwise."},
           "compiler-options/browser-repl" {:ns "compiler-options",
                                            :name "browser-repl",
                                            :name-encode "browser-repl",
                                            :type "option",
                                            :full-name-encode "compiler-options/browser-repl",
                                            :full-name "compiler-options/browser-repl",
                                            :history [["+" "1.9.183"]]},
           "cljs.core/seqable?" {:ns "cljs.core",
                                 :name "seqable?",
                                 :signature ["[s]"],
                                 :name-encode "seqableQMARK",
                                 :history [["+" "0.0-1211"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/seqableQMARK",
                                 :source {:code "(defn seqable?\n  [s]\n  (or\n    (nil? s)\n    (satisfies? ISeqable s)\n    (js-iterable? s)\n    (array? s)\n    (string? s)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [2306 2314]},
                                 :full-name "cljs.core/seqable?",
                                 :docstring "Return true if the seq function is supported for s"},
           "clojure.browser.repl/flush-print-queue!" {:ns "clojure.browser.repl",
                                                      :name "flush-print-queue!",
                                                      :signature ["[conn]"],
                                                      :name-encode "flush-print-queueBANG",
                                                      :history [["+"
                                                                 "1.7.48"]],
                                                      :type "function",
                                                      :full-name-encode "clojure.browser.repl/flush-print-queueBANG",
                                                      :source {:code "(defn flush-print-queue! [conn]\n  (doseq [str print-queue]\n    (net/transmit conn :print\n      (json/serialize\n        #js {\"repl\" *repl*\n             \"str\"  str})))\n  (garray/clear print-queue))",
                                                               :title "Source code",
                                                               :repo "clojurescript",
                                                               :tag "r1.12.38",
                                                               :filename "src/main/cljs/clojure/browser/repl.cljs",
                                                               :lines [43
                                                                       49]},
                                                      :full-name "clojure.browser.repl/flush-print-queue!"},
           "clojure.zip/rights" {:ns "clojure.zip",
                                 :name "rights",
                                 :signature ["[loc]"],
                                 :name-encode "rights",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "clojure.zip/rights",
                                 :source {:code "(defn rights\n  [loc]\n    (:r (loc 1)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/clojure/zip.cljs",
                                          :lines [92 95]},
                                 :full-name "clojure.zip/rights",
                                 :docstring "Returns a seq of the right siblings of this loc"},
           "cljs.core/split-at" {:ns "cljs.core",
                                 :name "split-at",
                                 :signature ["[n coll]"],
                                 :name-encode "split-at",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/split-at",
                                 :source {:code "(defn split-at\n  [n coll]\n  [(take n coll) (drop n coll)])",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [5019 5022]},
                                 :full-name "cljs.core/split-at",
                                 :docstring "Returns a vector of [(take n coll) (drop n coll)]"},
           "clojure.zip/append-child" {:ns "clojure.zip",
                                       :name "append-child",
                                       :signature ["[loc item]"],
                                       :name-encode "append-child",
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "clojure.zip/append-child",
                                       :source {:code "(defn append-child\n  [loc item]\n    (replace loc (make-node loc (node loc) (concat (children loc) [item]))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/clojure/zip.cljs",
                                                :lines [200 204]},
                                       :full-name "clojure.zip/append-child",
                                       :docstring "Inserts the item as the rightmost child of the node at this loc,\nwithout moving"},
           "cljs.core/binding" {:ns "cljs.core",
                                :name "binding",
                                :signature ["[bindings & body]"],
                                :name-encode "binding",
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :full-name-encode "cljs.core/binding",
                                :source {:code "(core/defmacro binding\n  [bindings & body]\n  (core/let [names (take-nth 2 bindings)]\n    (cljs.analyzer/confirm-bindings &env names)\n    `(with-redefs ~bindings ~@body)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/clojure/cljs/core.cljc",
                                         :lines [2286 2297]},
                                :full-name "cljs.core/binding",
                                :docstring "binding => var-symbol init-expr\n\nCreates new bindings for the (already-existing) vars, with the\nsupplied initial values, executes the exprs in an implicit do, then\nre-establishes the bindings that existed before.  The new bindings\nare made in parallel (unlike let); all init-exprs are evaluated\nbefore the vars are bound to their new values."},
           "compiler-options/libs" {:ns "compiler-options",
                                    :name "libs",
                                    :name-encode "libs",
                                    :type "option",
                                    :full-name-encode "compiler-options/libs",
                                    :full-name "compiler-options/libs",
                                    :history [["+" "0.0-971"]]},
           "repl-options/read" {:ns "repl-options",
                                :name "read",
                                :name-encode "read",
                                :type "option",
                                :full-name-encode "repl-options/read",
                                :full-name "repl-options/read",
                                :history [["+" "0.0-2911"]]},
           "cljs.spec/invalid?" {:ns "cljs.spec",
                                 :name "invalid?",
                                 :signature ["[ret]"],
                                 :name-encode "invalidQMARK",
                                 :history [["+" "1.9.456"]
                                           ["-" "1.9.542"]],
                                 :type "function",
                                 :full-name-encode "cljs.spec/invalidQMARK",
                                 :source {:code "(defn invalid?\n  [ret]\n  (keyword-identical? ::invalid ret))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.9.521",
                                          :filename "src/main/cljs/cljs/spec.cljs",
                                          :lines [144 147]},
                                 :full-name "cljs.spec/invalid?",
                                 :docstring "tests the validity of a conform return value",
                                 :removed {:in "1.9.542",
                                           :last-seen "1.9.521"}},
           "cljs.core/simple-keyword?" {:ns "cljs.core",
                                        :name "simple-keyword?",
                                        :signature ["[x]"],
                                        :name-encode "simple-keywordQMARK",
                                        :history [["+" "1.9.75"]],
                                        :type "function",
                                        :full-name-encode "cljs.core/simple-keywordQMARK",
                                        :source {:code "(defn simple-keyword?\n  [x] (and (keyword? x) (nil? (namespace x))))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/cljs/cljs/core.cljs",
                                                 :lines [3474 3476]},
                                        :full-name "cljs.core/simple-keyword?",
                                        :docstring "Return true if x is a keyword without a namespace"},
           "closure-warnings/missing-provide" {:ns "closure-warnings",
                                               :name "missing-provide",
                                               :name-encode "missing-provide",
                                               :type "warning",
                                               :full-name-encode "closure-warnings/missing-provide",
                                               :full-name "closure-warnings/missing-provide",
                                               :history [["+"
                                                          "1.9.473"]]},
           "closure-warnings/es3" {:ns "closure-warnings",
                                   :name "es3",
                                   :name-encode "es3",
                                   :type "warning",
                                   :full-name-encode "closure-warnings/es3",
                                   :full-name "closure-warnings/es3",
                                   :history [["+" "1.9.473"]
                                             ["-" "1.10.738"]],
                                   :removed {:in "1.10.738",
                                             :last-seen "1.10.597"}},
           "cljs.test/get-current-env" {:ns "cljs.test",
                                        :name "get-current-env",
                                        :signature ["[]"],
                                        :name-encode "get-current-env",
                                        :history [["+" "0.0-2496"]],
                                        :type "function",
                                        :full-name-encode "cljs.test/get-current-env",
                                        :source {:code "(defn get-current-env []\n  (or *current-env* (empty-env)))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/cljs/cljs/test.cljs",
                                                 :lines [271 272]},
                                        :full-name "cljs.test/get-current-env"},
           "cljs.math/floor-mod" {:return-type number,
                                  :ns "cljs.math",
                                  :name "floor-mod",
                                  :signature ["[x y]"],
                                  :name-encode "floor-mod",
                                  :history [["+" "1.11.50"]],
                                  :type "function",
                                  :full-name-encode "cljs.math/floor-mod",
                                  :source {:code "(defn ^number floor-mod\n  {:added \"1.11.10\"}\n  [x y]\n  (if-not (and ^boolean (js/Number.isSafeInteger x) ^boolean (js/Number.isSafeInteger y))\n    (throw (ex-info \"floor-mod called with non-safe-integer arguments\"\n                    {:x-int? (js/Number.isSafeInteger x) :y-int? (js/Number.isSafeInteger y)}))\n    ;; this avoids using floor-div to keep within the safe integer range\n    (let [r (long (/ x y))]\n      (if (and (xor (< x 0) (< y 0)) (not (== (* r y) x)))\n        (- x (* y r) (- y))\n        (- x (* y r))))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/math.cljs",
                                           :lines [584 597]},
                                  :full-name "cljs.math/floor-mod",
                                  :docstring "Integer modulus x - (floorDiv(x, y) * y). Sign matches y and is in the\nrange -|y| < r < |y|.\nSee: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#floorMod-long-long-"},
           "cljs.math/floor" {:return-type number,
                              :ns "cljs.math",
                              :name "floor",
                              :signature ["[a]"],
                              :name-encode "floor",
                              :history [["+" "1.11.50"]],
                              :type "function",
                              :full-name-encode "cljs.math/floor",
                              :source {:code "(defn ^number floor\n  {:added \"1.11.10\"}\n  [a]\n  (if (some? a)\n    (Math/floor a)\n    (throw (ex-info \"Unexpected Null passed to floor\" {:fn \"floor\"}))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/math.cljs",
                                       :lines [425 436]},
                              :full-name "cljs.math/floor",
                              :docstring "Returns the largest double less than or equal to a, and equal to a\nmathematical integer.\nIf a is ##NaN or ##Inf or ##-Inf or already equal to an integer => a\nIf a is less than zero but greater than -1.0 => -0.0\nNote that if a is `nil` then an exception will be thrown. This matches Clojure, rather than js/Math.floor\nSee: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/floor"},
           "cljs.core/Set" {:protocols #{"IFn"
                                         "ISeqable"
                                         "IMeta"
                                         "IWithMeta"
                                         "IEmptyableCollection"
                                         "ISet"
                                         "ICounted"
                                         "ILookup"
                                         "ICollection"
                                         "IHash"
                                         "IPrintable"
                                         "IEquiv"},
                            :ns "cljs.core",
                            :name "Set",
                            :signature ["[meta hash-map]"],
                            :name-encode "Set",
                            :history [["+" "0.0-927"]
                                      ["-" "0.0-1211"]],
                            :type "type",
                            :full-name-encode "cljs.core/Set",
                            :source {:code "(deftype Set [meta hash-map]\n  IWithMeta\n  (-with-meta [coll meta] (Set. meta hash-map))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll o]\n    (Set. meta (assoc hash-map o nil)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.Set/EMPTY meta))\n\n  IEquiv\n  (-equiv [coll other]\n    (and\n     (set? other)\n     (= (count coll) (count other))\n     (every? #(contains? coll %)\n             other)))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll] (keys hash-map))\n\n  ICounted\n  (-count [coll] (count (seq coll)))\n\n  ILookup\n  (-lookup [coll v]\n    (-lookup coll v nil))\n  (-lookup [coll v not-found]\n    (if (-contains-key? hash-map v)\n      v\n      not-found))\n\n  ISet\n  (-disjoin [coll v]\n    (Set. meta (dissoc hash-map v)))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1011",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [2659 2706]},
                            :full-name "cljs.core/Set",
                            :removed {:in "0.0-1211",
                                      :last-seen "0.0-1011"}},
           "cljs.core/sorted-map" {:ns "cljs.core",
                                   :name "sorted-map",
                                   :signature ["[& keyvals]"],
                                   :name-encode "sorted-map",
                                   :history [["+" "0.0-1211"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/sorted-map",
                                   :source {:code "(defn sorted-map\n  ([& keyvals]\n     (loop [in (seq keyvals) out (.-EMPTY PersistentTreeMap)]\n       (if in\n         (recur (nnext in) (assoc out (first in) (second in)))\n         out))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [9158 9165]},
                                   :full-name "cljs.core/sorted-map",
                                   :docstring "keyval => key val\nReturns a new sorted map with supplied mappings."},
           "cljs.core/ns-publics" {:ns "cljs.core",
                                   :name "ns-publics",
                                   :signature ["[quoted-ns]"],
                                   :name-encode "ns-publics",
                                   :history [["+" "1.9.854"]],
                                   :type "macro",
                                   :full-name-encode "cljs.core/ns-publics",
                                   :source {:code "(core/defmacro ns-publics\n  [quoted-ns]\n  (core/assert (core/and (seq? quoted-ns)\n                         (= (first quoted-ns) 'quote)\n                         (core/symbol? (second quoted-ns)))\n    \"Argument to ns-publics must be a quoted symbol\")\n  (core/let [ns (second quoted-ns)]\n    `(into {}\n       [~@(map\n            (core/fn [[sym _]]\n              `[(symbol ~(name sym)) (var ~(symbol (name ns) (name sym)))])\n            (filter (core/fn [[_ info]]\n                      (not (core/-> info :meta :private)))\n              (get-in @env/*compiler* [:cljs.analyzer/namespaces ns :defs])))])))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/clojure/cljs/core.cljc",
                                            :lines [2922 2936]},
                                   :full-name "cljs.core/ns-publics",
                                   :docstring "Returns a map of the public intern mappings for the namespace."},
           "cljs.reader/macro-terminating?" {:return-type boolean,
                                             :ns "cljs.reader",
                                             :name "macro-terminating?",
                                             :signature ["[ch]"],
                                             :name-encode "macro-terminatingQMARK",
                                             :history [["+" "0.0-927"]
                                                       ["-" "1.9.854"]],
                                             :type "function",
                                             :full-name-encode "cljs.reader/macro-terminatingQMARK",
                                             :source {:code "(defn ^boolean macro-terminating? [ch]\n  (and (not (identical? ch \"#\"))\n       (not (identical? ch \\'))\n       (not (identical? ch \":\"))\n       (macros ch)))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.9.671",
                                                      :filename "src/main/cljs/cljs/reader.cljs",
                                                      :lines [74 78]},
                                             :full-name "cljs.reader/macro-terminating?",
                                             :removed {:in "1.9.854",
                                                       :last-seen "1.9.671"}},
           "cljs.analyzer.api/current-file" {:ns "cljs.analyzer.api",
                                             :name "current-file",
                                             :signature ["[]"],
                                             :name-encode "current-file",
                                             :history [["+"
                                                        "1.10.753"]],
                                             :type "function",
                                             :full-name-encode "cljs.analyzer.api/current-file",
                                             :source {:code "(defn current-file\n  []\n  ana/*cljs-file*)",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.12.38",
                                                      :filename "src/main/clojure/cljs/analyzer/api.cljc",
                                                      :lines [41 44]},
                                             :full-name "cljs.analyzer.api/current-file",
                                             :docstring "Return the current file under analysis or compilation."},
           "cljs.pprint/write" {:ns "cljs.pprint",
                                :name "write",
                                :signature ["[object & kw-args]"],
                                :name-encode "write",
                                :history [["+" "0.0-3255"]],
                                :type "function",
                                :full-name-encode "cljs.pprint/write",
                                :source {:code "(defn write\n  [object & kw-args]\n  (let [options (merge {:stream true} (apply hash-map kw-args))]\n    ;;TODO rewrite this as a macro\n    (binding [cljs.pprint/*print-base* (:base options cljs.pprint/*print-base*)\n              ;;:case             *print-case*,\n              cljs.pprint/*print-circle* (:circle options cljs.pprint/*print-circle*)\n              ;;:escape           *print-escape*\n              ;;:gensym           *print-gensym*\n              cljs.core/*print-length* (:length options cljs.core/*print-length*)\n              cljs.core/*print-level* (:level options cljs.core/*print-level*)\n              cljs.pprint/*print-lines* (:lines options cljs.pprint/*print-lines*)\n              cljs.pprint/*print-miser-width* (:miser-width options cljs.pprint/*print-miser-width*)\n              cljs.pprint/*print-pprint-dispatch* (:dispatch options cljs.pprint/*print-pprint-dispatch*)\n              cljs.pprint/*print-pretty* (:pretty options cljs.pprint/*print-pretty*)\n              cljs.pprint/*print-radix* (:radix options cljs.pprint/*print-radix*)\n              cljs.core/*print-readably* (:readably options cljs.core/*print-readably*)\n              cljs.pprint/*print-right-margin* (:right-margin options cljs.pprint/*print-right-margin*)\n              cljs.pprint/*print-suppress-namespaces* (:suppress-namespaces options cljs.pprint/*print-suppress-namespaces*)]\n      ;;TODO enable printing base\n      #_[bindings (if (or (not (= *print-base* 10)) *print-radix*)\n                  {#'pr pr-with-base}\n                  {})]\n      (binding []\n        (let [sb (StringBuffer.)\n              optval (if (contains? options :stream)\n                       (:stream options)\n                       true)\n              base-writer (if (or (true? optval) (nil? optval))\n                            (StringBufferWriter. sb)\n                            optval)]\n          (if *print-pretty*\n            (with-pretty-writer base-writer\n                                (write-out object))\n            (binding [*out* base-writer]\n              (pr object)))\n          (if (true? optval)\n            (string-print (str sb)))\n          (if (nil? optval)\n            (str sb)))))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/pprint.cljs",
                                         :lines [751 812]},
                                :full-name "cljs.pprint/write",
                                :docstring "Write an object subject to the current bindings of the printer control variables.\nUse the kw-args argument to override individual variables for this call (and any\nrecursive calls). Returns the string result if :stream is nil or nil otherwise.\n\nThe following keyword arguments can be passed with values:\n  Keyword              Meaning                              Default value\n  :stream              Writer for output or nil             true (indicates *out*)\n  :base                Base to use for writing rationals    Current value of *print-base*\n  :circle*             If true, mark circular structures    Current value of *print-circle*\n  :length              Maximum elements to show in sublists Current value of *print-length*\n  :level               Maximum depth                        Current value of *print-level*\n  :lines*              Maximum lines of output              Current value of *print-lines*\n  :miser-width         Width to enter miser mode            Current value of *print-miser-width*\n  :dispatch            The pretty print dispatch function   Current value of *print-pprint-dispatch*\n  :pretty              If true, do pretty printing          Current value of *print-pretty*\n  :radix               If true, prepend a radix specifier   Current value of *print-radix*\n  :readably*           If true, print readably              Current value of *print-readably*\n  :right-margin        The column for the right margin      Current value of *print-right-margin*\n  :suppress-namespaces If true, no namespaces in symbols    Current value of *print-suppress-namespaces*\n\n  * = not yet supported\n"},
           "cljs.spec.impl.gen/gen-for-pred" {:ns "cljs.spec.impl.gen",
                                              :name "gen-for-pred",
                                              :signature ["[pred]"],
                                              :name-encode "gen-for-pred",
                                              :history [["+" "1.9.14"]
                                                        ["-"
                                                         "1.9.542"]],
                                              :type "function",
                                              :full-name-encode "cljs.spec.impl.gen/gen-for-pred",
                                              :source {:code "(defn gen-for-pred\n  [pred]\n  (if (set? pred)\n    (elements pred)\n    (get @gen-builtins pred)))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.9.521",
                                                       :filename "src/main/cljs/cljs/spec/impl/gen.cljs",
                                                       :lines [141
                                                               146]},
                                              :full-name "cljs.spec.impl.gen/gen-for-pred",
                                              :docstring "Given a predicate, returns a built-in generator if one exists.",
                                              :removed {:in "1.9.542",
                                                        :last-seen "1.9.521"}},
           "cljs.test/join-fixtures" {:ns "cljs.test",
                                      :name "join-fixtures",
                                      :signature ["[fixtures]"],
                                      :name-encode "join-fixtures",
                                      :history [["+" "0.0-2496"]],
                                      :type "function",
                                      :full-name-encode "cljs.test/join-fixtures",
                                      :source {:code "(defn join-fixtures\n  [fixtures]\n  (reduce compose-fixtures default-fixture fixtures))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/test.cljs",
                                               :lines [517 523]},
                                      :full-name "cljs.test/join-fixtures",
                                      :docstring "Composes a collection of fixtures, in order.  Always returns a valid\nfixture function, even if the collection is empty.\n\nNOTE: Incompatible with map fixtures."},
           "cljs.core/prefers" {:ns "cljs.core",
                                :name "prefers",
                                :signature ["[multifn]"],
                                :name-encode "prefers",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/prefers",
                                :source {:code "(defn prefers\n  [multifn] (-prefers multifn))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [11696 11698]},
                                :full-name "cljs.core/prefers",
                                :docstring "Given a multimethod, returns a map of preferred value -> set of other values"},
           "cljs.math/to-degrees" {:return-type number,
                                   :ns "cljs.math",
                                   :name "to-degrees",
                                   :signature ["[r]"],
                                   :name-encode "to-degrees",
                                   :history [["+" "1.11.50"]],
                                   :type "function",
                                   :full-name-encode "cljs.math/to-degrees",
                                   :source {:code "(defn ^number to-degrees\n  {:added \"1.11.10\"}\n  [r]\n  (* r RADIANS-TO-DEGREES))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/math.cljs",
                                            :lines [133 138]},
                                   :full-name "cljs.math/to-degrees",
                                   :docstring "Converts an angle in radians to an approximate equivalent angle in degrees.\nSee: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#toDegrees-double-"},
           "cljs.test/assert-predicate" {:ns "cljs.test",
                                         :name "assert-predicate",
                                         :signature ["[msg form]"],
                                         :name-encode "assert-predicate",
                                         :history [["+" "1.8.51"]],
                                         :type "function",
                                         :full-name-encode "cljs.test/assert-predicate",
                                         :source {:code "(defn assert-predicate\n  [msg form]\n  (let [args (rest form)\n        pred (first form)\n        {:keys [file line end-line column end-column]} (meta form)]\n    `(let [values# (list ~@args)\n           result# (apply ~pred values#)]\n       (if result#\n         (report\n          {:type :pass, :message ~msg,\n           :file ~file :line ~line :end-line ~end-line :column ~column :end-column ~end-column\n           :expected '~form, :actual (cons '~pred values#)})\n         (report\n          {:type :fail, :message ~msg,\n           :file ~file :line ~line :end-line ~end-line :column ~column :end-column ~end-column\n           :expected '~form, :actual (list '~'not (cons '~pred values#))}))\n       result#)))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/cljs/cljs/test.cljc",
                                                  :lines [25 46]},
                                         :full-name "cljs.test/assert-predicate",
                                         :docstring "Returns generic assertion code for any functional predicate.  The\n'expected' argument to 'report' will contains the original form, the\n'actual' argument will contain the form with all its sub-forms\nevaluated.  If the predicate returns false, the 'actual' form will\nbe wrapped in (not...)."},
           "cljs.core/vary-meta" {:ns "cljs.core",
                                  :name "vary-meta",
                                  :signature ["[obj f]"
                                              "[obj f a]"
                                              "[obj f a b]"
                                              "[obj f a b c]"
                                              "[obj f a b c d]"
                                              "[obj f a b c d & args]"],
                                  :name-encode "vary-meta",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/vary-meta",
                                  :source {:code "(defn vary-meta\n ([obj f]\n   (with-meta obj (f (meta obj))))\n  ([obj f a]\n   (with-meta obj (f (meta obj) a)))\n  ([obj f a b]\n   (with-meta obj (f (meta obj) a b)))\n  ([obj f a b c]\n   (with-meta obj (f (meta obj) a b c)))\n  ([obj f a b c d]\n   (with-meta obj (f (meta obj) a b c d)))\n  ([obj f a b c d & args]\n   (with-meta obj (apply f (meta obj) a b c d args))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [4077 4091]},
                                  :full-name "cljs.core/vary-meta",
                                  :docstring "Returns an object of the same type and value as obj, with\n(apply f (meta obj) args) as its metadata."},
           "cljs.core/unchecked-add" {:return-type number,
                                      :ns "cljs.core",
                                      :name "unchecked-add",
                                      :signature ["[]"
                                                  "[x]"
                                                  "[x y]"
                                                  "[x y & more]"],
                                      :name-encode "unchecked-add",
                                      :history [["+" "0.0-1798"]],
                                      :type "function/macro",
                                      :full-name-encode "cljs.core/unchecked-add",
                                      :source {:code "(defn ^number unchecked-add\n  ([] 0)\n  ([x] x)\n  ([x y] (cljs.core/unchecked-add x y))\n  ([x y & more] (reduce unchecked-add (cljs.core/unchecked-add x y) more)))",
                                               :title "Function code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [2805 2810]},
                                      :extra-sources [{:code "(core/defmacro ^::ana/numeric unchecked-add\n  ([& xs] `(+ ~@xs)))",
                                                       :title "Macro code",
                                                       :repo "clojurescript",
                                                       :tag "r1.12.38",
                                                       :filename "src/main/clojure/cljs/core.cljc",
                                                       :lines [1077
                                                               1078]}],
                                      :full-name "cljs.core/unchecked-add",
                                      :docstring "Returns the sum of nums. (+) returns 0."},
           "cljs.core/when-let" {:ns "cljs.core",
                                 :name "when-let",
                                 :signature ["[bindings & body]"],
                                 :name-encode "when-let",
                                 :history [["+" "0.0-927"]],
                                 :type "macro",
                                 :full-name-encode "cljs.core/when-let",
                                 :source {:code "(defmacro when-let\n  {:added \"1.0\"}\n  [bindings & body]\n  (assert-args\n     (vector? bindings) \"a vector for its binding\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n   (let [form (bindings 0) tst (bindings 1)]\n    `(let [temp# ~tst]\n       (when temp#\n         (let [~form temp#]\n           ~@body)))))",
                                          :title "Source code",
                                          :repo "clojure",
                                          :tag "clojure-1.10.0",
                                          :filename "src/clj/clojure/core.clj",
                                          :lines [1861 1874]},
                                 :full-name "cljs.core/when-let",
                                 :docstring "bindings => binding-form test\n\nWhen test is true, evaluates body with binding-form bound to the value of test"},
           "cljs.build.api/node-module-deps" {:ns "cljs.build.api",
                                              :name "node-module-deps",
                                              :signature ["[entry]"],
                                              :name-encode "node-module-deps",
                                              :history [["+"
                                                         "1.9.456"]
                                                        ["-"
                                                         "1.9.854"]],
                                              :type "function",
                                              :full-name-encode "cljs.build.api/node-module-deps",
                                              :source {:code "(defn node-module-deps\n  [entry]\n  (closure/node-module-deps entry))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.9.671",
                                                       :filename "src/main/clojure/cljs/build/api.clj",
                                                       :lines [218
                                                               223]},
                                              :full-name "cljs.build.api/node-module-deps",
                                              :docstring "EXPERIMENTAL: return the foreign libs entries as computed by running\nthe module-deps package on the supplied JavaScript entry point. Assumes\nthat the module-deps NPM package is either locally or globally installed.",
                                              :removed {:in "1.9.854",
                                                        :last-seen "1.9.671"}},
           "cljs.spec.alpha/&" {:ns "cljs.spec.alpha",
                                :name "&",
                                :signature ["[re & preds]"],
                                :name-encode "&",
                                :history [["+" "1.9.542"]],
                                :type "macro",
                                :full-name-encode "cljs.spec.alpha/&",
                                :source {:code "(defmacro &\n  [re & preds]\n  (let [pv (vec preds)]\n    `(amp-impl ~re '~(res &env re) ~pv '~(mapv #(res &env %) pv))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/spec/alpha.cljc",
                                         :lines [372 378]},
                                :full-name "cljs.spec.alpha/&",
                                :docstring "takes a regex op re, and predicates. Returns a regex-op that consumes\ninput as per re but subjects the resulting value to the\nconjunction of the predicates, and any conforming they might perform."},
           "cljs.build.api/install-node-deps!" {:ns "cljs.build.api",
                                                :name "install-node-deps!",
                                                :signature ["[dependencies]"
                                                            "[dependencies opts]"],
                                                :name-encode "install-node-depsBANG",
                                                :history [["+"
                                                           "1.9.854"]],
                                                :type "function",
                                                :full-name-encode "cljs.build.api/install-node-depsBANG",
                                                :source {:code "(defn install-node-deps!\n  ([dependencies]\n   (if (compiler-opts? dependencies)\n     (install-node-deps! (:npm-deps dependencies) dependencies)\n     (install-node-deps! dependencies\n       (when-let [state (ana-api/current-state)]\n         (:options @state)))))\n  ([dependencies opts]\n   {:pre [(map? dependencies)]}\n   (closure/check-npm-deps opts)\n   (closure/maybe-install-node-deps!\n     (update-in opts [:npm-deps] merge dependencies))))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1.12.38",
                                                         :filename "src/main/clojure/cljs/build/api.clj",
                                                         :lines [258
                                                                 271]},
                                                :full-name "cljs.build.api/install-node-deps!",
                                                :docstring "EXPERIMENTAL: Install the supplied dependencies via NPM. dependencies must be\na map of name to version or a valid compiler options map."},
           "clojure.core.reducers/folder" {:ns "clojure.core.reducers",
                                           :name "folder",
                                           :signature ["[coll xf]"],
                                           :name-encode "folder",
                                           :history [["+" "0.0-1236"]],
                                           :type "function",
                                           :full-name-encode "clojure.core.reducers/folder",
                                           :source {:code "(defn folder\n  ([coll xf]\n     (reify\n       cljs.core/IReduce\n       (-reduce [_ f1]\n         (-reduce coll (xf f1) (f1)))\n       (-reduce [_ f1 init]\n         (-reduce coll (xf f1) init))\n\n       CollFold\n       (coll-fold [_ n combinef reducef]\n         (coll-fold coll n combinef (xf reducef))))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/cljs/clojure/core/reducers.cljs",
                                                    :lines [79 94]},
                                           :full-name "clojure.core.reducers/folder",
                                           :docstring "Given a foldable collection, and a transformation function xf,\nreturns a foldable collection, where any supplied reducing\nfn will be transformed by xf. xf is a function of reducing fn to\nreducing fn."},
           "cljs.core/ASeq" {:ns "cljs.core",
                             :name "ASeq",
                             :name-encode "ASeq",
                             :implementations #{"ChunkedCons"
                                                "ChunkedSeq"
                                                "IndexedSeq"
                                                "List"
                                                "Cons"},
                             :history [["+" "0.0-1211"]],
                             :type "protocol",
                             :full-name-encode "cljs.core/ASeq",
                             :source {:code "(defprotocol ASeq)",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [617 618]},
                             :full-name "cljs.core/ASeq",
                             :docstring "Marker protocol indicating an array sequence."},
           "cljs.core/drop" {:ns "cljs.core",
                             :name "drop",
                             :signature ["[n]" "[n coll]"],
                             :name-encode "drop",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/drop",
                             :source {:code "(defn drop\n  ([n]\n   {:pre [(number? n)]}\n     (fn [rf]\n       (let [na (volatile! n)]\n         (fn\n           ([] (rf))\n           ([result] (rf result))\n           ([result input]\n              (let [n @na]\n                (vswap! na dec)\n                (if (pos? n)\n                  result\n                  (rf result input))))))))\n  ([n coll]\n   {:pre [(number? n)]}\n     (if (implements? IDrop coll)\n       (or\n         (if (pos? n)\n           (-drop coll (Math/ceil n))\n           (seq coll))\n         ())\n       (let [step (fn [n coll]\n                    (let [s (seq coll)]\n                      (if (and (pos? n) s)\n                        (recur (dec n) (rest s))\n                        s)))]\n         (lazy-seq (step n coll))))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [4882 4911]},
                             :full-name "cljs.core/drop",
                             :docstring "Returns a laziness-preserving sequence of all but the first n items in coll.\nReturns a stateful transducer when no collection is provided."},
           "cljs.core/var" {:ns "cljs.core",
                            :name "var",
                            :signature ["[symbol]"],
                            :name-encode "var",
                            :history [["+" "0.0-2496"]],
                            :type "special form",
                            :full-name-encode "cljs.core/var",
                            :source {:code "(defmethod parse 'var\n  [op env [_ sym :as form] _ _]\n  (when (not= 2 (count form))\n    (throw (error env \"Wrong number of args to var\")))\n  (when-not (symbol? sym)\n    (throw (error env \"Argument to var must be symbol\")))\n  (merge\n    {:env env\n     :op :the-var\n     :children [:var :sym :meta]\n     :form form}\n    (var-ast env sym)))",
                                     :title "Parser code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/clojure/cljs/analyzer.cljc",
                                     :lines [1630 1641]},
                            :extra-sources ({:code "(defmethod emit* :the-var\n  [{:keys [env var sym meta] :as arg}]\n  {:pre [(ana/ast? sym) (ana/ast? meta)]}\n  (let [{:keys [name]} (:info var)]\n    (emit-wrap env\n      (emits \"new cljs.core.Var(function(){return \" (munge name) \";},\"\n        sym \",\" meta \")\"))))",
                                             :title "Emitting code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/clojure/cljs/compiler.cljc",
                                             :lines [504 510]}),
                            :full-name "cljs.core/var",
                            :docstring "The symbol must resolve to a var, and the Var object\nitself (not its value) is returned. The reader macro #'x expands to (var x)."},
           "cljs.core/ArrayList" {:ns "cljs.core",
                                  :name "ArrayList",
                                  :signature ["[arr]"],
                                  :name-encode "ArrayList",
                                  :history [["+" "0.0-2301"]],
                                  :type "type",
                                  :full-name-encode "cljs.core/ArrayList",
                                  :source {:code "(deftype ArrayList [^:mutable arr]\n  Object\n  (add [_ x] (.push arr x))\n  (size [_] (alength arr))\n  (clear [_] (set! arr (array)))\n  (isEmpty [_] (zero? (alength arr)))\n  (toArray [_] arr))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [9778 9784]},
                                  :full-name "cljs.core/ArrayList"},
           "cljs.spec.test.alpha/abbrev-result" {:ns "cljs.spec.test.alpha",
                                                 :name "abbrev-result",
                                                 :signature ["[x]"],
                                                 :name-encode "abbrev-result",
                                                 :history [["+"
                                                            "1.9.542"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.spec.test.alpha/abbrev-result",
                                                 :source {:code "(defn abbrev-result\n  [x]\n  (if (:failure x)\n    (-> (dissoc x :clojure.spec.test.check/ret)\n      (update :spec s/describe)\n      (update :failure unwrap-failure))\n    (dissoc x :spec :clojure.spec.test.check/opts)))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r1.12.38",
                                                          :filename "src/main/cljs/cljs/spec/test/alpha.cljs",
                                                          :lines [278
                                                                  286]},
                                                 :full-name "cljs.spec.test.alpha/abbrev-result",
                                                 :docstring "Given a check result, returns an abbreviated version\nsuitable for summary use."},
           "compiler-options/pseudo-names" {:ns "compiler-options",
                                            :name "pseudo-names",
                                            :name-encode "pseudo-names",
                                            :type "option",
                                            :full-name-encode "compiler-options/pseudo-names",
                                            :full-name "compiler-options/pseudo-names",
                                            :history [["+" "0.0-2227"]]},
           "cljs.core/stepper" {:ns "cljs.core",
                                :name "stepper",
                                :signature ["[xform iter]"],
                                :name-encode "stepper",
                                :history [["+" "0.0-2301"]
                                          ["-" "1.9.562"]],
                                :type "function",
                                :full-name-encode "cljs.core/stepper",
                                :source {:code "(defn stepper [xform iter]\n  (letfn [(stepfn\n            ([result]\n               (let [lt (if (reduced? result)\n                          @result\n                          result)]\n                 (set! (.-stepper lt) nil)\n                 result))\n            ([result input]\n               (let [lt result]\n                 (set! (.-first lt) input)\n                 (set! (.-rest lt) (lazy-transformer (.-stepper lt)))\n                 (set! (.-stepper lt) nil)\n                 (.-rest lt))))]\n   (Stepper. (xform stepfn) iter)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.9.542",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [3889 3903]},
                                :full-name "cljs.core/stepper",
                                :removed {:in "1.9.562",
                                          :last-seen "1.9.542"}},
           "cljs.pprint/char-code" {:ns "cljs.pprint",
                                    :name "char-code",
                                    :signature ["[c]"],
                                    :name-encode "char-code",
                                    :history [["+" "0.0-3255"]],
                                    :type "function",
                                    :full-name-encode "cljs.pprint/char-code",
                                    :source {:code "(defn char-code\n  [c]\n  (cond\n    (number? c) c\n    (and (string? c) (== (.-length c) 1)) (.charCodeAt c 0)\n    :else (throw (js/Error. \"Argument to char must be a character or number\"))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/pprint.cljs",
                                             :lines [63 69]},
                                    :full-name "cljs.pprint/char-code",
                                    :docstring "Convert char to int"},
           "compiler-options/spec-skip-macros" {:ns "compiler-options",
                                                :name "spec-skip-macros",
                                                :name-encode "spec-skip-macros",
                                                :type "option",
                                                :full-name-encode "compiler-options/spec-skip-macros",
                                                :full-name "compiler-options/spec-skip-macros",
                                                :history [["+"
                                                           "1.10.439"]]},
           "compiler-options/bundle-cmd" {:ns "compiler-options",
                                          :name "bundle-cmd",
                                          :name-encode "bundle-cmd",
                                          :type "option",
                                          :full-name-encode "compiler-options/bundle-cmd",
                                          :full-name "compiler-options/bundle-cmd",
                                          :history [["+" "1.10.738"]]},
           "cljs.core/IAtom" {:ns "cljs.core",
                              :name "IAtom",
                              :name-encode "IAtom",
                              :implementations #{"Atom"},
                              :history [["+" "0.0-2173"]],
                              :type "protocol",
                              :full-name-encode "cljs.core/IAtom",
                              :source {:code "(defprotocol IAtom)",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [865 866]},
                              :full-name "cljs.core/IAtom",
                              :docstring "Marker protocol indicating an atom."},
           "cljs.core/reduceable?" {:ns "cljs.core",
                                    :name "reduceable?",
                                    :signature ["[x]"],
                                    :name-encode "reduceableQMARK",
                                    :history [["+" "0.0-1211"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/reduceableQMARK",
                                    :source {:code "(defn reduceable?\n  [x] (satisfies? IReduce x))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [2216 2218]},
                                    :full-name "cljs.core/reduceable?",
                                    :docstring "Returns true if coll satisfies IReduce"},
           "syntax/-Inf" {:syntax-equiv {:edn-url nil, :clj-url nil},
                          :ns "syntax",
                          :name "-Inf",
                          :name-encode "-Inf",
                          :history [["+" "1.9.946"]],
                          :type "symbolic value",
                          :full-name-encode "syntax/-Inf",
                          :extra-sources ({:code "(defn- read-symbolic-value\n  [rdr _ opts pending-forms]\n  (let [sym (read* rdr true nil opts pending-forms)]\n    (case sym\n      Inf Double/POSITIVE_INFINITY\n      -Inf Double/NEGATIVE_INFINITY\n      NaN Double/NaN\n      (err/reader-error rdr (str \"Invalid token: ##\" sym)))))",
                                           :title "Reader code",
                                           :repo "tools.reader",
                                           :tag "v1.3.6",
                                           :filename "src/main/clojure/clojure/tools/reader.clj",
                                           :lines [412 419]}
                                          {:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    \\? read-cond\n    \\: read-namespaced-map\n    \\# read-symbolic-value\n    nil))",
                                           :title "Reader table",
                                           :repo "tools.reader",
                                           :tag "v1.3.6",
                                           :filename "src/main/clojure/clojure/tools/reader.clj",
                                           :lines [809 823]}),
                          :full-name "syntax/-Inf"},
           "closure-warnings/strict-missing-require" {:ns "closure-warnings",
                                                      :name "strict-missing-require",
                                                      :name-encode "strict-missing-require",
                                                      :type "warning",
                                                      :full-name-encode "closure-warnings/strict-missing-require",
                                                      :full-name "closure-warnings/strict-missing-require",
                                                      :history [["+"
                                                                 "1.9.473"]
                                                                ["-"
                                                                 "1.10.844"]],
                                                      :removed {:in "1.10.844",
                                                                :last-seen "1.10.773"}},
           "cljs.core/while" {:ns "cljs.core",
                              :name "while",
                              :signature ["[test & body]"],
                              :name-encode "while",
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :full-name-encode "cljs.core/while",
                              :source {:code "(defmacro while\n  {:added \"1.0\"}\n  [test & body]\n  `(loop []\n     (when ~test\n       ~@body\n       (recur))))",
                                       :title "Source code",
                                       :repo "clojure",
                                       :tag "clojure-1.10.0",
                                       :filename "src/clj/clojure/core.clj",
                                       :lines [6333 6341]},
                              :full-name "cljs.core/while",
                              :docstring "Repeatedly executes body while test expression is true. Presumes\nsome side-effect will cause test to become false/nil. Returns nil"},
           "cljs.analyzer.api/read-analysis-cache" {:ns "cljs.analyzer.api",
                                                    :name "read-analysis-cache",
                                                    :signature ["[cache-file]"],
                                                    :name-encode "read-analysis-cache",
                                                    :history [["+"
                                                               "1.10.753"]],
                                                    :type "function",
                                                    :full-name-encode "cljs.analyzer.api/read-analysis-cache",
                                                    :source {:code "   (defn read-analysis-cache\n     [cache-file]\n     (case (util/ext cache-file)\n       \"edn\" (edn/read-string (slurp cache-file))\n       \"json\" (let [{:keys [reader read]} @ana/transit]\n                (with-open [is (io/input-stream cache-file)]\n                  (read (reader is :json ana/transit-read-opts))))))",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r1.12.38",
                                                             :filename "src/main/clojure/cljs/analyzer/api.cljc",
                                                             :lines [189
                                                                     196]},
                                                    :full-name "cljs.analyzer.api/read-analysis-cache",
                                                    :docstring "Read an analysis cache."},
           "closure-warnings/const" {:ns "closure-warnings",
                                     :name "const",
                                     :name-encode "const",
                                     :type "warning",
                                     :full-name-encode "closure-warnings/const",
                                     :full-name "closure-warnings/const",
                                     :history [["+" "0.0-2120"]]},
           "cljs.core/dispatch-fn" {:ns "cljs.core",
                                    :name "dispatch-fn",
                                    :signature ["[multifn]"],
                                    :name-encode "dispatch-fn",
                                    :history [["+" "0.0-3165"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/dispatch-fn",
                                    :source {:code "(defn dispatch-fn\n  [multifn] (-dispatch-fn multifn))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [11704 11706]},
                                    :full-name "cljs.core/dispatch-fn",
                                    :docstring "Given a multimethod, return its dispatch-fn."},
           "cljs.core/*out*" {:ns "cljs.core",
                              :name "*out*",
                              :name-encode "STARoutSTAR",
                              :type "dynamic var",
                              :full-name-encode "cljs.core/STARoutSTAR",
                              :source {:code "(def\n  ^{:dynamic true\n    :jsdoc [\"@type {*}\"]}\n  *out* nil)",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [62 65]},
                              :full-name "cljs.core/*out*",
                              :history [["+" "1.7.10"]]},
           "cljs.spec.test.alpha/->sym" {:ns "cljs.spec.test.alpha",
                                         :name "->sym",
                                         :signature ["[x]"],
                                         :name-encode "-GTsym",
                                         :history [["+" "1.9.542"]],
                                         :type "function",
                                         :full-name-encode "cljs.spec.test.alpha/-GTsym",
                                         :source {:code "(defn ->sym\n  [x]\n  (@#'s/->sym x))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/cljs/cljs/spec/test/alpha.cljs",
                                                  :lines [33 35]},
                                         :full-name "cljs.spec.test.alpha/->sym"},
           "cljs.core/import-macros" {:ns "cljs.core",
                                      :name "import-macros",
                                      :signature ["[ns [& vars]]"],
                                      :name-encode "import-macros",
                                      :history [["+" "0.0-927"]],
                                      :type "macro",
                                      :full-name-encode "cljs.core/import-macros",
                                      :source {:code "   (core/defmacro import-macros [ns [& vars]]\n     (core/let [ns (find-ns ns)\n                vars (map #(ns-resolve ns %) vars)\n                syms (map\n                       (core/fn [^clojure.lang.Var v]\n                         (core/-> v .sym\n                           (with-meta\n                             (merge\n                               {:macro true}\n                               (update-in (select-keys (meta v) [:arglists :doc :file :line])\n                                 [:arglists] (core/fn [arglists] `(quote ~arglists)))))))\n                       vars)\n                defs (map\n                       (core/fn [sym var]\n                         (core/let [{:keys [arglists doc file line]} (meta sym)]\n                           `(do\n                              (def ~sym (deref ~var))\n                              ;for AOT compilation\n                              (alter-meta! (var ~sym) assoc\n                                :macro true\n                                :arglists ~arglists\n                                :doc ~doc\n                                :file ~file\n                                :line ~line))))\n                       syms vars)]\n       `(do ~@defs\n            :imported)))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/clojure/cljs/core.cljc",
                                               :lines [64 90]},
                                      :full-name "cljs.core/import-macros"},
           "cljs.spec.gen.alpha/frequency" {:ns "cljs.spec.gen.alpha",
                                            :name "frequency",
                                            :signature ["[& args]"],
                                            :name-encode "frequency",
                                            :history [["+" "1.9.542"]],
                                            :type "function",
                                            :full-name-encode "cljs.spec.gen.alpha/frequency",
                                            :source {:code "(lazy-combinators hash-map list map not-empty set vector vector-distinct fmap elements\n  bind choose one-of such-that tuple sample return\n  large-integer* double* frequency shuffle)",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/cljs/cljs/spec/gen/alpha.cljs",
                                                     :lines [70 72]},
                                            :full-name "cljs.spec.gen.alpha/frequency",
                                            :docstring "Lazy loaded version of clojure.test.check.generators/frequency"},
           "cljs.build.api/dependency-order" {:ns "cljs.build.api",
                                              :name "dependency-order",
                                              :signature ["[xs]"],
                                              :name-encode "dependency-order",
                                              :history [["+"
                                                         "1.10.738"]],
                                              :type "function",
                                              :full-name-encode "cljs.build.api/dependency-order",
                                              :source {:code "(defn dependency-order\n  [xs]\n  (deps/dependency-order xs))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.12.38",
                                                       :filename "src/main/clojure/cljs/build/api.clj",
                                                       :lines [163
                                                               166]},
                                              :full-name "cljs.build.api/dependency-order",
                                              :docstring "Topologically sort a collection of IJavaScript values."},
           "cljs.repl.browser/add-in-order" {:ns "cljs.repl.browser",
                                             :name "add-in-order",
                                             :signature ["[{:keys [expecting fns]} order f]"],
                                             :name-encode "add-in-order",
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.repl.browser/add-in-order",
                                             :source {:code "(defn add-in-order [{:keys [expecting fns]} order f]\n  {:expecting (or expecting order)\n   :fns (assoc fns order f)})",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.12.38",
                                                      :filename "src/main/clojure/cljs/repl/browser.clj",
                                                      :lines [274 276]},
                                             :full-name "cljs.repl.browser/add-in-order"},
           "cljs.spec.impl.gen/uuid" {:ns "cljs.spec.impl.gen",
                                      :name "uuid",
                                      :signature ["[& args]"],
                                      :name-encode "uuid",
                                      :history [["+" "1.9.14"]
                                                ["-" "1.9.542"]],
                                      :type "function",
                                      :full-name-encode "cljs.spec.impl.gen/uuid",
                                      :source {:code "(lazy-prims any any-printable boolean char char-alpha char-alphanumeric char-ascii double\n  int keyword keyword-ns large-integer ratio simple-type simple-type-printable\n  string string-ascii string-alphanumeric symbol symbol-ns uuid)",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.9.521",
                                               :filename "src/main/cljs/cljs/spec/impl/gen.cljs",
                                               :lines [73 75]},
                                      :full-name "cljs.spec.impl.gen/uuid",
                                      :docstring "Fn returning clojure.test.check.generators/uuid",
                                      :removed {:in "1.9.542",
                                                :last-seen "1.9.521"}},
           "cljs.repl.nashorn/-main" {:ns "cljs.repl.nashorn",
                                      :name "-main",
                                      :signature ["[& args]"],
                                      :name-encode "-main",
                                      :history [["+" "0.0-3165"]
                                                ["-" "1.10.738"]],
                                      :type "function",
                                      :full-name-encode "cljs.repl.nashorn/-main",
                                      :source {:code "(defn -main [& args]\n      (apply cli/main repl-env args))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.10.597",
                                               :filename "src/main/clojure/cljs/repl/nashorn.clj",
                                               :lines [174 175]},
                                      :full-name "cljs.repl.nashorn/-main",
                                      :removed {:in "1.10.738",
                                                :last-seen "1.10.597"}},
           "cljs.core/string-print" {:ns "cljs.core",
                                     :name "string-print",
                                     :signature ["[x]"],
                                     :name-encode "string-print",
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "cljs.core/string-print",
                                     :source {:code "(defn string-print [x]\n  (when (nil? *print-fn*)\n    (throw (js/Error. \"No *print-fn* fn set for evaluation environment\")))\n  (*print-fn* x)\n  nil)",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/cljs/cljs/core.cljs",
                                              :lines [10466 10470]},
                                     :full-name "cljs.core/string-print"},
           "cljs.core/ES6IteratorSeq" {:protocols #{"ISeqable"
                                                    "ISeq"
                                                    "IPrintWithWriter"},
                                       :ns "cljs.core",
                                       :name "ES6IteratorSeq",
                                       :signature ["[value iter _rest]"],
                                       :name-encode "ES6IteratorSeq",
                                       :history [["+" "0.0-2411"]],
                                       :type "type",
                                       :full-name-encode "cljs.core/ES6IteratorSeq",
                                       :source {:code "(deftype ES6IteratorSeq [value iter ^:mutable _rest]\n  ISeqable\n  (-seq [this] this)\n  ISeq\n  (-first [_] value)\n  (-rest [_]\n    (when (nil? _rest)\n      (set! _rest (es6-iterator-seq iter)))\n    _rest))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/core.cljs",
                                                :lines [1344 1352]},
                                       :full-name "cljs.core/ES6IteratorSeq"},
           "cljs.repl.browser/default-index" {:ns "cljs.repl.browser",
                                              :name "default-index",
                                              :signature ["[output-to]"],
                                              :name-encode "default-index",
                                              :history [["+"
                                                         "1.10.63"]],
                                              :type "function",
                                              :full-name-encode "cljs.repl.browser/default-index",
                                              :source {:code "(defn default-index [output-to]\n  (str\n    \"<!DOCTYPE html><html>\"\n    \"<head>\"\n    \"<meta charset=\\\"UTF-8\\\">\"\n    \"<meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1\\\" >\"\n    \"<link rel=\\\"shortcut icon\\\" type=\\\"image/x-icon\\\" href=\\\"cljs-logo-icon-32.png\\\"/>\"\n    \"</head>\"\n    \"<body>\"\n    \"<div id=\\\"app\\\">\"\n    \"<link href=\\\"https://fonts.googleapis.com/css?family=Open+Sans\\\" rel=\\\"stylesheet\\\">\"\n    \"<style>\"\n    \"body { padding: 40px; margin: auto; max-width: 38em; \"\n    \"font-family: \\\"Open Sans\\\", sans-serif; }\"\n    \"code { color: #4165a2; font-size: 17px; }\"\n    \"pre  { color: #4165a2; font-size: 15px; white-space: pre-wrap; }\"\n    \"</style>\"\n    \"<center><img src=\\\"cljs-logo.svg\\\" style=\\\"width: 200px; height: 200px; margin: 15px;\\\"/></center>\"\n    \"<p>Welcome to the ClojureScript browser REPL.</p>\"\n    \"<p>This page hosts your REPL and application evaluation environment. \"\n    \"Validate the connection by typing <code>(js/alert&nbsp;\\\"Hello&nbsp;CLJS!\\\")</code> in the REPL.</p>\"\n    \"<p>To provide your own custom page, place an <code>index.html</code> file in \"\n    \"the REPL launch directory, starting with this template:</p>\"\n    \"<pre>\"\n    \"&lt;!DOCTYPE html&gt;\\n\"\n    \"&lt;html&gt;\\n\"\n    \"  &lt;head&gt;\\n\"\n    \"    &lt;meta charset=\\\"UTF-8\\\"&gt;\\n\"\n    \"  &lt;/head&gt;\\n\"\n    \"  &lt;body&gt;\\n\"\n    \"    &lt;script src=\\\"\" output-to \"\\\" type=\\\"text/javascript\\\"&gt;&lt;/script&gt;\\n\"\n    \"  &lt;/body&gt;\\n\"\n    \"&lt;/html&gt;\\n\"\n    \"</pre>\"\n    \"</div></div>\"\n    \"<script src=\\\"\" output-to \"\\\"></script>\"\n    \"</body></html>\"))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.12.38",
                                                       :filename "src/main/clojure/cljs/repl/browser.clj",
                                                       :lines [136
                                                               172]},
                                              :full-name "cljs.repl.browser/default-index"},
           "cljs.js/sm-data" {:ns "cljs.js",
                              :name "sm-data",
                              :signature ["[]"],
                              :name-encode "sm-data",
                              :history [["+" "1.7.10"] ["-" "1.7.28"]],
                              :type "function",
                              :full-name-encode "cljs.js/sm-data",
                              :source {:code "(defn sm-data []\n  (atom\n    {:source-map (sorted-map)\n     :gen-col    0\n     :gen-line   0}))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.10",
                                       :filename "src/main/cljs/cljs/js.cljs",
                                       :lines [122 126]},
                              :full-name "cljs.js/sm-data",
                              :removed {:in "1.7.28",
                                        :last-seen "1.7.10"}},
           "cljs.repl/err-out" {:ns "cljs.repl",
                                :name "err-out",
                                :signature ["[& body]"],
                                :name-encode "err-out",
                                :history [["+" "0.0-3148"]
                                          ["-" "1.10.312"]],
                                :type "macro",
                                :full-name-encode "cljs.repl/err-out",
                                :source {:code "(defmacro err-out [& body]\n  `(binding [*out* *err*]\n     ~@body))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.10.238",
                                         :filename "src/main/clojure/cljs/repl.cljc",
                                         :lines [45 47]},
                                :full-name "cljs.repl/err-out",
                                :removed {:in "1.10.312",
                                          :last-seen "1.10.238"}},
           "cljs.spec.test/instrumentable-syms" {:ns "cljs.spec.test",
                                                 :name "instrumentable-syms",
                                                 :signature ["[]"
                                                             "[opts]"],
                                                 :name-encode "instrumentable-syms",
                                                 :history [["+"
                                                            "1.9.183"]
                                                           ["-"
                                                            "1.9.542"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.spec.test/instrumentable-syms",
                                                 :source {:code "(defn instrumentable-syms\n  ([] (instrumentable-syms nil))\n  ([opts]\n   (assert (every? ident? (keys (:gen opts))) \"instrument :gen expects ident keys\")\n   (reduce into #{} [(filter fn-spec-name? (keys (s/registry)))\n                     (keys (:spec opts))\n                     (:stub opts)\n                     (keys (:replace opts))])))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r1.9.521",
                                                          :filename "src/main/cljs/cljs/spec/test.cljs",
                                                          :lines [169
                                                                  178]},
                                                 :full-name "cljs.spec.test/instrumentable-syms",
                                                 :docstring "Given an opts map as per instrument, returns the set of syms\nthat can be instrumented.",
                                                 :removed {:in "1.9.542",
                                                           :last-seen "1.9.521"}},
           "cljs.spec.alpha/map-of" {:ns "cljs.spec.alpha",
                                     :name "map-of",
                                     :signature ["[kpred vpred & opts]"],
                                     :name-encode "map-of",
                                     :history [["+" "1.9.542"]],
                                     :type "macro",
                                     :full-name-encode "cljs.spec.alpha/map-of",
                                     :source {:code "(defmacro map-of\n  [kpred vpred & opts]\n  (let [desc `(map-of ~(res &env kpred) ~(res &env vpred) ~@(res-kind &env opts))]\n    `(every-kv ~kpred ~vpred ::conform-all true :kind map? ::describe '~desc ~@opts)))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/cljs/cljs/spec/alpha.cljc",
                                              :lines [307 319]},
                                     :full-name "cljs.spec.alpha/map-of",
                                     :docstring "Returns a spec for a map whose keys satisfy kpred and vals satisfy\nvpred. Unlike 'every-kv', map-of will exhaustively conform every\nvalue.\n\nSame options as 'every', :kind defaults to map?, with the addition of:\n\n:conform-keys - conform keys as well as values (default false)\n\nSee also - every-kv"},
           "cljs.core/IntegerRange" {:protocols #{"IChunkedNext"
                                                  "ISeqable"
                                                  "IMeta"
                                                  "IWithMeta"
                                                  "IEmptyableCollection"
                                                  "ICounted"
                                                  "IReduce"
                                                  "ISequential"
                                                  "ISeq"
                                                  "ICollection"
                                                  "IHash"
                                                  "IDrop"
                                                  "IPrintWithWriter"
                                                  "IChunkedSeq"
                                                  "IIndexed"
                                                  "IIterable"
                                                  "INext"
                                                  "IEquiv"
                                                  "ICloneable"},
                                     :ns "cljs.core",
                                     :name "IntegerRange",
                                     :signature ["[meta start end step cnt __hash]"],
                                     :name-encode "IntegerRange",
                                     :history [["+" "1.10.844"]],
                                     :type "type",
                                     :full-name-encode "cljs.core/IntegerRange",
                                     :source {:code "(deftype IntegerRange [meta start end step cnt ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  ICloneable\n  (-clone [_] (IntegerRange. meta start end step cnt __hash))\n\n  IWithMeta\n  (-with-meta [rng new-meta]\n    (if (identical? new-meta meta)\n      rng\n      (IntegerRange. new-meta start end step cnt __hash)))\n\n  IMeta\n  (-meta [rng] meta)\n\n  ISeqable\n  (-seq [rng] rng)\n\n  ISeq\n  (-first [rng] start)\n  (-rest [rng]\n    (let [s (-next rng)]\n      (if (nil? s)\n        ()\n        s)))\n\n  IIterable\n  (-iterator [_]\n    (RangeIterator. start end step))\n\n  INext\n  (-next [rng]\n    (if (pos? step)\n      (when (< (+ start step) end)\n        (IntegerRange. nil (+ start step) end step (range-count (+ start step) end step) nil))\n      (when (> (+ start step) end)\n        (IntegerRange. nil (+ start step) end step (range-count (+ start step) end step) nil))))\n\n  IDrop\n  (-drop [rng n]\n    (if (pos? n)\n      (if (< n cnt)\n        (IntegerRange. nil (+ start (* step n)) end step (- cnt n) nil)\n        nil)\n      rng))\n\n  IChunkedSeq\n  (-chunked-first [rng]\n    (IntegerRangeChunk. start step (min cnt 32)))\n  (-chunked-rest [rng]\n    (if (<= cnt 32)\n      ()\n      (let [start (+ start (* step 32))]\n        (cond\n          (pos? step)\n          (if (<= end start)\n            ()\n            (IntegerRange. nil start end step (range-count start end step) nil))\n\n          (neg? step)\n          (if (>= end start)\n            ()\n            (IntegerRange. nil start end step (range-count start end step) nil))\n\n          :else\n          (if (== end start)\n            ()\n            (repeat start))))))\n\n  IChunkedNext\n  (-chunked-next [rng]\n    (seq (-chunked-rest rng)))\n\n  ICollection\n  (-conj [rng o] (cons o rng))\n\n  IEmptyableCollection\n  (-empty [rng] (.-EMPTY List))\n\n  ISequential\n  IEquiv\n  (-equiv [rng other] (equiv-sequential rng other))\n\n  IHash\n  (-hash [rng] (caching-hash rng hash-ordered-coll __hash))\n\n  ICounted\n  (-count [rng]\n    cnt)\n\n  IIndexed\n  (-nth [rng n]\n    (if (and (<= 0 n) (< n (-count rng)))\n      (+ start (* n step))\n      (if (and (<= 0 n) (> start end) (zero? step))\n        start\n        (throw (js/Error. \"Index out of bounds\")))))\n  (-nth [rng n not-found]\n    (if (and (<= 0 n) (< n (-count rng)))\n      (+ start (* n step))\n      (if (and (<= 0 n) (> start end) (zero? step))\n        start\n        not-found)))\n\n  IReduce\n  (-reduce [rng f] (ci-reduce rng f))\n  (-reduce [rng f init]\n    (loop [i start ret init]\n      (if (if (pos? step) (< i end) (> i end))\n        (let [ret (f ret i)]\n          (if (reduced? ret)\n            @ret\n            (recur (+ i step) ret)))\n        ret))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/cljs/cljs/core.cljs",
                                              :lines [9953 10078]},
                                     :full-name "cljs.core/IntegerRange"},
           "cljs.spec.gen.alpha/keyword" {:ns "cljs.spec.gen.alpha",
                                          :name "keyword",
                                          :signature ["[& args]"],
                                          :name-encode "keyword",
                                          :history [["+" "1.9.542"]],
                                          :type "function",
                                          :full-name-encode "cljs.spec.gen.alpha/keyword",
                                          :source {:code "(lazy-prims any any-printable boolean char char-alpha char-alphanumeric char-ascii double\n  int keyword keyword-ns large-integer ratio simple-type simple-type-printable\n  string string-ascii string-alphanumeric symbol symbol-ns uuid)",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/cljs/cljs/spec/gen/alpha.cljs",
                                                   :lines [74 76]},
                                          :full-name "cljs.spec.gen.alpha/keyword",
                                          :docstring "Fn returning clojure.test.check.generators/keyword"},
           "cljs.core/-" {:return-type number,
                          :ns "cljs.core",
                          :name "-",
                          :signature ["[x]" "[x y]" "[x y & more]"],
                          :name-encode "-",
                          :history [["+" "0.0-927"]],
                          :type "function/macro",
                          :full-name-encode "cljs.core/-",
                          :source {:code "(defn ^number -\n  ([x] (cljs.core/- x))\n  ([x y] (cljs.core/- x y))\n  ([x y & more] (reduce - (cljs.core/- x y) more)))",
                                   :title "Function code",
                                   :repo "clojurescript",
                                   :tag "r1.12.38",
                                   :filename "src/main/cljs/cljs/core.cljs",
                                   :lines [2691 2696]},
                          :extra-sources [{:code "(core/defmacro ^::ana/numeric -\n  ([x] (core/list 'js* \"(- ~{})\" x))\n  ([x y] (core/list 'js* \"(~{} - ~{})\" x y))\n  ([x y & more] `(- (- ~x ~y) ~@more)))",
                                           :title "Macro code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/clojure/cljs/core.cljc",
                                           :lines [1119 1122]}],
                          :full-name "cljs.core/-",
                          :docstring "If no ys are supplied, returns the negation of x, else subtracts\nthe ys from x and returns the result."},
           "cljs.core/loop*" {:ns "cljs.core",
                              :name "loop*",
                              :name-encode "loopSTAR",
                              :history [["+" "0.0-927"]],
                              :type "special form",
                              :full-name-encode "cljs.core/loopSTAR",
                              :source {:code "(defmethod parse 'loop*\n  [op encl-env form _ _]\n  (analyze-let encl-env form true nil))",
                                       :title "Parser code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/clojure/cljs/analyzer.cljc",
                                       :lines [2527 2529]},
                              :extra-sources ({:code "(defmethod emit* :loop [ast]\n  (emit-let ast true))",
                                               :title "Emitting code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/clojure/cljs/compiler.cljc",
                                               :lines [1112 1113]}),
                              :full-name "cljs.core/loop*"},
           "cljs.core/vector-seq" {:ns "cljs.core",
                                   :name "vector-seq",
                                   :signature ["[v offset]"],
                                   :name-encode "vector-seq",
                                   :history [["+" "0.0-1211"]
                                             ["-" "0.0-1424"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/vector-seq",
                                   :source {:code "(defn vector-seq [v offset]\n  (let [c (-count v)]\n    (when (pos? c)\n      (reify\n        IPrintable\n        (-pr-seq [vseq opts] (pr-sequential pr-seq \"(\" \" \" \")\" opts vseq))\n        ISequential\n        IEquiv\n        (-equiv [vseq other] (equiv-sequential vseq other))\n        ASeq\n        ISeq\n        (-first [_] (-nth v offset))\n        (-rest [_]\n          (let [offset (inc offset)]\n            (if (< offset c)\n              (vector-seq v offset)\n              ())))\n        ISeqable\n        (-seq [vseq] vseq)))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1236",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [2522 2540]},
                                   :full-name "cljs.core/vector-seq",
                                   :removed {:in "0.0-1424",
                                             :last-seen "0.0-1236"}},
           "cljs.core/IIterable" {:ns "cljs.core",
                                  :name "IIterable",
                                  :name-encode "IIterable",
                                  :implementations #{"Subvec"
                                                     "PersistentQueue"
                                                     "PersistentHashMap"
                                                     "ArrayNode"
                                                     "PersistentVector"
                                                     "IntegerRange"
                                                     "Range"
                                                     "IndexedSeq"
                                                     "PersistentArrayMap"
                                                     "PersistentHashSet"
                                                     "HashCollisionNode"
                                                     "BitmapIndexedNode"
                                                     "Eduction"},
                                  :history [["+" "0.0-2356"]],
                                  :type "protocol",
                                  :full-name-encode "cljs.core/IIterable",
                                  :source {:code "(defprotocol IIterable\n  (-iterator [coll]\n    \"Returns an iterator for coll.\"))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [884 887]},
                                  :methods [{:name "-iterator",
                                             :signature ["[coll]"],
                                             :docstring "Returns an iterator for coll."}],
                                  :full-name "cljs.core/IIterable",
                                  :docstring "Protocol for iterating over a collection."},
           "cljs.repl/repl-nil?" {:ns "cljs.repl",
                                  :name "repl-nil?",
                                  :signature ["[x]"],
                                  :name-encode "repl-nilQMARK",
                                  :history [["+" "1.10.63"]],
                                  :type "function",
                                  :full-name-encode "cljs.repl/repl-nilQMARK",
                                  :source {:code "(defn repl-nil? [x]\n  (boolean (#{\"\" \"nil\"} x)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/clojure/cljs/repl.cljc",
                                           :lines [1000 1001]},
                                  :full-name "cljs.repl/repl-nil?"},
           "cljs.test/testing-contexts-str" {:ns "cljs.test",
                                             :name "testing-contexts-str",
                                             :signature ["[]"],
                                             :name-encode "testing-contexts-str",
                                             :history [["+"
                                                        "0.0-2496"]],
                                             :type "function",
                                             :full-name-encode "cljs.test/testing-contexts-str",
                                             :source {:code "(defn testing-contexts-str\n  []\n  (apply str (interpose \" \" (reverse (:testing-contexts (get-current-env))))))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.12.38",
                                                      :filename "src/main/cljs/cljs/test.cljs",
                                                      :lines [299 303]},
                                             :full-name "cljs.test/testing-contexts-str",
                                             :docstring "Returns a string representation of the current test context. Joins\nstrings in *testing-contexts* with spaces."},
           "clojure.zip/vector-zip" {:ns "clojure.zip",
                                     :name "vector-zip",
                                     :signature ["[root]"],
                                     :name-encode "vector-zip",
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "clojure.zip/vector-zip",
                                     :source {:code "(defn vector-zip\n  [root]\n    (zipper vector?\n            seq\n            (fn [node children] (with-meta (vec children) (meta node)))\n            root))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/cljs/clojure/zip.cljs",
                                              :lines [42 48]},
                                     :full-name "clojure.zip/vector-zip",
                                     :docstring "Returns a zipper for nested vectors, given a root vector"},
           "cljs.reader/read-2-chars" {:ns "cljs.reader",
                                       :name "read-2-chars",
                                       :signature ["[reader]"],
                                       :name-encode "read-2-chars",
                                       :history [["+" "0.0-1424"]
                                                 ["-" "1.9.854"]],
                                       :type "function",
                                       :full-name-encode "cljs.reader/read-2-chars",
                                       :source {:code "(defn read-2-chars [reader]\n  (.toString\n    (StringBuffer.\n      (read-char reader)\n      (read-char reader))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.9.671",
                                                :filename "src/main/cljs/cljs/reader.cljs",
                                                :lines [168 172]},
                                       :full-name "cljs.reader/read-2-chars",
                                       :removed {:in "1.9.854",
                                                 :last-seen "1.9.671"}},
           "cljs.core/chunk" {:ns "cljs.core",
                              :name "chunk",
                              :signature ["[b]"],
                              :name-encode "chunk",
                              :history [["+" "0.0-1424"]],
                              :type "function",
                              :full-name-encode "cljs.core/chunk",
                              :source {:code "(defn chunk [b]\n  (.chunk b))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [3719 3720]},
                              :full-name "cljs.core/chunk"},
           "cljs.core/conj!" {:ns "cljs.core",
                              :name "conj!",
                              :signature ["[]"
                                          "[tcoll]"
                                          "[tcoll val]"
                                          "[tcoll val & vals]"],
                              :name-encode "conjBANG",
                              :history [["+" "0.0-1211"]],
                              :type "function",
                              :full-name-encode "cljs.core/conjBANG",
                              :source {:code "(defn conj!\n  ([] (transient []))\n  ([tcoll] tcoll)\n  ([tcoll val]\n    (-conj! tcoll val))\n  ([tcoll val & vals]\n    (let [ntcoll (-conj! tcoll val)]\n      (if vals\n        (recur ntcoll (first vals) (next vals))\n        ntcoll))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [3915 3926]},
                              :full-name "cljs.core/conj!",
                              :docstring "Adds val to the transient collection, and return tcoll. The 'addition'\nmay happen at different 'places' depending on the concrete type."},
           "syntax/earmuffs" {:syntax-equiv {:edn-url nil,
                                             :clj-url nil},
                              :ns "syntax",
                              :name "earmuffs",
                              :name-encode "earmuffs",
                              :type "convention",
                              :full-name-encode "syntax/earmuffs",
                              :full-name "syntax/earmuffs",
                              :history [["+" "0.0-927"]]},
           "cljs.spec.test.alpha/summarize-results" {:ns "cljs.spec.test.alpha",
                                                     :name "summarize-results",
                                                     :signature ["[check-results]"
                                                                 "[check-results summary-result]"],
                                                     :name-encode "summarize-results",
                                                     :history [["+"
                                                                "1.9.542"]],
                                                     :type "function",
                                                     :full-name-encode "cljs.spec.test.alpha/summarize-results",
                                                     :source {:code "(defn summarize-results\n  ([check-results] (summarize-results check-results abbrev-result))\n  ([check-results summary-result]\n   (reduce\n     (fn [summary result]\n       (pp/pprint (summary-result result))\n       (-> summary\n         (update :total inc)\n         (update (result-type result) (fnil inc 0))))\n     {:total 0}\n     check-results)))",
                                                              :title "Source code",
                                                              :repo "clojurescript",
                                                              :tag "r1.12.38",
                                                              :filename "src/main/cljs/cljs/spec/test/alpha.cljs",
                                                              :lines [288
                                                                      303]},
                                                     :full-name "cljs.spec.test.alpha/summarize-results",
                                                     :docstring "Given a collection of check-results, e.g. from 'check', pretty\nprints the summary-result (default abbrev-result) of each.\n\nReturns a map with :total, the total number of results, plus a\nkey with a count for each different :type of result."},
           "cljs.test/do-report" {:ns "cljs.test",
                                  :name "do-report",
                                  :signature ["[m]"],
                                  :name-encode "do-report",
                                  :history [["+" "0.0-2496"]],
                                  :type "function",
                                  :full-name-encode "cljs.test/do-report",
                                  :source {:code "(defn do-report [m]\n  (let [m (case (:type m)\n            :fail (merge (file-and-line (js/Error.) 4) m)\n            :error (merge (file-and-line (:actual m) 0) m)\n            m)]\n    (report m)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/test.cljs",
                                           :lines [420 425]},
                                  :full-name "cljs.test/do-report"},
           "cljs.spec.gen.alpha/double*" {:ns "cljs.spec.gen.alpha",
                                          :name "double*",
                                          :signature ["[& args]"],
                                          :name-encode "doubleSTAR",
                                          :history [["+" "1.9.542"]],
                                          :type "function",
                                          :full-name-encode "cljs.spec.gen.alpha/doubleSTAR",
                                          :source {:code "(lazy-combinators hash-map list map not-empty set vector vector-distinct fmap elements\n  bind choose one-of such-that tuple sample return\n  large-integer* double* frequency shuffle)",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/cljs/cljs/spec/gen/alpha.cljs",
                                                   :lines [70 72]},
                                          :full-name "cljs.spec.gen.alpha/double*",
                                          :docstring "Lazy loaded version of clojure.test.check.generators/double*"},
           "cljs.core/print-map" {:ns "cljs.core",
                                  :name "print-map",
                                  :signature ["[m print-one writer opts]"],
                                  :name-encode "print-map",
                                  :history [["+" "0.0-2120"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/print-map",
                                  :source {:code "(defn print-map [m print-one writer opts]\n  (let [[ns lift-map] (when (map? m)\n                        (lift-ns m))]\n    (if ns\n      (print-prefix-map (str \"#:\" ns) lift-map print-one writer opts)\n      (print-prefix-map nil m print-one writer opts))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [10725 10730]},
                                  :full-name "cljs.core/print-map"},
           "cljs.core/js->clj" {:ns "cljs.core",
                                :name "js->clj",
                                :signature ["[x]" "[x & opts]"],
                                :name-encode "js-GTclj",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/js-GTclj",
                                :source {:code "(defn js->clj\n  ([x] (js->clj x :keywordize-keys false))\n  ([x & opts]\n    (let [{:keys [keywordize-keys]} opts\n          keyfn (if keywordize-keys keyword str)\n          f (fn thisfn [x]\n              (cond\n                (satisfies? IEncodeClojure x)\n                (-js->clj x (apply array-map opts))\n\n                (seq? x)\n                (doall (map thisfn x))\n\n                (map-entry? x)\n                (MapEntry. (thisfn (key x)) (thisfn (val x)) nil)\n\n                (coll? x)\n                (into (empty x) (map thisfn) x)\n\n                (array? x)\n                (persistent!\n                 (reduce #(conj! %1 (thisfn %2))\n                         (transient []) x))\n\n                (identical? (type x) js/Object)\n                (persistent!\n                 (reduce (fn [r k] (assoc! r (keyfn k) (thisfn (gobject/get x k))))\n                         (transient {}) (js-keys x)))\n                :else x))]\n      (f x))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [11205 11238]},
                                :full-name "cljs.core/js->clj",
                                :docstring "Recursively transforms JavaScript arrays into ClojureScript\nvectors, and JavaScript objects into ClojureScript maps.  With\noption ':keywordize-keys true' will convert object fields from\nstrings to keywords."},
           "cljs.core/List" {:protocols #{"ISeqable"
                                          "IMeta"
                                          "IWithMeta"
                                          "IStack"
                                          "IEmptyableCollection"
                                          "ICounted"
                                          "IReduce"
                                          "ISequential"
                                          "ISeq"
                                          "ICollection"
                                          "IHash"
                                          "ASeq"
                                          "IPrintWithWriter"
                                          "INext"
                                          "IEquiv"
                                          "ICloneable"
                                          "IList"},
                             :ns "cljs.core",
                             :name "List",
                             :signature ["[meta first rest count __hash]"],
                             :name-encode "List",
                             :history [["+" "0.0-927"]],
                             :type "type",
                             :full-name-encode "cljs.core/List",
                             :source {:code "(deftype List [meta first rest count ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x count))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IList\n\n  ICloneable\n  (-clone [_] (List. meta first rest count __hash))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (List. new-meta first rest count __hash)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ASeq\n  ISeq\n  (-first [coll] first)\n  (-rest [coll]\n    (if (== count 1)\n      ()\n      rest))\n\n  INext\n  (-next [coll]\n    (if (== count 1)\n      nil\n      rest))\n\n  IStack\n  (-peek [coll] first)\n  (-pop [coll] (-rest coll))\n\n  ICollection\n  (-conj [coll o] (List. meta o coll (inc count) nil))\n\n  IEmptyableCollection\n  (-empty [coll] (-with-meta (.-EMPTY List) meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ICounted\n  (-count [coll] count)\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [3130 3198]},
                             :full-name "cljs.core/List"},
           "cljs.spec/*coll-check-limit*" {:ns "cljs.spec",
                                           :name "*coll-check-limit*",
                                           :name-encode "STARcoll-check-limitSTAR",
                                           :history [["+" "1.9.14"]
                                                     ["-" "1.9.542"]],
                                           :type "dynamic var",
                                           :full-name-encode "cljs.spec/STARcoll-check-limitSTAR",
                                           :source {:code "(def ^:dynamic *coll-check-limit*\n  \"The number of items validated in a collection spec'ed with 'every'\"\n  101)",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.9.521",
                                                    :filename "src/main/cljs/cljs/spec.cljs",
                                                    :lines [31 33]},
                                           :full-name "cljs.spec/*coll-check-limit*",
                                           :removed {:in "1.9.542",
                                                     :last-seen "1.9.521"}},
           "cljs.core/identical?" {:return-type boolean,
                                   :ns "cljs.core",
                                   :name "identical?",
                                   :signature ["[x y]"],
                                   :name-encode "identicalQMARK",
                                   :history [["+" "0.0-927"]],
                                   :type "function/macro",
                                   :full-name-encode "cljs.core/identicalQMARK",
                                   :source {:code "(defn ^boolean identical?\n  [x y]\n  (cljs.core/identical? x y))",
                                            :title "Function code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [236 239]},
                                   :extra-sources [{:code "(core/defmacro identical? [a b]\n  (bool-expr (core/list 'js* \"(~{} === ~{})\" a b)))",
                                                    :title "Macro code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/clojure/cljs/core.cljc",
                                                    :lines [998 999]}],
                                   :full-name "cljs.core/identical?",
                                   :docstring "Tests if 2 arguments are the same object"},
           "cljs.core/*main-cli-fn*" {:ns "cljs.core",
                                      :name "*main-cli-fn*",
                                      :name-encode "STARmain-cli-fnSTAR",
                                      :history [["+" "0.0-927"]],
                                      :type "var",
                                      :full-name-encode "cljs.core/STARmain-cli-fnSTAR",
                                      :source {:code "(def\n  *main-cli-fn* nil)",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [306 310]},
                                      :full-name "cljs.core/*main-cli-fn*",
                                      :docstring "When compiled for a command-line target, whatever function\n*main-cli-fn* is set to will be called with the command-line\nargv as arguments"},
           "clojure.browser.dom/html->dom" {:ns "clojure.browser.dom",
                                            :name "html->dom",
                                            :signature ["[s]"],
                                            :name-encode "html-GTdom",
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "clojure.browser.dom/html-GTdom",
                                            :source {:code "(defn html->dom [s]\n  (gdom/htmlToDocumentFragment s))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/cljs/clojure/browser/dom.cljs",
                                                     :lines [101 102]},
                                            :full-name "clojure.browser.dom/html->dom"},
           "cljs.core/js-arguments" {:ns "cljs.core",
                                     :name "js-arguments",
                                     :signature ["[]"],
                                     :name-encode "js-arguments",
                                     :history [["+" "0.0-1798"]
                                               ["-" "1.9.493"]
                                               ["+" "1.9.494"]],
                                     :type "macro",
                                     :full-name-encode "cljs.core/js-arguments",
                                     :source {:code "(core/defmacro js-arguments []\n  (core/list 'js* \"arguments\"))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/clojure/cljs/core.cljc",
                                              :lines [923 924]},
                                     :full-name "cljs.core/js-arguments"},
           "cljs.repl.server/handlers" {:ns "cljs.repl.server",
                                        :name "handlers",
                                        :name-encode "handlers",
                                        :type "var",
                                        :full-name-encode "cljs.repl.server/handlers",
                                        :source {:code "(defonce handlers (atom {}))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/clojure/cljs/repl/server.clj",
                                                 :lines [46]},
                                        :full-name "cljs.repl.server/handlers",
                                        :history [["+" "0.0-1503"]]},
           "cljs.core/symbol-identical?" {:ns "cljs.core",
                                          :name "symbol-identical?",
                                          :signature ["[x y]"],
                                          :name-encode "symbol-identicalQMARK",
                                          :history [["+" "1.7.10"]],
                                          :type "function",
                                          :full-name-encode "cljs.core/symbol-identicalQMARK",
                                          :source {:code "(defn symbol-identical?\n  [x y]\n  (if (identical? x y)\n    true\n    (if (and (symbol? x) (symbol? y))\n      (identical? (.-str x) (.-str y))\n      false)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/cljs/cljs/core.cljs",
                                                   :lines [3438 3445]},
                                          :full-name "cljs.core/symbol-identical?",
                                          :docstring "Efficient test to determine that two symbols are identical."},
           "cljs.repl.node/load-javascript" {:ns "cljs.repl.node",
                                             :name "load-javascript",
                                             :signature ["[repl-env provides url]"],
                                             :name-encode "load-javascript",
                                             :history [["+"
                                                        "0.0-2629"]],
                                             :type "function",
                                             :full-name-encode "cljs.repl.node/load-javascript",
                                             :source {:code "(defn load-javascript\n  [repl-env provides url]\n  (node-eval repl-env\n    (str \"goog.require('\" (comp/munge (first provides)) \"')\")))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.12.38",
                                                      :filename "src/main/clojure/cljs/repl/node.clj",
                                                      :lines [77 81]},
                                             :full-name "cljs.repl.node/load-javascript",
                                             :docstring "Load a Closure JavaScript file into the Node REPL process."},
           "cljs.core/LazyTransformer.create" {:ns "cljs.core",
                                               :name "LazyTransformer.create",
                                               :signature ["[xform coll]"],
                                               :name-encode "LazyTransformerDOTcreate",
                                               :history [["+"
                                                          "0.0-2301"]
                                                         ["-"
                                                          "1.9.562"]],
                                               :parent-type "LazyTransformer",
                                               :type "function",
                                               :full-name-encode "cljs.core/LazyTransformerDOTcreate",
                                               :source {:code "(set! (.-create LazyTransformer)\n  (fn [xform coll]\n    (LazyTransformer. (stepper xform (iter coll)) nil nil nil)))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.9.542",
                                                        :filename "src/main/cljs/cljs/core.cljs",
                                                        :lines [4026
                                                                4028]},
                                               :full-name "cljs.core/LazyTransformer.create",
                                               :removed {:in "1.9.562",
                                                         :last-seen "1.9.542"}},
           "cljs.core/chunk-next" {:ns "cljs.core",
                                   :name "chunk-next",
                                   :signature ["[s]"],
                                   :name-encode "chunk-next",
                                   :history [["+" "0.0-1424"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/chunk-next",
                                   :source {:code "(defn chunk-next [s]\n  (if (implements? IChunkedNext s)\n    (-chunked-next s)\n    (seq (-chunked-rest s))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [3728 3731]},
                                   :full-name "cljs.core/chunk-next"},
           "cljs.core/enable-console-print!" {:ns "cljs.core",
                                              :name "enable-console-print!",
                                              :signature ["[]"],
                                              :name-encode "enable-console-printBANG",
                                              :history [["+"
                                                         "0.0-2060"]],
                                              :type "function",
                                              :full-name-encode "cljs.core/enable-console-printBANG",
                                              :source {:code "(defn enable-console-print!\n  []\n  (set! *print-newline* false)\n  (set-print-fn!\n    (fn []\n      (let [xs (js-arguments)]\n        (.apply (.-log js/console) js/console (garray/clone xs)))))\n  (set-print-err-fn!\n    (fn []\n      (let [xs (js-arguments)]\n        (.apply (.-error js/console) js/console (garray/clone xs)))))\n  nil)",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.12.38",
                                                       :filename "src/main/cljs/cljs/core.cljs",
                                                       :lines [193
                                                               205]},
                                              :full-name "cljs.core/enable-console-print!",
                                              :docstring "Set *print-fn* to console.log"},
           "cljs.core/sorted?" {:ns "cljs.core",
                                :name "sorted?",
                                :signature ["[x]"],
                                :name-encode "sortedQMARK",
                                :history [["+" "0.0-2120"]],
                                :type "function",
                                :full-name-encode "cljs.core/sortedQMARK",
                                :source {:code "(defn sorted?\n  [x] (satisfies? ISorted x))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [2212 2214]},
                                :full-name "cljs.core/sorted?",
                                :docstring "Returns true if coll satisfies ISorted"},
           "cljs.core/some" {:ns "cljs.core",
                             :name "some",
                             :signature ["[pred coll]"],
                             :name-encode "some",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/some",
                             :source {:code "(defn some\n  [pred coll]\n  (when-let [s (seq coll)]\n    (or (pred (first s)) (recur pred (next s)))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [4336 4343]},
                             :full-name "cljs.core/some",
                             :docstring "Returns the first logical true value of (pred x) for any x in coll,\nelse nil.  One common idiom is to use a set as pred, for example\nthis will return :fred if :fred is in the sequence, otherwise nil:\n(some #{:fred} coll)"},
           "warnings/munged-namespace" {:ns "warnings",
                                        :name "munged-namespace",
                                        :name-encode "munged-namespace",
                                        :type "warning",
                                        :full-name-encode "warnings/munged-namespace",
                                        :full-name "warnings/munged-namespace",
                                        :history [["+" "0.0-3115"]]},
           "warnings/js-shadowed-by-local" {:ns "warnings",
                                            :name "js-shadowed-by-local",
                                            :name-encode "js-shadowed-by-local",
                                            :type "warning",
                                            :full-name-encode "warnings/js-shadowed-by-local",
                                            :full-name "warnings/js-shadowed-by-local",
                                            :history [["+" "1.9.293"]]},
           "cljs.core/PersistentArrayMapSeq" {:protocols #{"ISeqable"
                                                           "IMeta"
                                                           "IWithMeta"
                                                           "IEmptyableCollection"
                                                           "ICounted"
                                                           "IReduce"
                                                           "ISequential"
                                                           "ISeq"
                                                           "ICollection"
                                                           "IHash"
                                                           "IDrop"
                                                           "IPrintWithWriter"
                                                           "INext"
                                                           "IEquiv"},
                                              :ns "cljs.core",
                                              :name "PersistentArrayMapSeq",
                                              :signature ["[arr i _meta]"],
                                              :name-encode "PersistentArrayMapSeq",
                                              :history [["+"
                                                         "0.0-1820"]],
                                              :type "type",
                                              :full-name-encode "cljs.core/PersistentArrayMapSeq",
                                              :source {:code "(deftype PersistentArrayMapSeq [arr i _meta]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IMeta\n  (-meta [coll] _meta)\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta _meta)\n      coll\n      (PersistentArrayMapSeq. arr i new-meta)))\n\n  ICounted\n  (-count [coll]\n    (/ (- (alength arr) i) 2))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ICollection\n  (-conj [coll o]\n    (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (.-EMPTY List))\n\n  IHash\n  (-hash [coll] (hash-ordered-coll coll))\n\n  ISeq\n  (-first [coll]\n    (MapEntry. (aget arr i) (aget arr (inc i)) nil))\n\n  (-rest [coll]\n    (if (< i (- (alength arr) 2))\n      (PersistentArrayMapSeq. arr (+ i 2) nil)\n      ()))\n\n  INext\n  (-next [coll]\n    (when (< i (- (alength arr) 2))\n      (PersistentArrayMapSeq. arr (+ i 2) nil)))\n\n  IDrop\n  (-drop [coll n]\n    (when (< n (-count coll))\n      (PersistentArrayMapSeq. arr (+ i (* 2 n)) nil)))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.12.38",
                                                       :filename "src/main/cljs/cljs/core.cljs",
                                                       :lines [6890
                                                               6956]},
                                              :full-name "cljs.core/PersistentArrayMapSeq"},
           "cljs.reader/make-unicode-char" {:ns "cljs.reader",
                                            :name "make-unicode-char",
                                            :signature ["[code-str]"],
                                            :name-encode "make-unicode-char",
                                            :history [["+" "0.0-1424"]
                                                      ["-" "1.9.854"]],
                                            :type "function",
                                            :full-name-encode "cljs.reader/make-unicode-char",
                                            :source {:code "(defn make-unicode-char [code-str]\n    (let [code (js/parseInt code-str 16)]\n      (.fromCharCode js/String code)))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.9.671",
                                                     :filename "src/main/cljs/cljs/reader.cljs",
                                                     :lines [190 192]},
                                            :full-name "cljs.reader/make-unicode-char",
                                            :removed {:in "1.9.854",
                                                      :last-seen "1.9.671"}},
           "cljs.core/if" {:ns "cljs.core",
                           :name "if",
                           :signature ["[test then else?]"],
                           :name-encode "if",
                           :history [["+" "0.0-927"]],
                           :type "special form",
                           :full-name-encode "cljs.core/if",
                           :source {:code "(defmethod parse 'if\n  [op env [_ test then else :as form] name _]\n  (when (< (count form) 3)\n    (throw (compile-syntax-error env \"Too few arguments to if\" 'if)))\n  (when (> (count form) 4)\n    (throw (compile-syntax-error env \"Too many arguments to if\" 'if)))\n  (let [test-expr (disallowing-recur (analyze (assoc env :context :expr) test))\n        then-expr (allowing-redef (analyze (set-test-induced-tags env test) then))\n        else-expr (allowing-redef (analyze env else))]\n    {:env env :op :if :form form\n     :test test-expr :then then-expr :else else-expr\n     :unchecked *unchecked-if*\n     :children [:test :then :else]}))",
                                    :title "Parser code",
                                    :repo "clojurescript",
                                    :tag "r1.12.38",
                                    :filename "src/main/clojure/cljs/analyzer.cljc",
                                    :lines [1767 1779]},
                           :extra-sources ({:code "(defmethod emit* :if\n  [{:keys [test then else env unchecked]}]\n  (let [context (:context env)\n        checked (not (or unchecked (safe-test? env test)))]\n    (cond\n      (truthy-constant? test) (emitln then)\n      (falsey-constant? test) (emitln else)\n      :else\n      (if (= :expr context)\n        (emits \"(\" (when checked \"cljs.core.truth_\") \"(\" test \")?\" then \":\" else \")\")\n        (do\n          (if checked\n            (emitln \"if(cljs.core.truth_(\" test \")){\")\n            (emitln \"if(\" test \"){\"))\n          (emitln then \"} else {\")\n          (emitln else \"}\"))))))",
                                            :title "Emitting code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/clojure/cljs/compiler.cljc",
                                            :lines [646 661]}),
                           :full-name "cljs.core/if",
                           :docstring "Evaluates test. If not the singular values nil or false,\nevaluates and yields then, otherwise, evaluates and yields else. If\nelse is not supplied it defaults to nil."},
           "cljs.spec.alpha/*" {:ns "cljs.spec.alpha",
                                :name "*",
                                :signature ["[pred-form]"],
                                :name-encode "STAR",
                                :history [["+" "1.9.542"]],
                                :type "macro",
                                :full-name-encode "cljs.spec.alpha/STAR",
                                :source {:code "(defmacro *\n  [pred-form]\n  `(rep-impl '~(res &env pred-form) ~pred-form))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/spec/alpha.cljc",
                                         :lines [321 325]},
                                :full-name "cljs.spec.alpha/*",
                                :docstring "Returns a regex op that matches zero or more values matching\npred. Produces a vector of matches iff there is at least one match"},
           "clojure.core.reducers/Cat" {:protocols #{"CollFold"
                                                     "cljs.core/ISeqable"
                                                     "cljs.core/IReduce"
                                                     "cljs.core/ICounted"},
                                        :ns "clojure.core.reducers",
                                        :name "Cat",
                                        :signature ["[cnt left right]"],
                                        :name-encode "Cat",
                                        :history [["+" "0.0-1236"]],
                                        :type "type",
                                        :full-name-encode "clojure.core.reducers/Cat",
                                        :source {:code "(deftype Cat [cnt left right]\n  cljs.core/ICounted\n  (-count [_] cnt)\n\n  cljs.core/ISeqable\n  (-seq [_] (concat (seq left) (seq right)))\n\n  cljs.core/IReduce\n  (-reduce [this f1] (-reduce this f1 (f1)))\n  (-reduce\n    [_  f1 init]\n    (-reduce\n     right f1\n     (-reduce left f1 init)))\n\n  CollFold\n  (coll-fold\n    [this n combinef reducef]\n    (-reduce this reducef)))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/cljs/clojure/core/reducers.cljs",
                                                 :lines [193 211]},
                                        :full-name "clojure.core.reducers/Cat"},
           "cljs.build.api/add-implicit-options" {:ns "cljs.build.api",
                                                  :name "add-implicit-options",
                                                  :signature ["[opts]"],
                                                  :name-encode "add-implicit-options",
                                                  :history [["+"
                                                             "0.0-3291"]],
                                                  :type "function",
                                                  :full-name-encode "cljs.build.api/add-implicit-options",
                                                  :source {:code "(defn add-implicit-options\n  [opts]\n  (closure/add-implicit-options opts))",
                                                           :title "Source code",
                                                           :repo "clojurescript",
                                                           :tag "r1.12.38",
                                                           :filename "src/main/clojure/cljs/build/api.clj",
                                                           :lines [168
                                                                   173]},
                                                  :full-name "cljs.build.api/add-implicit-options",
                                                  :docstring "Given a valid map of build options add any standard implicit options. For\nexample :optimizations :none implies :cache-analysis true and :source-map\ntrue."},
           "cljs.core/write-all" {:ns "cljs.core",
                                  :name "write-all",
                                  :signature ["[writer & ss]"],
                                  :name-encode "write-all",
                                  :history [["+" "0.0-1503"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/write-all",
                                  :source {:code "(defn write-all [writer & ss]\n  (doseq [s ss]\n    (-write writer s)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [10462 10464]},
                                  :full-name "cljs.core/write-all"},
           "cljs.core/doall" {:ns "cljs.core",
                              :name "doall",
                              :signature ["[coll]" "[n coll]"],
                              :name-encode "doall",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/doall",
                              :source {:code "(defn doall\n  ([coll]\n   (dorun coll)\n   coll)\n  ([n coll]\n   (dorun n coll)\n   coll))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [10358 10370]},
                              :full-name "cljs.core/doall",
                              :docstring "When lazy sequences are produced via functions that have side\neffects, any effects other than those needed to produce the first\nelement in the seq do not occur until the seq is consumed. doall can\nbe used to force any effects. Walks through the successive nexts of\nthe seq, retains the head and returns it, thus causing the entire\nseq to reside in memory at one time."},
           "cljs.core/condp" {:ns "cljs.core",
                              :name "condp",
                              :signature ["[pred expr & clauses]"],
                              :name-encode "condp",
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :full-name-encode "cljs.core/condp",
                              :source {:code "(core/defmacro condp\n  {:added \"1.0\"}\n\n  [pred expr & clauses]\n  (core/let [gpred (gensym \"pred__\")\n             gexpr (gensym \"expr__\")\n             emit (core/fn emit [pred expr args]\n                    (core/let [[[a b c :as clause] more]\n                               (split-at (if (= :>> (second args)) 3 2) args)\n                               n (count clause)]\n                      (core/cond\n                        (= 0 n) `(throw (js/Error. (cljs.core/str \"No matching clause: \" ~expr)))\n                        (= 1 n) a\n                        (= 2 n) `(if (~pred ~a ~expr)\n                                   ~b\n                                   ~(emit pred expr more))\n                        :else `(if-let [p# (~pred ~a ~expr)]\n                                 (~c p#)\n                                 ~(emit pred expr more)))))\n             gres (gensym \"res__\")]\n    `(let [~gpred ~pred\n           ~gexpr ~expr]\n       ~(emit gpred gexpr clauses))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/clojure/cljs/core.cljc",
                                       :lines [2299 2338]},
                              :full-name "cljs.core/condp",
                              :docstring "Takes a binary predicate, an expression, and a set of clauses.\nEach clause can take the form of either:\n\ntest-expr result-expr\n\ntest-expr :>> result-fn\n\nNote :>> is an ordinary keyword.\n\nFor each clause, (pred test-expr expr) is evaluated. If it returns\nlogical true, the clause is a match. If a binary clause matches, the\nresult-expr is returned, if a ternary clause matches, its result-fn,\nwhich must be a unary function, is called with the result of the\npredicate as its argument, the result of that call being the return\nvalue of condp. A single default expression can follow the clauses,\nand its value will be returned if no clause matches. If no default\nexpression is provided and no clause matches, an Error is thrown."},
           "clojure.zip/down" {:ns "clojure.zip",
                               :name "down",
                               :signature ["[loc]"],
                               :name-encode "down",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip/down",
                               :source {:code "(defn down\n  [loc]\n    (when (branch? loc)\n      (let [[node path] loc\n            [c & cnext :as cs] (children loc)]\n        (when cs\n          (with-meta [c {:l [] \n                         :pnodes (if path (conj (:pnodes path) node) [node]) \n                         :ppath path \n                         :r cnext}] (meta loc))))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/clojure/zip.cljs",
                                        :lines [98 109]},
                               :full-name "clojure.zip/down",
                               :docstring "Returns the loc of the leftmost child of the node at this loc, or\nnil if no children"},
           "cljs.pprint/simple-dispatch" {:ns "cljs.pprint",
                                          :name "simple-dispatch",
                                          :name-encode "simple-dispatch",
                                          :history [["+" "0.0-3255"]],
                                          :type "multimethod",
                                          :full-name-encode "cljs.pprint/simple-dispatch",
                                          :source {:code "(defmulti simple-dispatch\n  type-dispatcher)",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/cljs/cljs/pprint.cljs",
                                                   :lines [2905 2907]},
                                          :full-name "cljs.pprint/simple-dispatch",
                                          :docstring "The pretty print dispatch function for simple data structure format."},
           "cljs.core/IPending" {:ns "cljs.core",
                                 :name "IPending",
                                 :name-encode "IPending",
                                 :implementations #{"Cycle"
                                                    "Delay"
                                                    "Iterate"
                                                    "Repeat"
                                                    "LazySeq"},
                                 :history [["+" "0.0-927"]],
                                 :type "protocol",
                                 :full-name-encode "cljs.core/IPending",
                                 :source {:code "(defprotocol IPending\n  (^boolean -realized? [x]\n    \"Returns true if a value for x has been produced, false otherwise.\"))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [784 788]},
                                 :methods [{:name "-realized?",
                                            :signature ["[x]"],
                                            :docstring "Returns true if a value for x has been produced, false otherwise."}],
                                 :full-name "cljs.core/IPending",
                                 :docstring "Protocol for types which can have a deferred realization. Currently only\n  implemented by Delay and LazySeq."},
           "cljs.core/count" {:ns "cljs.core",
                              :name "count",
                              :signature ["[coll]"],
                              :name-encode "count",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/count",
                              :source {:code "(defn count\n  [coll]\n  (if-not (nil? coll)\n    (cond\n      (implements? ICounted coll)\n      (-count coll)\n\n      (array? coll)\n      (alength coll)\n\n      (string? coll)\n      ^number (.-length coll)\n\n      (implements? ISeqable coll)\n      (accumulating-seq-count coll)\n\n      :else (-count coll))\n    0))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [1868 1887]},
                              :full-name "cljs.core/count",
                              :docstring "Returns the number of items in the collection. (count nil) returns\n0.  Also works on strings, arrays, and Maps"},
           "cljs.core/bit-test" {:return-type boolean,
                                 :ns "cljs.core",
                                 :name "bit-test",
                                 :signature ["[x n]"],
                                 :name-encode "bit-test",
                                 :history [["+" "0.0-927"]],
                                 :type "function/macro",
                                 :full-name-encode "cljs.core/bit-test",
                                 :source {:code "(defn ^boolean bit-test\n  [x n]\n  (cljs.core/bit-test x n))",
                                          :title "Function code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [2980 2983]},
                                 :extra-sources [{:code "(core/defmacro bit-test [x n]\n  (bool-expr (core/list 'js* \"((~{} & (1 << ~{})) != 0)\" x n)))",
                                                  :title "Macro code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/clojure/cljs/core.cljc",
                                                  :lines [1228 1229]}],
                                 :full-name "cljs.core/bit-test",
                                 :docstring "Test bit at index n"},
           "cljs.repl.browser/lock" {:ns "cljs.repl.browser",
                                     :name "lock",
                                     :name-encode "lock",
                                     :type "var",
                                     :full-name-encode "cljs.repl.browser/lock",
                                     :source {:code "(def lock (Object.))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/clojure/cljs/repl/browser.clj",
                                              :lines [347]},
                                     :full-name "cljs.repl.browser/lock",
                                     :history [["+" "1.10.145"]]},
           "repl-options/bind-err" {:ns "repl-options",
                                    :name "bind-err",
                                    :name-encode "bind-err",
                                    :type "option",
                                    :full-name-encode "repl-options/bind-err",
                                    :full-name "repl-options/bind-err",
                                    :history [["+" "0.0-3148"]]},
           "cljs.build.api/handle-js-modules" {:ns "cljs.build.api",
                                               :name "handle-js-modules",
                                               :signature ["[state xs opts]"],
                                               :name-encode "handle-js-modules",
                                               :history [["+"
                                                          "1.10.738"]],
                                               :type "function",
                                               :full-name-encode "cljs.build.api/handle-js-modules",
                                               :source {:code "(defn handle-js-modules\n  [state xs opts]\n  (closure/handle-js-modules opts xs state))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.12.38",
                                                        :filename "src/main/clojure/cljs/build/api.clj",
                                                        :lines [156
                                                                161]},
                                               :full-name "cljs.build.api/handle-js-modules",
                                               :docstring "Given a collection of IJavaScript values representing a build, index all\nnode modules, convert all JS modules (ES6 etc), and store the updated\njs-dependency-index (likely changed due to modules) in compiler state."},
           "cljs.core/js-mod" {:ns "cljs.core",
                               :name "js-mod",
                               :signature ["[n d]"],
                               :name-encode "js-mod",
                               :history [["+" "0.0-1552"]],
                               :type "function/macro",
                               :full-name-encode "cljs.core/js-mod",
                               :source {:code "(defn js-mod\n  [n d]\n  (cljs.core/js-mod n d))",
                                        :title "Function code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [2915 2918]},
                               :extra-sources [{:code "(core/defmacro ^::ana/numeric js-mod [num div]\n  (core/list 'js* \"(~{} % ~{})\" num div))",
                                                :title "Macro code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/clojure/cljs/core.cljc",
                                                :lines [1192 1193]}],
                               :full-name "cljs.core/js-mod",
                               :docstring "Modulus of num and div with original javascript behavior. i.e. bug for negative numbers"},
           "syntax/cond" {:syntax-equiv {:edn-url nil, :clj-url nil},
                          :ns "syntax",
                          :name "cond",
                          :name-encode "cond",
                          :history [["+" "0.0-3190"]],
                          :type "syntax",
                          :full-name-encode "syntax/cond",
                          :extra-sources ({:code "(defn- read-cond\n  [rdr _ opts pending-forms]\n  (when (not (and opts (#{:allow :preserve} (:read-cond opts))))\n    (throw (RuntimeException. \"Conditional read not allowed\")))\n  (if-let [ch (read-char rdr)]\n    (let [splicing (= ch \\@)\n          ch (if splicing (read-char rdr) ch)]\n      (when splicing\n        (when-not *read-delim*\n          (err/reader-error rdr \"cond-splice not in list\")))\n      (if-let [ch (if (whitespace? ch) (read-past whitespace? rdr) ch)]\n        (if (not= ch \\()\n          (throw (RuntimeException. \"read-cond body must be a list\"))\n          (binding [*suppress-read* (or *suppress-read* (= :preserve (:read-cond opts)))]\n            (if *suppress-read*\n              (reader-conditional (read-list rdr ch opts pending-forms) splicing)\n              (read-cond-delimited rdr splicing opts pending-forms))))\n        (err/throw-eof-in-character rdr)))\n    (err/throw-eof-in-character rdr)))",
                                           :title "Reader code",
                                           :repo "tools.reader",
                                           :tag "v1.3.6",
                                           :filename "src/main/clojure/clojure/tools/reader.clj",
                                           :lines [506 524]}
                                          {:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    \\? read-cond\n    \\: read-namespaced-map\n    \\# read-symbolic-value\n    nil))",
                                           :title "Reader table",
                                           :repo "tools.reader",
                                           :tag "v1.3.6",
                                           :filename "src/main/clojure/clojure/tools/reader.clj",
                                           :lines [809 823]}),
                          :full-name "syntax/cond"},
           "repl-options/host" {:ns "repl-options",
                                :name "host",
                                :name-encode "host",
                                :type "option",
                                :full-name-encode "repl-options/host",
                                :full-name "repl-options/host",
                                :history [["+" "1.10.63"]]},
           "cljs.spec/conform" {:ns "cljs.spec",
                                :name "conform",
                                :signature ["[spec x]"],
                                :name-encode "conform",
                                :history [["+" "1.9.14"]
                                          ["-" "1.9.542"]],
                                :type "function",
                                :full-name-encode "cljs.spec/conform",
                                :source {:code "(defn conform\n  [spec x]\n  (conform* (specize spec) x))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.9.521",
                                         :filename "src/main/cljs/cljs/spec.cljs",
                                         :lines [149 153]},
                                :full-name "cljs.spec/conform",
                                :docstring "Given a spec and a value, returns :clojure.spec/invalid if value does not match spec,\nelse the (possibly destructured) value.",
                                :removed {:in "1.9.542",
                                          :last-seen "1.9.521"}},
           "cljs.compiler.api/cljs-files-in" {:ns "cljs.compiler.api",
                                              :name "cljs-files-in",
                                              :signature ["[dir]"],
                                              :name-encode "cljs-files-in",
                                              :history [["+"
                                                         "0.0-3255"]],
                                              :type "function",
                                              :full-name-encode "cljs.compiler.api/cljs-files-in",
                                              :source {:code "(defn cljs-files-in\n  [dir]\n  (comp/cljs-files-in dir))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.12.38",
                                                       :filename "src/main/clojure/cljs/compiler/api.clj",
                                                       :lines [83 86]},
                                              :full-name "cljs.compiler.api/cljs-files-in",
                                              :docstring "Return a sequence of all .cljs and .cljc files in the given directory."},
           "cljs.core/es6-set-entries-iterator" {:ns "cljs.core",
                                                 :name "es6-set-entries-iterator",
                                                 :signature ["[coll]"],
                                                 :name-encode "es6-set-entries-iterator",
                                                 :history [["+"
                                                            "0.0-2371"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core/es6-set-entries-iterator",
                                                 :source {:code "(defn es6-set-entries-iterator [coll]\n  (ES6SetEntriesIterator. (seq coll)))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r1.12.38",
                                                          :filename "src/main/cljs/cljs/core.cljs",
                                                          :lines [6708
                                                                  6709]},
                                                 :full-name "cljs.core/es6-set-entries-iterator"},
           "cljs.repl.browser/safari-st-el->frame" {:ns "cljs.repl.browser",
                                                    :name "safari-st-el->frame",
                                                    :signature ["[repl-env st-el opts]"],
                                                    :name-encode "safari-st-el-GTframe",
                                                    :history [["+"
                                                               "0.0-3053"]
                                                              ["-"
                                                               "1.7.10"]],
                                                    :type "function",
                                                    :full-name-encode "cljs.repl.browser/safari-st-el-GTframe",
                                                    :source {:code "(defn safari-st-el->frame\n  [repl-env st-el opts]\n  (let [[function flc] (if (re-find #\"@\" st-el)\n                         (string/split st-el #\"@\")\n                         [nil st-el])\n        [file line column] (parse-file-line-column flc)]\n    (if (and file function line column)\n      {:file (parse-file repl-env file opts)\n       :function function\n       :line line\n       :column column}\n      (when-not (string/blank? function)\n        {:file nil\n         :function (string/trim function)\n         :line nil\n         :column nil}))))",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r3308",
                                                             :filename "src/main/clojure/cljs/repl/browser.clj",
                                                             :lines [318
                                                                     333]},
                                                    :full-name "cljs.repl.browser/safari-st-el->frame",
                                                    :removed {:in "1.7.10",
                                                              :last-seen "0.0-3308"}},
           "cljs.test/set-env!" {:ns "cljs.test",
                                 :name "set-env!",
                                 :signature ["[new-env]"],
                                 :name-encode "set-envBANG",
                                 :history [["+" "0.0-2496"]],
                                 :type "function",
                                 :full-name-encode "cljs.test/set-envBANG",
                                 :source {:code "(defn set-env! [new-env]\n  (set! *current-env* new-env))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/test.cljs",
                                          :lines [277 278]},
                                 :full-name "cljs.test/set-env!"},
           "cljs.core/SetEntriesIterator" {:ns "cljs.core",
                                           :name "SetEntriesIterator",
                                           :signature ["[s]"],
                                           :name-encode "SetEntriesIterator",
                                           :history [["+" "0.0-2268"]
                                                     ["-" "0.0-2371"]],
                                           :type "type",
                                           :full-name-encode "cljs.core/SetEntriesIterator",
                                           :source {:code "(deftype SetEntriesIterator [^:mutable s]\n  Object\n  (next [_]\n    (if-not (nil? s)\n      (let [x (first s)]\n        (set! s (next s))\n        #js {:value #js [x x] :done false})\n      #js {:value nil :done true})))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2356",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [4887 4894]},
                                           :full-name "cljs.core/SetEntriesIterator",
                                           :removed {:in "0.0-2371",
                                                     :last-seen "0.0-2356"}},
           "cljs.spec.gen.alpha/quick-check" {:ns "cljs.spec.gen.alpha",
                                              :name "quick-check",
                                              :signature ["[& args]"],
                                              :name-encode "quick-check",
                                              :history [["+"
                                                         "1.9.542"]],
                                              :type "function",
                                              :full-name-encode "cljs.spec.gen.alpha/quick-check",
                                              :source {:code "(defn quick-check\n  [& args]\n  (apply @quick-check-ref args))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.12.38",
                                                       :filename "src/main/cljs/cljs/spec/gen/alpha.cljs",
                                                       :lines [30 32]},
                                              :full-name "cljs.spec.gen.alpha/quick-check"},
           "cljs.spec/int-in-range?" {:ns "cljs.spec",
                                      :name "int-in-range?",
                                      :signature ["[start end val]"],
                                      :name-encode "int-in-rangeQMARK",
                                      :history [["+" "1.9.75"]
                                                ["-" "1.9.542"]],
                                      :type "function",
                                      :full-name-encode "cljs.spec/int-in-rangeQMARK",
                                      :source {:code "(defn int-in-range?\n  [start end val]\n  (cond\n    (integer? val) (c/and (<= start val) (< val end))\n\n    (instance? goog.math.Long val)\n    (c/and (.lessThanOrEqual start val)\n           (.lessThan val end))\n\n    (instance? goog.math.Integer val)\n    (c/and (.lessThanOrEqual start val)\n           (.lessThan val end))\n\n    :else false))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.9.521",
                                               :filename "src/main/cljs/cljs/spec.cljs",
                                               :lines [1391 1405]},
                                      :full-name "cljs.spec/int-in-range?",
                                      :docstring "Return true if start <= val and val < end",
                                      :removed {:in "1.9.542",
                                                :last-seen "1.9.521"}},
           "closure-warnings/type-invalidation" {:ns "closure-warnings",
                                                 :name "type-invalidation",
                                                 :name-encode "type-invalidation",
                                                 :type "warning",
                                                 :full-name-encode "closure-warnings/type-invalidation",
                                                 :full-name "closure-warnings/type-invalidation",
                                                 :history [["+"
                                                            "1.9.473"]]},
           "cljs.core/loop" {:ns "cljs.core",
                             :name "loop",
                             :signature ["[bindings & body]"],
                             :name-encode "loop",
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :full-name-encode "cljs.core/loop",
                             :source {:code "(core/defmacro loop\n  [bindings & body]\n  (assert-args loop\n    (vector? bindings) \"a vector for its binding\"\n    (even? (count bindings)) \"an even number of forms in binding vector\")\n  (core/let [db (destructure bindings)]\n    (if (= db bindings)\n      `(loop* ~bindings ~@body)\n      (core/let [vs (take-nth 2 (drop 1 bindings))\n                 bs (take-nth 2 bindings)\n                 gs (map (core/fn [b] (if (core/symbol? b) b (gensym))) bs)\n                 bfs (reduce (core/fn [ret [b v g]]\n                               (if (core/symbol? b)\n                                 (conj ret g v)\n                                 (conj ret g v b g)))\n                       [] (map core/vector bs vs gs))]\n        `(let ~bfs\n           (loop* ~(vec (interleave gs gs))\n             (let ~(vec (interleave bs gs))\n               ~@body)))))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/clojure/cljs/core.cljc",
                                      :lines [789 811]},
                             :full-name "cljs.core/loop",
                             :docstring "Evaluates the exprs in a lexical context in which the symbols in\nthe binding-forms are bound to their respective init-exprs or parts\ntherein. Acts as a recur target."},
           "cljs.core/subvec" {:ns "cljs.core",
                               :name "subvec",
                               :signature ["[v start]"
                                           "[v start end]"],
                               :name-encode "subvec",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/subvec",
                               :source {:code "(defn subvec\n  ([v start]\n   (subvec v start (count v)))\n  ([v start end]\n   (assert (and (not (nil? start)) (not (nil? end))))\n   (build-subvec nil v (int start) (int end) nil)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [6132 6142]},
                               :full-name "cljs.core/subvec",
                               :docstring "Returns a persistent vector of the items in vector from\nstart (inclusive) to end (exclusive).  If end is not supplied,\ndefaults to (count vector). This operation is O(1) and very fast, as\nthe resulting vector shares structure with the original and no\ntrimming is done."},
           "cljs.repl.browser/mime-type->encoding" {:ns "cljs.repl.browser",
                                                    :name "mime-type->encoding",
                                                    :name-encode "mime-type-GTencoding",
                                                    :type "var",
                                                    :full-name-encode "cljs.repl.browser/mime-type-GTencoding",
                                                    :source {:code "(def mime-type->encoding\n  {\"text/html\" \"UTF-8\"\n   \"text/css\" \"UTF-8\"\n\n   \"font/ttf\" \"ISO-8859-1\"\n   \"font/otf\" \"ISO-8859-1\"\n\n   \"application/pdf\" \"ISO-8859-1\"\n\n   \"image/jpeg\" \"ISO-8859-1\"\n   \"image/png\" \"ISO-8859-1\"\n   \"image/gif\" \"ISO-8859-1\"\n   \"image/svg+xml\" \"UTF-8\"\n\n   \"video/mp4\" \"ISO-8859-1\"\n   \"audio/m4a\" \"ISO-8859-1\"\n   \"audio/mpeg\" \"ISO-8859-1\"\n   \"video/mpeg\" \"ISO-8859-1\"\n   \"audio/wav\" \"ISO-8859-1\"\n\n   \"text/javascript\" \"UTF-8\"\n   \"text/x-clojure\" \"UTF-8\"\n   \"application/json\" \"UTF-8\"\n   \"application/wasm\" \"ISO-8859-1\"})",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r1.12.38",
                                                             :filename "src/main/clojure/cljs/repl/browser.clj",
                                                             :lines [66
                                                                     89]},
                                                    :full-name "cljs.repl.browser/mime-type->encoding",
                                                    :history [["+"
                                                               "0.0-3297"]]},
           "cljs.core/bit-clear" {:ns "cljs.core",
                                  :name "bit-clear",
                                  :signature ["[x n]"],
                                  :name-encode "bit-clear",
                                  :history [["+" "0.0-927"]],
                                  :type "function/macro",
                                  :full-name-encode "cljs.core/bit-clear",
                                  :source {:code "(defn bit-clear\n  [x n]\n  (cljs.core/bit-clear x n))",
                                           :title "Function code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [2961 2964]},
                                  :extra-sources [{:code "(core/defmacro ^::ana/numeric bit-clear [x n]\n  (core/list 'js* \"(~{} & ~(1 << ~{}))\" x n))",
                                                   :title "Macro code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/clojure/cljs/core.cljc",
                                                   :lines [1222 1223]}],
                                  :full-name "cljs.core/bit-clear",
                                  :docstring "Clear bit at index n"},
           "cljs.spec.impl.gen/bind" {:ns "cljs.spec.impl.gen",
                                      :name "bind",
                                      :signature ["[& args]"],
                                      :name-encode "bind",
                                      :history [["+" "1.9.14"]
                                                ["-" "1.9.542"]],
                                      :type "function",
                                      :full-name-encode "cljs.spec.impl.gen/bind",
                                      :source {:code "(lazy-combinators hash-map list map not-empty set vector vector-distinct fmap elements\n  bind choose one-of such-that tuple sample return\n  large-integer* double* frequency)",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.9.521",
                                               :filename "src/main/cljs/cljs/spec/impl/gen.cljs",
                                               :lines [69 71]},
                                      :full-name "cljs.spec.impl.gen/bind",
                                      :docstring "Lazy loaded version of clojure.test.check.generators/bind",
                                      :removed {:in "1.9.542",
                                                :last-seen "1.9.521"}},
           "syntax/Math-namespace" {:syntax-equiv {:edn-url nil,
                                                   :clj-url nil},
                                    :ns "syntax",
                                    :name "Math-namespace",
                                    :name-encode "Math-namespace",
                                    :type "special namespace",
                                    :full-name-encode "syntax/Math-namespace",
                                    :full-name "syntax/Math-namespace",
                                    :history [["+" "0.0-927"]]},
           "repl-options/warn-on-undeclared" {:ns "repl-options",
                                              :name "warn-on-undeclared",
                                              :name-encode "warn-on-undeclared",
                                              :type "option",
                                              :full-name-encode "repl-options/warn-on-undeclared",
                                              :full-name "repl-options/warn-on-undeclared",
                                              :history [["+"
                                                         "0.0-971"]]},
           "cljs.repl/apropos" {:ns "cljs.repl",
                                :name "apropos",
                                :signature ["[str-or-pattern]"],
                                :name-encode "apropos",
                                :history [["+" "0.0-2985"]],
                                :type "macro",
                                :full-name-encode "cljs.repl/apropos",
                                :source {:code "(defmacro apropos\n  [str-or-pattern]\n  (let [matches? (if (instance? Pattern str-or-pattern)\n                   #(re-find str-or-pattern (str %))\n                   #(.contains (str %) (str str-or-pattern)))]\n    `(quote\n       ~(sort\n          (mapcat\n            (fn [ns]\n              (let [ns-name (str ns)]\n                (map #(symbol ns-name (str %))\n                  (filter matches? (named-publics-vars ns)))))\n            (ana-api/all-ns))))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/clojure/cljs/repl.cljc",
                                         :lines [1547 1562]},
                                :full-name "cljs.repl/apropos",
                                :docstring "Given a regular expression or stringable thing, return a seq of all\npublic definitions in all currently-loaded namespaces that match the\nstr-or-pattern."},
           "cljs.core/gensym" {:ns "cljs.core",
                               :name "gensym",
                               :signature ["[]" "[prefix-string]"],
                               :name-encode "gensym",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/gensym",
                               :source {:code "(defn gensym\n  ([] (gensym \"G__\"))\n  ([prefix-string]\n     (when (nil? gensym_counter)\n       (set! gensym_counter (atom 0)))\n     (symbol (str prefix-string (swap! gensym_counter inc)))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [10951 10959]},
                               :full-name "cljs.core/gensym",
                               :docstring "Returns a new symbol with a unique name. If a prefix string is\nsupplied, the name is prefix# where # is some unique number. If\nprefix is not supplied, the prefix is 'G__'."},
           "compiler-options/optimizations" {:ns "compiler-options",
                                             :name "optimizations",
                                             :name-encode "optimizations",
                                             :type "option",
                                             :full-name-encode "compiler-options/optimizations",
                                             :full-name "compiler-options/optimizations",
                                             :history [["+" "0.0-971"]]},
           "cljs.core/MODULE_URIS" {:ns "cljs.core",
                                    :name "MODULE_URIS",
                                    :name-encode "MODULE_URIS",
                                    :type "var",
                                    :full-name-encode "cljs.core/MODULE_URIS",
                                    :source {:code "(def MODULE_URIS nil)",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [39]},
                                    :full-name "cljs.core/MODULE_URIS",
                                    :history [["+" "1.9.854"]]},
           "cljs.core/gensym_counter" {:ns "cljs.core",
                                       :name "gensym_counter",
                                       :name-encode "gensym_counter",
                                       :type "var",
                                       :full-name-encode "cljs.core/gensym_counter",
                                       :source {:code "(def\n  ^{:jsdoc [\"@type {*}\"]}\n  gensym_counter nil)",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/core.cljs",
                                                :lines [10947 10949]},
                                       :full-name "cljs.core/gensym_counter",
                                       :history [["+" "0.0-927"]]},
           "warnings/redef-in-file" {:ns "warnings",
                                     :name "redef-in-file",
                                     :name-encode "redef-in-file",
                                     :type "warning",
                                     :full-name-encode "warnings/redef-in-file",
                                     :full-name "warnings/redef-in-file",
                                     :history [["+" "0.0-2629"]]},
           "cljs.core/in-ns" {:ns "cljs.core",
                              :name "in-ns",
                              :signature ["[name]"],
                              :name-encode "in-ns",
                              :history [["+" "0.0-927"]],
                              :type "special form (repl)",
                              :full-name-encode "cljs.core/in-ns",
                              :source {:code "(def default-special-fns\n  (let [load-file-fn\n        (fn self\n          ([repl-env env form]\n            (self repl-env env form nil))\n          ([repl-env env [_ file :as form] opts]\n            (load-file repl-env file opts)))\n        in-ns-fn\n        (fn self\n          ([repl-env env form]\n           (self repl-env env form nil))\n          ([repl-env env [_ [quote ns-name] :as form] _]\n            ;; guard against craziness like '5 which wreaks havoc\n           (when-not (and (= quote 'quote) (symbol? ns-name))\n             (throw (IllegalArgumentException. \"Argument to in-ns must be a symbol.\")))\n           (when-not (ana/get-namespace ns-name)\n             (swap! env/*compiler* assoc-in [::ana/namespaces ns-name] {:name ns-name})\n             (-evaluate repl-env \"<cljs repl>\" 1\n               (str \"goog.provide('\" (comp/munge ns-name) \"');\")))\n           (set! ana/*cljs-ns* ns-name)))\n        load-fn\n        (fn self\n          ([repl-env env form]\n           (self env repl-env form nil))\n          ([repl-env env [_ & paths :as form] opts]\n           (let [cp-paths (map load-path->cp-path paths)]\n             (run! #(load-file repl-env % opts) cp-paths))))]\n    (wrap-special-fns wrap-self\n     {'in-ns in-ns-fn\n      'clojure.core/in-ns in-ns-fn\n      'load-file load-file-fn\n      'clojure.core/load-file load-file-fn\n      'load-namespace\n      (fn self\n        ([repl-env env form]\n         (self env repl-env form nil))\n        ([repl-env env [_ ns :as form] opts]\n         (load-namespace repl-env ns opts)))\n      'load load-fn\n      'clojure.core/load load-fn})))",
                                       :title "repl specials table",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/clojure/cljs/repl.cljc",
                                       :lines [754 793]},
                              :full-name "cljs.core/in-ns",
                              :repl-only? true,
                              :docstring "Sets *cljs-ns* to the namespace named by the symbol, creating it if needed."},
           "cljs.core/Symbol" {:protocols #{"IFn"
                                            "IMeta"
                                            "IWithMeta"
                                            "IHash"
                                            "INamed"
                                            "IComparable"
                                            "IPrintWithWriter"
                                            "IEquiv"},
                               :ns "cljs.core",
                               :name "Symbol",
                               :signature ["[ns name str _hash _meta]"],
                               :name-encode "Symbol",
                               :history [["+" "0.0-1798"]],
                               :type "type",
                               :full-name-encode "cljs.core/Symbol",
                               :source {:code "(deftype Symbol [ns name str ^:mutable _hash _meta]\n  Object\n  (toString [_] str)\n  (equiv [this other] (-equiv this other))\n\n  IEquiv\n  (-equiv [_ other]\n    (if (instance? Symbol other)\n      (identical? str (.-str other))\n      false))\n\n  IFn\n  (-invoke [sym coll]\n    (get coll sym))\n  (-invoke [sym coll not-found]\n    (get coll sym not-found))\n\n  IMeta\n  (-meta [_] _meta)\n\n  IWithMeta\n  (-with-meta [_ new-meta] (Symbol. ns name str _hash new-meta))\n\n  IHash\n  (-hash [sym]\n    (caching-hash sym hash-symbol _hash))\n\n  INamed\n  (-name [_] name)\n  (-namespace [_] ns)\n\n  IPrintWithWriter\n  (-pr-writer [o writer _] (-write writer str)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [1099 1131]},
                               :full-name "cljs.core/Symbol"},
           "cljs.core/hash-string*" {:ns "cljs.core",
                                     :name "hash-string*",
                                     :signature ["[s]"],
                                     :name-encode "hash-stringSTAR",
                                     :history [["+" "0.0-2261"]],
                                     :type "function",
                                     :full-name-encode "cljs.core/hash-stringSTAR",
                                     :source {:code "(defn hash-string* [s]\n  (if-not (nil? s)\n    (let [len (.-length s)]\n      (if (pos? len)\n        (loop [i 0 hash 0]\n          (if (< i len)\n            (recur (inc i) (+ (imul 31 hash) (.charCodeAt s i)))\n            hash))\n        0))\n    0))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/cljs/cljs/core.cljs",
                                              :lines [996 1005]},
                                     :full-name "cljs.core/hash-string*"},
           "cljs.core/shuffle" {:ns "cljs.core",
                                :name "shuffle",
                                :signature ["[coll]"],
                                :name-encode "shuffle",
                                :history [["+" "0.0-1424"]],
                                :type "function",
                                :full-name-encode "cljs.core/shuffle",
                                :source {:code "(defn shuffle\n  [coll]\n  (let [a (to-array coll)]\n    (garray/shuffle a)\n    (vec a)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [2557 2562]},
                                :full-name "cljs.core/shuffle",
                                :docstring "Return a random permutation of coll"},
           "cljs.core/+" {:return-type number,
                          :ns "cljs.core",
                          :name "+",
                          :signature ["[]"
                                      "[x]"
                                      "[x y]"
                                      "[x y & more]"],
                          :name-encode "PLUS",
                          :history [["+" "0.0-927"]],
                          :type "function/macro",
                          :full-name-encode "cljs.core/PLUS",
                          :source {:code "(defn ^number +\n  ([] 0)\n  ([x] x)\n  ([x y] (cljs.core/+ x y))\n  ([x y & more]\n    (reduce + (cljs.core/+ x y) more)))",
                                   :title "Function code",
                                   :repo "clojurescript",
                                   :tag "r1.12.38",
                                   :filename "src/main/cljs/cljs/core.cljs",
                                   :lines [2683 2689]},
                          :extra-sources [{:code "(core/defmacro ^::ana/numeric +\n  ([] 0)\n  ([x] (core/list 'js* \"(~{})\" x))\n  ([x y] (core/list 'js* \"(~{} + ~{})\" x y))\n  ([x y & more] `(+ (+ ~x ~y) ~@more)))",
                                           :title "Macro code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/clojure/cljs/core.cljc",
                                           :lines [1060 1064]}],
                          :full-name "cljs.core/+",
                          :docstring "Returns the sum of nums. (+) returns 0."},
           "cljs.core/clone" {:ns "cljs.core",
                              :name "clone",
                              :signature ["[value]"],
                              :name-encode "clone",
                              :history [["+" "0.0-2134"]],
                              :type "function",
                              :full-name-encode "cljs.core/clone",
                              :source {:code "(defn clone\n  [value]\n  (-clone value))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [1240 1243]},
                              :full-name "cljs.core/clone",
                              :docstring "Clone the supplied value which must implement ICloneable."},
           "cljs.core/comp" {:ns "cljs.core",
                             :name "comp",
                             :signature ["[]"
                                         "[f]"
                                         "[f g]"
                                         "[f g h]"
                                         "[f1 f2 f3 & fs]"],
                             :name-encode "comp",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/comp",
                             :source {:code "(defn comp\n  ([] identity)\n  ([f] f)\n  ([f g]\n     (fn\n       ([] (f (g)))\n       ([x] (f (g x)))\n       ([x y] (f (g x y)))\n       ([x y z] (f (g x y z)))\n       ([x y z & args] (f (apply g x y z args)))))\n  ([f g h]\n     (fn\n       ([] (f (g (h))))\n       ([x] (f (g (h x))))\n       ([x y] (f (g (h x y))))\n       ([x y z] (f (g (h x y z))))\n       ([x y z & args] (f (g (apply h x y z args))))))\n  ([f1 f2 f3 & fs]\n    (let [fs (reverse (list* f1 f2 f3 fs))]\n      (fn [& args]\n        (loop [ret (apply (first fs) args) fs (next fs)]\n          (if fs\n            (recur ((first fs) ret) (next fs))\n            ret))))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [4374 4401]},
                             :full-name "cljs.core/comp",
                             :docstring "Takes a set of functions and returns a fn that is the composition\nof those fns.  The returned fn takes a variable number of args,\napplies the rightmost of fns to the args, the next\nfn (right-to-left) to the result, etc."},
           "cljs.core/ArrayIter" {:ns "cljs.core",
                                  :name "ArrayIter",
                                  :signature ["[arr i]"],
                                  :name-encode "ArrayIter",
                                  :history [["+" "0.0-2301"]],
                                  :type "type",
                                  :full-name-encode "cljs.core/ArrayIter",
                                  :source {:code "(deftype ArrayIter [arr ^:mutable i]\n  Object\n  (hasNext [_] (< i (alength arr)))\n  (next [_]\n    (let [ret (aget arr i)]\n      (set! i (inc i))\n      ret))\n  (remove [_] (js/Error. \"Unsupported operation\")))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [4123 4130]},
                                  :full-name "cljs.core/ArrayIter"},
           "syntax/comma" {:syntax-equiv {:edn-url nil, :clj-url nil},
                           :ns "syntax",
                           :name "comma",
                           :name-encode "comma",
                           :type "special character",
                           :full-name-encode "syntax/comma",
                           :full-name "syntax/comma",
                           :history [["+" "0.0-927"]]},
           "cljs.core/var?" {:ns "cljs.core",
                             :name "var?",
                             :signature ["[v]"],
                             :name-encode "varQMARK",
                             :history [["+" "0.0-3255"]],
                             :type "function",
                             :full-name-encode "cljs.core/varQMARK",
                             :source {:code "(defn var?\n  [v]\n  (instance? cljs.core.Var v))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [1133 1136]},
                             :full-name "cljs.core/var?",
                             :docstring "Returns true if v is of type cljs.core.Var"},
           "cljs.reader/desugar-meta" {:ns "cljs.reader",
                                       :name "desugar-meta",
                                       :signature ["[f]"],
                                       :name-encode "desugar-meta",
                                       :history [["+" "0.0-927"]
                                                 ["-" "1.9.854"]],
                                       :type "function",
                                       :full-name-encode "cljs.reader/desugar-meta",
                                       :source {:code "(defn desugar-meta\n  [f]\n  (cond\n   (symbol? f) {:tag f}\n   (string? f) {:tag f}\n   (keyword? f) {f true}\n   :else f))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.9.671",
                                                :filename "src/main/cljs/cljs/reader.cljs",
                                                :lines [381 387]},
                                       :full-name "cljs.reader/desugar-meta",
                                       :removed {:in "1.9.854",
                                                 :last-seen "1.9.671"}},
           "cljs.spec/form" {:ns "cljs.spec",
                             :name "form",
                             :signature ["[spec]"],
                             :name-encode "form",
                             :history [["+" "1.9.14"] ["-" "1.9.542"]],
                             :type "function",
                             :full-name-encode "cljs.spec/form",
                             :source {:code "(defn form\n  [spec]\n  ;;TODO - incorporate gens\n  (describe* (specize spec)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.9.521",
                                      :filename "src/main/cljs/cljs/spec.cljs",
                                      :lines [162 166]},
                             :full-name "cljs.spec/form",
                             :docstring "returns the spec as data",
                             :removed {:in "1.9.542",
                                       :last-seen "1.9.521"}},
           "closure-warnings/jsdoc-missing-type" {:ns "closure-warnings",
                                                  :name "jsdoc-missing-type",
                                                  :name-encode "jsdoc-missing-type",
                                                  :type "warning",
                                                  :full-name-encode "closure-warnings/jsdoc-missing-type",
                                                  :full-name "closure-warnings/jsdoc-missing-type",
                                                  :history [["+"
                                                             "1.10.217"]]},
           "cljs.repl/load-namespace" {:ns "cljs.repl",
                                       :name "load-namespace",
                                       :signature ["[repl-env ns]"
                                                   "[repl-env ns opts]"],
                                       :name-encode "load-namespace",
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "cljs.repl/load-namespace",
                                       :source {:code "(defn load-namespace\n  ([repl-env ns] (load-namespace repl-env ns nil))\n  ([repl-env ns opts]\n   (let [ns      (if (and (seq? ns) (= (first ns) 'quote)) (second ns) ns)\n         sources (seq\n                   (when-not (ana/node-module-dep? ns)\n                     (let [input (ns->input ns opts)]\n                       (if (compilable? input)\n                         (->> (cljsc/compile-inputs [input]\n                                (merge (env->opts repl-env) opts))\n                           (remove (comp #{[\"goog\"]} :provides)))\n                         (map #(cljsc/source-on-disk opts %)\n                              (cljsc/add-js-sources [input] opts))))))]\n     (when (:repl-verbose opts)\n       (println (str \"load-namespace \" ns \" , compiled:\") (map :provides sources)))\n     (load-sources repl-env sources opts)\n     sources)))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/clojure/cljs/repl.cljc",
                                                :lines [233 252]},
                                       :full-name "cljs.repl/load-namespace",
                                       :docstring "Load a namespace and all of its dependencies into the evaluation environment.\nThe environment is responsible for ensuring that each namespace is\nloaded once and only once. Returns the compiled sources."},
           "cljs.pprint/fresh-line" {:ns "cljs.pprint",
                                     :name "fresh-line",
                                     :signature ["[]"],
                                     :name-encode "fresh-line",
                                     :history [["+" "0.0-3255"]],
                                     :type "function",
                                     :full-name-encode "cljs.pprint/fresh-line",
                                     :source {:code "(defn fresh-line\n  []\n  (if (satisfies? IDeref *out*)\n    (if (not (= 0 (get-column (:base @@*out*))))\n      (prn))\n    (prn)))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/cljs/cljs/pprint.cljs",
                                              :lines [2096 2103]},
                                     :full-name "cljs.pprint/fresh-line",
                                     :docstring "Make a newline if *out* is not already at the beginning of the line. If *out* is\nnot a pretty writer (which keeps track of columns), this function always outputs a newline."},
           "cljs.repl.rhino/wrap-fn" {:ns "cljs.repl.rhino",
                                      :name "wrap-fn",
                                      :signature ["[form]"],
                                      :name-encode "wrap-fn",
                                      :history [["+" "0.0-2985"]
                                                ["-" "1.10.738"]],
                                      :type "function",
                                      :full-name-encode "cljs.repl.rhino/wrap-fn",
                                      :source {:code "(defn wrap-fn [form]\n  (cond\n    (and (seq? form)\n      (#{'ns 'require 'require-macros\n         'use 'use-macros 'import 'refer-clojure} (first form)))\n    identity\n\n    ('#{*1 *2 *3 *e} form) (fn [x] `(cljs.core.pr-str ~x))\n\n    :else\n    (fn [x]\n      `(cljs.core.pr-str\n         (let [ret# ~x]\n           (set! *3 *2)\n           (set! *2 *1)\n           (set! *1 ret#)\n           ret#)))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.10.597",
                                               :filename "src/main/clojure/cljs/repl/rhino.clj",
                                               :lines [169 185]},
                                      :full-name "cljs.repl.rhino/wrap-fn",
                                      :removed {:in "1.10.738",
                                                :last-seen "1.10.597"}},
           "cljs.math/copy-sign" {:return-type number,
                                  :ns "cljs.math",
                                  :name "copy-sign",
                                  :signature ["[magnitude sign]"],
                                  :name-encode "copy-sign",
                                  :history [["+" "1.11.50"]],
                                  :type "function",
                                  :full-name-encode "cljs.math/copy-sign",
                                  :source {:code "(defn ^number copy-sign\n  {:added \"1.11.10\"}\n  [magnitude sign]\n  ;; create a buffer large enough for 2 doubles\n  (let [a (js/ArrayBuffer. 16)\n        ;; represent the buffer as a double array\n        d (js/Float64Array. a)\n        ;; represent the buffer as bytes\n        b (js/Uint8Array. a)\n        ;; find the offset of the byte that holds the sign bit\n        sbyte (if little-endian? 7 0)]\n    ;; the first double holds the magnitude, the second holds the sign value\n    (aset d 0 magnitude)\n    (aset d 1 sign)\n    ;; read the sign bit from the sign value\n    (let [sign-sbyte (bit-and 0x80 (aget b (+ 8 sbyte)))\n          ;; read all the bits that aren't the sign bit in the same byte of the magnitude\n          mag-sbyte (bit-and 0x7F (aget b sbyte))]\n      ;; combine the sign bit from the sign value and the non-sign-bits from the magnitude value\n      ;; write it back into the byte in the magnitude\n      (aset b sbyte (bit-or sign-sbyte mag-sbyte))\n      ;; retrieve the full magnitude value with the updated byte\n      (aget d 0))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/math.cljs",
                                           :lines [438 463]},
                                  :full-name "cljs.math/copy-sign",
                                  :docstring "Returns a double with the magnitude of the first argument and the sign of\nthe second.\nSee: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#copySign-double-double-"},
           "cljs.repl/known-repl-opts" {:ns "cljs.repl",
                                        :name "known-repl-opts",
                                        :name-encode "known-repl-opts",
                                        :type "var",
                                        :full-name-encode "cljs.repl/known-repl-opts",
                                        :source {:code "(def known-repl-opts\n  #{:analyze-path :bind-err :caught :compiler-env :def-emits-var :eval :flush\n    :init :inits :need-prompt :print :print-no-newline :prompt :quit-prompt :read\n    :reader :repl-requires :repl-verbose :source-map-inline :watch :watch-fn\n    :wrap})",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/clojure/cljs/repl.cljc",
                                                 :lines [38 43]},
                                        :full-name "cljs.repl/known-repl-opts",
                                        :history [["+" "1.8.34"]]},
           "cljs.spec.test.alpha/get-host-port" {:ns "cljs.spec.test.alpha",
                                                 :name "get-host-port",
                                                 :signature ["[]"],
                                                 :name-encode "get-host-port",
                                                 :history [["+"
                                                            "1.9.542"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.spec.test.alpha/get-host-port",
                                                 :source {:code "(defn get-host-port []\n  (if (not= \"browser\" *target*)\n    {}\n    {:host (.. js/window -location -host)\n     :port (.. js/window -location -port)}))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r1.12.38",
                                                          :filename "src/main/cljs/cljs/spec/test/alpha.cljs",
                                                          :lines [43
                                                                  47]},
                                                 :full-name "cljs.spec.test.alpha/get-host-port"},
           "cljs.core/pr" {:ns "cljs.core",
                           :name "pr",
                           :signature ["[& objs]"],
                           :name-encode "pr",
                           :history [["+" "0.0-927"]],
                           :type "function",
                           :full-name-encode "cljs.core/pr",
                           :source {:code "(defn pr\n  [& objs]\n  (pr-with-opts objs (pr-opts)))",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r1.12.38",
                                    :filename "src/main/cljs/cljs/core.cljs",
                                    :lines [10654 10660]},
                           :full-name "cljs.core/pr",
                           :docstring "Prints the object(s) using string-print.  Prints the\nobject(s), separated by spaces if there is more than one.\nBy default, pr and prn print in a way that objects can be\nread by the reader"},
           "compiler-options/static-fns" {:ns "compiler-options",
                                          :name "static-fns",
                                          :name-encode "static-fns",
                                          :type "option",
                                          :full-name-encode "compiler-options/static-fns",
                                          :full-name "compiler-options/static-fns",
                                          :history [["+" "0.0-1424"]]},
           "cljs.test/run-tests" {:ns "cljs.test",
                                  :name "run-tests",
                                  :signature ["[]"
                                              "[env-or-ns]"
                                              "[env-or-ns & namespaces]"],
                                  :name-encode "run-tests",
                                  :history [["+" "0.0-2496"]],
                                  :type "macro",
                                  :full-name-encode "cljs.test/run-tests",
                                  :source {:code "(defmacro run-tests\n  ([] `(run-tests (empty-env) '~ana/*cljs-ns*))\n  ([env-or-ns]\n   (if (ns? env-or-ns)\n     `(run-tests (empty-env) ~env-or-ns)\n     `(run-tests ~env-or-ns '~ana/*cljs-ns*)))\n  ([env-or-ns & namespaces]\n   `(run-block (run-tests-block ~env-or-ns ~@namespaces))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/test.cljc",
                                           :lines [308 320]},
                                  :full-name "cljs.test/run-tests",
                                  :docstring "Runs all tests in the given namespaces; prints results.\nDefaults to current namespace if none given. Does not return a meaningful\nvalue due to the possiblity of asynchronous execution. To detect test\ncompletion add a :end-run-tests method case to the cljs.test/report\nmultimethod."},
           "clojure.string/upper-case" {:return-type string,
                                        :ns "clojure.string",
                                        :name "upper-case",
                                        :signature ["[s]"],
                                        :name-encode "upper-case",
                                        :history [["+" "0.0-927"]],
                                        :type "function",
                                        :full-name-encode "clojure.string/upper-case",
                                        :source {:code "(defn ^string upper-case\n  [s]\n  (.toUpperCase s))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/cljs/clojure/string.cljs",
                                                 :lines [119 122]},
                                        :full-name "clojure.string/upper-case",
                                        :docstring "Converts string to all upper-case."},
           "cljs.core/chars" {:ns "cljs.core",
                              :name "chars",
                              :signature ["[x]"],
                              :name-encode "chars",
                              :history [["+" "0.0-1798"]],
                              :type "function",
                              :full-name-encode "cljs.core/chars",
                              :source {:code "(defn chars [x] x)",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [2908]},
                              :full-name "cljs.core/chars"},
           "cljs.core/coercive-boolean" {:ns "cljs.core",
                                         :name "coercive-boolean",
                                         :signature ["[x]"],
                                         :name-encode "coercive-boolean",
                                         :history [["+" "0.0-1798"]
                                                   ["-" "1.9.493"]
                                                   ["+" "1.9.494"]],
                                         :type "macro",
                                         :full-name-encode "cljs.core/coercive-boolean",
                                         :source {:code "(core/defmacro coercive-boolean [x]\n  (with-meta (core/list 'js* \"~{}\" x)\n    {:tag 'boolean}))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/clojure/cljs/core.cljc",
                                                  :lines [914 916]},
                                         :full-name "cljs.core/coercive-boolean"},
           "cljs.analyzer.api/find-ns" {:ns "cljs.analyzer.api",
                                        :name "find-ns",
                                        :signature ["[sym]"
                                                    "[state sym]"],
                                        :name-encode "find-ns",
                                        :history [["+" "0.0-2496"]],
                                        :type "function",
                                        :full-name-encode "cljs.analyzer.api/find-ns",
                                        :source {:code "(defn find-ns\n  ([sym]\n   (find-ns env/*compiler* sym))\n  ([state sym]\n   {:pre [(symbol? sym)]}\n   (get-in @state [::ana/namespaces sym])))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/clojure/cljs/analyzer/api.cljc",
                                                 :lines [221 228]},
                                        :full-name "cljs.analyzer.api/find-ns",
                                        :docstring "Given a namespace return the corresponding namespace analysis map. Analagous\nto clojure.core/find-ns."},
           "cljs.core/boolean?" {:ns "cljs.core",
                                 :name "boolean?",
                                 :signature ["[x]"],
                                 :name-encode "booleanQMARK",
                                 :history [["+" "1.9.75"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/booleanQMARK",
                                 :source {:code "(defn boolean?\n  [x] (or (cljs.core/true? x) (cljs.core/false? x)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [2290 2292]},
                                 :full-name "cljs.core/boolean?",
                                 :docstring "Return true if x is a Boolean"},
           "cljs.spec.gen.alpha/vector-distinct" {:ns "cljs.spec.gen.alpha",
                                                  :name "vector-distinct",
                                                  :signature ["[& args]"],
                                                  :name-encode "vector-distinct",
                                                  :history [["+"
                                                             "1.9.542"]],
                                                  :type "function",
                                                  :full-name-encode "cljs.spec.gen.alpha/vector-distinct",
                                                  :source {:code "(lazy-combinators hash-map list map not-empty set vector vector-distinct fmap elements\n  bind choose one-of such-that tuple sample return\n  large-integer* double* frequency shuffle)",
                                                           :title "Source code",
                                                           :repo "clojurescript",
                                                           :tag "r1.12.38",
                                                           :filename "src/main/cljs/cljs/spec/gen/alpha.cljs",
                                                           :lines [70
                                                                   72]},
                                                  :full-name "cljs.spec.gen.alpha/vector-distinct",
                                                  :docstring "Lazy loaded version of clojure.test.check.generators/vector-distinct"},
           "syntax/string" {:syntax-equiv {:edn-url nil, :clj-url nil},
                            :ns "syntax",
                            :name "string",
                            :name-encode "string",
                            :history [["+" "0.0-1853"]],
                            :type "syntax",
                            :full-name-encode "syntax/string",
                            :extra-sources ({:code "(defn- read-string*\n  [reader _ opts pending-forms]\n  (loop [sb (StringBuilder.)\n         ch (read-char reader)]\n    (case ch\n      nil (err/throw-eof-reading reader :string sb)\n      \\\\ (recur (doto sb (.append (escape-char sb reader)))\n                (read-char reader))\n      \\\" (str sb)\n      (recur (doto sb (.append ch)) (read-char reader)))))",
                                             :title "Reader code",
                                             :repo "tools.reader",
                                             :tag "v1.3.6",
                                             :filename "src/main/clojure/clojure/tools/reader.clj",
                                             :lines [293 302]}
                                            {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                             :title "Reader table",
                                             :repo "tools.reader",
                                             :tag "v1.3.6",
                                             :filename "src/main/clojure/clojure/tools/reader.clj",
                                             :lines [788 807]}),
                            :full-name "syntax/string"},
           "closure-warnings/strict-requires" {:ns "closure-warnings",
                                               :name "strict-requires",
                                               :name-encode "strict-requires",
                                               :type "warning",
                                               :full-name-encode "closure-warnings/strict-requires",
                                               :full-name "closure-warnings/strict-requires",
                                               :history [["+"
                                                          "1.9.473"]]},
           "clojure.browser.event/expose" {:ns "clojure.browser.event",
                                           :name "expose",
                                           :signature ["[e]"],
                                           :name-encode "expose",
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "clojure.browser.event/expose",
                                           :source {:code "(defn expose [e]\n  (events/expose e))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/cljs/clojure/browser/event.cljs",
                                                    :lines [81 82]},
                                           :full-name "clojure.browser.event/expose"},
           "cljs.core/partitionv" {:ns "cljs.core",
                                   :name "partitionv",
                                   :signature ["[n coll]"
                                               "[n step coll]"
                                               "[n step pad coll]"],
                                   :name-encode "partitionv",
                                   :history [["+" "1.11.121"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/partitionv",
                                   :source {:code "(defn partitionv\n  ([n coll]\n   (partitionv n n coll))\n  ([n step coll]\n   (lazy-seq\n     (when-let [s (seq coll)]\n       (let [p (into [] (take n) s)]\n         (when (= n (count p))\n           (cons p (partitionv n step (nthrest s step))))))))\n  ([n step pad coll]\n   (lazy-seq\n     (when-let [s (seq coll)]\n       (let [p (into [] (take n) s)]\n         (if (= n (count p))\n           (cons p (partitionv n step pad (nthrest s step)))\n           (list (into [] (take n) (concat p pad)))))))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [9825 9845]},
                                   :full-name "cljs.core/partitionv",
                                   :docstring "Returns a lazy sequence of vectors of n items each, at offsets step\napart. If step is not supplied, defaults to n, i.e. the partitions\ndo not overlap. If a pad collection is supplied, use its elements as\nnecessary to complete last partition upto n items. In case there are\nnot enough padding elements, return a partition with less than n items."},
           "clojure.browser.event/listen-once" {:ns "clojure.browser.event",
                                                :name "listen-once",
                                                :signature ["[src type fn]"
                                                            "[src type fn capture?]"],
                                                :name-encode "listen-once",
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "clojure.browser.event/listen-once",
                                                :source {:code "(defn listen-once\n  ([src type fn]\n     (listen-once src type fn false))\n  ([src type fn capture?]\n     (events/listenOnce src\n                        (get (event-types src) type type)\n                        fn\n                        capture?)))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1.12.38",
                                                         :filename "src/main/cljs/clojure/browser/event.cljs",
                                                         :lines [55
                                                                 62]},
                                                :full-name "clojure.browser.event/listen-once"},
           "cljs.spec.gen.alpha/LazyVar" {:protocols #{"IDeref"},
                                          :ns "cljs.spec.gen.alpha",
                                          :name "LazyVar",
                                          :signature ["[f cached]"],
                                          :name-encode "LazyVar",
                                          :history [["+" "1.9.542"]],
                                          :type "type",
                                          :full-name-encode "cljs.spec.gen.alpha/LazyVar",
                                          :source {:code "(deftype LazyVar [f ^:mutable cached]\n  IDeref\n  (-deref [this]\n    (if-not (nil? cached)\n      cached\n      (let [x (f)]\n        (when-not (nil? x)\n          (set! cached x))\n        x))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/cljs/cljs/spec/gen/alpha.cljs",
                                                   :lines [17 25]},
                                          :full-name "cljs.spec.gen.alpha/LazyVar"},
           "cljs.core/m3-C1" {:ns "cljs.core",
                              :name "m3-C1",
                              :name-encode "m3-C1",
                              :type "var",
                              :full-name-encode "cljs.core/m3-C1",
                              :source {:code "(def m3-C1 (int 0xcc9e2d51))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [938]},
                              :full-name "cljs.core/m3-C1",
                              :history [["+" "0.0-2261"]]},
           "cljs.core/empty?" {:ns "cljs.core",
                               :name "empty?",
                               :signature ["[coll]"],
                               :name-encode "emptyQMARK",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/emptyQMARK",
                               :source {:code "(defn empty?\n  [coll]\n  (cond\n    (nil? coll)\n    true\n\n    (satisfies? ICounted coll)\n    (zero? (-count coll))\n\n    :else\n    (not (seq coll))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [2172 2184]},
                               :full-name "cljs.core/empty?",
                               :docstring "Returns true if coll has no items. To check the emptiness of a seq,\nplease use the idiom (seq x) rather than (not (empty? x))"},
           "cljs.core/m3-fmix" {:return-type number,
                                :ns "cljs.core",
                                :name "m3-fmix",
                                :signature ["[h1 len]"],
                                :name-encode "m3-fmix",
                                :history [["+" "0.0-2261"]],
                                :type "function",
                                :full-name-encode "cljs.core/m3-fmix",
                                :source {:code "(defn ^number m3-fmix [h1 len]\n  (as-> (int h1) h1\n    (bit-xor h1 len)\n    (bit-xor h1 (unsigned-bit-shift-right h1 16))\n    (imul h1 (int 0x85ebca6b))\n    (bit-xor h1 (unsigned-bit-shift-right h1 13))\n    (imul h1 (int 0xc2b2ae35))\n    (bit-xor h1 (unsigned-bit-shift-right h1 16))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [947 954]},
                                :full-name "cljs.core/m3-fmix"},
           "clojure.browser.repl/*repl*" {:ns "clojure.browser.repl",
                                          :name "*repl*",
                                          :name-encode "STARreplSTAR",
                                          :type "dynamic var",
                                          :full-name-encode "clojure.browser.repl/STARreplSTAR",
                                          :source {:code "(def ^:dynamic *repl* nil)",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/cljs/clojure/browser/repl.cljs",
                                                   :lines [34]},
                                          :full-name "clojure.browser.repl/*repl*",
                                          :history [["+" "1.10.217"]]},
           "compiler-options/pretty-print" {:ns "compiler-options",
                                            :name "pretty-print",
                                            :name-encode "pretty-print",
                                            :type "option",
                                            :full-name-encode "compiler-options/pretty-print",
                                            :full-name "compiler-options/pretty-print",
                                            :history [["+" "0.0-971"]]},
           "cljs.core/newline" {:ns "cljs.core",
                                :name "newline",
                                :signature ["[]" "[opts]"],
                                :name-encode "newline",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/newline",
                                :source {:code "(defn newline\n  ([] (newline nil))\n  ([opts]\n   (string-print \"\\n\")\n   (when (get opts :flush-on-newline)\n     (flush))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [10636 10642]},
                                :full-name "cljs.core/newline",
                                :docstring "Prints a newline using *print-fn*"},
           "repl-options/flush" {:ns "repl-options",
                                 :name "flush",
                                 :name-encode "flush",
                                 :type "option",
                                 :full-name-encode "repl-options/flush",
                                 :full-name "repl-options/flush",
                                 :history [["+" "0.0-2911"]]},
           "cljs.core/PersistentHashMap" {:protocols #{"IFn"
                                                       "ISeqable"
                                                       "IMap"
                                                       "IMeta"
                                                       "IWithMeta"
                                                       "IKVReduce"
                                                       "IEditableCollection"
                                                       "IEmptyableCollection"
                                                       "ICounted"
                                                       "ILookup"
                                                       "ICollection"
                                                       "IHash"
                                                       "IPrintWithWriter"
                                                       "IIterable"
                                                       "IAssociative"
                                                       "IFind"
                                                       "IEquiv"
                                                       "ICloneable"},
                                          :ns "cljs.core",
                                          :name "PersistentHashMap",
                                          :signature ["[meta cnt root has-nil? nil-val __hash]"],
                                          :name-encode "PersistentHashMap",
                                          :history [["+" "0.0-1211"]],
                                          :type "type",
                                          :full-name-encode "cljs.core/PersistentHashMap",
                                          :source {:code "(deftype PersistentHashMap [meta cnt root ^boolean has-nil? nil-val ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (keys [coll]\n    (es6-iterator (keys coll)))\n  (entries [coll]\n    (es6-entries-iterator (seq coll)))\n  (values [coll]\n    (es6-iterator (vals coll)))\n  (has [coll k]\n    (contains? coll k))\n  (get [coll k not-found]\n    (-lookup coll k not-found))\n  (forEach [coll f]\n    (doseq [[k v] coll]\n      (f v k)))\n\n  ICloneable\n  (-clone [_] (PersistentHashMap. meta cnt root has-nil? nil-val __hash))\n\n  IIterable\n  (-iterator [coll]\n    (let [root-iter (if ^boolean root (-iterator root) (nil-iter))]\n      (if has-nil?\n        (HashMapIter. nil-val root-iter false)\n        root-iter)))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (PersistentHashMap. new-meta cnt root has-nil? nil-val __hash)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (loop [ret coll es (seq entry)]\n        (if (nil? es)\n          ret\n          (let [e (first es)]\n            (if (vector? e)\n              (recur (-assoc ret (-nth e 0) (-nth e 1))\n                     (next es))\n              (throw (js/Error. \"conj on a map takes map entries or seqables of map entries\"))))))))\n\n  IEmptyableCollection\n  (-empty [coll] (-with-meta (.-EMPTY PersistentHashMap) meta))\n\n  IEquiv\n  (-equiv [coll other] (equiv-map coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-unordered-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (when (pos? cnt)\n      (let [s (if-not (nil? root) (.inode-seq root))]\n        (if has-nil?\n          (cons (MapEntry. nil nil-val nil) s)\n          s))))\n\n  ICounted\n  (-count [coll] cnt)\n\n  ILookup\n  (-lookup [coll k]\n    (-lookup coll k nil))\n\n  (-lookup [coll k not-found]\n    (cond (nil? k)    (if has-nil?\n                        nil-val\n                        not-found)\n          (nil? root) not-found\n          :else       (.inode-lookup root 0 (hash k) k not-found)))\n\n  IAssociative\n  (-assoc [coll k v]\n    (if (nil? k)\n      (if (and has-nil? (identical? v nil-val))\n        coll\n        (PersistentHashMap. meta (if has-nil? cnt (inc cnt)) root true v nil))\n      (let [added-leaf? (Box. false)\n            new-root    (-> (if (nil? root)\n                              (.-EMPTY BitmapIndexedNode)\n                              root)\n                            (.inode-assoc 0 (hash k) k v added-leaf?))]\n        (if (identical? new-root root)\n          coll\n          (PersistentHashMap. meta (if ^boolean (.-val added-leaf?) (inc cnt) cnt) new-root has-nil? nil-val nil)))))\n\n  (-contains-key? [coll k]\n    (cond (nil? k)    has-nil?\n          (nil? root) false\n          :else       (not (identical? (.inode-lookup root 0 (hash k) k lookup-sentinel)\n                                       lookup-sentinel))))\n\n  IFind\n  (-find [coll k]\n    (cond\n      (nil? k) (when has-nil? (MapEntry. nil nil-val nil))\n      (nil? root) nil\n      :else (.inode-find root 0 (hash k) k nil)))\n\n  IMap\n  (-dissoc [coll k]\n    (cond (nil? k)    (if has-nil?\n                        (PersistentHashMap. meta (dec cnt) root false nil nil)\n                        coll)\n          (nil? root) coll\n          :else\n          (let [new-root (.inode-without root 0 (hash k) k)]\n            (if (identical? new-root root)\n              coll\n              (PersistentHashMap. meta (dec cnt) new-root has-nil? nil-val nil)))))\n\n  IKVReduce\n  (-kv-reduce [coll f init]\n    (let [init (if has-nil? (f init nil nil-val) init)]\n      (cond\n        (reduced? init)          @init\n        (not (nil? root)) (unreduced (.kv-reduce root f init))\n        :else                    init)))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found))\n\n  IEditableCollection\n  (-as-transient [coll]\n    (TransientHashMap. (js-obj) root cnt has-nil? nil-val)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/cljs/cljs/core.cljs",
                                                   :lines [8087 8227]},
                                          :full-name "cljs.core/PersistentHashMap"},
           "cljs.spec/*" {:ns "cljs.spec",
                          :name "*",
                          :signature ["[pred-form]"],
                          :name-encode "STAR",
                          :history [["+" "1.9.14"] ["-" "1.9.542"]],
                          :type "macro",
                          :full-name-encode "cljs.spec/STAR",
                          :source {:code "(defmacro *\n  [pred-form]\n  `(rep-impl '~(res &env pred-form) ~pred-form))",
                                   :title "Source code",
                                   :repo "clojurescript",
                                   :tag "r1.9.521",
                                   :filename "src/main/cljs/cljs/spec.cljc",
                                   :lines [301 305]},
                          :full-name "cljs.spec/*",
                          :docstring "Returns a regex op that matches zero or more values matching\npred. Produces a vector of matches iff there is at least one match",
                          :removed {:in "1.9.542",
                                    :last-seen "1.9.521"}},
           "cljs.spec.alpha/gen" {:ns "cljs.spec.alpha",
                                  :name "gen",
                                  :signature ["[spec]"
                                              "[spec overrides]"],
                                  :name-encode "gen",
                                  :history [["+" "1.9.542"]],
                                  :type "function",
                                  :full-name-encode "cljs.spec.alpha/gen",
                                  :source {:code "(defn gen\n  ([spec] (gen spec nil))\n  ([spec overrides] (gensub spec overrides [] {::recursion-limit *recursion-limit*} spec)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/spec/alpha.cljs",
                                           :lines [293 304]},
                                  :full-name "cljs.spec.alpha/gen",
                                  :docstring "Given a spec, returns the generator for it, or throws if none can\nbe constructed. Optionally an overrides map can be provided which\nshould map spec names or paths (vectors of keywords) to no-arg\ngenerator-creating fns. These will be used instead of the generators at those\nnames/paths. Note that parent generator (in the spec or overrides\nmap) will supersede those of any subtrees. A generator for a regex\nop must always return a sequential collection (i.e. a generator for\ns/? should return either an empty sequence/vector or a\nsequence/vector with one item in it)"},
           "cljs.pprint/pprint-set" {:ns "cljs.pprint",
                                     :name "pprint-set",
                                     :name-encode "pprint-set",
                                     :type "var",
                                     :full-name-encode "cljs.pprint/pprint-set",
                                     :source {:code "(def pprint-set (formatter-out \"~<#{~;~@{~w~^ ~:_~}~;}~:>\"))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/cljs/cljs/pprint.cljs",
                                              :lines [2867]},
                                     :full-name "cljs.pprint/pprint-set",
                                     :history [["+" "0.0-3255"]]},
           "compiler-options/watch-fn" {:ns "compiler-options",
                                        :name "watch-fn",
                                        :name-encode "watch-fn",
                                        :type "option",
                                        :full-name-encode "compiler-options/watch-fn",
                                        :full-name "compiler-options/watch-fn",
                                        :history [["+" "0.0-3030"]]},
           "cljs.pprint/deftype" {:ns "cljs.pprint",
                                  :name "deftype",
                                  :signature ["[type-name & fields]"],
                                  :name-encode "deftype",
                                  :history [["+" "0.0-3255"]],
                                  :type "macro",
                                  :full-name-encode "cljs.pprint/deftype",
                                  :source {:code "(defmacro deftype\n  [type-name & fields]\n  (let [name-str (name type-name)\n        fields (map (comp symbol name) fields)]\n    `(do\n       (defrecord ~type-name [~'type-tag ~@fields])\n       (defn- ~(symbol (str \"make-\" name-str))\n         ~(vec fields)\n         (~(symbol (str type-name \".\")) ~(keyword name-str) ~@fields))\n       (defn- ~(symbol (str name-str \"?\")) [x#] (= (:type-tag x#) ~(keyword name-str))))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/pprint.cljc",
                                           :lines [40 49]},
                                  :full-name "cljs.pprint/deftype"},
           "cljs.spec.alpha/spec?" {:ns "cljs.spec.alpha",
                                    :name "spec?",
                                    :signature ["[x]"],
                                    :name-encode "specQMARK",
                                    :history [["+" "1.9.542"]],
                                    :type "function",
                                    :full-name-encode "cljs.spec.alpha/specQMARK",
                                    :source {:code "(defn spec?\n  [x]\n  (when (implements? Spec x)\n    x))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/spec/alpha.cljs",
                                             :lines [74 78]},
                                    :full-name "cljs.spec.alpha/spec?",
                                    :docstring "returns x if x is a spec object, else logical false"},
           "cljs.core/replace" {:ns "cljs.core",
                                :name "replace",
                                :signature ["[smap]" "[smap coll]"],
                                :name-encode "replace",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/replace",
                                :source {:code "(defn replace\n  ([smap]\n     (map #(if-let [e (find smap %)] (val e) %)))\n  ([smap coll]\n     (if (vector? coll)\n       (let [n (count coll)]\n         (reduce (fn [v i]\n                   (if-let [e (find smap (nth v i))]\n                     (assoc v i (second e))\n                     v))\n           coll (take n (iterate inc 0))))\n       (map #(if-let [e (find smap %)] (second e) %) coll))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [9688 9703]},
                                :full-name "cljs.core/replace",
                                :docstring "Given a map of replacement pairs and a vector/collection, returns a\nvector/seq with any elements = a key in smap replaced with the\ncorresponding val in smap.  Returns a transducer when no collection\nis provided."},
           "cljs.core/rand" {:ns "cljs.core",
                             :name "rand",
                             :signature ["[]" "[n]"],
                             :name-encode "rand",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/rand",
                             :source {:code "(defn rand\n  ([] (rand 1))\n  ([n] (* (Math/random) n)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [11271 11275]},
                             :full-name "cljs.core/rand",
                             :docstring "Returns a random floating point number between 0 (inclusive) and\nn (default 1) (exclusive)."},
           "cljs.core/add-watch" {:ns "cljs.core",
                                  :name "add-watch",
                                  :signature ["[iref key f]"],
                                  :name-encode "add-watch",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/add-watch",
                                  :source {:code "(defn add-watch\n  [iref key f]\n  (-add-watch iref key f)\n  iref)",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [10916 10937]},
                                  :full-name "cljs.core/add-watch",
                                  :docstring "Adds a watch function to an atom reference. The watch fn must be a\nfn of 4 args: a key, the reference, its old-state, its\nnew-state. Whenever the reference's state might have been changed,\nany registered watches will have their functions called. The watch\nfn will be called synchronously. Note that an atom's state\nmay have changed again prior to the fn call, so use old/new-state\nrather than derefing the reference. Keys must be unique per\nreference, and can be used to remove the watch with remove-watch,\nbut are otherwise considered opaque by the watch mechanism.  Bear in\nmind that regardless of the result or action of the watch fns the\natom's value will change.  Example:\n\n    (def a (atom 0))\n    (add-watch a :inc (fn [k r o n] (assert (== 0 n))))\n    (swap! a inc)\n    ;; Assertion Error\n    (deref a)\n    ;=> 1"},
           "cljs.repl.rhino/loaded-libs" {:ns "cljs.repl.rhino",
                                          :name "loaded-libs",
                                          :name-encode "loaded-libs",
                                          :history [["+" "0.0-927"]
                                                    ["-" "0.0-1576"]],
                                          :type "var",
                                          :full-name-encode "cljs.repl.rhino/loaded-libs",
                                          :source {:code "(def loaded-libs (atom #{}))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1552",
                                                   :filename "src/clj/cljs/repl/rhino.clj",
                                                   :lines [20]},
                                          :full-name "cljs.repl.rhino/loaded-libs",
                                          :removed {:in "0.0-1576",
                                                    :last-seen "0.0-1552"}},
           "cljs.math/exp" {:return-type number,
                            :ns "cljs.math",
                            :name "exp",
                            :signature ["[a]"],
                            :name-encode "exp",
                            :history [["+" "1.11.50"]],
                            :type "function",
                            :full-name-encode "cljs.math/exp",
                            :source {:code "(defn ^number exp\n  {:added \"1.11.10\"}\n  [a] (Math/exp a))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/cljs/cljs/math.cljs",
                                     :lines [140 147]},
                            :full-name "cljs.math/exp",
                            :docstring "Returns Euler's number e raised to the power of a.\nIf a is ##NaN => ##NaN\nIf a is ##Inf => ##Inf\nIf a is ##-Inf => +0.0\nSee: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/exp"},
           "cljs.core/cloneable?" {:ns "cljs.core",
                                   :name "cloneable?",
                                   :signature ["[value]"],
                                   :name-encode "cloneableQMARK",
                                   :history [["+" "0.0-2156"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/cloneableQMARK",
                                   :source {:code "(defn cloneable?\n  [value]\n  (satisfies? ICloneable value))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [1245 1248]},
                                   :full-name "cljs.core/cloneable?",
                                   :docstring "Return true if x implements ICloneable protocol."},
           "clojure.string/capitalize" {:return-type string,
                                        :ns "clojure.string",
                                        :name "capitalize",
                                        :signature ["[s]"],
                                        :name-encode "capitalize",
                                        :history [["+" "0.0-927"]],
                                        :type "function",
                                        :full-name-encode "clojure.string/capitalize",
                                        :source {:code "(defn ^string capitalize\n  [s]\n  (gstring/capitalize s))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/cljs/clojure/string.cljs",
                                                 :lines [129 133]},
                                        :full-name "clojure.string/capitalize",
                                        :docstring "Converts first character of the string to upper-case, all other\ncharacters to lower-case."},
           "cljs.core/short" {:return-type number,
                              :ns "cljs.core",
                              :name "short",
                              :signature ["[x]"],
                              :name-encode "short",
                              :history [["+" "0.0-1798"]],
                              :type "function/macro",
                              :full-name-encode "cljs.core/short",
                              :source {:code "(defn ^number short [x] x)",
                                       :title "Function code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [2795]},
                              :extra-sources [{:code "(core/defmacro short [x] x)",
                                               :title "Macro code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/clojure/cljs/core.cljc",
                                               :lines [1067]}],
                              :full-name "cljs.core/short"},
           "cljs.core/replicate" {:ns "cljs.core",
                                  :name "replicate",
                                  :signature ["[n x]"],
                                  :name-encode "replicate",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/replicate",
                                  :source {:code "(defn replicate\n  [n x] (take n (repeat x)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [5136 5139]},
                                  :full-name "cljs.core/replicate",
                                  :docstring "DEPRECATED: Use 'repeat' instead.\nReturns a lazy seq of n xs."},
           "cljs.core/es6-entries-iterator" {:ns "cljs.core",
                                             :name "es6-entries-iterator",
                                             :signature ["[coll]"],
                                             :name-encode "es6-entries-iterator",
                                             :history [["+"
                                                        "0.0-2371"]],
                                             :type "function",
                                             :full-name-encode "cljs.core/es6-entries-iterator",
                                             :source {:code "(defn es6-entries-iterator [coll]\n  (ES6EntriesIterator. (seq coll)))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.12.38",
                                                      :filename "src/main/cljs/cljs/core.cljs",
                                                      :lines [6696
                                                              6697]},
                                             :full-name "cljs.core/es6-entries-iterator"},
           "cljs.spec.impl.gen/vector" {:ns "cljs.spec.impl.gen",
                                        :name "vector",
                                        :signature ["[& args]"],
                                        :name-encode "vector",
                                        :history [["+" "1.9.14"]
                                                  ["-" "1.9.542"]],
                                        :type "function",
                                        :full-name-encode "cljs.spec.impl.gen/vector",
                                        :source {:code "(lazy-combinators hash-map list map not-empty set vector vector-distinct fmap elements\n  bind choose one-of such-that tuple sample return\n  large-integer* double* frequency)",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.9.521",
                                                 :filename "src/main/cljs/cljs/spec/impl/gen.cljs",
                                                 :lines [69 71]},
                                        :full-name "cljs.spec.impl.gen/vector",
                                        :docstring "Lazy loaded version of clojure.test.check.generators/vector",
                                        :removed {:in "1.9.542",
                                                  :last-seen "1.9.521"}},
           "cljs.core/Many" {:ns "cljs.core",
                             :name "Many",
                             :signature ["[vals]"],
                             :name-encode "Many",
                             :history [["+" "1.9.562"]],
                             :type "type",
                             :full-name-encode "cljs.core/Many",
                             :source {:code "(deftype Many [vals]\n  Object\n  (add [this o]\n    (.push vals o)\n    this)\n  (remove [this]\n    (.shift vals))\n  (isEmpty [this]\n    (zero? (.-length vals)))\n  (toString [this]\n    (str \"Many: \" vals)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [4168 4178]},
                             :full-name "cljs.core/Many"},
           "cljs.core/ArrayChunk" {:protocols #{"ICounted"
                                                "IReduce"
                                                "IChunk"
                                                "IIndexed"},
                                   :ns "cljs.core",
                                   :name "ArrayChunk",
                                   :signature ["[arr off end]"],
                                   :name-encode "ArrayChunk",
                                   :history [["+" "0.0-1424"]],
                                   :type "type",
                                   :full-name-encode "cljs.core/ArrayChunk",
                                   :source {:code "(deftype ArrayChunk [arr off end]\n  ICounted\n  (-count [_] (- end off))\n\n  IIndexed\n  (-nth [coll i]\n    (aget arr (+ off i)))\n  (-nth [coll i not-found]\n    (if (and (>= i 0) (< i (- end off)))\n      (aget arr (+ off i))\n      not-found))\n\n  IChunk\n  (-drop-first [coll]\n    (if (== off end)\n      (throw (js/Error. \"-drop-first of empty chunk\"))\n      (ArrayChunk. arr (inc off) end)))\n\n  IReduce\n  (-reduce [coll f]\n    (array-reduce arr f (aget arr off) (inc off)))\n  (-reduce [coll f start]\n    (array-reduce arr f start off)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [3606 3628]},
                                   :full-name "cljs.core/ArrayChunk"},
           "cljs.core/sequential?" {:ns "cljs.core",
                                    :name "sequential?",
                                    :signature ["[x]"],
                                    :name-encode "sequentialQMARK",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/sequentialQMARK",
                                    :source {:code "(defn sequential?\n  [x] (satisfies? ISequential x))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [2208 2210]},
                                    :full-name "cljs.core/sequential?",
                                    :docstring "Returns true if coll satisfies ISequential"},
           "cljs.core/underive" {:ns "cljs.core",
                                 :name "underive",
                                 :signature ["[tag parent]"
                                             "[h tag parent]"],
                                 :name-encode "underive",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/underive",
                                 :source {:code "(defn underive\n  ([tag parent]\n    (swap-global-hierarchy! underive tag parent)\n    nil)\n  ([h tag parent]\n    (let [parentMap (:parents h)\n          childsParents (if (parentMap tag)\n                          (disj (parentMap tag) parent) #{})\n          newParents (if (not-empty childsParents)\n                      (assoc parentMap tag childsParents)\n                      (dissoc parentMap tag))\n          deriv-seq (flatten (map #(cons (first %) (interpose (first %) (second %)))\n                                  (seq newParents)))]\n      (if (contains? (parentMap tag) parent)\n        (reduce #(apply derive %1 %2) (make-hierarchy)\n                (partition 2 deriv-seq))\n        h))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [11396 11415]},
                                 :full-name "cljs.core/underive",
                                 :docstring "Removes a parent/child relationship between parent and\ntag. h must be a hierarchy obtained from make-hierarchy, if not\nsupplied defaults to, and modifies, the global hierarchy."},
           "cljs.core/PersistentArrayMapIterator" {:ns "cljs.core",
                                                   :name "PersistentArrayMapIterator",
                                                   :signature ["[arr i cnt]"],
                                                   :name-encode "PersistentArrayMapIterator",
                                                   :history [["+"
                                                              "0.0-2371"]],
                                                   :type "type",
                                                   :full-name-encode "cljs.core/PersistentArrayMapIterator",
                                                   :source {:code "(deftype PersistentArrayMapIterator [arr ^:mutable i cnt]\n  Object\n  (hasNext [_]\n    (< i cnt))\n  (next [_]\n    (let [ret (MapEntry. (aget arr i) (aget arr (inc i)) nil)]\n      (set! i (+ i 2))\n      ret)))",
                                                            :title "Source code",
                                                            :repo "clojurescript",
                                                            :tag "r1.12.38",
                                                            :filename "src/main/cljs/cljs/core.cljs",
                                                            :lines [6966
                                                                    6973]},
                                                   :full-name "cljs.core/PersistentArrayMapIterator"},
           "cljs.core/coercive-not" {:ns "cljs.core",
                                     :name "coercive-not",
                                     :signature ["[x]"],
                                     :name-encode "coercive-not",
                                     :history [["+" "0.0-1211"]
                                               ["-" "1.9.493"]
                                               ["+" "1.9.494"]],
                                     :type "macro",
                                     :full-name-encode "cljs.core/coercive-not",
                                     :source {:code "(core/defmacro coercive-not [x]\n  (bool-expr (core/list 'js* \"(!~{})\" x)))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/clojure/cljs/core.cljc",
                                              :lines [905 906]},
                                     :full-name "cljs.core/coercive-not"},
           "cljs.spec/registry-ref" {:ns "cljs.spec",
                                     :name "registry-ref",
                                     :name-encode "registry-ref",
                                     :history [["+" "1.9.183"]
                                               ["-" "1.9.542"]],
                                     :type "var",
                                     :full-name-encode "cljs.spec/registry-ref",
                                     :source {:code "(defonce registry-ref (atom {}))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.9.521",
                                              :filename "src/main/cljs/cljs/spec.cljc",
                                              :lines [19]},
                                     :full-name "cljs.spec/registry-ref",
                                     :removed {:in "1.9.542",
                                               :last-seen "1.9.521"}},
           "cljs.core/ns-unmap" {:ns "cljs.core",
                                 :name "ns-unmap",
                                 :signature ["[quoted-ns quoted-sym]"],
                                 :name-encode "ns-unmap",
                                 :history [["+" "0.0-3169"]],
                                 :type "macro",
                                 :full-name-encode "cljs.core/ns-unmap",
                                 :source {:code "(core/defmacro ns-unmap\n  [quoted-ns quoted-sym]\n  (core/assert\n    (core/and (seq? quoted-ns) (= (first quoted-ns) 'quote) (core/symbol? (second quoted-ns))\n              (seq? quoted-sym) (= (first quoted-sym) 'quote) (core/symbol? (second quoted-sym)))\n    \"Arguments to ns-unmap must be quoted symbols\")\n  (core/let [ns (second quoted-ns)\n             sym (second quoted-sym)]\n    (swap! env/*compiler* update-in [::ana/namespaces ns :defs] dissoc sym)\n    `(js-delete ~(comp/munge ns) ~(comp/munge (core/str sym)))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/clojure/cljs/core.cljc",
                                          :lines [2966 2976]},
                                 :full-name "cljs.core/ns-unmap",
                                 :docstring "Removes the mappings for the symbol from the namespace."},
           "cljs.spec.gen.alpha/cat" {:ns "cljs.spec.gen.alpha",
                                      :name "cat",
                                      :signature ["[& gens]"],
                                      :name-encode "cat",
                                      :history [["+" "1.9.542"]],
                                      :type "function",
                                      :full-name-encode "cljs.spec.gen.alpha/cat",
                                      :source {:code "(defn cat\n  [& gens]\n  (fmap #(apply concat %)\n    (apply tuple gens)))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/spec/gen/alpha.cljs",
                                               :lines [78 83]},
                                      :full-name "cljs.spec.gen.alpha/cat",
                                      :docstring "Returns a generator of a sequence catenated from results of\ngens, each of which should generate something sequential."},
           "cljs.core/use" {:ns "cljs.core",
                            :name "use",
                            :signature ["[& args]"],
                            :name-encode "use",
                            :history [["+" "1.9.183"]],
                            :type "macro",
                            :full-name-encode "cljs.core/use",
                            :source {:code "(core/defmacro use\n  [& args]\n  `(~'ns* ~(cons :use args)))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/clojure/cljs/core.cljc",
                                     :lines [3052 3063]},
                            :full-name "cljs.core/use",
                            :docstring "Like require, but referring vars specified by the mandatory\n:only option.\n\nExample:\n\nThe following would load the library clojure.set while referring\nthe intersection var.\n\n(use '[clojure.set :only [intersection]])"},
           "cljs.core/macroexpand" {:ns "cljs.core",
                                    :name "macroexpand",
                                    :signature ["[quoted]"],
                                    :name-encode "macroexpand",
                                    :history [["+" "0.0-3165"]],
                                    :type "macro",
                                    :full-name-encode "cljs.core/macroexpand",
                                    :source {:code "(core/defmacro macroexpand\n  [quoted]\n  (core/assert (core/= (core/first quoted) 'quote)\n    \"Argument to macroexpand must be quoted\")\n  (core/let [form (second quoted)\n             env &env]\n    (if (seq? form)\n      (core/loop [form form form' (ana/macroexpand-1 env form)]\n        (core/if-not (core/identical? form form')\n          (recur form' (ana/macroexpand-1 env form'))\n          `(quote ~form')))\n      form)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/clojure/cljs/core.cljc",
                                             :lines [3107 3121]},
                                    :full-name "cljs.core/macroexpand",
                                    :docstring "Repeatedly calls macroexpand-1 on form until it no longer\nrepresents a macro form, then returns it.  Note neither\nmacroexpand-1 nor macroexpand expand macros in subforms."},
           "compiler-options/npm-deps" {:ns "compiler-options",
                                        :name "npm-deps",
                                        :name-encode "npm-deps",
                                        :type "option",
                                        :full-name-encode "compiler-options/npm-deps",
                                        :full-name "compiler-options/npm-deps",
                                        :history [["+" "1.9.518"]]},
           "clojure.browser.repl/get-ua-product" {:ns "clojure.browser.repl",
                                                  :name "get-ua-product",
                                                  :signature ["[]"],
                                                  :name-encode "get-ua-product",
                                                  :history [["+"
                                                             "0.0-3058"]],
                                                  :type "function",
                                                  :full-name-encode "clojure.browser.repl/get-ua-product",
                                                  :source {:code "(defn get-ua-product []\n  (cond\n    product/SAFARI :safari\n    product/CHROME :chrome\n    product/FIREFOX :firefox\n    product/IE :ie))",
                                                           :title "Source code",
                                                           :repo "clojurescript",
                                                           :tag "r1.12.38",
                                                           :filename "src/main/cljs/clojure/browser/repl.cljs",
                                                           :lines [60
                                                                   65]},
                                                  :full-name "clojure.browser.repl/get-ua-product"},
           "cljs.math/next-down" {:return-type number,
                                  :ns "cljs.math",
                                  :name "next-down",
                                  :signature ["[d]"],
                                  :name-encode "next-down",
                                  :history [["+" "1.11.50"]],
                                  :type "function",
                                  :full-name-encode "cljs.math/next-down",
                                  :source {:code "(defn ^number next-down\n  {:added \"1.11.10\"}\n  [d]\n  (cond\n    (or ^boolean (js/isNaN d) (== ##-Inf d)) d\n    (zero? d) (- js/Number.MIN_VALUE)\n    :default\n    (let [a (js/ArrayBuffer. 8)\n          f (js/Float64Array. a)\n          i (js/Uint32Array. a)\n          _ (aset f 0 d)\n          ht (aget i HI)\n          lt (aget i LO)\n          [hr lr] (if (> d 0)\n                    (add64 ht lt 0xFFFFFFFF 0xFFFFFFFF)\n                    (add64 ht lt 0 1))]\n      (aset i HI hr)\n      (aset i LO lr)\n      (aget f 0))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/math.cljs",
                                           :lines [816 839]},
                                  :full-name "cljs.math/next-down",
                                  :docstring "Returns the adjacent double of d in the direction of ##-Inf.\nIf d is ##NaN => ##NaN\nIf d is ##Inf => Number/MAX_VALUE\nIf d is zero => -Number/MIN_VALUE\nSee: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#nextDown-double-"},
           "cljs.core/get-method" {:ns "cljs.core",
                                   :name "get-method",
                                   :signature ["[multifn dispatch-val]"],
                                   :name-encode "get-method",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/get-method",
                                   :source {:code "(defn get-method\n  [multifn dispatch-val] (-get-method multifn dispatch-val))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [11691 11694]},
                                   :full-name "cljs.core/get-method",
                                   :docstring "Given a multimethod and a dispatch value, returns the dispatch fn\nthat would apply to that value, or nil if none apply and no default"},
           "cljs.spec/valid?" {:ns "cljs.spec",
                               :name "valid?",
                               :signature ["[spec x]" "[spec x form]"],
                               :name-encode "validQMARK",
                               :history [["+" "1.9.14"]
                                         ["-" "1.9.542"]],
                               :type "function",
                               :full-name-encode "cljs.spec/validQMARK",
                               :source {:code "(defn valid?\n  ([spec x]\n   (let [spec (specize spec)]\n     (not (invalid? (conform* spec x)))))\n  ([spec x form]\n   (let [spec (specize spec form)]\n     (not (invalid? (conform* spec x))))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.9.521",
                                        :filename "src/main/cljs/cljs/spec.cljs",
                                        :lines [353 360]},
                               :full-name "cljs.spec/valid?",
                               :docstring "Helper function that returns true when x is valid for spec.",
                               :removed {:in "1.9.542",
                                         :last-seen "1.9.521"}},
           "compiler-options/deps-cmd" {:ns "compiler-options",
                                        :name "deps-cmd",
                                        :name-encode "deps-cmd",
                                        :type "option",
                                        :full-name-encode "compiler-options/deps-cmd",
                                        :full-name "compiler-options/deps-cmd",
                                        :history [["+" "1.10.738"]]},
           "cljs.core/=" {:return-type boolean,
                          :ns "cljs.core",
                          :name "=",
                          :signature ["[x]" "[x y]" "[x y & more]"],
                          :name-encode "EQ",
                          :history [["+" "0.0-927"]],
                          :type "function",
                          :full-name-encode "cljs.core/EQ",
                          :source {:code "(defn ^boolean =\n  ([x] true)\n  ([x y]\n    (if (nil? x)\n      (nil? y)\n      (or (identical? x y)\n        ^boolean (-equiv x y))))\n  ([x y & more]\n     (if (= x y)\n       (if (next more)\n         (recur y (first more) (next more))\n         (= y (first more)))\n       false)))",
                                   :title "Source code",
                                   :repo "clojurescript",
                                   :tag "r1.12.38",
                                   :filename "src/main/cljs/cljs/core.cljs",
                                   :lines [1312 1328]},
                          :full-name "cljs.core/=",
                          :docstring "Equality. Returns true if x equals y, false if not. Compares\nnumbers and collections in a type-independent manner.  Clojure's immutable data\nstructures define -equiv (and thus =) as a value, not an identity,\ncomparison."},
           "cljs.math/rint" {:return-type number,
                             :ns "cljs.math",
                             :name "rint",
                             :signature ["[a]"],
                             :name-encode "rint",
                             :history [["+" "1.11.50"]],
                             :type "function",
                             :full-name-encode "cljs.math/rint",
                             :source {:code "(defn ^number rint\n  {:added \"1.11.10\"}\n  [a]\n  (let [sign (copy-sign 1.0, a)\n        a (Math/abs a)\n        a (if (< a TWO-TO-THE-52)\n            (- (+ TWO-TO-THE-52 a) TWO-TO-THE-52) a)]\n    (* sign a)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/math.cljs",
                                      :lines [465 476]},
                             :full-name "cljs.math/rint",
                             :docstring "Returns the double closest to a and equal to a mathematical integer.\nIf two values are equally close, return the even one.\nIf a is ##NaN or ##Inf or ##-Inf or zero => a\nSee: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#rint-double-"},
           "cljs.core/mask" {:ns "cljs.core",
                             :name "mask",
                             :signature ["[hash shift]"],
                             :name-encode "mask",
                             :history [["+" "0.0-1211"]
                                       ["-" "1.9.493"]
                                       ["+" "1.9.494"]],
                             :type "macro",
                             :full-name-encode "cljs.core/mask",
                             :source {:code "(core/defmacro mask [hash shift]\n  (core/list 'js* \"((~{} >>> ~{}) & 0x01f)\" hash shift))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/clojure/cljs/core.cljc",
                                      :lines [1247 1248]},
                             :full-name "cljs.core/mask"},
           "cljs.repl.server/dispatch-on" {:ns "cljs.repl.server",
                                           :name "dispatch-on",
                                           :signature ["[method pred handler]"
                                                       "[method {:as m}]"],
                                           :name-encode "dispatch-on",
                                           :history [["+" "0.0-1503"]],
                                           :type "function",
                                           :full-name-encode "cljs.repl.server/dispatch-on",
                                           :source {:code "(defn dispatch-on\n  ([method pred handler]\n    (dispatch-on method {:pred pred :handler handler}))\n  ([method {:as m}]\n    (swap! handlers\n      (fn [old]\n        (update-in old [method] #(conj (vec %) m))))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/clojure/cljs/repl/server.clj",
                                                    :lines [48 60]},
                                           :full-name "cljs.repl.server/dispatch-on",
                                           :docstring "Registers a handler to be dispatched based on a request method and a\npredicate.\n\npred should be a function that accepts an options map, a connection,\nand a request map and returns a boolean value based on whether or not\nthat request should be dispatched to the related handler."},
           "cljs.reader/deregister-default-tag-parser!" {:ns "cljs.reader",
                                                         :name "deregister-default-tag-parser!",
                                                         :signature ["[]"],
                                                         :name-encode "deregister-default-tag-parserBANG",
                                                         :history [["+"
                                                                    "0.0-1576"]],
                                                         :type "function",
                                                         :full-name-encode "cljs.reader/deregister-default-tag-parserBANG",
                                                         :source {:code "(defn deregister-default-tag-parser!\n  []\n  (let [old-parser @*default-data-reader-fn*]\n    (swap! *default-data-reader-fn* (fn [_] nil))\n    old-parser))",
                                                                  :title "Source code",
                                                                  :repo "clojurescript",
                                                                  :tag "r1.12.38",
                                                                  :filename "src/main/cljs/cljs/reader.cljs",
                                                                  :lines [210
                                                                          214]},
                                                         :full-name "cljs.reader/deregister-default-tag-parser!"},
           "syntax/comment" {:syntax-equiv {:edn-url nil,
                                            :clj-url nil},
                             :ns "syntax",
                             :name "comment",
                             :name-encode "comment",
                             :history [["+" "0.0-1853"]],
                             :type "syntax",
                             :full-name-encode "syntax/comment",
                             :extra-sources ({:code "(defn read-comment\n  [rdr & _]\n  (skip-line rdr))",
                                              :title "Reader code",
                                              :repo "tools.reader",
                                              :tag "v1.3.6",
                                              :filename "src/main/clojure/clojure/tools/reader/impl/commons.clj",
                                              :lines [124 126]}
                                             {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                              :title "Reader table",
                                              :repo "tools.reader",
                                              :tag "v1.3.6",
                                              :filename "src/main/clojure/clojure/tools/reader.clj",
                                              :lines [788 807]}),
                             :full-name "syntax/comment"},
           "cljs.repl.browser/firefox-st-el->frame" {:ns "cljs.repl.browser",
                                                     :name "firefox-st-el->frame",
                                                     :signature ["[repl-env st-el opts]"],
                                                     :name-encode "firefox-st-el-GTframe",
                                                     :history [["+"
                                                                "0.0-3053"]
                                                               ["-"
                                                                "1.7.10"]],
                                                     :type "function",
                                                     :full-name-encode "cljs.repl.browser/firefox-st-el-GTframe",
                                                     :source {:code "(defn firefox-st-el->frame\n  [repl-env st-el opts]\n  (let [[function flc] (if (re-find #\"@\" st-el)\n                         (string/split st-el #\"@\")\n                         [nil st-el])\n        [file line column] (parse-file-line-column flc)]\n    (if (and file function line column)\n      {:file (parse-file repl-env file opts)\n       :function (firefox-clean-function function)\n       :line line\n       :column column}\n      (when-not (string/blank? function)\n        {:file nil\n         :function (firefox-clean-function function)\n         :line nil\n         :column nil}))))",
                                                              :title "Source code",
                                                              :repo "clojurescript",
                                                              :tag "r3308",
                                                              :filename "src/main/clojure/cljs/repl/browser.clj",
                                                              :lines [404
                                                                      419]},
                                                     :full-name "cljs.repl.browser/firefox-st-el->frame",
                                                     :removed {:in "1.7.10",
                                                               :last-seen "0.0-3308"}},
           "cljs.core/system-time" {:ns "cljs.core",
                                    :name "system-time",
                                    :signature ["[]"],
                                    :name-encode "system-time",
                                    :history [["+" "1.7.145"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/system-time",
                                    :source {:code "(defn system-time\n  []\n  (cond\n    (and (exists? js/performance)\n         (not (nil? (. js/performance -now))))\n    (.now js/performance)\n\n    (and (exists? js/process)\n         (not (nil? (. js/process -hrtime))))\n    (let [t (.hrtime js/process)]\n      (/ (+ (* (aget t 0) 1e9) (aget t 1)) 1e6))\n\n    :else (.getTime (js/Date.))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [403 416]},
                                    :full-name "cljs.core/system-time",
                                    :docstring "Returns highest resolution time offered by host in milliseconds."},
           "cljs.core/defn-" {:ns "cljs.core",
                              :name "defn-",
                              :signature ["[name & decls]"],
                              :name-encode "defn-",
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :full-name-encode "cljs.core/defn-",
                              :source {:code "(defmacro defn-\n  {:added \"1.0\"}\n  [name & decls]\n    (list* `defn (with-meta name (assoc (meta name) :private true)) decls))",
                                       :title "Source code",
                                       :repo "clojure",
                                       :tag "clojure-1.10.0",
                                       :filename "src/clj/clojure/core.clj",
                                       :lines [4925 4929]},
                              :full-name "cljs.core/defn-",
                              :docstring "same as defn, yielding non-public def"},
           "compiler-options/target" {:ns "compiler-options",
                                      :name "target",
                                      :name-encode "target",
                                      :type "option",
                                      :full-name-encode "compiler-options/target",
                                      :full-name "compiler-options/target",
                                      :history [["+" "0.0-971"]]},
           "cljs.js/append-source-map" {:ns "cljs.js",
                                        :name "append-source-map",
                                        :signature ["[state name source sb sm-data {:keys [output-dir asset-path], :as opts}]"],
                                        :name-encode "append-source-map",
                                        :history [["+" "1.7.10"]
                                                  ["-" "1.7.28"]],
                                        :type "function",
                                        :full-name-encode "cljs.js/append-source-map",
                                        :source {:code "(defn append-source-map\n  [state name source sb sm-data {:keys [output-dir asset-path] :as opts}]\n   (let [t    (.valueOf (js/Date.))\n         smn  (if name\n                (string/replace (munge (str name)) \".\" \"/\")\n                (str \"cljs-\" t))\n         ts   (.valueOf (js/Date.))\n         out  (or output-dir asset-path)\n         src  (cond-> (str smn \".cljs?rel=\" ts)\n                out (prefix (str out \"/\")))\n         file (cond-> (str smn \".js?rel=\" ts)\n                out (prefix (str out \"/\")))\n         json (sm/encode {src (:source-map sm-data)}\n                {:lines (+ (:gen-line sm-data) 3)\n                 :file  file :sources-content [source]})]\n     (when (:verbose opts) (debug-prn json))\n     (swap! state assoc-in\n       [:source-maps name] (sm/invert-reverse-map (:source-map sm-data)))\n     (.append sb\n       (str \"\\n//# sourceURL=\" file\n            \"\\n//# sourceMappingURL=data:application/json;base64,\"\n            (base64/encodeString json)))))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.7.10",
                                                 :filename "src/main/cljs/cljs/js.cljs",
                                                 :lines [131 152]},
                                        :full-name "cljs.js/append-source-map",
                                        :removed {:in "1.7.28",
                                                  :last-seen "1.7.10"}},
           "cljs.reader/read-symbol" {:ns "cljs.reader",
                                      :name "read-symbol",
                                      :signature ["[reader initch]"],
                                      :name-encode "read-symbol",
                                      :history [["+" "0.0-927"]
                                                ["-" "1.9.854"]],
                                      :type "function",
                                      :full-name-encode "cljs.reader/read-symbol",
                                      :source {:code "(defn read-symbol\n  [reader initch]\n  (let [token (read-token reader initch)]\n    (if (and (gstring/contains token \"/\")\n             (not (== (.-length token) 1)))\n      (symbol (subs token 0 (.indexOf token \"/\"))\n              (subs token (inc (.indexOf token \"/\"))\n                (.-length token)))\n      (special-symbols token (symbol token)))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.9.671",
                                               :filename "src/main/cljs/cljs/reader.cljs",
                                               :lines [339 347]},
                                      :full-name "cljs.reader/read-symbol",
                                      :removed {:in "1.9.854",
                                                :last-seen "1.9.671"}},
           "cljs.reader/push-back-reader" {:ns "cljs.reader",
                                           :name "push-back-reader",
                                           :signature ["[s]"],
                                           :name-encode "push-back-reader",
                                           :history [["+" "0.0-927"]
                                                     ["-" "1.9.854"]],
                                           :type "function",
                                           :full-name-encode "cljs.reader/push-back-reader",
                                           :source {:code "(defn push-back-reader [s]\n  \"Creates a StringPushbackReader from a given string\"\n  (StringPushbackReader. s (array) -1))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.9.671",
                                                    :filename "src/main/cljs/cljs/reader.cljs",
                                                    :lines [30 32]},
                                           :full-name "cljs.reader/push-back-reader",
                                           :removed {:in "1.9.854",
                                                     :last-seen "1.9.671"}},
           "closure-warnings/access-controls" {:ns "closure-warnings",
                                               :name "access-controls",
                                               :name-encode "access-controls",
                                               :type "warning",
                                               :full-name-encode "closure-warnings/access-controls",
                                               :full-name "closure-warnings/access-controls",
                                               :history [["+"
                                                          "0.0-2120"]]},
           "cljs.core/deftype" {:ns "cljs.core",
                                :name "deftype",
                                :signature ["[t fields & impls]"],
                                :name-encode "deftype",
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :full-name-encode "cljs.core/deftype",
                                :source {:code "(core/defmacro deftype\n  [t fields & impls]\n  (validate-fields \"deftype\" t fields)\n  (core/let [env &env\n             r (:name (cljs.analyzer/resolve-var (dissoc env :locals) t))\n             [fpps pmasks] (prepare-protocol-masks env impls)\n             protocols (collect-protocols impls env)\n             t (vary-meta t assoc\n                 :protocols protocols\n                 :skip-protocol-flag fpps) ]\n    `(do\n       (deftype* ~t ~fields ~pmasks\n         ~(if (seq impls)\n            `(extend-type ~t ~@(dt->et t impls fields))))\n       (set! (.-getBasis ~t) (fn [] '[~@fields]))\n       (set! (.-cljs$lang$type ~t) true)\n       (set! (.-cljs$lang$ctorStr ~t) ~(core/str r))\n       (set! (.-cljs$lang$ctorPrWriter ~t) (fn [this# writer# opt#] (-write writer# ~(core/str r))))\n\n       ~(build-positional-factory t r fields)\n       ~t)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/clojure/cljs/core.cljc",
                                         :lines [1740 1808]},
                                :full-name "cljs.core/deftype",
                                :docstring "(deftype name [fields*]  options* specs*)\n\nCurrently there are no options.\n\nEach spec consists of a protocol or interface name followed by zero\nor more method bodies:\n\nprotocol-or-Object\n(methodName [args*] body)*\n\nThe type will have the (by default, immutable) fields named by\nfields, which can have type hints. Protocols and methods\nare optional. The only methods that can be supplied are those\ndeclared in the protocols/interfaces.  Note that method bodies are\nnot closures, the local environment includes only the named fields,\nand those fields can be accessed directly. Fields can be qualified\nwith the metadata :mutable true at which point (set! afield aval) will be\nsupported in method bodies. Note well that mutable fields are extremely\ndifficult to use correctly, and are present only to facilitate the building\nof higherlevel constructs, such as ClojureScript's reference types, in\nClojureScript itself. They are for experts only - if the semantics and\nimplications of :mutable are not immediately apparent to you, you should not\nbe using them.\n\nMethod definitions take the form:\n\n(methodname [args*] body)\n\nThe argument and return types can be hinted on the arg and\nmethodname symbols. If not supplied, they will be inferred, so type\nhints should be reserved for disambiguation.\n\nMethods should be supplied for all methods of the desired\nprotocol(s). You can also define overrides for methods of Object. Note that\na parameter must be supplied to correspond to the target object\n('this' in JavaScript parlance). Note also that recur calls to the method\nhead should *not* pass the target object, it will be supplied\nautomatically and can not be substituted.\n\nIn the method bodies, the (unqualified) name can be used to name the\nclass (for calls to new, instance? etc).\n\nOne constructor will be defined, taking the designated fields.  Note\nthat the field names __meta and __extmap are currently reserved and\nshould not be used when defining your own types.\n\nGiven (deftype TypeName ...), a factory function called ->TypeName\nwill be defined, taking positional parameters for the fields"},
           "cljs.repl/load" {:ns "cljs.repl",
                             :name "load",
                             :signature ["[repl-env provides url]"],
                             :name-encode "load",
                             :history [["+" "1.10.63"]],
                             :type "function",
                             :full-name-encode "cljs.repl/load",
                             :source {:code "(defn load [repl-env provides url]\n  (-load repl-env provides url))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/clojure/cljs/repl.cljc",
                                      :lines [133 134]},
                             :full-name "cljs.repl/load"},
           "cljs.repl/print-doc" {:ns "cljs.repl",
                                  :name "print-doc",
                                  :signature ["[{n :ns, nm :name, :as m}]"],
                                  :name-encode "print-doc",
                                  :history [["+" "0.0-2496"]],
                                  :type "function",
                                  :full-name-encode "cljs.repl/print-doc",
                                  :source {:code "(defn print-doc [{n :ns nm :name :as m}]\n  (println \"-------------------------\")\n  (println (or (:spec m) (str (when-let [ns (:ns m)] (str ns \"/\")) (:name m))))\n  (when (:protocol m)\n    (println \"Protocol\"))\n  (cond\n    (:forms m) (doseq [f (:forms m)]\n                 (println \"  \" f))\n    (:arglists m) (let [arglists (:arglists m)]\n                    (if (or (:macro m)\n                         (:repl-special-function m))\n                     (prn arglists)\n                     (prn\n                       (if (= 'quote (first arglists))\n                         (second arglists)\n                         arglists)))))\n  (if (:special-form m)\n    (do\n      (println \"Special Form\")\n      (println \" \" (:doc m))\n      (if (contains? m :url)\n        (when (:url m)\n          (println (str \"\\n  Please see http://clojure.org/\" (:url m))))\n        (println (str \"\\n  Please see http://clojure.org/special_forms#\"\n                   (:name m)))))\n    (do\n      (when (:macro m)\n        (println \"Macro\"))\n      (when (:spec m)\n        (println \"Spec\"))\n      (when (:repl-special-function m)\n        (println \"REPL Special Function\"))\n      (println \" \" (:doc m))\n      (when (:protocol m)\n        (doseq [[name {:keys [doc arglists]}] (:methods m)]\n          (println)\n          (println \" \" name)\n          (println \" \" arglists)\n          (when doc\n            (println \" \" doc))))\n      (when n\n        (when-let [fnspec (spec/get-spec (symbol (str (ns-name n)) (name nm)))]\n          (print \"Spec\")\n          (doseq [role [:args :ret :fn]]\n            (when-let [spec (get fnspec role)]\n              (print (str \"\\n \" (name role) \":\") (spec/describe spec)))))))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/repl.cljs",
                                           :lines [15 60]},
                                  :full-name "cljs.repl/print-doc"},
           "cljs.core/longs" {:ns "cljs.core",
                              :name "longs",
                              :signature ["[x]"],
                              :name-encode "longs",
                              :history [["+" "0.0-1798"]],
                              :type "function",
                              :full-name-encode "cljs.core/longs",
                              :source {:code "(defn longs [x] x)",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [2913]},
                              :full-name "cljs.core/longs"},
           "cljs.repl/Error->map" {:ns "cljs.repl",
                                   :name "Error->map",
                                   :signature ["[o]"],
                                   :name-encode "Error-GTmap",
                                   :history [["+" "1.10.514"]],
                                   :type "function",
                                   :full-name-encode "cljs.repl/Error-GTmap",
                                   :source {:code "(defn Error->map\n  [o]\n  (Throwable->map o))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/repl.cljs",
                                            :lines [62 73]},
                                   :full-name "cljs.repl/Error->map",
                                   :docstring "Constructs a data representation for a Error with keys:\n :cause - root cause message\n :phase - error phase\n :via - cause chain, with cause keys:\n          :type - exception class symbol\n          :message - exception message\n          :data - ex-data\n          :at - top stack element\n :trace - root cause stack elements"},
           "cljs.core/Subvec" {:protocols #{"IFn"
                                            "ISeqable"
                                            "IMeta"
                                            "IWithMeta"
                                            "IKVReduce"
                                            "IReversible"
                                            "IStack"
                                            "IEmptyableCollection"
                                            "ICounted"
                                            "IReduce"
                                            "ILookup"
                                            "ISequential"
                                            "ICollection"
                                            "IHash"
                                            "IComparable"
                                            "IPrintWithWriter"
                                            "IIndexed"
                                            "IIterable"
                                            "IAssociative"
                                            "IVector"
                                            "IFind"
                                            "IEquiv"
                                            "ICloneable"},
                               :ns "cljs.core",
                               :name "Subvec",
                               :signature ["[meta v start end __hash]"],
                               :name-encode "Subvec",
                               :history [["+" "0.0-927"]],
                               :type "type",
                               :full-name-encode "cljs.core/Subvec",
                               :source {:code "(deftype Subvec [meta v start end ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  ICloneable\n  (-clone [_] (Subvec. meta v start end __hash))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (build-subvec new-meta v start end __hash)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IStack\n  (-peek [coll]\n    (when-not (== start end)\n      (-nth v (dec end))))\n  (-pop [coll]\n    (if (== start end)\n      (throw (js/Error. \"Can't pop empty vector\"))\n      (build-subvec meta v start (dec end) nil)))\n\n  ICollection\n  (-conj [coll o]\n    (build-subvec meta (-assoc-n v end o) start (inc end) nil))\n\n  IEmptyableCollection\n  (-empty [coll] (-with-meta (.-EMPTY PersistentVector) meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (let [subvec-seq (fn subvec-seq [i]\n                       (when-not (== i end)\n                         (cons (-nth v i)\n                               (lazy-seq\n                                (subvec-seq (inc i))))))]\n      (subvec-seq start)))\n\n  IReversible\n  (-rseq [coll]\n    (if-not (== start end)\n      (RSeq. coll (dec (- end start)) nil)))\n\n  ICounted\n  (-count [coll] (- end start))\n\n  IIndexed\n  (-nth [coll n]\n    (if (or (neg? n) (<= end (+ start n)))\n      (vector-index-out-of-bounds n (- end start))\n      (-nth v (+ start n))))\n  (-nth [coll n not-found]\n    (if (or (neg? n) (<= end (+ start n)))\n      not-found\n      (-nth v (+ start n) not-found)))\n\n  ILookup\n  (-lookup [coll k] (-lookup coll k nil))\n  (-lookup [coll k not-found] (if (number? k)\n                                (-nth coll k not-found)\n                                not-found))\n\n  IAssociative\n  (-assoc [coll key val]\n    (if (number? key)\n      (-assoc-n coll key val)\n      (throw (js/Error. \"Subvec's key for assoc must be a number.\"))))\n  (-contains-key? [coll key]\n    (if (integer? key)\n      (and (<= 0 key) (< key (- end start)))\n      false))\n\n  IFind\n  (-find [coll n]\n    (when-not (neg? n)\n      (let [idx (+ start n)]\n        (when (< idx end)\n          (MapEntry. n (-lookup v idx) nil)))))\n\n  IVector\n  (-assoc-n [coll n val]\n    (let [v-pos (+ start n)]\n      (if (or (neg? n) (<= (inc end) v-pos))\n        (throw (js/Error. (str \"Index \" n \" out of bounds [0,\" (-count coll) \"]\")))\n        (build-subvec meta (assoc v v-pos val) start (max end (inc v-pos)) nil))))\n\n  IReduce\n  (-reduce [coll f]\n    (if (implements? APersistentVector v)\n      (pv-reduce v f start end)\n      (ci-reduce coll f)))\n  (-reduce [coll f init]\n    (if (implements? APersistentVector v)\n      (pv-reduce v f init start end)\n      (ci-reduce coll f init)))\n\n  IKVReduce\n  (-kv-reduce [coll f init]\n    (loop [i start j 0 init init]\n      (if (< i end)\n        (let [init (f init j (-nth v i))]\n          (if (reduced? init)\n            @init\n            (recur (inc i) (inc j) init)))\n        init)))\n\n  IFn\n  (-invoke [coll k]\n    (-nth coll k))\n  (-invoke [coll k not-found]\n    (-nth coll k not-found))\n\n  IIterable\n  (-iterator [coll]\n    (if (implements? APersistentVector v)\n      (ranged-iterator v start end)\n      (seq-iter coll))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [5979 6116]},
                               :full-name "cljs.core/Subvec"},
           "cljs.repl.browser/run-in-order" {:ns "cljs.repl.browser",
                                             :name "run-in-order",
                                             :signature ["[{:keys [expecting fns]}]"],
                                             :name-encode "run-in-order",
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.repl.browser/run-in-order",
                                             :source {:code "(defn run-in-order [{:keys [expecting fns]}]\n  (loop [order expecting fns fns]\n    (if-let [f (get fns order)]\n      (do\n        (f)\n        (recur (inc order) (dissoc fns order)))\n      {:expecting order :fns fns})))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.12.38",
                                                      :filename "src/main/clojure/cljs/repl/browser.clj",
                                                      :lines [278 284]},
                                             :full-name "cljs.repl.browser/run-in-order"},
           "cljs.repl.browser/compile-client-js" {:ns "cljs.repl.browser",
                                                  :name "compile-client-js",
                                                  :signature ["[opts]"],
                                                  :name-encode "compile-client-js",
                                                  :history [["+"
                                                             "0.0-927"]
                                                            ["-"
                                                             "1.10.63"]],
                                                  :type "function",
                                                  :full-name-encode "cljs.repl.browser/compile-client-js",
                                                  :source {:code "(defn compile-client-js [opts]\n  (let [copts {:optimizations (:optimizations opts)\n               :output-dir (:working-dir opts)}]\n    ;; we're inside the REPL process where cljs.env/*compiler* is already\n    ;; established, need to construct a new one to avoid mutating the one\n    ;; the REPL uses\n    (cljsc/build\n      '[(ns clojure.browser.repl.client\n          (:require [goog.events :as event]\n                    [clojure.browser.repl :as repl]))\n        (defn start [url]\n          (event/listen js/window\n            \"load\"\n            (fn []\n              (repl/start-evaluator url))))]\n      copts (env/default-compiler-env copts))))",
                                                           :title "Source code",
                                                           :repo "clojurescript",
                                                           :tag "r1.9.946",
                                                           :filename "src/main/clojure/cljs/repl/browser.clj",
                                                           :lines [219
                                                                   234]},
                                                  :full-name "cljs.repl.browser/compile-client-js",
                                                  :removed {:in "1.10.63",
                                                            :last-seen "1.9.946"}},
           "cljs.core/macroexpand-1" {:ns "cljs.core",
                                      :name "macroexpand-1",
                                      :signature ["[quoted]"],
                                      :name-encode "macroexpand-1",
                                      :history [["+" "0.0-3165"]],
                                      :type "macro",
                                      :full-name-encode "cljs.core/macroexpand-1",
                                      :source {:code "(core/defmacro macroexpand-1\n  [quoted]\n  (core/assert (core/= (core/first quoted) 'quote)\n    \"Argument to macroexpand-1 must be quoted\")\n  (core/let [form (second quoted)]\n    (if (seq? form)\n      `(quote ~(ana/macroexpand-1 &env form))\n      form)))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/clojure/cljs/core.cljc",
                                               :lines [3096 3105]},
                                      :full-name "cljs.core/macroexpand-1",
                                      :docstring "If form represents a macro form, returns its expansion,\nelse returns form."},
           "compiler-options/closure-module-roots" {:ns "compiler-options",
                                                    :name "closure-module-roots",
                                                    :name-encode "closure-module-roots",
                                                    :type "option",
                                                    :full-name-encode "compiler-options/closure-module-roots",
                                                    :full-name "compiler-options/closure-module-roots",
                                                    :history [["+"
                                                               "1.9.456"]]},
           "cljs.core/." {:ns "cljs.core",
                          :name ".",
                          :signature ["[.instanceMethod instance args*]"
                                      "[.-instanceField instance]"],
                          :name-encode "DOT",
                          :history [["+" "0.0-927"]],
                          :type "special form",
                          :full-name-encode "cljs.core/DOT",
                          :source {:code "(defmethod parse '.\n  [_ env [_ target & [field & member+] :as form] _ _]\n  (disallowing-recur (analyze-dot env target field member+ form)))",
                                   :title "Parser code",
                                   :repo "clojurescript",
                                   :tag "r1.12.38",
                                   :filename "src/main/clojure/cljs/analyzer.cljc",
                                   :lines [3608 3610]},
                          :full-name "cljs.core/.",
                          :docstring "The instance member form works for methods and fields.\nThey all expand into calls to the dot operator at macroexpansion time."},
           "syntax/js-namespace" {:syntax-equiv {:edn-url nil,
                                                 :clj-url nil},
                                  :ns "syntax",
                                  :name "js-namespace",
                                  :name-encode "js-namespace",
                                  :type "special namespace",
                                  :full-name-encode "syntax/js-namespace",
                                  :full-name "syntax/js-namespace",
                                  :history [["+" "0.0-927"]]},
           "cljs.core/if-some" {:ns "cljs.core",
                                :name "if-some",
                                :signature ["[bindings then]"
                                            "[bindings then else & oldform]"],
                                :name-encode "if-some",
                                :history [["+" "0.0-2261"]],
                                :type "macro",
                                :full-name-encode "cljs.core/if-some",
                                :source {:code "(defmacro if-some\n  {:added \"1.6\"}\n  ([bindings then]\n   `(if-some ~bindings ~then nil))\n  ([bindings then else & oldform]\n   (assert-args\n     (vector? bindings) \"a vector for its binding\"\n     (nil? oldform) \"1 or 2 forms after binding vector\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n   (let [form (bindings 0) tst (bindings 1)]\n     `(let [temp# ~tst]\n        (if (nil? temp#)\n          ~else\n          (let [~form temp#]\n            ~then))))))",
                                         :title "Source code",
                                         :repo "clojure",
                                         :tag "clojure-1.10.0",
                                         :filename "src/clj/clojure/core.clj",
                                         :lines [1876 1894]},
                                :full-name "cljs.core/if-some",
                                :docstring "bindings => binding-form test\n\nIf test is not nil, evaluates then with binding-form bound to the\nvalue of test, if not, yields else"},
           "cljs.test/js-filename" {:ns "cljs.test",
                                    :name "js-filename",
                                    :signature ["[stack-element]"],
                                    :name-encode "js-filename",
                                    :history [["+" "0.0-2496"]],
                                    :type "function",
                                    :full-name-encode "cljs.test/js-filename",
                                    :source {:code "(defn js-filename [stack-element]\n  (let [output-dir (cljs.test/cljs-output-dir)\n        output-dir (cond-> output-dir\n                     (not (string/ends-with? output-dir \"/\"))\n                     (str \"/\"))]\n    (-> (.split stack-element output-dir)\n      last\n      (.split \":\")\n      first)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/test.cljs",
                                             :lines [378 386]},
                                    :full-name "cljs.test/js-filename"},
           "cljs.core/IReversible" {:ns "cljs.core",
                                    :name "IReversible",
                                    :name-encode "IReversible",
                                    :implementations #{"Subvec"
                                                       "PersistentTreeSet"
                                                       "RedNode"
                                                       "BlackNode"
                                                       "PersistentVector"
                                                       "IndexedSeq"
                                                       "PersistentTreeMap"
                                                       "MapEntry"},
                                    :history [["+" "0.0-1211"]],
                                    :type "protocol",
                                    :full-name-encode "cljs.core/IReversible",
                                    :source {:code "(defprotocol IReversible\n  (^clj -rseq [coll]\n    \"Returns a seq of the items in coll in reversed order.\"))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [747 750]},
                                    :methods [{:name "-rseq",
                                               :signature ["[coll]"],
                                               :docstring "Returns a seq of the items in coll in reversed order."}],
                                    :full-name "cljs.core/IReversible",
                                    :docstring "Protocol for reversing a seq."},
           "cljs.core/extend-protocol" {:ns "cljs.core",
                                        :name "extend-protocol",
                                        :signature ["[p & specs]"],
                                        :name-encode "extend-protocol",
                                        :history [["+" "0.0-927"]],
                                        :type "macro",
                                        :full-name-encode "cljs.core/extend-protocol",
                                        :source {:code "(defmacro extend-protocol \n  {:added \"1.2\"}\n\n  [p & specs]\n  (emit-extend-protocol p specs))",
                                                 :title "Source code",
                                                 :repo "clojure",
                                                 :tag "clojure-1.10.0",
                                                 :filename "src/clj/clojure/core_deftype.clj",
                                                 :lines [868 906]},
                                        :full-name "cljs.core/extend-protocol",
                                        :docstring "Useful when you want to provide several implementations of the same\nprotocol all at once. Takes a single protocol and the implementation\nof that protocol for one or more types. Expands into calls to\nextend-type:\n\n(extend-protocol Protocol\n  AType\n    (foo [x] ...)\n    (bar [x y] ...)\n  BType\n    (foo [x] ...)\n    (bar [x y] ...)\n  AClass\n    (foo [x] ...)\n    (bar [x y] ...)\n  nil\n    (foo [x] ...)\n    (bar [x y] ...))\n\nexpands into:\n\n(do\n (clojure.core/extend-type AType Protocol \n   (foo [x] ...) \n   (bar [x y] ...))\n (clojure.core/extend-type BType Protocol \n   (foo [x] ...) \n   (bar [x y] ...))\n (clojure.core/extend-type AClass Protocol \n   (foo [x] ...) \n   (bar [x y] ...))\n (clojure.core/extend-type nil Protocol \n   (foo [x] ...) \n   (bar [x y] ...)))"},
           "cljs.reader/read" {:ns "cljs.reader",
                               :name "read",
                               :signature ["[reader]"
                                           "[{:keys [eof], :as opts} reader]"
                                           "[reader eof-error? eof opts]"],
                               :name-encode "read",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.reader/read",
                               :source {:code "(defn read\n  ([reader]\n   (edn/read\n     {:readers @*tag-table*\n      :default @*default-data-reader-fn*\n      :eof nil}\n     reader))\n  ([{:keys [eof] :as opts} reader]\n   (edn/read\n     (update (merge opts {:default @*default-data-reader-fn*})\n       :readers (fn [m] (merge @*tag-table* m))) reader))\n  ([reader eof-error? eof opts]\n   (edn/read reader eof-error? eof\n     (update (merge opts {:default @*default-data-reader-fn*})\n       :readers (fn [m] (merge @*tag-table* m))))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/reader.cljs",
                                        :lines [142 172]},
                               :full-name "cljs.reader/read",
                               :docstring "Reads the first object from an cljs.tools.reader.reader-types/IPushbackReader.\nReturns the object read. If EOF, throws if eof-error? is true otherwise returns eof.\nIf no reader is provided, *in* will be used.\n\nReads data in the edn format (subset of Clojure data):\nhttp://edn-format.org\n\ncljs.tools.reader.edn/read doesn't depend on dynamic Vars, all configuration\nis done by passing an opt map.\n\nopts is a map that can include the following keys:\n:eof - value to return on end-of-file. When not supplied, eof throws an exception.\n:readers  - a map of tag symbols to data-reader functions to be considered before default-data-readers.\n           When not supplied, only the default-data-readers will be used.\n:default - A function of two args, that will, if present and no reader is found for a tag,\n           be called with the tag and the value."},
           "cljs.core/IFind" {:ns "cljs.core",
                              :name "IFind",
                              :name-encode "IFind",
                              :implementations #{"Subvec"
                                                 "PersistentHashMap"
                                                 "RedNode"
                                                 "ObjMap"
                                                 "BlackNode"
                                                 "PersistentVector"
                                                 "PersistentTreeMap"
                                                 "PersistentArrayMap"
                                                 "MapEntry"},
                              :history [["+" "1.9.518"]],
                              :type "protocol",
                              :full-name-encode "cljs.core/IFind",
                              :source {:code "(defprotocol IFind\n  (-find [coll k] \"Returns the map entry for key, or nil if key not present.\"))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [653 655]},
                              :methods [{:name "-find",
                                         :signature ["[coll k]"],
                                         :docstring "Returns the map entry for key, or nil if key not present."}],
                              :full-name "cljs.core/IFind",
                              :docstring "Protocol for implementing entry finding in collections."},
           "warnings/invalid-array-access" {:ns "warnings",
                                            :name "invalid-array-access",
                                            :name-encode "invalid-array-access",
                                            :type "warning",
                                            :full-name-encode "warnings/invalid-array-access",
                                            :full-name "warnings/invalid-array-access",
                                            :history [["+" "1.9.854"]]},
           "cljs.spec.alpha/inst-in-range?" {:ns "cljs.spec.alpha",
                                             :name "inst-in-range?",
                                             :signature ["[start end inst]"],
                                             :name-encode "inst-in-rangeQMARK",
                                             :history [["+" "1.9.542"]],
                                             :type "function",
                                             :full-name-encode "cljs.spec.alpha/inst-in-rangeQMARK",
                                             :source {:code "(defn inst-in-range?\n  [start end inst]\n  (c/and (inst? inst)\n         (let [t (inst-ms inst)]\n           (c/and (<= (inst-ms start) t) (< t (inst-ms end))))))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.12.38",
                                                      :filename "src/main/cljs/cljs/spec/alpha.cljs",
                                                      :lines [1445
                                                              1450]},
                                             :full-name "cljs.spec.alpha/inst-in-range?",
                                             :docstring "Return true if inst at or after start and before end"},
           "clojure.browser.repl/parent-connected?" {:ns "clojure.browser.repl",
                                                     :name "parent-connected?",
                                                     :name-encode "parent-connectedQMARK",
                                                     :type "var",
                                                     :full-name-encode "clojure.browser.repl/parent-connectedQMARK",
                                                     :source {:code "(def parent-connected? (atom false))",
                                                              :title "Source code",
                                                              :repo "clojurescript",
                                                              :tag "r1.12.38",
                                                              :filename "src/main/cljs/clojure/browser/repl.cljs",
                                                              :lines [38]},
                                                     :full-name "clojure.browser.repl/parent-connected?",
                                                     :history [["+"
                                                                "1.10.126"]]},
           "cljs.core/EmptyList" {:protocols #{"ISeqable"
                                               "IMeta"
                                               "IWithMeta"
                                               "IStack"
                                               "IEmptyableCollection"
                                               "ICounted"
                                               "IReduce"
                                               "ISequential"
                                               "ISeq"
                                               "ICollection"
                                               "IHash"
                                               "IPrintWithWriter"
                                               "INext"
                                               "IEquiv"
                                               "ICloneable"
                                               "IList"},
                                  :ns "cljs.core",
                                  :name "EmptyList",
                                  :signature ["[meta]"],
                                  :name-encode "EmptyList",
                                  :history [["+" "0.0-927"]],
                                  :type "type",
                                  :full-name-encode "cljs.core/EmptyList",
                                  :source {:code "(deftype EmptyList [meta]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IList\n\n  ICloneable\n  (-clone [_] (EmptyList. meta))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (EmptyList. new-meta)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] nil)\n  (-rest [coll] ())\n\n  INext\n  (-next [coll] nil)\n\n  IStack\n  (-peek [coll] nil)\n  (-pop [coll] (throw (js/Error. \"Can't pop empty list\")))\n\n  ICollection\n  (-conj [coll o] (List. meta o nil 1 nil))\n\n  IEmptyableCollection\n  (-empty [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other]\n    (if (or (list? other)\n            (sequential? other))\n      (nil? (seq other))\n      false))\n\n  IHash\n  (-hash [coll] empty-ordered-hash)\n\n  ISeqable\n  (-seq [coll] nil)\n\n  ICounted\n  (-count [coll] 0)\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [3207 3272]},
                                  :full-name "cljs.core/EmptyList"},
           "cljs.core/specify!" {:ns "cljs.core",
                                 :name "specify!",
                                 :signature ["[expr & impls]"],
                                 :name-encode "specifyBANG",
                                 :history [["+" "0.0-2156"]],
                                 :type "macro",
                                 :full-name-encode "cljs.core/specifyBANG",
                                 :source {:code "(core/defmacro specify!\n  [expr & impls]\n  (core/let [x (with-meta (gensym \"x\") {:extend :instance})]\n    `(let [~x ~expr]\n       (extend-type ~x ~@impls)\n       ~x)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/clojure/cljs/core.cljc",
                                          :lines [1387 1393]},
                                 :full-name "cljs.core/specify!",
                                 :docstring "Identical to reify but mutates its first argument."},
           "cljs.core/DEMUNGE_MAP" {:ns "cljs.core",
                                    :name "DEMUNGE_MAP",
                                    :name-encode "DEMUNGE_MAP",
                                    :type "var",
                                    :full-name-encode "cljs.core/DEMUNGE_MAP",
                                    :source {:code "(def ^{:jsdoc [\"@enum {string}\"]}\n  DEMUNGE_MAP\n  #js {\"_\"             \"-\"\n       \"_COLON_\"       \":\"\n       \"_PLUS_\"        \"+\"\n       \"_GT_\"          \">\"\n       \"_LT_\"          \"<\"\n       \"_EQ_\"          \"=\"\n       \"_TILDE_\"       \"~\"\n       \"_BANG_\"        \"!\"\n       \"_CIRCA_\"       \"@\"\n       \"_SHARP_\"       \"#\"\n       \"_SINGLEQUOTE_\" \"'\"\n       \"_DOUBLEQUOTE_\" \"\\\\\\\"\"\n       \"_PERCENT_\"     \"%\"\n       \"_CARET_\"       \"^\"\n       \"_AMPERSAND_\"   \"&\"\n       \"_STAR_\"        \"*\"\n       \"_BAR_\"         \"|\"\n       \"_LBRACE_\"      \"{\"\n       \"_RBRACE_\"      \"}\"\n       \"_LBRACK_\"      \"[\"\n       \"_RBRACK_\"      \"]\"\n       \"_SLASH_\"       \"/\"\n       \"_BSLASH_\"      \"\\\\\\\\\"\n       \"_QMARK_\"       \"?\"})",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [374 399]},
                                    :full-name "cljs.core/DEMUNGE_MAP",
                                    :history [["+" "1.7.10"]]},
           "warnings/undeclared-var" {:ns "warnings",
                                      :name "undeclared-var",
                                      :name-encode "undeclared-var",
                                      :type "warning",
                                      :full-name-encode "warnings/undeclared-var",
                                      :full-name "warnings/undeclared-var",
                                      :history [["+" "0.0-2014"]]},
           "cljs.core/cat" {:ns "cljs.core",
                            :name "cat",
                            :signature ["[rf]"],
                            :name-encode "cat",
                            :history [["+" "0.0-2341"]],
                            :type "function",
                            :full-name-encode "cljs.core/cat",
                            :source {:code "(defn cat\n  {:added \"1.7\"}\n  [rf]\n  (let [rf1 (preserving-reduced rf)]\n    (fn\n      ([] (rf))\n      ([result] (rf result))\n      ([result input]\n         (reduce rf1 result input)))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [11004 11014]},
                            :full-name "cljs.core/cat",
                            :docstring "A transducer which concatenates the contents of each input, which must be a\ncollection, into the reduction."},
           "clojure.walk/postwalk" {:ns "clojure.walk",
                                    :name "postwalk",
                                    :signature ["[f form]"],
                                    :name-encode "postwalk",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "clojure.walk/postwalk",
                                    :source {:code "(defn postwalk\n  {:added \"1.1\"}\n  [f form]\n  (walk (partial postwalk f) f form))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/clojure/walk.cljs",
                                             :lines [54 60]},
                                    :full-name "clojure.walk/postwalk",
                                    :docstring "Performs a depth-first, post-order traversal of form.  Calls f on\neach sub-form, uses f's return value in place of the original.\nRecognizes all Clojure data structures. Consumes seqs as with doall."},
           "cljs.spec.alpha/int-in" {:ns "cljs.spec.alpha",
                                     :name "int-in",
                                     :signature ["[start end]"],
                                     :name-encode "int-in",
                                     :history [["+" "1.9.542"]],
                                     :type "macro",
                                     :full-name-encode "cljs.spec.alpha/int-in",
                                     :source {:code "(defmacro int-in\n  [start end]\n  `(spec (and c/int? #(int-in-range? ~start ~end %))\n     :gen #(gen/large-integer* {:min ~start :max (dec ~end)})))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/cljs/cljs/spec/alpha.cljc",
                                              :lines [488 493]},
                                     :full-name "cljs.spec.alpha/int-in",
                                     :docstring "Returns a spec that validates fixed precision integers in the\nrange from start (inclusive) to end (exclusive)."},
           "cljs.core/PersistentArrayMap.HASHMAP-THRESHOLD" {:ns "cljs.core",
                                                             :name "PersistentArrayMap.HASHMAP-THRESHOLD",
                                                             :name-encode "PersistentArrayMapDOTHASHMAP-THRESHOLD",
                                                             :history [["+"
                                                                        "0.0-2301"]],
                                                             :parent-type "PersistentArrayMap",
                                                             :type "var",
                                                             :full-name-encode "cljs.core/PersistentArrayMapDOTHASHMAP-THRESHOLD",
                                                             :source {:code "(set! (.-HASHMAP-THRESHOLD PersistentArrayMap) 8)",
                                                                      :title "Source code",
                                                                      :repo "clojurescript",
                                                                      :tag "r1.12.38",
                                                                      :filename "src/main/cljs/cljs/core.cljs",
                                                                      :lines [7147]},
                                                             :full-name "cljs.core/PersistentArrayMap.HASHMAP-THRESHOLD"},
           "repl-options/src" {:ns "repl-options",
                               :name "src",
                               :name-encode "src",
                               :type "option",
                               :full-name-encode "repl-options/src",
                               :full-name "repl-options/src",
                               :history [["+" "0.0-1503"]]},
           "cljs.core/PersistentArrayMap.createWithCheck" {:ns "cljs.core",
                                                           :name "PersistentArrayMap.createWithCheck",
                                                           :signature ["[arr]"],
                                                           :name-encode "PersistentArrayMapDOTcreateWithCheck",
                                                           :history [["+"
                                                                      "1.9.456"]],
                                                           :parent-type "PersistentArrayMap",
                                                           :type "function",
                                                           :full-name-encode "cljs.core/PersistentArrayMapDOTcreateWithCheck",
                                                           :source {:code "(set! (.-createWithCheck PersistentArrayMap)\n  (fn [arr]\n    (let [ret (array)]\n      (loop [i 0]\n        (when (< i (alength arr))\n          (let [k (aget arr i)\n                v (aget arr (inc i))\n                idx (array-index-of ret k)]\n            (if (== idx -1)\n              (doto ret (.push k) (.push v))\n              (throw (js/Error. (str \"Duplicate key: \" k)))))\n          (recur (+ i 2))))\n      (let [cnt (/ (alength arr) 2)]\n        (PersistentArrayMap. nil cnt arr nil)))))",
                                                                    :title "Source code",
                                                                    :repo "clojurescript",
                                                                    :tag "r1.12.38",
                                                                    :filename "src/main/cljs/cljs/core.cljs",
                                                                    :lines [7168
                                                                            7181]},
                                                           :full-name "cljs.core/PersistentArrayMap.createWithCheck"},
           "clojure.zip/edit" {:ns "clojure.zip",
                               :name "edit",
                               :signature ["[loc f & args]"],
                               :name-encode "edit",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip/edit",
                               :source {:code "(defn edit\n  [loc f & args]\n    (replace loc (apply f (node loc) args)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/clojure/zip.cljs",
                                        :lines [189 192]},
                               :full-name "clojure.zip/edit",
                               :docstring "Replaces the node at this loc with the value of (f node args)"},
           "cljs.core/unreduced" {:ns "cljs.core",
                                  :name "unreduced",
                                  :signature ["[x]"],
                                  :name-encode "unreduced",
                                  :history [["+" "0.0-2411"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/unreduced",
                                  :source {:code "(defn unreduced\n  [x]\n  (if (reduced? x) (deref x) x))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [1492 1495]},
                                  :full-name "cljs.core/unreduced",
                                  :docstring "If x is reduced?, returns (deref x), else returns x"},
           "cljs.core/re-seq" {:ns "cljs.core",
                               :name "re-seq",
                               :signature ["[re s]"],
                               :name-encode "re-seq",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/re-seq",
                               :source {:code "(defn re-seq\n  [re s]\n  (if (string? s)\n    (re-seq* re s)\n    (throw (js/TypeError. \"re-seq must match against a string.\"))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [10419 10424]},
                               :full-name "cljs.core/re-seq",
                               :docstring "Returns a lazy sequence of successive matches of re in s."},
           "cljs.reader/read-list" {:ns "cljs.reader",
                                    :name "read-list",
                                    :signature ["[rdr _]"],
                                    :name-encode "read-list",
                                    :history [["+" "0.0-927"]
                                              ["-" "1.9.854"]],
                                    :type "function",
                                    :full-name-encode "cljs.reader/read-list",
                                    :source {:code "(defn read-list\n  [rdr _]\n  (let [arr (read-delimited-list \")\" rdr true)]\n    (loop [i (alength arr) ^not-native r ()]\n      (if (> i 0)\n        (recur (dec i) (-conj r (aget arr (dec i))))\n        r))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.9.671",
                                             :filename "src/main/cljs/cljs/reader.cljs",
                                             :lines [269 275]},
                                    :full-name "cljs.reader/read-list",
                                    :removed {:in "1.9.854",
                                              :last-seen "1.9.671"}},
           "cljs.core/IKVReduce" {:ns "cljs.core",
                                  :name "IKVReduce",
                                  :name-encode "IKVReduce",
                                  :implementations #{"Subvec"
                                                     "PersistentHashMap"
                                                     "ObjMap"
                                                     "PersistentVector"
                                                     "PersistentTreeMap"
                                                     "PersistentArrayMap"},
                                  :history [["+" "0.0-1211"]],
                                  :type "protocol",
                                  :full-name-encode "cljs.core/IKVReduce",
                                  :source {:code "(defprotocol IKVReduce\n  (-kv-reduce [coll f init]\n    \"Reduces an associative collection and returns the result. f should be\n     a function that takes three arguments.\"))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [716 721]},
                                  :methods [{:name "-kv-reduce",
                                             :signature ["[coll f init]"],
                                             :docstring "Reduces an associative collection and returns the result. f should be\n     a function that takes three arguments."}],
                                  :full-name "cljs.core/IKVReduce",
                                  :docstring "Protocol for associative types that can reduce themselves\n  via a function of key and val. Called by cljs.core/reduce-kv."},
           "cljs.core/Atom" {:protocols #{"IWatchable"
                                          "IMeta"
                                          "IDeref"
                                          "IHash"
                                          "IPrintWithWriter"
                                          "IAtom"
                                          "IEquiv"},
                             :ns "cljs.core",
                             :name "Atom",
                             :signature ["[state meta validator watches]"],
                             :name-encode "Atom",
                             :history [["+" "0.0-927"]],
                             :type "type",
                             :full-name-encode "cljs.core/Atom",
                             :source {:code "(deftype Atom [state meta validator watches]\n  Object\n  (equiv [this other]\n    (-equiv this other))\n\n  IAtom\n\n  IEquiv\n  (-equiv [o other] (identical? o other))\n\n  IDeref\n  (-deref [_] state)\n\n  IMeta\n  (-meta [_] meta)\n\n  IWatchable\n  (-notify-watches [this oldval newval]\n    (doseq [[key f] watches]\n      (f key this oldval newval)))\n  (-add-watch [this key f]\n    (set! (.-watches this) (assoc watches key f))\n    this)\n  (-remove-watch [this key]\n    (set! (.-watches this) (dissoc watches key)))\n\n  IHash\n  (-hash [this] (goog/getUid this)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [4519 4546]},
                             :full-name "cljs.core/Atom"},
           "clojure.core.reducers/foldcat" {:ns "clojure.core.reducers",
                                            :name "foldcat",
                                            :signature ["[coll]"],
                                            :name-encode "foldcat",
                                            :history [["+" "0.0-1236"]],
                                            :type "function",
                                            :full-name-encode "clojure.core.reducers/foldcat",
                                            :source {:code "(defn foldcat\n  [coll]\n  (fold cat append! coll))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/cljs/clojure/core/reducers.cljs",
                                                     :lines [237 240]},
                                            :full-name "clojure.core.reducers/foldcat",
                                            :docstring "Equivalent to (fold cat append! coll)"},
           "cljs.spec/with-gen" {:ns "cljs.spec",
                                 :name "with-gen",
                                 :signature ["[spec gen-fn]"],
                                 :name-encode "with-gen",
                                 :history [["+" "1.9.14"]
                                           ["-" "1.9.542"]],
                                 :type "function",
                                 :full-name-encode "cljs.spec/with-gen",
                                 :source {:code "(defn with-gen\n  [spec gen-fn]\n  (let [spec (reg-resolve spec)]\n    (if (regex? spec)\n      (assoc spec ::gfn gen-fn)\n      (with-gen* (specize spec) gen-fn))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.9.521",
                                          :filename "src/main/cljs/cljs/spec.cljs",
                                          :lines [192 198]},
                                 :full-name "cljs.spec/with-gen",
                                 :docstring "Takes a spec and a no-arg, generator-returning fn and returns a version of that spec that uses that generator",
                                 :removed {:in "1.9.542",
                                           :last-seen "1.9.521"}},
           "cljs.core/specify" {:ns "cljs.core",
                                :name "specify",
                                :signature ["[expr & impls]"],
                                :name-encode "specify",
                                :history [["+" "0.0-2138"]],
                                :type "macro",
                                :full-name-encode "cljs.core/specify",
                                :source {:code "(core/defmacro specify\n  [expr & impls]\n  `(cljs.core/specify! (cljs.core/clone ~expr)\n     ~@impls))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/clojure/cljs/core.cljc",
                                         :lines [1395 1400]},
                                :full-name "cljs.core/specify",
                                :docstring "Identical to specify! but does not mutate its first argument. The first\nargument must be an ICloneable instance."},
           "cljs.repl.server/start" {:ns "cljs.repl.server",
                                     :name "start",
                                     :signature ["[opts]"],
                                     :name-encode "start",
                                     :history [["+" "0.0-1503"]],
                                     :type "function",
                                     :full-name-encode "cljs.repl.server/start",
                                     :source {:code "(defn start\n  [opts]\n  (let [ss (ServerSocket. (:port opts))]\n    (.start\n      (Thread.\n        ((ns-resolve 'clojure.core 'binding-conveyor-fn)\n          (fn [] (server-loop opts ss)))))\n    (swap! state (fn [old] (assoc old :socket ss :port (:port opts))))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/clojure/cljs/repl/server.clj",
                                              :lines [222 230]},
                                     :full-name "cljs.repl.server/start",
                                     :docstring "Start the server on the specified port."},
           "cljs.repl.node/outs" {:ns "cljs.repl.node",
                                  :name "outs",
                                  :name-encode "outs",
                                  :type "var",
                                  :full-name-encode "cljs.repl.node/outs",
                                  :source {:code "(def outs (ConcurrentHashMap.))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/clojure/cljs/repl/node.clj",
                                           :lines [28]},
                                  :full-name "cljs.repl.node/outs",
                                  :history [["+" "1.10.217"]]},
           "cljs.core/IMap" {:ns "cljs.core",
                             :name "IMap",
                             :name-encode "IMap",
                             :implementations #{"PersistentHashMap"
                                                "ObjMap"
                                                "PersistentTreeMap"
                                                "PersistentArrayMap"},
                             :history [["+" "0.0-927"]],
                             :type "protocol",
                             :full-name-encode "cljs.core/IMap",
                             :source {:code "(defprotocol IMap\n  #_(-assoc-ex [coll k v])\n  (^clj -dissoc [coll k]\n    \"Returns a new collection of coll without the mapping for key k.\"))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [657 661]},
                             :methods [{:name "-dissoc",
                                        :signature ["[coll k]"],
                                        :docstring "Returns a new collection of coll without the mapping for key k."}],
                             :full-name "cljs.core/IMap",
                             :docstring "Protocol for adding mapping functionality to collections."},
           "cljs.core/LongImpl" {:ns "cljs.core",
                                 :name "LongImpl",
                                 :name-encode "LongImpl",
                                 :history [["+" "1.10.891"]],
                                 :type "var",
                                 :full-name-encode "cljs.core/LongImpl",
                                 :source {:code "(def\n  LongImpl goog.math.Long)",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [2337 2339]},
                                 :full-name "cljs.core/LongImpl",
                                 :docstring "INTERNAL: do not use"},
           "cljs.core/pr-sequential-writer" {:ns "cljs.core",
                                             :name "pr-sequential-writer",
                                             :signature ["[writer print-one begin sep end opts coll]"],
                                             :name-encode "pr-sequential-writer",
                                             :history [["+"
                                                        "0.0-1503"]],
                                             :type "function",
                                             :full-name-encode "cljs.core/pr-sequential-writer",
                                             :source {:code "(defn pr-sequential-writer [writer print-one begin sep end opts coll]\n  (binding [*print-level* (when-not (nil? *print-level*) (dec *print-level*))]\n    (if (and (not (nil? *print-level*)) (neg? *print-level*))\n      (-write writer \"#\")\n      (do\n        (-write writer begin)\n        (if (zero? (:print-length opts))\n          (when (seq coll)\n            (-write writer (or (:more-marker opts) \"...\")))\n          (do\n            (when (seq coll)\n              (print-one (first coll) writer opts))\n            (loop [coll (next coll) n (dec (:print-length opts))]\n              (if (and coll (or (nil? n) (not (zero? n))))\n                (do\n                  (-write writer sep)\n                  (print-one (first coll) writer opts)\n                  (recur (next coll) (dec n)))\n                (when (and (seq coll) (zero? n))\n                  (-write writer sep)\n                  (-write writer (or (:more-marker opts) \"...\")))))))\n        (-write writer end)))))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.12.38",
                                                      :filename "src/main/cljs/cljs/core.cljs",
                                                      :lines [10439
                                                              10460]},
                                             :full-name "cljs.core/pr-sequential-writer"},
           "cljs.core/unchecked-multiply" {:return-type number,
                                           :ns "cljs.core",
                                           :name "unchecked-multiply",
                                           :signature ["[]"
                                                       "[x]"
                                                       "[x y]"
                                                       "[x y & more]"],
                                           :name-encode "unchecked-multiply",
                                           :history [["+" "0.0-1798"]],
                                           :type "function/macro",
                                           :full-name-encode "cljs.core/unchecked-multiply",
                                           :source {:code "(defn ^number unchecked-multiply\n  ([] 1)\n  ([x] x)\n  ([x y] (cljs.core/unchecked-multiply x y))\n  ([x y & more] (reduce unchecked-multiply (cljs.core/unchecked-multiply x y) more)))",
                                                    :title "Function code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/cljs/cljs/core.cljs",
                                                    :lines [2842 2847]},
                                           :extra-sources [{:code "(core/defmacro ^::ana/numeric unchecked-multiply\n  ([& xs] `(* ~@xs)))",
                                                            :title "Macro code",
                                                            :repo "clojurescript",
                                                            :tag "r1.12.38",
                                                            :filename "src/main/clojure/cljs/core.cljc",
                                                            :lines [1098
                                                                    1099]}],
                                           :full-name "cljs.core/unchecked-multiply",
                                           :docstring "Returns the product of nums. (*) returns 1."},
           "cljs.reader/read-vector" {:ns "cljs.reader",
                                      :name "read-vector",
                                      :signature ["[rdr _]"],
                                      :name-encode "read-vector",
                                      :history [["+" "0.0-927"]
                                                ["-" "1.9.854"]],
                                      :type "function",
                                      :full-name-encode "cljs.reader/read-vector",
                                      :source {:code "(defn read-vector\n  [rdr _]\n  (vec (read-delimited-list \"]\" rdr true)))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.9.671",
                                               :filename "src/main/cljs/cljs/reader.cljs",
                                               :lines [279 281]},
                                      :full-name "cljs.reader/read-vector",
                                      :removed {:in "1.9.854",
                                                :last-seen "1.9.671"}},
           "clojure.set/join" {:ns "clojure.set",
                               :name "join",
                               :signature ["[xrel yrel]"
                                           "[xrel yrel km]"],
                               :name-encode "join",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.set/join",
                               :source {:code "(defn join\n  ([xrel yrel] ;natural join\n   (if (and (seq xrel) (seq yrel))\n     (let [ks (intersection (set (keys (first xrel))) (set (keys (first yrel))))\n           [r s] (if (<= (count xrel) (count yrel))\n                   [xrel yrel]\n                   [yrel xrel])\n           idx (index r ks)]\n       (reduce (fn [ret x]\n                 (let [found (idx (select-keys x ks))]\n                   (if found\n                     (reduce #(conj %1 (merge %2 x)) ret found)\n                     ret)))\n               #{} s))\n     #{}))\n  ([xrel yrel km] ;arbitrary key mapping\n   (let [[r s k] (if (<= (count xrel) (count yrel))\n                   [xrel yrel (map-invert km)]\n                   [yrel xrel km])\n         idx (index r (vals k))]\n     (reduce (fn [ret x]\n               (let [found (idx (rename-keys (select-keys x (keys k)) k))]\n                 (if found\n                   (reduce #(conj %1 (merge %2 x)) ret found)\n                   ret)))\n             #{} s))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/clojure/set.cljs",
                                        :lines [105 133]},
                               :full-name "clojure.set/join",
                               :docstring "When passed 2 rels, returns the rel corresponding to the natural\njoin. When passed an additional keymap, joins on the corresponding\nkeys."},
           "closure-warnings/fileoverview-jsdoc" {:ns "closure-warnings",
                                                  :name "fileoverview-jsdoc",
                                                  :name-encode "fileoverview-jsdoc",
                                                  :type "warning",
                                                  :full-name-encode "closure-warnings/fileoverview-jsdoc",
                                                  :full-name "closure-warnings/fileoverview-jsdoc",
                                                  :history [["+"
                                                             "0.0-2120"]
                                                            ["-"
                                                             "1.10.738"]],
                                                  :removed {:in "1.10.738",
                                                            :last-seen "1.10.597"}},
           "cljs.spec.gen.alpha/double" {:ns "cljs.spec.gen.alpha",
                                         :name "double",
                                         :signature ["[& args]"],
                                         :name-encode "double",
                                         :history [["+" "1.9.542"]],
                                         :type "function",
                                         :full-name-encode "cljs.spec.gen.alpha/double",
                                         :source {:code "(lazy-prims any any-printable boolean char char-alpha char-alphanumeric char-ascii double\n  int keyword keyword-ns large-integer ratio simple-type simple-type-printable\n  string string-ascii string-alphanumeric symbol symbol-ns uuid)",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/cljs/cljs/spec/gen/alpha.cljs",
                                                  :lines [74 76]},
                                         :full-name "cljs.spec.gen.alpha/double",
                                         :docstring "Fn returning clojure.test.check.generators/double"},
           "cljs.core/HashMap" {:protocols #{"IFn"
                                             "ISeqable"
                                             "IMap"
                                             "IMeta"
                                             "IWithMeta"
                                             "IEmptyableCollection"
                                             "ICounted"
                                             "ILookup"
                                             "ICollection"
                                             "IHash"
                                             "IPrintWithWriter"
                                             "IAssociative"
                                             "IPrintable"
                                             "IEquiv"},
                                :ns "cljs.core",
                                :name "HashMap",
                                :signature ["[meta count hashobj __hash]"],
                                :name-encode "HashMap",
                                :history [["+" "0.0-927"]
                                          ["-" "0.0-1798"]],
                                :type "type",
                                :full-name-encode "cljs.core/HashMap",
                                :source {:code "(deftype HashMap [meta count hashobj ^:mutable __hash]\n  Object\n  (toString [this]\n    (pr-str this))\n\n  IWithMeta\n  (-with-meta [coll meta] (HashMap. meta count hashobj __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (reduce -conj\n              coll\n              entry)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.HashMap/EMPTY meta))\n\n  IEquiv\n  (-equiv [coll other] (equiv-map coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-imap __hash))\n\n  ISeqable\n  (-seq [coll]\n    (when (pos? count)\n      (let [hashes (.sort (js-keys hashobj))]\n        (mapcat #(map vec (partition 2 (aget hashobj %)))\n                hashes))))\n\n  ICounted\n  (-count [coll] count)\n\n  ILookup\n  (-lookup [coll k] (-lookup coll k nil))\n  (-lookup [coll k not-found]\n    (let [bucket (aget hashobj (hash k))\n          i (when bucket (scan-array 2 k bucket))]\n      (if i\n        (aget bucket (inc i))\n        not-found)))\n\n  IAssociative\n  (-assoc [coll k v]\n    (let [h (hash k)\n          bucket (aget hashobj h)]\n      (if bucket\n        (let [new-bucket (aclone bucket)\n              new-hashobj (goog.object/clone hashobj)]\n          (aset new-hashobj h new-bucket)\n          (if-let [i (scan-array 2 k new-bucket)]\n            (do                         ; found key, replace\n              (aset new-bucket (inc i) v)\n              (HashMap. meta count new-hashobj nil))\n            (do                         ; did not find key, append\n              (.push new-bucket k v)\n              (HashMap. meta (inc count) new-hashobj nil))))\n        (let [new-hashobj (goog.object/clone hashobj)] ; did not find bucket\n          (aset new-hashobj h (array k v))\n          (HashMap. meta (inc count) new-hashobj nil)))))\n  (-contains-key? [coll k]\n    (let [bucket (aget hashobj (hash k))\n          i (when bucket (scan-array 2 k bucket))]\n      (if i\n        true\n        false)))\n\n  IMap\n  (-dissoc [coll k]\n    (let [h (hash k)\n          bucket (aget hashobj h)\n          i (when bucket (scan-array 2 k bucket))]\n      (if (not i)\n        coll ; key not found, return coll unchanged\n        (let [new-hashobj (goog.object/clone hashobj)]\n          (if (> 3 (alength bucket))\n            (js-delete new-hashobj h)\n            (let [new-bucket (aclone bucket)]\n              (.splice new-bucket i 2)\n              (aset new-hashobj h new-bucket)))\n          (HashMap. meta (dec count) new-hashobj nil)))))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1586",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [3737 3828]},
                                :full-name "cljs.core/HashMap",
                                :removed {:in "0.0-1798",
                                          :last-seen "0.0-1586"}},
           "cljs.repl.browser/handle-get" {:ns "cljs.repl.browser",
                                           :name "handle-get",
                                           :signature ["[opts conn request]"],
                                           :name-encode "handle-get",
                                           :history [["+" "0.0-927"]
                                                     ["-" "0.0-1503"]],
                                           :type "function",
                                           :full-name-encode "cljs.repl.browser/handle-get",
                                           :source {:code "(defn handle-get [opts conn request]\n  (let [path (:path request)]\n    (cond\n     (.startsWith path \"/repl\") (send-repl-client-page opts conn request)\n     (:serve-static opts) (send-static opts conn request)\n     :else (send-404 conn (:path request)))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1450",
                                                    :filename "src/clj/cljs/repl/browser.clj",
                                                    :lines [199 204]},
                                           :full-name "cljs.repl.browser/handle-get",
                                           :removed {:in "0.0-1503",
                                                     :last-seen "0.0-1450"}},
           "cljs.core/es6-iterable" {:ns "cljs.core",
                                     :name "es6-iterable",
                                     :signature ["[ty]"],
                                     :name-encode "es6-iterable",
                                     :history [["+" "0.0-2411"]],
                                     :type "macro",
                                     :full-name-encode "cljs.core/es6-iterable",
                                     :source {:code "(core/defmacro es6-iterable [ty]\n  `(unchecked-set (.-prototype ~ty) cljs.core/ITER_SYMBOL\n     (fn []\n       (this-as this#\n         (cljs.core/es6-iterator this#)))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/clojure/cljs/core.cljc",
                                              :lines [2916 2920]},
                                     :full-name "cljs.core/es6-iterable"},
           "cljs.reader/int-pattern" {:ns "cljs.reader",
                                      :name "int-pattern",
                                      :name-encode "int-pattern",
                                      :history [["+" "0.0-927"]
                                                ["-" "1.9.854"]],
                                      :type "var",
                                      :full-name-encode "cljs.reader/int-pattern",
                                      :source {:code "(def int-pattern (re-pattern \"^([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+))(N)?$\"))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.9.671",
                                               :filename "src/main/cljs/cljs/reader.cljs",
                                               :lines [99]},
                                      :full-name "cljs.reader/int-pattern",
                                      :removed {:in "1.9.854",
                                                :last-seen "1.9.671"}},
           "cljs.core/swap!" {:ns "cljs.core",
                              :name "swap!",
                              :signature ["[a f]"
                                          "[a f x]"
                                          "[a f x y]"
                                          "[a f x y & more]"],
                              :name-encode "swapBANG",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/swapBANG",
                              :source {:code "(defn swap!\n  ([a f]\n   (if (instance? Atom a)\n     (reset! a (f (.-state a)))\n     (-swap! a f)))\n  ([a f x]\n   (if (instance? Atom a)\n     (reset! a (f (.-state a) x))\n     (-swap! a f x)))\n  ([a f x y]\n   (if (instance? Atom a)\n     (reset! a (f (.-state a) x y))\n     (-swap! a f x y)))\n  ([a f x y & more]\n   (if (instance? Atom a)\n     (reset! a (apply f (.-state a) x y more))\n     (-swap! a f x y more))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [4600 4620]},
                              :full-name "cljs.core/swap!",
                              :docstring "Atomically swaps the value of atom to be:\n(apply f current-value-of-atom args). Note that f may be called\nmultiple times, and thus should be free of side effects.  Returns\nthe value that was swapped in."},
           "cljs.core/finally" {:ns "cljs.core",
                                :name "finally",
                                :signature ["[expr*]"],
                                :name-encode "finally",
                                :history [["+" "0.0-927"]],
                                :type "special form",
                                :full-name-encode "cljs.core/finally",
                                :source {:code "(defmethod parse 'try\n  [op env [_ & body :as form] name _]\n  (let [catchenv (update-in env [:context] #(if (= :expr %) :return %))\n        catch? (every-pred seq? #(= (first %) 'catch))\n        default? (every-pred catch? #(= (second %) :default))\n        finally? (every-pred seq? #(= (first %) 'finally))\n\n        {:keys [body cblocks dblock fblock]}\n        (loop [parser {:state :start :forms body\n                       :body [] :cblocks [] :dblock nil :fblock nil}]\n          (if (seq? (:forms parser))\n            (let [[form & forms*] (:forms parser)\n                  parser* (assoc parser :forms forms*)]\n              (case (:state parser)\n                :start (cond\n                         (catch? form) (recur (assoc parser :state :catches))\n                         (finally? form) (recur (assoc parser :state :finally))\n                         :else (recur (update-in parser* [:body] conj form)))\n                :catches (cond\n                           (default? form) (recur (assoc parser* :dblock form :state :finally))\n                           (catch? form) (recur (update-in parser* [:cblocks] conj form))\n                           (finally? form) (recur (assoc parser :state :finally))\n                           :else (throw (error env \"Invalid try form\")))\n                :finally (recur (assoc parser* :fblock form :state :done))\n                :done (throw (error env \"Unexpected form after finally\"))))\n            parser))\n\n        finally (when (seq fblock)\n                  (-> (disallowing-recur (analyze (assoc env :context :statement) `(do ~@(rest fblock))))\n                      (assoc :body? true)))\n        e (when (or (seq cblocks) dblock) (gensym \"e\"))\n        default (if-let [[_ _ name & cb] dblock]\n                  `(cljs.core/let [~name ~e] ~@cb)\n                  `(throw ~e))\n        cblock (if (seq cblocks)\n                 `(cljs.core/cond\n                   ~@(mapcat\n                      (fn [[_ type name & cb]]\n                        (when name (assert (not (namespace name)) \"Can't qualify symbol in catch\"))\n                        `[(cljs.core/instance? ~type ~e)\n                          (cljs.core/let [~name ~e] ~@cb)])\n                      cblocks)\n                   :else ~default)\n                 default)\n        locals (:locals catchenv)\n        locals (if e\n                 (assoc locals e\n                        {:name e\n                         :line (get-line e env)\n                         :column (get-col e env)\n                         ;; :local is required for {:op :local ...} nodes\n                         ;; but previously we had no way to figure this out\n                         ;; for `catch` locals, by adding it here we can recover\n                         ;; it later\n                         :local :catch})\n                 locals)\n        catch (when cblock\n                (disallowing-recur (analyze (assoc catchenv :locals locals) cblock)))\n        try (disallowing-recur (analyze (if (or e finally) catchenv env) `(do ~@body)))]\n\n    {:env env :op :try :form form\n     :body (assoc try :body? true)\n     :finally finally\n     :name e\n     :catch catch\n     :children (vec\n                 (concat [:body]\n                         (when catch\n                           [:catch])\n                         (when finally\n                           [:finally])))}))",
                                         :title "Parser code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/clojure/cljs/analyzer.cljc",
                                         :lines [1834 1904]},
                                :extra-sources ({:code "(defmethod emit* :try\n  [{try :body :keys [env catch name finally]}]\n  (let [context (:context env)]\n    (if (or name finally)\n      (do\n        (when (= :expr context)\n          (emits \"(function (){\"))\n        (emits \"try{\" try \"}\")\n        (when name\n          (emits \"catch (\" (munge name) \"){\" catch \"}\"))\n        (when finally\n          (assert (not= :const (:op (ana/unwrap-quote finally))) \"finally block cannot contain constant\")\n          (emits \"finally {\" finally \"}\"))\n        (when (= :expr context)\n          (emits \"})()\")))\n      (emits try))))",
                                                 :title "Emitting code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/clojure/cljs/compiler.cljc",
                                                 :lines [1068 1083]}),
                                :full-name "cljs.core/finally",
                                :docstring "catch-clause => (catch classname name expr*)\nfinally-clause => (finally expr*)\nCatches and handles JavaScript exceptions."},
           "cljs.spec/explain-str" {:ns "cljs.spec",
                                    :name "explain-str",
                                    :signature ["[spec x]"],
                                    :name-encode "explain-str",
                                    :history [["+" "1.9.14"]
                                              ["-" "1.9.542"]],
                                    :type "function",
                                    :full-name-encode "cljs.spec/explain-str",
                                    :source {:code "(defn explain-str\n  [spec x]\n  (with-out-str (explain spec x)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.9.521",
                                             :filename "src/main/cljs/cljs/spec.cljs",
                                             :lines [259 262]},
                                    :full-name "cljs.spec/explain-str",
                                    :docstring "Given a spec and a value that fails to conform, returns an explanation as a string.",
                                    :removed {:in "1.9.542",
                                              :last-seen "1.9.521"}},
           "cljs.spec.alpha/check-asserts?" {:return-type boolean,
                                             :ns "cljs.spec.alpha",
                                             :name "check-asserts?",
                                             :signature ["[]"],
                                             :name-encode "check-assertsQMARK",
                                             :history [["+" "1.9.542"]],
                                             :type "function",
                                             :full-name-encode "cljs.spec.alpha/check-assertsQMARK",
                                             :source {:code "(defn ^boolean check-asserts?\n  []\n  *runtime-asserts*)",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.12.38",
                                                      :filename "src/main/cljs/cljs/spec/alpha.cljs",
                                                      :lines [1485
                                                              1488]},
                                             :full-name "cljs.spec.alpha/check-asserts?",
                                             :docstring "Returns the value set by check-asserts."},
           "cljs.spec/coll-of" {:ns "cljs.spec",
                                :name "coll-of",
                                :signature ["[pred & opts]"],
                                :name-encode "coll-of",
                                :history [["+" "1.9.14"]
                                          ["-" "1.9.542"]],
                                :type "macro",
                                :full-name-encode "cljs.spec/coll-of",
                                :source {:code "(defmacro coll-of\n  [pred & opts]\n  (let [desc `(coll-of ~(res &env pred) ~@(res-kind &env opts))]\n    `(every ~pred ::conform-all true ::describe '~desc ~@opts)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.9.521",
                                         :filename "src/main/cljs/cljs/spec.cljc",
                                         :lines [272 285]},
                                :full-name "cljs.spec/coll-of",
                                :docstring "Returns a spec for a collection of items satisfying pred. Unlike\ngenerator will fill an empty init-coll.\n\nSame options as 'every'. conform will produce a collection\ncorresponding to :into if supplied, else will match the input collection,\navoiding rebuilding when possible.\n\nSame options as 'every'.\n\nSee also - every, map-of",
                                :removed {:in "1.9.542",
                                          :last-seen "1.9.521"}},
           "warnings/extending-base-js-type" {:ns "warnings",
                                              :name "extending-base-js-type",
                                              :name-encode "extending-base-js-type",
                                              :type "warning",
                                              :full-name-encode "warnings/extending-base-js-type",
                                              :full-name "warnings/extending-base-js-type",
                                              :history [["+"
                                                         "0.0-2024"]]},
           "cljs.core/dec" {:ns "cljs.core",
                            :name "dec",
                            :signature ["[x]"],
                            :name-encode "dec",
                            :history [["+" "0.0-927"]],
                            :type "function/macro",
                            :full-name-encode "cljs.core/dec",
                            :source {:code "(defn dec\n  [x] (- x 1))",
                                     :title "Function code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [2762 2764]},
                            :extra-sources [{:code "(core/defmacro ^::ana/numeric dec [x]\n  `(- ~x 1))",
                                             :title "Macro code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/clojure/cljs/core.cljc",
                                             :lines [1165 1166]}],
                            :full-name "cljs.core/dec",
                            :docstring "Returns a number one less than num."},
           "cljs.core/EntriesIterator" {:ns "cljs.core",
                                        :name "EntriesIterator",
                                        :signature ["[s]"],
                                        :name-encode "EntriesIterator",
                                        :history [["+" "0.0-2268"]
                                                  ["-" "0.0-2371"]],
                                        :type "type",
                                        :full-name-encode "cljs.core/EntriesIterator",
                                        :source {:code "(deftype EntriesIterator [^:mutable s]\n  Object\n  (next [_]\n    (if-not (nil? s)\n      (let [[k v] (first s)]\n        (set! s (next s))\n        #js {:value #js [k v] :done false})\n      #js {:value nil :done true})))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2356",
                                                 :filename "src/cljs/cljs/core.cljs",
                                                 :lines [4874 4881]},
                                        :full-name "cljs.core/EntriesIterator",
                                        :removed {:in "0.0-2371",
                                                  :last-seen "0.0-2356"}},
           "cljs.core/*clojurescript-version*" {:ns "cljs.core",
                                                :name "*clojurescript-version*",
                                                :name-encode "STARclojurescript-versionSTAR",
                                                :type "var",
                                                :full-name-encode "cljs.core/STARclojurescript-versionSTAR",
                                                :source {:code "(def *clojurescript-version*)",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1.12.38",
                                                         :filename "src/main/cljs/cljs/core.cljs",
                                                         :lines [19]},
                                                :full-name "cljs.core/*clojurescript-version*",
                                                :history [["+"
                                                           "0.0-2014"]]},
           "cljs.js/dump-core" {:ns "cljs.js",
                                :name "dump-core",
                                :signature ["[]"],
                                :name-encode "dump-core",
                                :history [["+" "1.7.10"]],
                                :type "macro",
                                :full-name-encode "cljs.js/dump-core",
                                :source {:code "(defmacro dump-core []\n  (let [state @env/*compiler*]\n    (if-not (false? (get-in state [:options :dump-core]))\n      `(quote ~(get-in state [::ana/namespaces 'cljs.core]))\n      `(hash-map))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/js.clj",
                                         :lines [20 24]},
                                :full-name "cljs.js/dump-core"},
           "cljs.spec.alpha/*coll-check-limit*" {:ns "cljs.spec.alpha",
                                                 :name "*coll-check-limit*",
                                                 :name-encode "STARcoll-check-limitSTAR",
                                                 :type "dynamic var",
                                                 :full-name-encode "cljs.spec.alpha/STARcoll-check-limitSTAR",
                                                 :source {:code "(def ^:dynamic *coll-check-limit*\n  101)",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r1.12.38",
                                                          :filename "src/main/cljs/cljs/spec/alpha.cljs",
                                                          :lines [31
                                                                  33]},
                                                 :full-name "cljs.spec.alpha/*coll-check-limit*",
                                                 :history [["+"
                                                            "1.9.542"]]},
           "clojure.core.reducers/fold" {:ns "clojure.core.reducers",
                                         :name "fold",
                                         :signature ["[reducef coll]"
                                                     "[combinef reducef coll]"
                                                     "[n combinef reducef coll]"],
                                         :name-encode "fold",
                                         :history [["+" "0.0-1236"]],
                                         :type "function",
                                         :full-name-encode "clojure.core.reducers/fold",
                                         :source {:code "(defn fold\n  ([reducef coll] (fold reducef reducef coll))\n  ([combinef reducef coll] (fold 512 combinef reducef coll))\n  ([n combinef reducef coll]\n     (coll-fold coll n combinef reducef)))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/cljs/clojure/core/reducers.cljs",
                                                  :lines [49 64]},
                                         :full-name "clojure.core.reducers/fold",
                                         :docstring "Reduces a collection using a (potentially parallel) reduce-combine\nstrategy. The collection is partitioned into groups of approximately\nn (default 512), each of which is reduced with reducef (with a seed\nvalue obtained by calling (combinef) with no arguments). The results\nof these reductions are then reduced with combinef (default\nreducef). combinef must be associative, and, when called with no\narguments, (combinef) must produce its identity element. These\noperations may be performed in parallel, but the results will\npreserve order.\n\nNote: Performing operations in parallel is currently not implemented."},
           "cljs.spec/instrument-ns" {:ns "cljs.spec",
                                      :name "instrument-ns",
                                      :signature ["[& ns-syms]"],
                                      :name-encode "instrument-ns",
                                      :history [["+" "1.9.14"]
                                                ["-" "1.9.183"]],
                                      :type "macro",
                                      :full-name-encode "cljs.spec/instrument-ns",
                                      :source {:code "(defmacro instrument-ns\n  [& ns-syms]\n  `(do\n     ~@(map #(list 'cljs.spec/instrument %) (speced-vars* ns-syms))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.9.93",
                                               :filename "src/main/cljs/cljs/spec.cljc",
                                               :lines [460 465]},
                                      :full-name "cljs.spec/instrument-ns",
                                      :docstring "Call instrument for all speced-vars in namespaces named\nby ns-syms. Idempotent.",
                                      :removed {:in "1.9.183",
                                                :last-seen "1.9.93"}},
           "cljs.core/StringBufferWriter" {:protocols #{"IWriter"},
                                           :ns "cljs.core",
                                           :name "StringBufferWriter",
                                           :signature ["[sb]"],
                                           :name-encode "StringBufferWriter",
                                           :history [["+" "0.0-1503"]],
                                           :type "type",
                                           :full-name-encode "cljs.core/StringBufferWriter",
                                           :source {:code "(deftype StringBufferWriter [sb]\n  IWriter\n  (-write [_ s] (.append sb s))\n  (-flush [_] nil))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/cljs/cljs/core.cljs",
                                                    :lines [899 902]},
                                           :full-name "cljs.core/StringBufferWriter"},
           "cljs.js/analyze" {:ns "cljs.js",
                              :name "analyze",
                              :signature ["[state source cb]"
                                          "[state source name cb]"
                                          "[state source name opts cb]"],
                              :name-encode "analyze",
                              :history [["+" "1.7.10"] ["-" "1.7.28"]],
                              :type "function",
                              :full-name-encode "cljs.js/analyze",
                              :source {:code "(defn analyze\n  ([state source cb]\n   (analyze state source nil cb))\n  ([state source name cb]\n   (analyze state source name nil cb))\n  ([state source name opts cb]\n   {:pre [(atom? state) (string? source)\n          (valid-name? name) (valid-opts? opts) (fn? cb)]}\n   (analyze*\n     {:*compiler*     state\n      :*data-readers* tags/*cljs-data-readers*\n      :*load-fn*      (or (:load opts) *load-fn*)\n      :*eval-fn*      (or (:eval opts) *eval-fn*)}\n     source name opts cb)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.10",
                                       :filename "src/main/cljs/cljs/js.cljs",
                                       :lines [423 459]},
                              :full-name "cljs.js/analyze",
                              :docstring "Analyze ClojureScript source. The compiler state will be populated with\nthe results of analyzes. The parameters:\n\nstate (atom)\n  the compiler state\n\nsource (string)\n  the ClojureScript source\n\nname (symbol)\n  optional, the name of the source\n\nopts (map)\n  compilation options.\n\n:eval - the eval function to invoke, see *eval-fn*\n:load - library resolution function, see *load-fn*\n\ncb (function)\n  callback, will be invoked with a map. If successful the map will contain\n  a key :value, the actual value is not meaningful. If unsuccessful the\n  map will contain a key :error with an ex-info instance describing the cause\n  of failure.",
                              :removed {:in "1.7.28",
                                        :last-seen "1.7.10"}},
           "cljs.core/gen-apply-to-simple" {:ns "cljs.core",
                                            :name "gen-apply-to-simple",
                                            :signature ["[f num-args args]"],
                                            :name-encode "gen-apply-to-simple",
                                            :history [["+" "1.9.655"]],
                                            :type "macro",
                                            :full-name-encode "cljs.core/gen-apply-to-simple",
                                            :source {:code "(core/defmacro gen-apply-to-simple\n  [f num-args args]\n  (gen-apply-to-simple-helper f num-args args))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/clojure/cljs/core.cljc",
                                                     :lines [2889
                                                             2891]},
                                            :full-name "cljs.core/gen-apply-to-simple"},
           "cljs.spec.alpha/invalid?" {:ns "cljs.spec.alpha",
                                       :name "invalid?",
                                       :signature ["[ret]"],
                                       :name-encode "invalidQMARK",
                                       :history [["+" "1.9.542"]],
                                       :type "function",
                                       :full-name-encode "cljs.spec.alpha/invalidQMARK",
                                       :source {:code "(defn invalid?\n  [ret]\n  (keyword-identical? ::invalid ret))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/spec/alpha.cljs",
                                                :lines [163 166]},
                                       :full-name "cljs.spec.alpha/invalid?",
                                       :docstring "tests the validity of a conform return value"},
           "cljs.repl.nashorn/eval-resource" {:ns "cljs.repl.nashorn",
                                              :name "eval-resource",
                                              :signature ["[engine path debug]"],
                                              :name-encode "eval-resource",
                                              :history [["+"
                                                         "0.0-2814"]
                                                        ["-"
                                                         "1.10.738"]],
                                              :type "function",
                                              :full-name-encode "cljs.repl.nashorn/eval-resource",
                                              :source {:code "(defn eval-resource\n      [engine path debug]\n      (let [r (io/resource path)]\n        (eval-str engine (slurp r))\n        (when debug (println \"loaded: \" path))))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.10.597",
                                                       :filename "src/main/clojure/cljs/repl/nashorn.clj",
                                                       :lines [48 53]},
                                              :full-name "cljs.repl.nashorn/eval-resource",
                                              :docstring "Evaluate a file on the classpath in the engine.",
                                              :removed {:in "1.10.738",
                                                        :last-seen "1.10.597"}},
           "clojure.browser.dom/remove-children" {:ns "clojure.browser.dom",
                                                  :name "remove-children",
                                                  :signature ["[id]"],
                                                  :name-encode "remove-children",
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "clojure.browser.dom/remove-children",
                                                  :source {:code "(defn remove-children\n  [id]\n  (let [parent (gdom/getElement (name id))]\n    (do (gdom/removeChildren parent))))",
                                                           :title "Source code",
                                                           :repo "clojurescript",
                                                           :tag "r1.12.38",
                                                           :filename "src/main/cljs/clojure/browser/dom.cljs",
                                                           :lines [92
                                                                   96]},
                                                  :full-name "clojure.browser.dom/remove-children",
                                                  :docstring "Remove all children from the element with the passed id."},
           "cljs.core/BlackNode" {:protocols #{"IFn"
                                               "ISeqable"
                                               "IMeta"
                                               "IWithMeta"
                                               "IReversible"
                                               "IStack"
                                               "IEmptyableCollection"
                                               "ICounted"
                                               "IReduce"
                                               "ILookup"
                                               "ISequential"
                                               "ICollection"
                                               "IHash"
                                               "IComparable"
                                               "IPrintWithWriter"
                                               "IIndexed"
                                               "IAssociative"
                                               "IVector"
                                               "IFind"
                                               "IEquiv"
                                               "IMapEntry"},
                                  :ns "cljs.core",
                                  :name "BlackNode",
                                  :signature ["[key val left right __hash]"],
                                  :name-encode "BlackNode",
                                  :history [["+" "0.0-1211"]],
                                  :type "type",
                                  :full-name-encode "cljs.core/BlackNode",
                                  :source {:code "(deftype BlackNode [key val left right ^:mutable __hash]\n  Object\n  (add-left [node ins]\n    (.balance-left ins node))\n\n  (add-right [node ins]\n    (.balance-right ins node))\n\n  (remove-left [node del]\n    (balance-left-del key val del right))\n\n  (remove-right [node del]\n    (balance-right-del key val left del))\n\n  (blacken [node] node)\n\n  (redden [node] (RedNode. key val left right nil))\n\n  (balance-left [node parent]\n    (BlackNode. (.-key parent) (.-val parent) node (.-right parent) nil))\n\n  (balance-right [node parent]\n    (BlackNode. (.-key parent) (.-val parent) (.-left parent) node nil))\n\n  (replace [node key val left right]\n    (BlackNode. key val left right nil))\n\n  (kv-reduce [node f init]\n    (tree-map-kv-reduce node f init))\n\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IMapEntry\n  (-key [node] key)\n  (-val [node] val)\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IMeta\n  (-meta [node] nil)\n\n  IWithMeta\n  (-with-meta [node meta]\n    (-with-meta [key val] meta))\n\n  IStack\n  (-peek [node] val)\n\n  (-pop [node] [key])\n\n  ICollection\n  (-conj [node o] [key val o])\n\n  IEmptyableCollection\n  (-empty [node] nil)\n\n  ISequential\n  ISeqable\n  (-seq [node] (IndexedSeq. #js [key val] 0 nil))\n\n  IReversible\n  (-rseq [node] (IndexedSeq. #js [val key] 0 nil))\n\n  ICounted\n  (-count [node] 2)\n\n  IIndexed\n  (-nth [node n]\n    (cond (== n 0) key\n          (== n 1) val\n          :else    (throw (js/Error. \"Index out of bounds\"))))\n\n  (-nth [node n not-found]\n    (cond (== n 0) key\n          (== n 1) val\n          :else    not-found))\n\n  ILookup\n  (-lookup [node k] (-nth node k nil))\n  (-lookup [node k not-found] (-nth node k not-found))\n\n  IAssociative\n  (-assoc [node k v]\n    (assoc [key val] k v))\n  (-contains-key? [node k]\n    (or (== k 0) (== k 1)))\n\n  IFind\n  (-find [node k]\n    (case k\n      0 (MapEntry. 0 key nil)\n      1 (MapEntry. 1 val nil)\n      nil))\n\n  IVector\n  (-assoc-n [node n v]\n    (-assoc-n [key val] n v))\n\n  IReduce\n  (-reduce [node f]\n    (ci-reduce node f))\n\n  (-reduce [node f start]\n    (ci-reduce node f start))\n\n  IFn\n  (-invoke [node k]\n    (-nth node k))\n\n  (-invoke [node k not-found]\n    (-nth node k not-found)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [8563 8684]},
                                  :full-name "cljs.core/BlackNode"},
           "cljs.spec.test.alpha/checkable-syms" {:ns "cljs.spec.test.alpha",
                                                  :name "checkable-syms",
                                                  :signature ["[]"
                                                              "[opts]"],
                                                  :name-encode "checkable-syms",
                                                  :history [["+"
                                                             "1.9.542"]],
                                                  :type "macro",
                                                  :full-name-encode "cljs.spec.test.alpha/checkable-syms",
                                                  :source {:code "(defmacro checkable-syms\n  ([]\n   `(checkable-syms nil))\n  ([opts]\n   `(let [opts# ~opts]\n      (validate-check-opts opts#)\n      (reduce conj #{}\n        '[~@(filter fn-spec-name? (keys @(registry-ref)))\n          ~@(keys (:spec opts))]))))",
                                                           :title "Source code",
                                                           :repo "clojurescript",
                                                           :tag "r1.12.38",
                                                           :filename "src/main/cljs/cljs/spec/test/alpha.cljc",
                                                           :lines [246
                                                                   256]},
                                                  :full-name "cljs.spec.test.alpha/checkable-syms",
                                                  :docstring "Given an opts map as per check, returns the set of syms that\ncan be checked."},
           "cljs.repl/*repl-env*" {:ns "cljs.repl",
                                   :name "*repl-env*",
                                   :name-encode "STARrepl-envSTAR",
                                   :type "dynamic var",
                                   :full-name-encode "cljs.repl/STARrepl-envSTAR",
                                   :source {:code "(def ^:dynamic *repl-env* nil)",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/clojure/cljs/repl.cljc",
                                            :lines [36]},
                                   :full-name "cljs.repl/*repl-env*",
                                   :history [["+" "1.10.126"]]},
           "cljs.core/some->" {:ns "cljs.core",
                               :name "some->",
                               :signature ["[expr & forms]"],
                               :name-encode "some-GT",
                               :history [["+" "0.0-1798"]],
                               :type "macro",
                               :full-name-encode "cljs.core/some-GT",
                               :source {:code "(defmacro some->\n  {:added \"1.5\"}\n  [expr & forms]\n  (let [g (gensym)\n        steps (map (fn [step] `(if (nil? ~g) nil (-> ~g ~step)))\n                   forms)]\n    `(let [~g ~expr\n           ~@(interleave (repeat g) (butlast steps))]\n       ~(if (empty? steps)\n          g\n          (last steps)))))",
                                        :title "Source code",
                                        :repo "clojure",
                                        :tag "clojure-1.10.0",
                                        :filename "src/clj/clojure/core.clj",
                                        :lines [7584 7596]},
                               :full-name "cljs.core/some->",
                               :docstring "When expr is not nil, threads it into the first form (via ->),\nand when that result is not nil, through the next etc"},
           "cljs.core/hash-long" {:ns "cljs.core",
                                  :name "hash-long",
                                  :signature ["[high low]"],
                                  :name-encode "hash-long",
                                  :history [["+" "1.11.132"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/hash-long",
                                  :source {:code "(defn hash-long [high low]\n  (bit-xor high low))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [963 964]},
                                  :full-name "cljs.core/hash-long"},
           "cljs.core/get-validator" {:ns "cljs.core",
                                      :name "get-validator",
                                      :signature ["[iref]"],
                                      :name-encode "get-validator",
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "cljs.core/get-validator",
                                      :source {:code "(defn get-validator\n  [iref]\n  (.-validator iref))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [4667 4670]},
                                      :full-name "cljs.core/get-validator",
                                      :docstring "Gets the validator-fn for a var/ref/agent/atom."},
           "cljs.core/coll?" {:ns "cljs.core",
                              :name "coll?",
                              :signature ["[x]"],
                              :name-encode "collQMARK",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/collQMARK",
                              :source {:code "(defn coll?\n  [x]\n  (if (nil? x)\n    false\n    (satisfies? ICollection x)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [2186 2191]},
                              :full-name "cljs.core/coll?",
                              :docstring "Returns true if x satisfies ICollection"},
           "cljs.core/unchecked-negate-int" {:ns "cljs.core",
                                             :name "unchecked-negate-int",
                                             :signature ["[x]"],
                                             :name-encode "unchecked-negate-int",
                                             :history [["+"
                                                        "0.0-1798"]],
                                             :type "function/macro",
                                             :full-name-encode "cljs.core/unchecked-negate-int",
                                             :source {:code "(defn unchecked-negate-int [x]\n  (cljs.core/unchecked-negate-int x))",
                                                      :title "Function code",
                                                      :repo "clojurescript",
                                                      :tag "r1.12.38",
                                                      :filename "src/main/cljs/cljs/core.cljs",
                                                      :lines [2859
                                                              2860]},
                                             :extra-sources [{:code "(core/defmacro ^::ana/numeric unchecked-negate-int\n  ([x] `(- ~x)))",
                                                              :title "Macro code",
                                                              :repo "clojurescript",
                                                              :tag "r1.12.38",
                                                              :filename "src/main/clojure/cljs/core.cljc",
                                                              :lines [1107
                                                                      1108]}],
                                             :full-name "cljs.core/unchecked-negate-int"},
           "cljs.core/bit-or" {:ns "cljs.core",
                               :name "bit-or",
                               :signature ["[x y]" "[x y & more]"],
                               :name-encode "bit-or",
                               :history [["+" "0.0-927"]],
                               :type "function/macro",
                               :full-name-encode "cljs.core/bit-or",
                               :source {:code "(defn bit-or\n  ([x y] (cljs.core/bit-or x y))\n  ([x y & more]\n     (reduce bit-or (cljs.core/bit-or x y) more)))",
                                        :title "Function code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [2949 2953]},
                               :extra-sources [{:code "(core/defmacro ^::ana/numeric bit-or\n  ([x y] (core/list 'js* \"(~{} | ~{})\" x y))\n  ([x y & more] `(bit-or (bit-or ~x ~y) ~@more)))",
                                                :title "Macro code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/clojure/cljs/core.cljc",
                                                :lines [1207 1209]}],
                               :full-name "cljs.core/bit-or",
                               :docstring "Bitwise or"},
           "cljs.core/nfirst" {:ns "cljs.core",
                               :name "nfirst",
                               :signature ["[coll]"],
                               :name-encode "nfirst",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/nfirst",
                               :source {:code "(defn nfirst\n  [coll]\n  (next (first coll)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [1805 1808]},
                               :full-name "cljs.core/nfirst",
                               :docstring "Same as (next (first x))"},
           "cljs.core/keep" {:ns "cljs.core",
                             :name "keep",
                             :signature ["[f]" "[f coll]"],
                             :name-encode "keep",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/keep",
                             :source {:code "(defn keep\n  ([f]\n   (fn [rf]\n     (fn\n       ([] (rf))\n       ([result] (rf result))\n       ([result input]\n          (let [v (f input)]\n            (if (nil? v)\n              result\n              (rf result v)))))))\n  ([f coll]\n   (lazy-seq\n    (when-let [s (seq coll)]\n      (if (chunked-seq? s)\n        (let [c (chunk-first s)\n              size (count c)\n              b (chunk-buffer size)]\n          (dotimes [i size]\n            (let [x (f (-nth c i))]\n              (when-not (nil? x)\n                (chunk-append b x))))\n          (chunk-cons (chunk b) (keep f (chunk-rest s))))\n        (let [x (f (first s))]\n          (if (nil? x)\n            (keep f (rest s))\n            (cons x (keep f (rest s))))))))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [4485 4514]},
                             :full-name "cljs.core/keep",
                             :docstring "Returns a lazy sequence of the non-nil results of (f item). Note,\nthis means false return values will be included.  f must be free of\nside-effects.  Returns a transducer when no collection is provided."},
           "cljs.core/take" {:ns "cljs.core",
                             :name "take",
                             :signature ["[n]" "[n coll]"],
                             :name-encode "take",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/take",
                             :source {:code "(defn take\n  ([n]\n   {:pre [(number? n)]}\n     (fn [rf]\n       (let [na (volatile! n)]\n         (fn\n           ([] (rf))\n           ([result] (rf result))\n           ([result input]\n              (let [n @na\n                    nn (vswap! na dec)\n                    result (if (pos? n)\n                             (rf result input)\n                             result)]\n                (if (not (pos? nn))\n                  (ensure-reduced result)\n                  result)))))))\n  ([n coll]\n   {:pre [(number? n)]}\n     (lazy-seq\n       (when (pos? n)\n         (when-let [s (seq coll)]\n           (cons (first s) (take (dec n) (rest s))))))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [4855 4880]},
                             :full-name "cljs.core/take",
                             :docstring "Returns a lazy sequence of the first n items in coll, or all items if\nthere are fewer than n.  Returns a stateful transducer when\nno collection is provided."},
           "cljs.core/unchecked-get" {:ns "cljs.core",
                                      :name "unchecked-get",
                                      :signature ["[obj key]"],
                                      :name-encode "unchecked-get",
                                      :history [["+" "1.9.854"]],
                                      :type "macro",
                                      :full-name-encode "cljs.core/unchecked-get",
                                      :source {:code "(core/defmacro unchecked-get\n  [obj key]\n  (core/list 'js* \"(~{}[~{}])\" obj key))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/clojure/cljs/core.cljc",
                                               :lines [1046 1051]},
                                      :full-name "cljs.core/unchecked-get",
                                      :docstring "INTERNAL. Compiles to JavaScript property access using bracket notation. Does\nnot distinguish between object and array types and not subject to compiler\nstatic analysis."},
           "cljs.core/PersistentHashSet.EMPTY" {:ns "cljs.core",
                                                :name "PersistentHashSet.EMPTY",
                                                :name-encode "PersistentHashSetDOTEMPTY",
                                                :history [["+"
                                                           "0.0-1211"]],
                                                :parent-type "PersistentHashSet",
                                                :type "var",
                                                :full-name-encode "cljs.core/PersistentHashSetDOTEMPTY",
                                                :source {:code "(set! (.-EMPTY PersistentHashSet)\n  (PersistentHashSet. nil (.-EMPTY PersistentArrayMap) empty-unordered-hash))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1.12.38",
                                                         :filename "src/main/cljs/cljs/core.cljs",
                                                         :lines [9471
                                                                 9472]},
                                                :full-name "cljs.core/PersistentHashSet.EMPTY"},
           "cljs.core/cond" {:ns "cljs.core",
                             :name "cond",
                             :signature ["[& clauses]"],
                             :name-encode "cond",
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :full-name-encode "cljs.core/cond",
                             :source {:code "(defmacro cond\n  {:added \"1.0\"}\n  [& clauses]\n    (when clauses\n      (list 'if (first clauses)\n            (if (next clauses)\n                (second clauses)\n                (throw (IllegalArgumentException.\n                         \"cond requires an even number of forms\")))\n            (cons 'clojure.core/cond (next (next clauses))))))",
                                      :title "Source code",
                                      :repo "clojure",
                                      :tag "clojure-1.10.0",
                                      :filename "src/clj/clojure/core.clj",
                                      :lines [574 587]},
                             :full-name "cljs.core/cond",
                             :docstring "Takes a set of test/expr pairs. It evaluates each test one at a\ntime.  If a test returns logical true, cond evaluates and returns\nthe value of the corresponding expr and doesn't evaluate any of the\nother tests or exprs. (cond) returns nil."},
           "cljs.spec/unform" {:ns "cljs.spec",
                               :name "unform",
                               :signature ["[spec x]"],
                               :name-encode "unform",
                               :history [["+" "1.9.75"]
                                         ["-" "1.9.542"]],
                               :type "function",
                               :full-name-encode "cljs.spec/unform",
                               :source {:code "(defn unform\n  [spec x]\n  (unform* (specize spec) x))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.9.521",
                                        :filename "src/main/cljs/cljs/spec.cljs",
                                        :lines [155 160]},
                               :full-name "cljs.spec/unform",
                               :docstring "Given a spec and a value created by or compliant with a call to\n'conform' with the same spec, returns a value with all conform\n destructuring undone.",
                               :removed {:in "1.9.542",
                                         :last-seen "1.9.521"}},
           "cljs.spec.test.alpha/instrumentable-syms" {:ns "cljs.spec.test.alpha",
                                                       :name "instrumentable-syms",
                                                       :signature ["[]"
                                                                   "[opts]"],
                                                       :name-encode "instrumentable-syms",
                                                       :history [["+"
                                                                  "1.9.542"]],
                                                       :type "function",
                                                       :full-name-encode "cljs.spec.test.alpha/instrumentable-syms",
                                                       :source {:code "(defn instrumentable-syms\n  ([] (instrumentable-syms nil))\n  ([opts]\n   (assert (every? ident? (keys (:gen opts))) \"instrument :gen expects ident keys\")\n   (reduce into #{} [(filter fn-spec-name? (keys (s/registry)))\n                     (keys (:spec opts))\n                     (:stub opts)\n                     (keys (:replace opts))])))",
                                                                :title "Source code",
                                                                :repo "clojurescript",
                                                                :tag "r1.12.38",
                                                                :filename "src/main/cljs/cljs/spec/test/alpha.cljs",
                                                                :lines [188
                                                                        197]},
                                                       :full-name "cljs.spec.test.alpha/instrumentable-syms",
                                                       :docstring "Given an opts map as per instrument, returns the set of syms\nthat can be instrumented."},
           "cljs.core/bit-and" {:ns "cljs.core",
                                :name "bit-and",
                                :signature ["[x y]" "[x y & more]"],
                                :name-encode "bit-and",
                                :history [["+" "0.0-927"]],
                                :type "function/macro",
                                :full-name-encode "cljs.core/bit-and",
                                :source {:code "(defn bit-and\n  ([x y] (cljs.core/bit-and x y))\n  ([x y & more]\n     (reduce bit-and (cljs.core/bit-and x y) more)))",
                                         :title "Function code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [2943 2947]},
                                :extra-sources [{:code "(core/defmacro ^::ana/numeric bit-and\n  ([x y] (core/list 'js* \"(~{} & ~{})\" x y))\n  ([x y & more] `(bit-and (bit-and ~x ~y) ~@more)))",
                                                 :title "Macro code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/clojure/cljs/core.cljc",
                                                 :lines [1198 1200]}],
                                :full-name "cljs.core/bit-and",
                                :docstring "Bitwise and"},
           "cljs.core/MetaFn" {:protocols #{"IFn"
                                            "IMeta"
                                            "IWithMeta"
                                            "Fn"},
                               :ns "cljs.core",
                               :name "MetaFn",
                               :signature ["[afn meta]"],
                               :name-encode "MetaFn",
                               :history [["+" "0.0-2234"]],
                               :type "type",
                               :full-name-encode "cljs.core/MetaFn",
                               :source {:code "(deftype MetaFn [afn meta]\n  IMeta\n  (-meta [_] meta)\n  IWithMeta\n  (-with-meta [_ new-meta]\n    (MetaFn. afn new-meta))\n  Fn\n  IFn\n  (-invoke [_]\n    (afn))\n  (-invoke [_ a]\n    (afn a))\n  (-invoke [_ a b]\n    (afn a b))\n  (-invoke [_ a b c]\n    (afn a b c))\n  (-invoke [_ a b c d]\n    (afn a b c d))\n  (-invoke [_ a b c d e]\n    (afn a b c d e))\n  (-invoke [_ a b c d e f]\n    (afn a b c d e f))\n  (-invoke [_ a b c d e f g]\n    (afn a b c d e f g))\n  (-invoke [_ a b c d e f g h]\n    (afn a b c d e f g h))\n  (-invoke [_ a b c d e f g h i]\n    (afn a b c d e f g h i))\n  (-invoke [_ a b c d e f g h i j]\n    (afn a b c d e f g h i j))\n  (-invoke [_ a b c d e f g h i j k]\n    (afn a b c d e f g h i j k))\n  (-invoke [_ a b c d e f g h i j k l]\n    (afn a b c d e f g h i j k l))\n  (-invoke [_ a b c d e f g h i j k l m]\n    (afn a b c d e f g h i j k l m))\n  (-invoke [_ a b c d e f g h i j k l m n]\n    (afn a b c d e f g h i j k l m n))\n  (-invoke [_ a b c d e f g h i j k l m n o]\n    (afn a b c d e f g h i j k l m n o))\n  (-invoke [_ a b c d e f g h i j k l m n o p]\n    (afn a b c d e f g h i j k l m n o p))\n  (-invoke [_ a b c d e f g h i j k l m n o p q]\n    (afn a b c d e f g h i j k l m n o p q))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r]\n    (afn a b c d e f g h i j k l m n o p q r))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r s]\n    (afn a b c d e f g h i j k l m n o p q r s))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r s t]\n    (afn a b c d e f g h i j k l m n o p q r s t))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r s t rest]\n    (apply afn a b c d e f g h i j k l m n o p q r s t rest)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [2074 2125]},
                               :full-name "cljs.core/MetaFn"},
           "cljs.core/ObjMap.fromObject" {:ns "cljs.core",
                                          :name "ObjMap.fromObject",
                                          :signature ["[ks obj]"],
                                          :name-encode "ObjMapDOTfromObject",
                                          :history [["+" "0.0-927"]],
                                          :parent-type "ObjMap",
                                          :type "function",
                                          :full-name-encode "cljs.core/ObjMapDOTfromObject",
                                          :source {:code "(set! (.-fromObject ObjMap) (fn [ks obj] (ObjMap. nil ks obj 0 nil)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/cljs/cljs/core.cljs",
                                                   :lines [6672]},
                                          :full-name "cljs.core/ObjMap.fromObject"},
           "cljs.core/PersistentArrayMap" {:protocols #{"IFn"
                                                        "ISeqable"
                                                        "IMap"
                                                        "IMeta"
                                                        "IWithMeta"
                                                        "IKVReduce"
                                                        "IEditableCollection"
                                                        "IEmptyableCollection"
                                                        "ICounted"
                                                        "IReduce"
                                                        "ILookup"
                                                        "ICollection"
                                                        "IHash"
                                                        "IDrop"
                                                        "IPrintWithWriter"
                                                        "IIterable"
                                                        "IAssociative"
                                                        "IFind"
                                                        "IEquiv"
                                                        "ICloneable"},
                                           :ns "cljs.core",
                                           :name "PersistentArrayMap",
                                           :signature ["[meta cnt arr __hash]"],
                                           :name-encode "PersistentArrayMap",
                                           :history [["+" "0.0-1211"]],
                                           :type "type",
                                           :full-name-encode "cljs.core/PersistentArrayMap",
                                           :source {:code "(deftype PersistentArrayMap [meta cnt arr ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (keys [coll]\n    (es6-iterator (keys coll)))\n  (entries [coll]\n    (es6-entries-iterator (seq coll)))\n  (values [coll]\n    (es6-iterator (vals coll)))\n  (has [coll k]\n    (contains? coll k))\n  (get [coll k not-found]\n    (-lookup coll k not-found))\n  (forEach [coll f]\n    (doseq [[k v] coll]\n      (f v k)))\n\n  ICloneable\n  (-clone [_] (PersistentArrayMap. meta cnt arr __hash))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (PersistentArrayMap. new-meta cnt arr __hash)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (loop [ret coll es (seq entry)]\n        (if (nil? es)\n          ret\n          (let [e (first es)]\n            (if (vector? e)\n              (recur (-assoc ret (-nth e 0) (-nth e 1))\n                     (next es))\n              (throw (js/Error. \"conj on a map takes map entries or seqables of map entries\"))))))))\n\n  IEmptyableCollection\n  (-empty [coll] (-with-meta (.-EMPTY PersistentArrayMap) meta))\n\n  IEquiv\n  (-equiv [coll other]\n    (if (and (map? other) (not (record? other)))\n      (let [alen (alength arr)\n            ^not-native other other]\n        (if (== cnt (-count other))\n          (loop [i 0]\n            (if (< i alen)\n              (let [v (-lookup other (aget arr i) lookup-sentinel)]\n                (if-not (identical? v lookup-sentinel)\n                  (if (= (aget arr (inc i)) v)\n                    (recur (+ i 2))\n                    false)\n                  false))\n              true))\n          false))\n      false))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-unordered-coll __hash))\n\n  IIterable\n  (-iterator [this]\n    (PersistentArrayMapIterator. arr 0 (* cnt 2)))\n\n  ISeqable\n  (-seq [coll]\n    (persistent-array-map-seq arr 0 nil))\n\n  IDrop\n  (-drop [coll n]\n    (when-some [s (-seq coll)]\n      (-drop s n)))\n\n  ICounted\n  (-count [coll] cnt)\n\n  ILookup\n  (-lookup [coll k]\n    (-lookup coll k nil))\n\n  (-lookup [coll k not-found]\n    (let [idx (array-map-index-of coll k)]\n      (if (== idx -1)\n        not-found\n        (aget arr (inc idx)))))\n\n  IAssociative\n  (-assoc [coll k v]\n    (let [idx (array-map-index-of coll k)]\n      (cond\n        (== idx -1)\n        (if (< cnt (.-HASHMAP-THRESHOLD PersistentArrayMap))\n          (let [arr (array-map-extend-kv coll k v)]\n            (PersistentArrayMap. meta (inc cnt) arr nil))\n          (-> (into (.-EMPTY PersistentHashMap) coll)\n            (-assoc k v)\n            (-with-meta meta)))\n\n        (identical? v (aget arr (inc idx)))\n        coll\n\n        :else\n        (let [arr (doto (aclone arr)\n                    (aset (inc idx) v))]\n          (PersistentArrayMap. meta cnt arr nil)))))\n\n  (-contains-key? [coll k]\n    (not (== (array-map-index-of coll k) -1)))\n\n  IFind\n  (-find [coll k]\n    (let [idx (array-map-index-of coll k)]\n      (when-not (== idx -1)\n        (MapEntry. (aget arr idx) (aget arr (inc idx)) nil))))\n\n  IMap\n  (-dissoc [coll k]\n    (let [idx (array-map-index-of coll k)]\n      (if (>= idx 0)\n        (let [len     (alength arr)\n              new-len (- len 2)]\n          (if (zero? new-len)\n            (-empty coll)\n            (let [new-arr (make-array new-len)]\n              (loop [s 0 d 0]\n                (cond\n                  (>= s len) (PersistentArrayMap. meta (dec cnt) new-arr nil)\n                  (= k (aget arr s)) (recur (+ s 2) d)\n                  :else (do (aset new-arr d (aget arr s))\n                            (aset new-arr (inc d) (aget arr (inc s)))\n                            (recur (+ s 2) (+ d 2))))))))\n        coll)))\n\n  IKVReduce\n  (-kv-reduce [coll f init]\n    (let [len (alength arr)]\n      (loop [i 0 init init]\n        (if (< i len)\n          (let [init (f init (aget arr i) (aget arr (inc i)))]\n            (if (reduced? init)\n              @init\n              (recur (+ i 2) init)))\n          init))))\n\n  IReduce\n  (-reduce [coll f]\n    (iter-reduce coll f))\n  (-reduce [coll f start]\n    (iter-reduce coll f start))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found))\n\n  IEditableCollection\n  (-as-transient [coll]\n    (TransientArrayMap. (js-obj) (alength arr) (aclone arr))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/cljs/cljs/core.cljs",
                                                    :lines [6975 7143]},
                                           :full-name "cljs.core/PersistentArrayMap"},
           "cljs.core/HashMapIter" {:ns "cljs.core",
                                    :name "HashMapIter",
                                    :signature ["[nil-val root-iter seen]"],
                                    :name-encode "HashMapIter",
                                    :history [["+" "1.7.28"]],
                                    :type "type",
                                    :full-name-encode "cljs.core/HashMapIter",
                                    :source {:code "(deftype HashMapIter [nil-val root-iter ^:mutable seen]\n  Object\n  (hasNext [_]\n    (or (not ^boolean seen) ^boolean (.hasNext root-iter)))\n  (next [_]\n    (if-not ^boolean seen\n      (do\n        (set! seen true)\n        (MapEntry. nil nil-val nil))\n      (.next root-iter)))\n  (remove [_] (js/Error. \"Unsupported operation\")))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [8075 8085]},
                                    :full-name "cljs.core/HashMapIter"},
           "clojure.browser.event/unique-event-id" {:ns "clojure.browser.event",
                                                    :name "unique-event-id",
                                                    :signature ["[event-type]"],
                                                    :name-encode "unique-event-id",
                                                    :history [["+"
                                                               "0.0-927"]],
                                                    :type "function",
                                                    :full-name-encode "clojure.browser.event/unique-event-id",
                                                    :source {:code "(defn unique-event-id [event-type])",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r1.12.38",
                                                             :filename "src/main/cljs/clojure/browser/event.cljs",
                                                             :lines [94]},
                                                    :full-name "clojure.browser.event/unique-event-id"},
           "cljs.core/vswap!" {:ns "cljs.core",
                               :name "vswap!",
                               :signature ["[vol f & args]"],
                               :name-encode "vswapBANG",
                               :history [["+" "0.0-2496"]],
                               :type "macro",
                               :full-name-encode "cljs.core/vswapBANG",
                               :source {:code "(core/defmacro vswap!\n  [vol f & args]\n  `(-vreset! ~vol (~f (-deref ~vol) ~@args)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/clojure/cljs/core.cljc",
                                        :lines [2978 2983]},
                               :full-name "cljs.core/vswap!",
                               :docstring "Non-atomically swaps the value of the volatile as if:\n(apply f current-value-of-vol args). Returns the value that\nwas swapped in."},
           "cljs.spec/def" {:ns "cljs.spec",
                            :name "def",
                            :signature ["[k spec-form]"],
                            :name-encode "def",
                            :history [["+" "1.9.14"] ["-" "1.9.542"]],
                            :type "macro",
                            :full-name-encode "cljs.spec/def",
                            :source {:code "(defmacro def\n  [k spec-form]\n  (let [k    (if (symbol? k) (ns-qualify &env k) k)\n        form (res &env spec-form)]\n    (swap! registry-ref assoc k form)\n    `(def-impl '~k '~form ~spec-form)))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.9.521",
                                     :filename "src/main/cljs/cljs/spec.cljc",
                                     :lines [57 65]},
                            :full-name "cljs.spec/def",
                            :docstring "Given a namespace-qualified keyword or resolveable symbol k, and a spec,\nspec-name, predicate or regex-op makes an entry in the registry mapping k to\nthe spec",
                            :removed {:in "1.9.542",
                                      :last-seen "1.9.521"}},
           "closure-warnings/debugger-statement-present" {:ns "closure-warnings",
                                                          :name "debugger-statement-present",
                                                          :name-encode "debugger-statement-present",
                                                          :type "warning",
                                                          :full-name-encode "closure-warnings/debugger-statement-present",
                                                          :full-name "closure-warnings/debugger-statement-present",
                                                          :history [["+"
                                                                     "0.0-2120"]]},
           "cljs.repl.browser/ext->mime-type" {:ns "cljs.repl.browser",
                                               :name "ext->mime-type",
                                               :name-encode "ext-GTmime-type",
                                               :type "var",
                                               :full-name-encode "cljs.repl.browser/ext-GTmime-type",
                                               :source {:code "(def ext->mime-type\n  {\".html\" \"text/html\"\n   \".css\" \"text/css\"\n\n   \".ttf\" \"font/ttf\"\n   \".otf\" \"font/otf\"\n\n   \".pdf\" \"application/pdf\"\n\n   \".jpg\" \"image/jpeg\"\n   \".png\" \"image/png\"\n   \".gif\" \"image/gif\"\n   \".svg\" \"image/svg+xml\"\n\n   \".mp4\" \"video/mp4\"\n   \".m4a\" \"audio/m4a\"\n   \".m4v\" \"video/mp4\"\n   \".mp3\" \"audio/mpeg\"\n   \".mpeg\" \"video/mpeg\"\n   \".wav\" \"audio/wav\"\n\n   \".js\" \"text/javascript\"\n   \".json\" \"application/json\"\n   \".clj\" \"text/x-clojure\"\n   \".cljs\" \"text/x-clojure\"\n   \".cljc\" \"text/x-clojure\"\n   \".edn\" \"text/x-clojure\"\n   \".map\" \"application/json\"\n   \".wasm\" \"application/wasm\"})",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.12.38",
                                                        :filename "src/main/clojure/cljs/repl/browser.clj",
                                                        :lines [36 64]},
                                               :full-name "cljs.repl.browser/ext->mime-type",
                                               :history [["+"
                                                          "0.0-3291"]]},
           "cljs.repl.node/lock" {:ns "cljs.repl.node",
                                  :name "lock",
                                  :name-encode "lock",
                                  :type "var",
                                  :full-name-encode "cljs.repl.node/lock",
                                  :source {:code "(def lock (Object.))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/clojure/cljs/repl/node.clj",
                                           :lines [26]},
                                  :full-name "cljs.repl.node/lock",
                                  :history [["+" "1.10.217"]]},
           "cljs.core/ObjMap.HASHMAP_THRESHOLD" {:ns "cljs.core",
                                                 :name "ObjMap.HASHMAP_THRESHOLD",
                                                 :name-encode "ObjMapDOTHASHMAP_THRESHOLD",
                                                 :history [["+"
                                                            "0.0-1211"]],
                                                 :parent-type "ObjMap",
                                                 :type "var",
                                                 :full-name-encode "cljs.core/ObjMapDOTHASHMAP_THRESHOLD",
                                                 :source {:code "(set! (.-HASHMAP_THRESHOLD ObjMap) 8)",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r1.12.38",
                                                          :filename "src/main/cljs/cljs/core.cljs",
                                                          :lines [6670]},
                                                 :full-name "cljs.core/ObjMap.HASHMAP_THRESHOLD"},
           "repl-options/watch" {:ns "repl-options",
                                 :name "watch",
                                 :name-encode "watch",
                                 :type "option",
                                 :full-name-encode "repl-options/watch",
                                 :full-name "repl-options/watch",
                                 :history [["+" "0.0-2850"]]},
           "clojure.set/project" {:ns "clojure.set",
                                  :name "project",
                                  :signature ["[xrel ks]"],
                                  :name-encode "project",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.set/project",
                                  :source {:code "(defn project\n  [xrel ks]\n    (set (map #(select-keys % ks) xrel)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/clojure/set.cljs",
                                           :lines [67 70]},
                                  :full-name "clojure.set/project",
                                  :docstring "Returns a rel of the elements of xrel with only the keys in ks"},
           "cljs.core/int" {:ns "cljs.core",
                            :name "int",
                            :signature ["[x]"],
                            :name-encode "int",
                            :history [["+" "0.0-1211"]],
                            :type "function/macro",
                            :full-name-encode "cljs.core/int",
                            :source {:code "(defn int\n  [x]\n  (bit-or x 0))",
                                     :title "Function code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [2886 2889]},
                            :extra-sources [{:code "(core/defmacro ^::ana/numeric int [x]\n  `(bit-or ~x 0))",
                                             :title "Macro code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/clojure/cljs/core.cljc",
                                             :lines [1211 1212]}],
                            :full-name "cljs.core/int",
                            :docstring "Coerce to int by stripping decimal places."},
           "cljs.repl/js-src->cljs-src" {:return-type File,
                                         :ns "cljs.repl",
                                         :name "js-src->cljs-src",
                                         :signature ["[f]"],
                                         :name-encode "js-src-GTcljs-src",
                                         :history [["+" "0.0-2814"]],
                                         :type "function",
                                         :full-name-encode "cljs.repl/js-src-GTcljs-src",
                                         :source {:code "(defn ^File js-src->cljs-src\n  [f]\n  (let [f (io/file f)\n        dir (.getParentFile f)\n        base-name (string/replace (.getName f) \".js\" \"\")\n        cljsf (io/file dir (str base-name \".cljs\"))]\n    (if (.exists cljsf)\n      cljsf\n      (let [cljcf (io/file dir (str base-name \".cljc\"))]\n        (if (.exists cljcf)\n          cljcf)))))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/clojure/cljs/repl.cljc",
                                                  :lines [261 273]},
                                         :full-name "cljs.repl/js-src->cljs-src",
                                         :docstring "Map a JavaScript output file back to the original ClojureScript source\nfile (.cljs or .cljc)."},
           "clojure.reflect/macroexpand" {:ns "clojure.reflect",
                                          :name "macroexpand",
                                          :signature ["[form]"],
                                          :name-encode "macroexpand",
                                          :history [["+" "0.0-1503"]],
                                          :type "function",
                                          :full-name-encode "clojure.reflect/macroexpand",
                                          :source {:code "(defn macroexpand\n  [form]\n  (query-reflection (str \"macroform=\" (js/encodeURIComponent (str form))) println))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/cljs/clojure/reflect.cljs",
                                                   :lines [41 45]},
                                          :full-name "clojure.reflect/macroexpand",
                                          :docstring "Queries the reflection api with a quoted macro form, then calls the\ncallback function with the macroexpanded form, as a string."},
           "syntax/quote" {:syntax-equiv {:edn-url nil, :clj-url nil},
                           :ns "syntax",
                           :name "quote",
                           :name-encode "quote",
                           :history [["+" "0.0-1853"]],
                           :type "syntax",
                           :full-name-encode "syntax/quote",
                           :extra-sources ({:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                            :title "Reader table",
                                            :repo "tools.reader",
                                            :tag "v1.3.6",
                                            :filename "src/main/clojure/clojure/tools/reader.clj",
                                            :lines [788 807]}),
                           :full-name "syntax/quote"},
           "cljs.core/Empty" {:ns "cljs.core",
                              :name "Empty",
                              :signature ["[]"],
                              :name-encode "Empty",
                              :history [["+" "1.9.562"]],
                              :type "type",
                              :full-name-encode "cljs.core/Empty",
                              :source {:code "(deftype Empty []\n  Object\n  (add [this o]\n    (Single. o))\n  (remove [this]\n    (throw (js/Error. (str \"Removing object from empty buffer\"))))\n  (isEmpty [this]\n    true)\n  (toString [this]\n    \"Empty\"))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [4201 4210]},
                              :full-name "cljs.core/Empty"},
           "cljs.pprint/with-pretty-writer" {:ns "cljs.pprint",
                                             :name "with-pretty-writer",
                                             :signature ["[base-writer & body]"],
                                             :name-encode "with-pretty-writer",
                                             :history [["+"
                                                        "0.0-3255"]],
                                             :type "macro",
                                             :full-name-encode "cljs.pprint/with-pretty-writer",
                                             :source {:code "(defmacro with-pretty-writer [base-writer & body]\n  `(let [base-writer# ~base-writer\n         new-writer# (not (pretty-writer? base-writer#))]\n     (cljs.core/binding [cljs.core/*out* (if new-writer#\n                         (make-pretty-writer base-writer# *print-right-margin* *print-miser-width*)\n                         base-writer#)]\n       ~@body\n       (-ppflush cljs.core/*out*))))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.12.38",
                                                      :filename "src/main/cljs/cljs/pprint.cljc",
                                                      :lines [18 25]},
                                             :full-name "cljs.pprint/with-pretty-writer"},
           "clojure.string/trim-newline" {:return-type string,
                                          :ns "clojure.string",
                                          :name "trim-newline",
                                          :signature ["[s]"],
                                          :name-encode "trim-newline",
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "clojure.string/trim-newline",
                                          :source {:code "(defn ^string trim-newline\n  [s]\n  (loop [index (.-length s)]\n    (if (zero? index)\n      \"\"\n      (let [ch (get s (dec index))]\n        (if (or (identical? \\newline ch)\n                (identical? \\return ch))\n          (recur (dec index))\n          (.substring s 0 index))))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/cljs/clojure/string.cljs",
                                                   :lines [212 223]},
                                          :full-name "clojure.string/trim-newline",
                                          :docstring "Removes all trailing newline \\n or return \\r characters from\nstring.  Similar to Perl's chomp."},
           "cljs.repl.reflect/parse-param" {:ns "cljs.repl.reflect",
                                            :name "parse-param",
                                            :signature ["[path]"],
                                            :name-encode "parse-param",
                                            :history [["+" "0.0-1503"]],
                                            :type "function",
                                            :full-name-encode "cljs.repl.reflect/parse-param",
                                            :source {:code "(defn parse-param\n  [path]\n  (-> (str/split path #\"\\?\")\n      (last)\n      (str/split #\"=\")))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/clojure/cljs/repl/reflect.clj",
                                                     :lines [53 59]},
                                            :full-name "cljs.repl.reflect/parse-param",
                                            :docstring "Parses the query parameter of a path of the form \"/reflect?var=foo\"\ninto the vector [\"var\" \"foo\"]."},
           "cljs.spec/nilable" {:ns "cljs.spec",
                                :name "nilable",
                                :signature ["[pred]"],
                                :name-encode "nilable",
                                :history [["+" "1.9.14"]
                                          ["-" "1.9.542"]],
                                :type "macro",
                                :full-name-encode "cljs.spec/nilable",
                                :source {:code "(defmacro nilable\n  [pred]\n  (let [pf (res &env pred)]\n    `(nilable-impl '~pf ~pred nil)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.9.521",
                                         :filename "src/main/cljs/cljs/spec.cljc",
                                         :lines [456 460]},
                                :full-name "cljs.spec/nilable",
                                :docstring "returns a spec that accepts nil and values satisfiying pred",
                                :removed {:in "1.9.542",
                                          :last-seen "1.9.521"}},
           "cljs.math/acos" {:return-type number,
                             :ns "cljs.math",
                             :name "acos",
                             :signature ["[a]"],
                             :name-encode "acos",
                             :history [["+" "1.11.50"]],
                             :type "function",
                             :full-name-encode "cljs.math/acos",
                             :source {:code "(defn ^number acos\n  {:added \"1.11.10\"}\n  [a] (Math/acos a))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/math.cljs",
                                      :lines [111 116]},
                             :full-name "cljs.math/acos",
                             :docstring "Returns the arc cosine of a, in the range 0.0 to pi.\nIf a is ##NaN or |a|>1 => ##NaN\nSee: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/acos"},
           "cljs.repl/print-mapped-stacktrace" {:ns "cljs.repl",
                                                :name "print-mapped-stacktrace",
                                                :signature ["[stacktrace]"
                                                            "[stacktrace opts]"],
                                                :name-encode "print-mapped-stacktrace",
                                                :history [["+"
                                                           "0.0-2814"]],
                                                :type "function",
                                                :full-name-encode "cljs.repl/print-mapped-stacktrace",
                                                :source {:code "(defn print-mapped-stacktrace\n  ([stacktrace] (print-mapped-stacktrace stacktrace *repl-opts*))\n  ([stacktrace opts]\n   (doseq [{:keys [function file line column]}\n           (mapped-stacktrace stacktrace opts)]\n     (err-out\n       (println \"\\t\"\n         (str (when function (str function \" \"))\n           \"(\" (file-display file opts) (when line (str \":\" line)) (when column (str \":\" column)) \")\"))))))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1.12.38",
                                                         :filename "src/main/clojure/cljs/repl.cljc",
                                                         :lines [405
                                                                 415]},
                                                :full-name "cljs.repl/print-mapped-stacktrace",
                                                :docstring "Given a vector representing the canonicalized JavaScript stacktrace\nprint the ClojureScript stacktrace. See mapped-stacktrace."},
           "cljs.spec.alpha/explain-printer" {:ns "cljs.spec.alpha",
                                              :name "explain-printer",
                                              :signature ["[ed]"],
                                              :name-encode "explain-printer",
                                              :history [["+"
                                                         "1.9.542"]],
                                              :type "function",
                                              :full-name-encode "cljs.spec.alpha/explain-printer",
                                              :source {:code "(defn explain-printer\n  [ed]\n  (if ed\n    (let [problems (->> (::problems ed)\n                     (sort-by #(- (count (:in %))))\n                     (sort-by #(- (count (:path %)))))]\n      (print\n        (with-out-str\n          ;;(prn {:ed ed})\n          (doseq [{:keys [path pred val reason via in] :as prob} problems]\n            (pr val)\n            (print \" - failed: \")\n            (if reason (print reason) (pr (abbrev pred)))\n            (when-not (empty? in)\n              (print (str \" in: \" (pr-str in))))\n            (when-not (empty? path)\n              (print (str \" at: \" (pr-str path))))\n            (when-not (empty? via)\n              (print (str \" spec: \" (pr-str (last via)))))\n            (doseq [[k v] prob]\n              (when-not (#{:path :pred :val :reason :via :in} k)\n                (print \"\\n\\t\" (pr-str k) \" \")\n                (pr v)))\n            (newline)))))\n    (println \"Success!\")))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.12.38",
                                                       :filename "src/main/cljs/cljs/spec/alpha.cljs",
                                                       :lines [235
                                                               260]},
                                              :full-name "cljs.spec.alpha/explain-printer",
                                              :docstring "Default printer for explain-data. nil indicates a successful validation."},
           "cljs.spec.gen.alpha/char-alpha" {:ns "cljs.spec.gen.alpha",
                                             :name "char-alpha",
                                             :signature ["[& args]"],
                                             :name-encode "char-alpha",
                                             :history [["+" "1.9.542"]],
                                             :type "function",
                                             :full-name-encode "cljs.spec.gen.alpha/char-alpha",
                                             :source {:code "(lazy-prims any any-printable boolean char char-alpha char-alphanumeric char-ascii double\n  int keyword keyword-ns large-integer ratio simple-type simple-type-printable\n  string string-ascii string-alphanumeric symbol symbol-ns uuid)",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.12.38",
                                                      :filename "src/main/cljs/cljs/spec/gen/alpha.cljs",
                                                      :lines [74 76]},
                                             :full-name "cljs.spec.gen.alpha/char-alpha",
                                             :docstring "Fn returning clojure.test.check.generators/char-alpha"},
           "cljs.repl/ns->input" {:ns "cljs.repl",
                                  :name "ns->input",
                                  :signature ["[ns opts]"],
                                  :name-encode "ns-GTinput",
                                  :history [["+" "1.10.191"]],
                                  :type "function",
                                  :full-name-encode "cljs.repl/ns-GTinput",
                                  :source {:code "(defn ns->input [ns opts]\n  (or (some-> (util/ns->source ns) (ana/parse-ns opts))\n      (some-> (get-in @env/*compiler* [:js-dependency-index (str ns)]) add-url)\n      (some-> (deps/find-classpath-lib ns))\n      (throw\n        (ex-info (str ns \" does not exist\")\n          {::error :invalid-ns}))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/clojure/cljs/repl.cljc",
                                           :lines [198 204]},
                                  :full-name "cljs.repl/ns->input"},
           "cljs.core/pr-seq-writer" {:ns "cljs.core",
                                      :name "pr-seq-writer",
                                      :signature ["[objs writer opts]"],
                                      :name-encode "pr-seq-writer",
                                      :history [["+" "0.0-1503"]],
                                      :type "function",
                                      :full-name-encode "cljs.core/pr-seq-writer",
                                      :source {:code "(defn pr-seq-writer [objs writer opts]\n  (pr-writer (first objs) writer opts)\n  (doseq [obj (next objs)]\n    (-write writer \" \")\n    (pr-writer obj writer opts)))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [10600 10604]},
                                      :full-name "cljs.core/pr-seq-writer"},
           "cljs.repl/analyze-source" {:ns "cljs.repl",
                                       :name "analyze-source",
                                       :signature ["[src-dir]"
                                                   "[src-dir opts]"],
                                       :name-encode "analyze-source",
                                       :history [["+" "0.0-1503"]],
                                       :type "function",
                                       :full-name-encode "cljs.repl/analyze-source",
                                       :source {:code "(defn analyze-source\n  ([src-dir] (analyze-source src-dir nil))\n  ([src-dir opts]\n    (if-let [src-dir (and (not (empty? src-dir))\n                       (File. src-dir))]\n      (doseq [file (comp/cljs-files-in src-dir)]\n        (ana/analyze-file (str \"file://\" (.getAbsolutePath file)) opts)))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/clojure/cljs/repl.cljc",
                                                :lines [795 803]},
                                       :full-name "cljs.repl/analyze-source",
                                       :docstring "Given a source directory, analyzes all .cljs files. Used to populate\n(:cljs.analyzer/namespaces compiler-env) so as to support code reflection."},
           "cljs.repl.browser/stop-server" {:ns "cljs.repl.browser",
                                            :name "stop-server",
                                            :signature ["[]"],
                                            :name-encode "stop-server",
                                            :history [["+" "0.0-927"]
                                                      ["-" "0.0-1503"]],
                                            :type "function",
                                            :full-name-encode "cljs.repl.browser/stop-server",
                                            :source {:code "(defn stop-server\n  []\n  (.close (:socket @server-state)))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1450",
                                                     :filename "src/clj/cljs/repl/browser.clj",
                                                     :lines [272 274]},
                                            :full-name "cljs.repl.browser/stop-server",
                                            :removed {:in "0.0-1503",
                                                      :last-seen "0.0-1450"}},
           "compiler-options/dump-core" {:ns "compiler-options",
                                         :name "dump-core",
                                         :name-encode "dump-core",
                                         :type "option",
                                         :full-name-encode "compiler-options/dump-core",
                                         :full-name "compiler-options/dump-core",
                                         :history [["+" "1.7.10"]]},
           "cljs.spec.alpha/nonconforming" {:ns "cljs.spec.alpha",
                                            :name "nonconforming",
                                            :signature ["[spec]"],
                                            :name-encode "nonconforming",
                                            :history [["+" "1.9.542"]],
                                            :type "function",
                                            :full-name-encode "cljs.spec.alpha/nonconforming",
                                            :source {:code "(defn nonconforming\n  [spec]\n  (let [spec (delay (specize spec))]\n    (reify\n     Specize\n     (specize* [s] s)\n     (specize* [s _] s)\n\n     Spec\n     (conform* [_ x] (let [ret (conform* @spec x)]\n                       (if (invalid? ret)\n                         ::invalid\n                         x)))\n     (unform* [_ x] (unform* @spec x))\n     (explain* [_ path via in x] (explain* @spec path via in x))\n     (gen* [_ overrides path rmap] (gen* @spec overrides path rmap))\n     (with-gen* [_ gfn] (nonconforming (with-gen* @spec gfn)))\n     (describe* [_] `(nonconforming ~(describe* @spec))))))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/cljs/cljs/spec/alpha.cljs",
                                                     :lines [1389
                                                             1408]},
                                            :full-name "cljs.spec.alpha/nonconforming",
                                            :docstring "takes a spec and returns a spec that has the same properties except\n'conform' returns the original (not the conformed) value. Note, will specize regex ops."},
           "cljs.core/chunk-cons" {:ns "cljs.core",
                                   :name "chunk-cons",
                                   :signature ["[chunk rest]"],
                                   :name-encode "chunk-cons",
                                   :history [["+" "0.0-1424"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/chunk-cons",
                                   :source {:code "(defn chunk-cons [chunk rest]\n  (if (zero? (-count chunk))\n    rest\n    (ChunkedCons. chunk rest nil nil)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [3711 3714]},
                                   :full-name "cljs.core/chunk-cons"},
           "cljs.spec/alt" {:ns "cljs.spec",
                            :name "alt",
                            :signature ["[& key-pred-forms]"],
                            :name-encode "alt",
                            :history [["+" "1.9.14"] ["-" "1.9.542"]],
                            :type "macro",
                            :full-name-encode "cljs.spec/alt",
                            :source {:code "(defmacro alt\n  [& key-pred-forms]\n  (let [pairs (partition 2 key-pred-forms)\n        keys (mapv first pairs)\n        pred-forms (mapv second pairs)\n        pf (mapv #(res &env %) pred-forms)]\n    (clojure.core/assert (clojure.core/and (even? (count key-pred-forms)) (every? keyword? keys)) \"alt expects k1 p1 k2 p2..., where ks are keywords\")\n    `(alt-impl ~keys ~pred-forms '~pf)))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.9.521",
                                     :filename "src/main/cljs/cljs/spec.cljc",
                                     :lines [319 334]},
                            :full-name "cljs.spec/alt",
                            :docstring "Takes key+pred pairs, e.g.\n\n(s/alt :even even? :small #(< % 42))\n\nReturns a regex op that returns a map entry containing the key of the\nfirst matching pred and the corresponding value. Thus the\n'key' and 'val' functions can be used to refer generically to the\ncomponents of the tagged return.",
                            :removed {:in "1.9.542",
                                      :last-seen "1.9.521"}},
           "syntax/namespace" {:syntax-equiv {:edn-url nil,
                                              :clj-url nil},
                               :ns "syntax",
                               :name "namespace",
                               :name-encode "namespace",
                               :type "special character",
                               :full-name-encode "syntax/namespace",
                               :full-name "syntax/namespace",
                               :history [["+" "0.0-927"]]},
           "clojure.zip/insert-left" {:ns "clojure.zip",
                                      :name "insert-left",
                                      :signature ["[loc item]"],
                                      :name-encode "insert-left",
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "clojure.zip/insert-left",
                                      :source {:code "(defn insert-left\n  [loc item]\n    (let [[node {l :l :as path}] loc]\n      (if (nil? path)\n        (throw \"Insert at top\")\n        (with-meta [node (assoc path :l (conj l item) :changed? true)] (meta loc)))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/clojure/zip.cljs",
                                               :lines [165 172]},
                                      :full-name "clojure.zip/insert-left",
                                      :docstring "Inserts the item as the left sibling of the node at this loc,\nwithout moving"},
           "cljs.core/*print-level*" {:ns "cljs.core",
                                      :name "*print-level*",
                                      :name-encode "STARprint-levelSTAR",
                                      :history [["+" "0.0-2120"]],
                                      :type "dynamic var",
                                      :full-name-encode "cljs.core/STARprint-levelSTAR",
                                      :source {:code "(def\n  ^{:dynamic true\n    :jsdoc [\"@type {null|number}\"]}\n  *print-level* nil)",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [160 171]},
                                      :full-name "cljs.core/*print-level*",
                                      :docstring "*print-level* controls how many levels deep the printer will\nprint nested objects. If it is bound to logical false, there is no\nlimit. Otherwise, it must be bound to an integer indicating the maximum\nlevel to print. Each argument to print is at level 0; if an argument is a\ncollection, its items are at level 1; and so on. If an object is a\ncollection and is at a level greater than or equal to the value bound to\n*print-level*, the printer prints '#' to represent it. The root binding\nis nil indicating no limit."},
           "cljs.spec.gen.alpha/char" {:ns "cljs.spec.gen.alpha",
                                       :name "char",
                                       :signature ["[& args]"],
                                       :name-encode "char",
                                       :history [["+" "1.9.542"]],
                                       :type "function",
                                       :full-name-encode "cljs.spec.gen.alpha/char",
                                       :source {:code "(lazy-prims any any-printable boolean char char-alpha char-alphanumeric char-ascii double\n  int keyword keyword-ns large-integer ratio simple-type simple-type-printable\n  string string-ascii string-alphanumeric symbol symbol-ns uuid)",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/spec/gen/alpha.cljs",
                                                :lines [74 76]},
                                       :full-name "cljs.spec.gen.alpha/char",
                                       :docstring "Fn returning clojure.test.check.generators/char"},
           "cljs.core/truth_" {:ns "cljs.core",
                               :name "truth_",
                               :signature ["[x]"],
                               :name-encode "truth_",
                               :history [["+" "0.0-1798"]
                                         ["-" "1.9.493"]
                                         ["+" "1.9.494"]],
                               :type "macro",
                               :full-name-encode "cljs.core/truth_",
                               :source {:code "(core/defmacro truth_ [x]\n  (core/assert (core/symbol? x) \"x is substituted twice\")\n  (core/list 'js* \"(~{} != null && ~{} !== false)\" x x))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/clojure/cljs/core.cljc",
                                        :lines [919 921]},
                               :full-name "cljs.core/truth_"},
           "cljs.repl/*repl-opts*" {:ns "cljs.repl",
                                    :name "*repl-opts*",
                                    :name-encode "STARrepl-optsSTAR",
                                    :type "dynamic var",
                                    :full-name-encode "cljs.repl/STARrepl-optsSTAR",
                                    :source {:code "(def ^:dynamic *repl-opts* nil)",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/clojure/cljs/repl.cljc",
                                             :lines [35]},
                                    :full-name "cljs.repl/*repl-opts*",
                                    :history [["+" "0.0-2911"]]},
           "cljs.core/true?" {:return-type boolean,
                              :ns "cljs.core",
                              :name "true?",
                              :signature ["[x]"],
                              :name-encode "trueQMARK",
                              :history [["+" "0.0-927"]],
                              :type "function/macro",
                              :full-name-encode "cljs.core/trueQMARK",
                              :source {:code "(defn ^boolean true?\n  [x] (cljs.core/true? x))",
                                       :title "Function code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [2286 2288]},
                              :extra-sources [{:code "(core/defmacro true? [x]\n  (bool-expr (core/list 'js* \"~{} === true\" x)))",
                                               :title "Macro code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/clojure/cljs/core.cljc",
                                               :lines [964 965]}],
                              :full-name "cljs.core/true?",
                              :docstring "Returns true if x is the value true, false otherwise."},
           "cljs.core/unchecked-substract-int" {:return-type number,
                                                :ns "cljs.core",
                                                :name "unchecked-substract-int",
                                                :signature ["[x]"
                                                            "[x y]"
                                                            "[x y & more]"],
                                                :name-encode "unchecked-substract-int",
                                                :history [["+"
                                                           "0.0-1798"]
                                                          ["-"
                                                           "0.0-2277"]],
                                                :type "function",
                                                :full-name-encode "cljs.core/unchecked-substract-int",
                                                :source {:code "(defn ^number unchecked-substract-int\n  ([x] (cljs.core/unchecked-subtract-int x))\n  ([x y] (cljs.core/unchecked-subtract-int x y))\n  ([x y & more] (reduce unchecked-substract-int (cljs.core/unchecked-subtract-int x y) more)))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r2268",
                                                         :filename "src/cljs/cljs/core.cljs",
                                                         :lines [1812
                                                                 1817]},
                                                :full-name "cljs.core/unchecked-substract-int",
                                                :docstring "If no ys are supplied, returns the negation of x, else subtracts\nthe ys from x and returns the result.",
                                                :removed {:in "0.0-2277",
                                                          :last-seen "0.0-2268"}},
           "clojure.browser.net/xpc-connection" {:ns "clojure.browser.net",
                                                 :name "xpc-connection",
                                                 :signature ["[]"
                                                             "[config]"],
                                                 :name-encode "xpc-connection",
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.browser.net/xpc-connection",
                                                 :source {:code "(defn xpc-connection\n  ([]\n     (when-let [config (.getParameterValue\n                        (Uri. (.-href (.-location js/window)))\n                        \"xpc\")]\n       (CrossPageChannel. (gjson/parse config))))\n  ([config]\n     (CrossPageChannel.\n      (reduce (fn [sum [k v]]\n                (if-let [field (get xpc-config-fields k)]\n                  (doto sum (gobj/set field v))\n                  sum))\n              (js-obj)\n              config))))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r1.12.38",
                                                          :filename "src/main/cljs/clojure/browser/net.cljs",
                                                          :lines [117
                                                                  139]},
                                                 :full-name "clojure.browser.net/xpc-connection",
                                                 :docstring "When passed with a config hash-map, returns a parent\nCrossPageChannel object. Keys in the config hash map are downcased\nversions of the goog.net.xpc.CfgFields enum keys,\ne.g. goog.net.xpc.CfgFields.PEER_URI becomes :peer_uri in the config\nhash.\n\nWhen passed with no args, creates a child CrossPageChannel object,\nand the config is automatically taken from the URL param 'xpc', as\nper the CrossPageChannel API."},
           "cljs.core/infinite?" {:ns "cljs.core",
                                  :name "infinite?",
                                  :signature ["[x]"],
                                  :name-encode "infiniteQMARK",
                                  :history [["+" "1.9.293"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/infiniteQMARK",
                                  :source {:code "(defn infinite?\n  [x]\n  (or (identical? x js/Number.POSITIVE_INFINITY)\n      (identical? x js/Number.NEGATIVE_INFINITY)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [2404 2408]},
                                  :full-name "cljs.core/infinite?",
                                  :docstring "Returns true for Infinity and -Infinity values."},
           "cljs.spec.test/instrument-1" {:ns "cljs.spec.test",
                                          :name "instrument-1",
                                          :signature ["[[quote s] opts]"],
                                          :name-encode "instrument-1",
                                          :history [["+" "1.9.183"]
                                                    ["-" "1.9.542"]],
                                          :type "macro",
                                          :full-name-encode "cljs.spec.test/instrument-1",
                                          :source {:code "(defmacro instrument-1\n  [[quote s] opts]\n  (when-let [v (ana-api/resolve &env s)]\n    (swap! instrumented-vars conj (:name v))\n    `(let [checked# (instrument-1* ~s (var ~s) ~opts)]\n       (when checked# (set! ~s checked#))\n       '~(:name v))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.9.521",
                                                   :filename "src/main/cljs/cljs/spec/test.cljc",
                                                   :lines [35 41]},
                                          :full-name "cljs.spec.test/instrument-1",
                                          :removed {:in "1.9.542",
                                                    :last-seen "1.9.521"}},
           "cljs.core/ES6EntriesIterator" {:ns "cljs.core",
                                           :name "ES6EntriesIterator",
                                           :signature ["[s]"],
                                           :name-encode "ES6EntriesIterator",
                                           :history [["+" "0.0-2371"]],
                                           :type "type",
                                           :full-name-encode "cljs.core/ES6EntriesIterator",
                                           :source {:code "(deftype ES6EntriesIterator [^:mutable s]\n  Object\n  (next [_]\n    (if-not (nil? s)\n      (let [[k v] (first s)]\n        (set! s (next s))\n        #js {:value #js [k v] :done false})\n      #js {:value nil :done true})))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/cljs/cljs/core.cljs",
                                                    :lines [6687 6694]},
                                           :full-name "cljs.core/ES6EntriesIterator"},
           "cljs.core/not" {:ns "cljs.core",
                            :name "not",
                            :signature ["[x]"],
                            :name-encode "not",
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core/not",
                            :source {:code "(defn not\n  [x]\n  (cond\n    (nil? x) true\n    (false? x) true\n    :else false))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [258 264]},
                            :full-name "cljs.core/not",
                            :docstring "Returns true if x is logical false, false otherwise."},
           "cljs.core/js-obj" {:ns "cljs.core",
                               :name "js-obj",
                               :signature ["[]" "[& keyvals]"],
                               :name-encode "js-obj",
                               :history [["+" "0.0-927"]],
                               :type "function/macro",
                               :full-name-encode "cljs.core/js-obj",
                               :source {:code "(defn js-obj\n  ([]\n     (cljs.core/js-obj))\n  ([& keyvals]\n     (apply gobject/create keyvals)))",
                                        :title "Function code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [2243 2249]},
                               :extra-sources [{:code "(core/defmacro js-obj [& rest]\n  (core/let [sym-or-str? (core/fn [x] (core/or (core/symbol? x) (core/string? x)))\n             filter-on-keys (core/fn [f coll]\n                              (core/->> coll\n                                (filter (core/fn [[k _]] (f k)))\n                                (into {})))\n             kvs (into {} (map vec (partition 2 rest)))\n             sym-pairs (filter-on-keys core/symbol? kvs)\n             expr->local (zipmap\n                           (filter (complement sym-or-str?) (keys kvs))\n                           (repeatedly gensym))\n             obj (gensym \"obj\")]\n    (if (empty? rest)\n      (js-obj* '())\n      `(let [~@(apply concat (clojure.set/map-invert expr->local))\n            ~obj ~(js-obj* (filter-on-keys core/string? kvs))]\n        ~@(map (core/fn [[k v]] `(unchecked-set ~obj ~k ~v)) sym-pairs)\n        ~@(map (core/fn [[k v]] `(unchecked-set ~obj ~v ~(core/get kvs k))) expr->local)\n        ~obj))))",
                                                :title "Macro code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/clojure/cljs/core.cljc",
                                                :lines [2685 2703]}],
                               :full-name "cljs.core/js-obj",
                               :docstring "Create JavaSript object from an even number arguments representing\ninterleaved keys and values."},
           "compiler-options/parallel-build" {:ns "compiler-options",
                                              :name "parallel-build",
                                              :name-encode "parallel-build",
                                              :type "option",
                                              :full-name-encode "compiler-options/parallel-build",
                                              :full-name "compiler-options/parallel-build",
                                              :history [["+"
                                                         "1.7.189"]]},
           "cljs.core/complement" {:ns "cljs.core",
                                   :name "complement",
                                   :signature ["[f]"],
                                   :name-encode "complement",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/complement",
                                   :source {:code "(defn complement\n  [f]\n  (fn\n    ([] (not (f)))\n    ([x] (not (f x)))\n    ([x y] (not (f x y)))\n    ([x y & zs] (not (apply f x y zs)))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [4360 4368]},
                                   :full-name "cljs.core/complement",
                                   :docstring "Takes a fn f and returns a fn that takes the same arguments as f,\nhas the same effects, if any, and returns the opposite truth value."},
           "cljs.core/spread" {:ns "cljs.core",
                               :name "spread",
                               :signature ["[arglist]"],
                               :name-encode "spread",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/spread",
                               :source {:code "(defn spread\n  [arglist]\n  (when-not (nil? arglist)\n    (let [n (next arglist)]\n      (if (nil? n)\n        (seq (first arglist))\n        (cons (first arglist)\n              (spread n))))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [3856 3863]},
                               :full-name "cljs.core/spread"},
           "cljs.core/unchecked-double" {:return-type number,
                                         :ns "cljs.core",
                                         :name "unchecked-double",
                                         :signature ["[x]"],
                                         :name-encode "unchecked-double",
                                         :history [["+" "0.0-1798"]],
                                         :type "function/macro",
                                         :full-name-encode "cljs.core/unchecked-double",
                                         :source {:code "(defn ^number unchecked-double [x] x)",
                                                  :title "Function code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/cljs/cljs/core.cljs",
                                                  :lines [2803]},
                                         :extra-sources [{:code "(core/defmacro unchecked-double [x] x)",
                                                          :title "Macro code",
                                                          :repo "clojurescript",
                                                          :tag "r1.12.38",
                                                          :filename "src/main/clojure/cljs/core.cljc",
                                                          :lines [1075]}],
                                         :full-name "cljs.core/unchecked-double"},
           "closure-warnings/undefined-names" {:ns "closure-warnings",
                                               :name "undefined-names",
                                               :name-encode "undefined-names",
                                               :type "warning",
                                               :full-name-encode "closure-warnings/undefined-names",
                                               :full-name "closure-warnings/undefined-names",
                                               :history [["+"
                                                          "0.0-2120"]
                                                         ["-"
                                                          "1.10.891"]],
                                               :removed {:in "1.10.891",
                                                         :last-seen "1.10.879"}},
           "closure-warnings/analyzer-checks" {:ns "closure-warnings",
                                               :name "analyzer-checks",
                                               :name-encode "analyzer-checks",
                                               :type "warning",
                                               :full-name-encode "closure-warnings/analyzer-checks",
                                               :full-name "closure-warnings/analyzer-checks",
                                               :history [["+"
                                                          "1.9.473"]]},
           "cljs.repl.browser/chrome-st-el->frame" {:ns "cljs.repl.browser",
                                                    :name "chrome-st-el->frame",
                                                    :signature ["[repl-env st-el opts]"],
                                                    :name-encode "chrome-st-el-GTframe",
                                                    :history [["+"
                                                               "0.0-3053"]
                                                              ["-"
                                                               "1.7.10"]],
                                                    :type "function",
                                                    :full-name-encode "cljs.repl.browser/chrome-st-el-GTframe",
                                                    :source {:code "(defn chrome-st-el->frame\n  [repl-env st-el opts]\n  (let [xs (-> st-el\n             (string/replace #\"\\s+at\\s+\" \"\")\n             (string/split #\"\\s+\"))\n        [function flc] (if (== (count xs) 1)\n                         [nil (first xs)]\n                         [(first xs) (last xs)])\n        [file line column] (parse-file-line-column flc)]\n    (if (and file function line column)\n      {:file (parse-file repl-env file opts)\n       :function (string/replace function #\"Object\\.\" \"\")\n       :line line\n       :column column}\n      (when-not (string/blank? function)\n        {:file nil\n         :function (string/replace function #\"Object\\.\" \"\")\n         :line nil\n         :column nil}))))",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r3308",
                                                             :filename "src/main/clojure/cljs/repl/browser.clj",
                                                             :lines [248
                                                                     266]},
                                                    :full-name "cljs.repl.browser/chrome-st-el->frame",
                                                    :removed {:in "1.7.10",
                                                              :last-seen "0.0-3308"}},
           "cljs.core/keyword" {:ns "cljs.core",
                                :name "keyword",
                                :signature ["[name]" "[ns name]"],
                                :name-encode "keyword",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/keyword",
                                :source {:code "(defn keyword\n  ([name] (cond\n            (keyword? name) name\n            (symbol? name) (Keyword.\n                             (cljs.core/namespace name)\n                             (cljs.core/name name) (.-str name) nil)\n            (= \"/\" name) (Keyword. nil name name nil)\n            (string? name) (let [parts (.split name \"/\")]\n                             (if (== (alength parts) 2)\n                               (Keyword. (aget parts 0) (aget parts 1) name nil)\n                               (Keyword. nil (aget parts 0) name nil)))))\n  ([ns name]\n   (let [ns   (cond\n                (keyword? ns) (cljs.core/name ns)\n                (symbol? ns)  (cljs.core/name ns)\n                :else ns)\n         name (cond\n                (keyword? name) (cljs.core/name name)\n                (symbol? name) (cljs.core/name name)\n                :else name)]\n     (Keyword. ns name (str (when ns (str ns \"/\")) name) nil))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [3482 3504]},
                                :full-name "cljs.core/keyword",
                                :docstring "Returns a Keyword with the given namespace and name.  Do not use :\nin the keyword strings, it will be added automatically."},
           "cljs.spec.impl.gen/simple-type-printable" {:ns "cljs.spec.impl.gen",
                                                       :name "simple-type-printable",
                                                       :signature ["[& args]"],
                                                       :name-encode "simple-type-printable",
                                                       :history [["+"
                                                                  "1.9.14"]
                                                                 ["-"
                                                                  "1.9.542"]],
                                                       :type "function",
                                                       :full-name-encode "cljs.spec.impl.gen/simple-type-printable",
                                                       :source {:code "(lazy-prims any any-printable boolean char char-alpha char-alphanumeric char-ascii double\n  int keyword keyword-ns large-integer ratio simple-type simple-type-printable\n  string string-ascii string-alphanumeric symbol symbol-ns uuid)",
                                                                :title "Source code",
                                                                :repo "clojurescript",
                                                                :tag "r1.9.521",
                                                                :filename "src/main/cljs/cljs/spec/impl/gen.cljs",
                                                                :lines [73
                                                                        75]},
                                                       :full-name "cljs.spec.impl.gen/simple-type-printable",
                                                       :docstring "Fn returning clojure.test.check.generators/simple-type-printable",
                                                       :removed {:in "1.9.542",
                                                                 :last-seen "1.9.521"}},
           "syntax/keyword-qualify" {:syntax-equiv {:edn-url nil,
                                                    :clj-url nil},
                                     :ns "syntax",
                                     :name "keyword-qualify",
                                     :name-encode "keyword-qualify",
                                     :history [["+" "0.0-1853"]],
                                     :type "syntax",
                                     :full-name-encode "syntax/keyword-qualify",
                                     :extra-sources ({:code "(defn- read-keyword\n  [reader initch opts pending-forms]\n  (let [ch (read-char reader)]\n    (if-not (whitespace? ch)\n      (let [token (read-token reader :keyword ch)\n            s (parse-symbol token)]\n        (if s\n          (let [^String ns (s 0)\n                ^String name (s 1)]\n            (if (identical? \\: (nth token 0))\n              (if ns\n                (let [ns (resolve-alias (symbol (subs ns 1)))]\n                  (if ns\n                    (keyword (str ns) name)\n                    (err/throw-invalid reader :keyword (str \\: token))))\n                (keyword (str *ns*) (subs name 1)))\n              (keyword ns name)))\n          (err/throw-invalid reader :keyword (str \\: token))))\n      (err/throw-single-colon reader))))",
                                                      :title "Reader code",
                                                      :repo "tools.reader",
                                                      :tag "v1.3.6",
                                                      :filename "src/main/clojure/clojure/tools/reader.clj",
                                                      :lines [344 362]}
                                                     {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                                      :title "Reader table",
                                                      :repo "tools.reader",
                                                      :tag "v1.3.6",
                                                      :filename "src/main/clojure/clojure/tools/reader.clj",
                                                      :lines [788 807]}),
                                     :full-name "syntax/keyword-qualify"},
           "cljs.core/sort" {:ns "cljs.core",
                             :name "sort",
                             :signature ["[coll]" "[comp coll]"],
                             :name-encode "sort",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/sort",
                             :source {:code "(defn sort\n  ([coll]\n   (sort compare coll))\n  ([comp coll]\n   (if (seq coll)\n     (let [a (to-array coll)]\n       ;; matching Clojure's stable sort, though docs don't promise it\n       (garray/stableSort a (fn->comparator comp))\n       (with-meta (seq a) (meta coll)))\n     ())))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [2516 2528]},
                             :full-name "cljs.core/sort",
                             :docstring "Returns a sorted sequence of the items in coll. Comp can be\nboolean-valued comparison function, or a -/0/+ valued comparator.\nComp defaults to compare."},
           "cljs.spec.test.alpha/instrument" {:ns "cljs.spec.test.alpha",
                                              :name "instrument",
                                              :signature ["[]"
                                                          "[xs]"
                                                          "[sym-or-syms opts]"],
                                              :name-encode "instrument",
                                              :history [["+"
                                                         "1.9.542"]],
                                              :type "macro",
                                              :full-name-encode "cljs.spec.test.alpha/instrument",
                                              :source {:code "(defmacro instrument\n  ([]\n   `(instrument ^::no-eval '[~@(#?(:clj  s/speced-vars\n                                   :cljs cljs.spec.alpha$macros/speced-vars))]))\n  ([xs]\n   `(instrument ~xs nil))\n  ([sym-or-syms opts]\n   (let [syms (sym-or-syms->syms (form->sym-or-syms sym-or-syms))\n         opts-sym (gensym \"opts\")]\n     `(let [~opts-sym ~opts]\n        (reduce\n          (fn [ret# [_# f#]]\n            (let [sym# (f#)]\n              (cond-> ret# sym# (conj sym#))))\n          []\n          (->> (zipmap '~syms\n                 [~@(map\n                      (fn [sym]\n                        `(fn [] (instrument-1 '~sym ~opts-sym)))\n                      syms)])\n            (filter #((instrumentable-syms ~opts-sym) (first %)))\n            (distinct-by first)))))))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.12.38",
                                                       :filename "src/main/cljs/cljs/spec/test/alpha.cljc",
                                                       :lines [109
                                                               167]},
                                              :full-name "cljs.spec.test.alpha/instrument",
                                              :docstring "Instruments the vars named by sym-or-syms, a symbol or collection\nof symbols, or all instrumentable vars if sym-or-syms is not\nspecified. If a symbol identifies a namespace then all symbols in that\nnamespace will be enumerated.\n\nIf a var has an :args fn-spec, sets the var's root binding to a\nfn that checks arg conformance (throwing an exception on failure)\nbefore delegating to the original fn.\n\nThe opts map can be used to override registered specs, and/or to\nreplace fn implementations entirely. Opts for symbols not included\nin sym-or-syms are ignored. This facilitates sharing a common\noptions map across many different calls to instrument.\n\nThe opts map may have the following keys:\n\n  :spec     a map from var-name symbols to override specs\n  :stub     a set of var-name symbols to be replaced by stubs\n  :gen      a map from spec names to generator overrides\n  :replace  a map from var-name symbols to replacement fns\n\n:spec overrides registered fn-specs with specs your provide. Use\n:spec overrides to provide specs for libraries that do not have\nthem, or to constrain your own use of a fn to a subset of its\nspec'ed contract.\n\n:stub replaces a fn with a stub that checks :args, then uses the\n:ret spec to generate a return value.\n\n:gen overrides are used only for :stub generation.\n\n:replace replaces a fn with a fn that checks args conformance, then\ninvokes the fn you provide, enabling arbitrary stubbing and mocking.\n\n:spec can be used in combination with :stub or :replace.\n\nReturns a collection of syms naming the vars instrumented."},
           "clojure.string/trim" {:return-type string,
                                  :ns "clojure.string",
                                  :name "trim",
                                  :signature ["[s]"],
                                  :name-encode "trim",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.string/trim",
                                  :source {:code "(defn ^string trim\n  [s]\n  (gstring/trim s))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/clojure/string.cljs",
                                           :lines [197 200]},
                                  :full-name "clojure.string/trim",
                                  :docstring "Removes whitespace from both ends of string."},
           "closure-warnings/message-descriptions" {:ns "closure-warnings",
                                                    :name "message-descriptions",
                                                    :name-encode "message-descriptions",
                                                    :type "warning",
                                                    :full-name-encode "closure-warnings/message-descriptions",
                                                    :full-name "closure-warnings/message-descriptions",
                                                    :history [["+"
                                                               "1.9.473"]]},
           "cljs.core/meta" {:ns "cljs.core",
                             :name "meta",
                             :signature ["[o]"],
                             :name-encode "meta",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/meta",
                             :source {:code "(defn meta\n  [o]\n  (when (and (not (nil? o))\n             (satisfies? IMeta o))\n    (-meta o)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [2136 2141]},
                             :full-name "cljs.core/meta",
                             :docstring "Returns the metadata of obj, returns nil if there is no metadata."},
           "cljs.repl/IParseError" {:ns "cljs.repl",
                                    :name "IParseError",
                                    :name-encode "IParseError",
                                    :history [["+" "0.0-3030"]],
                                    :type "protocol",
                                    :full-name-encode "cljs.repl/IParseError",
                                    :source {:code "(defprotocol IParseError\n  (-parse-error [repl-env error build-options]\n    \"Given the original JavaScript error return the error to actually\n     use.\"))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/clojure/cljs/repl.cljc",
                                             :lines [144 147]},
                                    :methods [{:name "-parse-error",
                                               :signature ["[repl-env error build-options]"],
                                               :docstring "Given the original JavaScript error return the error to actually\n     use."}],
                                    :full-name "cljs.repl/IParseError"},
           "cljs.core/*command-line-args*" {:ns "cljs.core",
                                            :name "*command-line-args*",
                                            :name-encode "STARcommand-line-argsSTAR",
                                            :history [["+" "1.9.854"]],
                                            :type "var",
                                            :full-name-encode "cljs.core/STARcommand-line-argsSTAR",
                                            :source {:code "(def\n  *command-line-args* nil)",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/cljs/cljs/core.cljs",
                                                     :lines [312 315]},
                                            :full-name "cljs.core/*command-line-args*",
                                            :docstring "A sequence of the supplied command line arguments, or nil if\nnone were supplied"},
           "cljs.core/ifind?" {:ns "cljs.core",
                               :name "ifind?",
                               :signature ["[x]"],
                               :name-encode "ifindQMARK",
                               :history [["+" "1.9.518"]],
                               :type "function",
                               :full-name-encode "cljs.core/ifindQMARK",
                               :source {:code "(defn ifind?\n [x] (satisfies? IFind x))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [2204 2206]},
                               :full-name "cljs.core/ifind?",
                               :docstring "Returns true if coll implements IFind"},
           "cljs.spec.impl.gen/delay" {:ns "cljs.spec.impl.gen",
                                       :name "delay",
                                       :signature ["[& body]"],
                                       :name-encode "delay",
                                       :history [["+" "1.9.14"]
                                                 ["-" "1.9.542"]],
                                       :type "macro",
                                       :full-name-encode "cljs.spec.impl.gen/delay",
                                       :source {:code "(defmacro delay\n  [& body]\n  `(delay-impl (c/delay ~@body)))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.9.521",
                                                :filename "src/main/cljs/cljs/spec/impl/gen.cljc",
                                                :lines [32 37]},
                                       :full-name "cljs.spec.impl.gen/delay",
                                       :docstring "given body that returns a generator, returns a\ngenerator that delegates to that, but delays\ncreation until used.",
                                       :removed {:in "1.9.542",
                                                 :last-seen "1.9.521"}},
           "clojure.core.reducers/monoid" {:ns "clojure.core.reducers",
                                           :name "monoid",
                                           :signature ["[op ctor]"],
                                           :name-encode "monoid",
                                           :history [["+" "0.0-1236"]],
                                           :type "function",
                                           :full-name-encode "clojure.core.reducers/monoid",
                                           :source {:code "(defn monoid\n  [op ctor]\n  (fn m\n    ([] (ctor))\n    ([a b] (op a b))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/cljs/clojure/core/reducers.cljs",
                                                    :lines [242 249]},
                                           :full-name "clojure.core.reducers/monoid",
                                           :docstring "Builds a combining fn out of the supplied operator and identity\nconstructor. op must be associative and ctor called with no args\nmust return an identity value for it."},
           "cljs.core/Repeat" {:protocols #{"ISeqable"
                                            "IMeta"
                                            "IWithMeta"
                                            "IEmptyableCollection"
                                            "IPending"
                                            "IReduce"
                                            "ISequential"
                                            "ISeq"
                                            "ICollection"
                                            "IHash"
                                            "IDrop"
                                            "IPrintWithWriter"
                                            "INext"
                                            "IEquiv"},
                               :ns "cljs.core",
                               :name "Repeat",
                               :signature ["[meta count val next __hash]"],
                               :name-encode "Repeat",
                               :history [["+" "1.10.63"]],
                               :type "type",
                               :full-name-encode "cljs.core/Repeat",
                               :source {:code "(deftype Repeat [meta count val ^:mutable next ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x count))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IPending\n  (-realized? [coll] false)\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (Repeat. new-meta count val next nil)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll]\n    val)\n  (-rest [coll]\n    (if (nil? next)\n      (if (> count 1)\n        (do\n          (set! next (Repeat. nil (dec count) val nil nil))\n          next)\n        (if (== -1 count)\n          coll\n          ()))\n      next))\n\n  INext\n  (-next [coll]\n    (if (nil? next)\n      (if (> count 1)\n        (do\n          (set! next (Repeat. nil (dec count) val nil nil))\n          next)\n        (if (== -1 count)\n          coll\n          nil))\n      next))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IDrop\n  (-drop [coll n]\n    (if (== count -1)\n      coll\n      (let [dropped-count (- count n)]\n        (when (pos? dropped-count)\n          (Repeat. nil dropped-count val nil nil)))))\n\n  IEmptyableCollection\n  (-empty [coll] (.-EMPTY List))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  ISequential\n  ISeqable\n  (-seq [coll] coll)\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IReduce\n  (-reduce [coll f]\n    (if (== count -1)\n      (loop [ret (f val val)]\n        (if (reduced? ret)\n          @ret\n          (recur (f ret val))))\n      (loop [i 1 ret val]\n        (if (< i count)\n          (let [ret (f ret val)]\n            (if (reduced? ret)\n              @ret\n              (recur (inc i) ret)))\n          ret))))\n  (-reduce [coll f start]\n    (if (== count -1)\n      (loop [ret (f start val)]\n        (if (reduced? ret)\n          @ret\n          (recur (f ret val))))\n      (loop [i 0 ret start]\n        (if (< i count)\n          (let [ret (f ret val)]\n            (if (reduced? ret)\n              @ret\n              (recur (inc i) ret)))\n          ret)))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [5024 5127]},
                               :full-name "cljs.core/Repeat"},
           "cljs.core/time" {:ns "cljs.core",
                             :name "time",
                             :signature ["[expr]"],
                             :name-encode "time",
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :full-name-encode "cljs.core/time",
                             :source {:code "(core/defmacro time\n  [expr]\n  `(let [start# (system-time)\n         ret# ~expr]\n     (prn (cljs.core/str \"Elapsed time: \"\n            (.toFixed (- (system-time) start#) 6)\n            \" msecs\"))\n     ret#))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/clojure/cljs/core.cljc",
                                      :lines [2814 2822]},
                             :full-name "cljs.core/time",
                             :docstring "Evaluates expr and prints the time it took. Returns the value of expr."},
           "cljs.core/boolean" {:ns "cljs.core",
                                :name "boolean",
                                :signature ["[x]"],
                                :name-encode "boolean",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/boolean",
                                :source {:code "(defn boolean\n  [x]\n  (cond\n    (nil? x) false\n    (false? x) false\n    :else true))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [2316 2322]},
                                :full-name "cljs.core/boolean",
                                :docstring "Coerce to boolean"},
           "cljs.reader/read-token" {:ns "cljs.reader",
                                     :name "read-token",
                                     :signature ["[rdr initch]"],
                                     :name-encode "read-token",
                                     :history [["+" "0.0-927"]
                                               ["-" "1.9.854"]],
                                     :type "function",
                                     :full-name-encode "cljs.reader/read-token",
                                     :source {:code "(defn read-token\n  [rdr initch]\n  (loop [sb (StringBuffer. initch)\n         ch (read-char rdr)]\n    (if (or (nil? ch)\n            (whitespace? ch)\n            (macro-terminating? ch))\n      (do (unread rdr ch) (.toString sb))\n      (recur (do (.append sb ch) sb) (read-char rdr)))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.9.671",
                                              :filename "src/main/cljs/cljs/reader.cljs",
                                              :lines [80 88]},
                                     :full-name "cljs.reader/read-token",
                                     :removed {:in "1.9.854",
                                               :last-seen "1.9.671"}},
           "compiler-options/asset-path" {:ns "compiler-options",
                                          :name "asset-path",
                                          :name-encode "asset-path",
                                          :type "option",
                                          :full-name-encode "compiler-options/asset-path",
                                          :full-name "compiler-options/asset-path",
                                          :history [["+" "0.0-2727"]]},
           "cljs.core/update-in" {:ns "cljs.core",
                                  :name "update-in",
                                  :signature ["[m [k & ks] f]"
                                              "[m [k & ks] f a]"
                                              "[m [k & ks] f a b]"
                                              "[m [k & ks] f a b c]"
                                              "[m [k & ks] f a b c & args]"],
                                  :name-encode "update-in",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/update-in",
                                  :source {:code "(defn update-in\n  ([m [k & ks] f]\n   (if ks\n     (assoc m k (update-in (get m k) ks f))\n     (assoc m k (f (get m k)))))\n  ([m [k & ks] f a]\n   (if ks\n     (assoc m k (update-in (get m k) ks f a))\n     (assoc m k (f (get m k) a))))\n  ([m [k & ks] f a b]\n   (if ks\n     (assoc m k (update-in (get m k) ks f a b))\n     (assoc m k (f (get m k) a b))))\n  ([m [k & ks] f a b c]\n   (if ks\n     (assoc m k (update-in (get m k) ks f a b c))\n     (assoc m k (f (get m k) a b c))))\n  ([m [k & ks] f a b c & args]\n   (if ks\n     (assoc m k (apply update-in (get m k) ks f a b c args))\n     (assoc m k (apply f (get m k) a b c args)))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [5436 5461]},
                                  :full-name "cljs.core/update-in",
                                  :docstring "'Updates' a value in a nested associative structure, where ks is a\nsequence of keys and f is a function that will take the old value\nand any supplied args and return the new value, and returns a new\nnested structure.  If any levels do not exist, hash-maps will be\ncreated."},
           "cljs.spec.gen.alpha/ratio" {:ns "cljs.spec.gen.alpha",
                                        :name "ratio",
                                        :signature ["[& args]"],
                                        :name-encode "ratio",
                                        :history [["+" "1.9.542"]],
                                        :type "function",
                                        :full-name-encode "cljs.spec.gen.alpha/ratio",
                                        :source {:code "(lazy-prims any any-printable boolean char char-alpha char-alphanumeric char-ascii double\n  int keyword keyword-ns large-integer ratio simple-type simple-type-printable\n  string string-ascii string-alphanumeric symbol symbol-ns uuid)",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/cljs/cljs/spec/gen/alpha.cljs",
                                                 :lines [74 76]},
                                        :full-name "cljs.spec.gen.alpha/ratio",
                                        :docstring "Fn returning clojure.test.check.generators/ratio"},
           "cljs.core/map-indexed" {:ns "cljs.core",
                                    :name "map-indexed",
                                    :signature ["[f]" "[f coll]"],
                                    :name-encode "map-indexed",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/map-indexed",
                                    :source {:code "(defn map-indexed\n  ([f]\n    (fn [rf]\n      (let [i (volatile! -1)]\n        (fn\n          ([] (rf))\n          ([result] (rf result))\n          ([result input]\n            (rf result (f (vswap! i inc) input)))))))\n  ([f coll]\n    (letfn [(mapi [idx coll]\n              (lazy-seq\n                (when-let [s (seq coll)]\n                  (if (chunked-seq? s)\n                    (let [c (chunk-first s)\n                          size (count c)\n                          b (chunk-buffer size)]\n                      (dotimes [i size]\n                        (chunk-append b (f (+ idx i) (-nth c i))))\n                      (chunk-cons (chunk b) (mapi (+ idx size) (chunk-rest s))))\n                    (cons (f idx (first s)) (mapi (inc idx) (rest s)))))))]\n      (mapi 0 coll))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [4457 4483]},
                                    :full-name "cljs.core/map-indexed",
                                    :docstring "Returns a lazy sequence consisting of the result of applying f to 0\nand the first item of coll, followed by applying f to 1 and the second\nitem in coll, etc, until coll is exhausted. Thus function f should\naccept 2 arguments, index and item. Returns a stateful transducer when\nno collection is provided."},
           "cljs.core/IVolatile" {:ns "cljs.core",
                                  :name "IVolatile",
                                  :name-encode "IVolatile",
                                  :implementations #{"Volatile"},
                                  :history [["+" "0.0-2496"]],
                                  :type "protocol",
                                  :full-name-encode "cljs.core/IVolatile",
                                  :source {:code "(defprotocol IVolatile\n  (-vreset! [o new-value]\n    \"Sets the value of volatile o to new-value without regard for the\n     current value. Returns new-value.\"))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [878 882]},
                                  :methods [{:name "-vreset!",
                                             :signature ["[o new-value]"],
                                             :docstring "Sets the value of volatile o to new-value without regard for the\n     current value. Returns new-value."}],
                                  :full-name "cljs.core/IVolatile",
                                  :docstring "Protocol for adding volatile functionality."},
           "cljs.core/printf" {:ns "cljs.core",
                               :name "printf",
                               :signature ["[fmt & args]"],
                               :name-encode "printf",
                               :history [["+" "0.0-1443"]
                                         ["-" "0.0-1885"]],
                               :type "function",
                               :full-name-encode "cljs.core/printf",
                               :source {:code "(defn printf\n  [fmt & args]\n  (print (apply format fmt args)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1878",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [6758 6761]},
                               :full-name "cljs.core/printf",
                               :docstring "Prints formatted output, as per format",
                               :removed {:in "0.0-1885",
                                         :last-seen "0.0-1878"}},
           "clojure.core.reducers/map" {:ns "clojure.core.reducers",
                                        :name "map",
                                        :signature ["[f]" "[f coll]"],
                                        :name-encode "map",
                                        :history [["+" "0.0-1236"]],
                                        :type "function",
                                        :full-name-encode "clojure.core.reducers/map",
                                        :source {:code "(defcurried map\n  {}\n  [f coll]\n  (folder coll\n   (fn [f1]\n     (rfn [f1 k]\n          ([ret k v]\n             (f1 ret (f k v)))))))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/cljs/clojure/core/reducers.cljs",
                                                 :lines [96 104]},
                                        :full-name "clojure.core.reducers/map",
                                        :docstring "Applies f to every value in the reduction of coll. Foldable."},
           "cljs.spec.gen.alpha/simple-type" {:ns "cljs.spec.gen.alpha",
                                              :name "simple-type",
                                              :signature ["[& args]"],
                                              :name-encode "simple-type",
                                              :history [["+"
                                                         "1.9.542"]],
                                              :type "function",
                                              :full-name-encode "cljs.spec.gen.alpha/simple-type",
                                              :source {:code "(lazy-prims any any-printable boolean char char-alpha char-alphanumeric char-ascii double\n  int keyword keyword-ns large-integer ratio simple-type simple-type-printable\n  string string-ascii string-alphanumeric symbol symbol-ns uuid)",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.12.38",
                                                       :filename "src/main/cljs/cljs/spec/gen/alpha.cljs",
                                                       :lines [74 76]},
                                              :full-name "cljs.spec.gen.alpha/simple-type",
                                              :docstring "Fn returning clojure.test.check.generators/simple-type"},
           "cljs.core/IStack" {:ns "cljs.core",
                               :name "IStack",
                               :name-encode "IStack",
                               :implementations #{"Subvec"
                                                  "PersistentQueue"
                                                  "RedNode"
                                                  "EmptyList"
                                                  "BlackNode"
                                                  "PersistentVector"
                                                  "List"
                                                  "MapEntry"},
                               :history [["+" "0.0-927"]],
                               :type "protocol",
                               :full-name-encode "cljs.core/IStack",
                               :source {:code "(defprotocol IStack\n  (-peek [coll]\n    \"Returns the item from the top of the stack. Is used by cljs.core/peek.\")\n  (^clj -pop [coll]\n    \"Returns a new stack without the item on top of the stack. Is used\n     by cljs.core/pop.\"))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [675 683]},
                               :methods [{:name "-peek",
                                          :signature ["[coll]"],
                                          :docstring "Returns the item from the top of the stack. Is used by cljs.core/peek."}
                                         {:name "-pop",
                                          :signature ["[coll]"],
                                          :docstring "Returns a new stack without the item on top of the stack. Is used\n     by cljs.core/pop."}],
                               :full-name "cljs.core/IStack",
                               :docstring "Protocol for collections to provide access to their items as stacks. The top\n  of the stack should be accessed in the most efficient way for the different\n  data structures."},
           "cljs.spec.alpha/explain-data" {:ns "cljs.spec.alpha",
                                           :name "explain-data",
                                           :signature ["[spec x]"],
                                           :name-encode "explain-data",
                                           :history [["+" "1.9.542"]],
                                           :type "function",
                                           :full-name-encode "cljs.spec.alpha/explain-data",
                                           :source {:code "(defn explain-data\n  [spec x]\n  (explain-data* spec [] (if-let [name (spec-name spec)] [name] []) [] x))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/cljs/cljs/spec/alpha.cljs",
                                                    :lines [226 233]},
                                           :full-name "cljs.spec.alpha/explain-data",
                                           :docstring "Given a spec and a value x which ought to conform, returns nil if x\nconforms, else a map with at least the key ::problems whose value is\na collection of problem-maps, where problem-map has at least :path :pred and :val\nkeys describing the predicate and the value that failed at that\npath."},
           "cljs.spec.test/distinct-by" {:ns "cljs.spec.test",
                                         :name "distinct-by",
                                         :signature ["[f coll]"],
                                         :name-encode "distinct-by",
                                         :history [["+" "1.9.183"]
                                                   ["-" "1.9.542"]],
                                         :type "function",
                                         :full-name-encode "cljs.spec.test/distinct-by",
                                         :source {:code "(defn distinct-by\n  ([f coll]\n   (let [step (fn step [xs seen]\n                (lazy-seq\n                  ((fn [[x :as xs] seen]\n                     (when-let [s (seq xs)]\n                       (let [v (f x)]\n                         (if (contains? seen v)\n                           (recur (rest s) seen)\n                           (cons x (step (rest s) (conj seen v)))))))\n                    xs seen)))]\n     (step coll #{}))))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.9.521",
                                                  :filename "src/main/cljs/cljs/spec/test.cljs",
                                                  :lines [22 33]},
                                         :full-name "cljs.spec.test/distinct-by",
                                         :removed {:in "1.9.542",
                                                   :last-seen "1.9.521"}},
           "cljs.repl/pst" {:ns "cljs.repl",
                            :name "pst",
                            :signature ["[]" "[e]"],
                            :name-encode "pst",
                            :history [["+" "0.0-2985"]],
                            :type "macro",
                            :full-name-encode "cljs.repl/pst",
                            :source {:code "(defmacro pst\n  ([] `(pst *e))\n  ([e]\n   (let [{:keys [repl-env] :as env} &env]\n     (when (and e repl-env)\n       (when-let [ret (if (satisfies? IGetError repl-env)\n                   (-get-error repl-env e env *repl-opts*)\n                   (edn/read-string\n                     (evaluate-form repl-env env \"<cljs repl>\"\n                       `(when ~e\n                          (pr-str\n                            {:value (str ~e)\n                             :stacktrace (.-stack ~e)})))))]\n         (display-error repl-env\n           (if (satisfies? IParseError repl-env)\n             (-parse-error repl-env ret *repl-opts*)\n             ret)\n           nil *repl-opts*))))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/clojure/cljs/repl.cljc",
                                     :lines [1578 1595]},
                            :full-name "cljs.repl/pst"},
           "cljs.core/splitv-at" {:ns "cljs.core",
                                  :name "splitv-at",
                                  :signature ["[n coll]"],
                                  :name-encode "splitv-at",
                                  :history [["+" "1.11.121"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/splitv-at",
                                  :source {:code "(defn splitv-at\n  [n coll]\n  [(into [] (take n) coll) (drop n coll)])",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [9820 9823]},
                                  :full-name "cljs.core/splitv-at",
                                  :docstring "Returns a vector of [(into [] (take n) coll) (drop n coll)]"},
           "cljs.reader/parse-and-validate-timestamp" {:ns "cljs.reader",
                                                       :name "parse-and-validate-timestamp",
                                                       :signature ["[s]"],
                                                       :name-encode "parse-and-validate-timestamp",
                                                       :history [["+"
                                                                  "0.0-1853"]],
                                                       :type "function",
                                                       :full-name-encode "cljs.reader/parse-and-validate-timestamp",
                                                       :source {:code "(defn parse-and-validate-timestamp [s]\n  (let [[_ years months days hours minutes seconds fraction offset-sign offset-hours offset-minutes :as v]\n        (re-matches timestamp-regex s)]\n    (if-not v\n      (throw (js/Error. (str \"Unrecognized date/time syntax: \" s)))\n      (let [years (parse-int years)\n            months (or (parse-int months) 1)\n            days (or (parse-int days) 1)\n            hours (or (parse-int hours) 0)\n            minutes (or (parse-int minutes) 0)\n            seconds (or (parse-int seconds) 0)\n            fraction (or (parse-int (zero-fill-right-and-truncate fraction 3)) 0)\n            offset-sign (if (= offset-sign \"-\") -1 1)\n            offset-hours (or (parse-int offset-hours) 0)\n            offset-minutes (or (parse-int offset-minutes) 0)\n            offset (* offset-sign (+ (* offset-hours 60) offset-minutes))]\n        [years\n         (check 1 months 12 \"timestamp month field must be in range 1..12\")\n         (check 1 days (days-in-month months (leap-year? years)) \"timestamp day field must be in range 1..last day in month\")\n         (check 0 hours 23 \"timestamp hour field must be in range 0..23\")\n         (check 0 minutes 59 \"timestamp minute field must be in range 0..59\")\n         (check 0 seconds (if (= minutes 59) 60 59) \"timestamp second field must be in range 0..60\")\n         (check 0 fraction 999 \"timestamp millisecond field must be in range 0..999\")\n         offset]))))",
                                                                :title "Source code",
                                                                :repo "clojurescript",
                                                                :tag "r1.12.38",
                                                                :filename "src/main/cljs/cljs/reader.cljs",
                                                                :lines [58
                                                                        81]},
                                                       :full-name "cljs.reader/parse-and-validate-timestamp"},
           "closure-warnings/missing-properties" {:ns "closure-warnings",
                                                  :name "missing-properties",
                                                  :name-encode "missing-properties",
                                                  :type "warning",
                                                  :full-name-encode "closure-warnings/missing-properties",
                                                  :full-name "closure-warnings/missing-properties",
                                                  :history [["+"
                                                             "0.0-2120"]]},
           "clojure.browser.repl/PORT" {:ns "clojure.browser.repl",
                                        :name "PORT",
                                        :name-encode "PORT",
                                        :type "var",
                                        :full-name-encode "clojure.browser.repl/PORT",
                                        :source {:code "(goog-define PORT 9000)",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/cljs/clojure/browser/repl.cljs",
                                                 :lines [32]},
                                        :full-name "clojure.browser.repl/PORT",
                                        :history [["+" "1.10.63"]]},
           "cljs.core/Throwable->map" {:ns "cljs.core",
                                       :name "Throwable->map",
                                       :signature ["[o]"],
                                       :name-encode "Throwable-GTmap",
                                       :history [["+" "1.11.121"]],
                                       :type "function",
                                       :full-name-encode "cljs.core/Throwable-GTmap",
                                       :source {:code "(defn Throwable->map\n  [o]\n  (let [base (fn [t]\n               (merge {:type (cond\n                               (instance? ExceptionInfo t) `ExceptionInfo\n                               (instance? js/Error t) (symbol \"js\" (.-name t))\n                               :else nil)}\n                 (when-let [msg (ex-message t)]\n                   {:message msg})\n                 (when-let [ed (ex-data t)]\n                   {:data ed})\n                 #_(let [st (extract-canonical-stacktrace t)]\n                     (when (pos? (count st))\n                       {:at st}))))\n        via  (loop [via [], t o]\n               (if t\n                 (recur (conj via t) (ex-cause t))\n                 via))\n        root (peek via)]\n    (merge {:via   (vec (map base via))\n            :trace nil #_(extract-canonical-stacktrace (or root o))}\n      (when-let [root-msg (ex-message root)]\n        {:cause root-msg})\n      (when-let [data (ex-data root)]\n        {:data data})\n      (when-let [phase (-> o ex-data :clojure.error/phase)]\n        {:phase phase}))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/core.cljs",
                                                :lines [11837 11872]},
                                       :full-name "cljs.core/Throwable->map",
                                       :docstring "Constructs a data representation for an Error with keys:\n :cause - root cause message\n :phase - error phase\n :via - cause chain, with cause keys:\n          :type - exception class symbol\n          :message - exception message\n          :data - ex-data\n          :at - top stack element\n :trace - root cause stack elements"},
           "cljs.core/ISorted" {:ns "cljs.core",
                                :name "ISorted",
                                :name-encode "ISorted",
                                :implementations #{"PersistentTreeSet"
                                                   "PersistentTreeMap"},
                                :history [["+" "0.0-1211"]],
                                :type "protocol",
                                :full-name-encode "cljs.core/ISorted",
                                :source {:code "(defprotocol ISorted\n  (^clj -sorted-seq [coll ascending?]\n    \"Returns a sorted seq from coll in either ascending or descending order.\")\n  (^clj -sorted-seq-from [coll k ascending?]\n    \"Returns a sorted seq from coll in either ascending or descending order.\n     If ascending is true, the result should contain all items which are > or >=\n     than k. If ascending is false, the result should contain all items which\n     are < or <= than k, e.g.\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 true) => (3 4 5)\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 false) => (3 2 1)\")\n  (-entry-key [coll entry]\n    \"Returns the key for entry.\")\n  (-comparator [coll]\n    \"Returns the comparator for coll.\"))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [752 767]},
                                :methods [{:name "-sorted-seq",
                                           :signature ["[coll ascending?]"],
                                           :docstring "Returns a sorted seq from coll in either ascending or descending order."}
                                          {:name "-sorted-seq-from",
                                           :signature ["[coll k ascending?]"],
                                           :docstring "Returns a sorted seq from coll in either ascending or descending order.\n     If ascending is true, the result should contain all items which are > or >=\n     than k. If ascending is false, the result should contain all items which\n     are < or <= than k, e.g.\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 true) => (3 4 5)\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 false) => (3 2 1)"}
                                          {:name "-entry-key",
                                           :signature ["[coll entry]"],
                                           :docstring "Returns the key for entry."}
                                          {:name "-comparator",
                                           :signature ["[coll]"],
                                           :docstring "Returns the comparator for coll."}],
                                :full-name "cljs.core/ISorted",
                                :docstring "Protocol for a collection which can represent their items\n  in a sorted manner. "},
           "cljs.core/*print-namespace-maps*" {:ns "cljs.core",
                                               :name "*print-namespace-maps*",
                                               :name-encode "STARprint-namespace-mapsSTAR",
                                               :history [["+"
                                                          "1.9.456"]],
                                               :type "dynamic var",
                                               :full-name-encode "cljs.core/STARprint-namespace-mapsSTAR",
                                               :source {:code "(def\n  ^{:dynamic true}\n  *print-namespace-maps* false)",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.12.38",
                                                        :filename "src/main/cljs/cljs/core.cljs",
                                                        :lines [140
                                                                146]},
                                               :full-name "cljs.core/*print-namespace-maps*",
                                               :docstring "*print-namespace-maps* controls whether the printer will print\nnamespace map literal syntax.\n\nDefaults to false, but the REPL binds it to true."},
           "cljs.test/file-and-line" {:ns "cljs.test",
                                      :name "file-and-line",
                                      :signature ["[exception depth]"],
                                      :name-encode "file-and-line",
                                      :history [["+" "0.0-2496"]],
                                      :type "function",
                                      :full-name-encode "cljs.test/file-and-line",
                                      :source {:code "(defn file-and-line [exception depth]\n  ;; TODO: flesh out\n  (if-let [stack-element (and (string? (.-stack exception))\n                              (some-> (.-stack exception)\n                                      string/split-lines\n                                      (get depth)\n                                      string/trim))]\n    (let [fname (js-filename stack-element)\n          [line column] (js-line-and-column stack-element)\n          [fname line column] (mapped-line-and-column fname line column)]\n      {:file fname :line line :column column})\n    {:file (.-fileName exception)\n     :line (.-lineNumber exception)}))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/test.cljs",
                                               :lines [406 418]},
                                      :full-name "cljs.test/file-and-line"},
           "cljs.core/IIndexed" {:ns "cljs.core",
                                 :name "IIndexed",
                                 :name-encode "IIndexed",
                                 :implementations #{"Subvec"
                                                    "RedNode"
                                                    "ArrayChunk"
                                                    "BlackNode"
                                                    "PersistentVector"
                                                    "IntegerRange"
                                                    "TransientVector"
                                                    "IntegerRangeChunk"
                                                    "IndexedSeq"
                                                    "MapEntry"},
                                 :history [["+" "0.0-927"]],
                                 :type "protocol",
                                 :full-name-encode "cljs.core/IIndexed",
                                 :source {:code "(defprotocol IIndexed\n  (-nth [coll n] [coll n not-found]\n    \"Returns the value at the index n in the collection coll.\n     Returns not-found if index n is out of bounds and not-found is supplied.\"))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [611 615]},
                                 :methods [{:name "-nth",
                                            :signature ["[coll n]"
                                                        "[coll n not-found]"],
                                            :docstring "Returns the value at the index n in the collection coll.\n     Returns not-found if index n is out of bounds and not-found is supplied."}],
                                 :full-name "cljs.core/IIndexed",
                                 :docstring "Protocol for collections to provide indexed-based access to their items."},
           "cljs.math/decrement-exact" {:return-type number,
                                        :ns "cljs.math",
                                        :name "decrement-exact",
                                        :signature ["[a]"],
                                        :name-encode "decrement-exact",
                                        :history [["+" "1.11.50"]],
                                        :type "function",
                                        :full-name-encode "cljs.math/decrement-exact",
                                        :source {:code "(defn ^number decrement-exact\n  {:added \"1.11.10\"}\n  [a]\n  (if (or (<= a js/Number.MIN_SAFE_INTEGER) (> a js/Number.MAX_SAFE_INTEGER))\n    (throw (ex-info \"Integer overflow\" {:fn \"decrement-exact\"}))\n    (dec a)))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/cljs/cljs/math.cljs",
                                                 :lines [551 557]},
                                        :full-name "cljs.math/decrement-exact",
                                        :docstring "Returns a decremented by 1, throws ArithmeticException on overflow. "},
           "clojure.browser.repl/repl-print" {:ns "clojure.browser.repl",
                                              :name "repl-print",
                                              :signature ["[data]"],
                                              :name-encode "repl-print",
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "clojure.browser.repl/repl-print",
                                              :source {:code "(defn repl-print [data]\n  (.push print-queue (pr-str data))\n  (when @parent-connected?\n    (flush-print-queue! @xpc-connection)))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.12.38",
                                                       :filename "src/main/cljs/clojure/browser/repl.cljs",
                                                       :lines [51 54]},
                                              :full-name "clojure.browser.repl/repl-print"},
           "cljs.spec.gen.alpha/keyword-ns" {:ns "cljs.spec.gen.alpha",
                                             :name "keyword-ns",
                                             :signature ["[& args]"],
                                             :name-encode "keyword-ns",
                                             :history [["+" "1.9.542"]],
                                             :type "function",
                                             :full-name-encode "cljs.spec.gen.alpha/keyword-ns",
                                             :source {:code "(lazy-prims any any-printable boolean char char-alpha char-alphanumeric char-ascii double\n  int keyword keyword-ns large-integer ratio simple-type simple-type-printable\n  string string-ascii string-alphanumeric symbol symbol-ns uuid)",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.12.38",
                                                      :filename "src/main/cljs/cljs/spec/gen/alpha.cljs",
                                                      :lines [74 76]},
                                             :full-name "cljs.spec.gen.alpha/keyword-ns",
                                             :docstring "Fn returning clojure.test.check.generators/keyword-ns"},
           "clojure.browser.net/xpc-config-fields" {:ns "clojure.browser.net",
                                                    :name "xpc-config-fields",
                                                    :name-encode "xpc-config-fields",
                                                    :type "var",
                                                    :full-name-encode "clojure.browser.net/xpc-config-fields",
                                                    :source {:code "(def xpc-config-fields\n  (into {}\n        (map\n         (fn [[k v]]\n           [(keyword (.toLowerCase k))\n            v])\n         (js->clj CfgFields))))",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r1.12.38",
                                                             :filename "src/main/cljs/clojure/browser/net.cljs",
                                                             :lines [74
                                                                     80]},
                                                    :full-name "clojure.browser.net/xpc-config-fields",
                                                    :history [["+"
                                                               "0.0-927"]]},
           "cljs.js/compile*" {:ns "cljs.js",
                               :name "compile*",
                               :signature ["[bound-vars source name opts cb]"],
                               :name-encode "compileSTAR",
                               :history [["+" "1.7.10"]
                                         ["-" "1.7.28"]],
                               :type "function",
                               :full-name-encode "cljs.js/compileSTAR",
                               :source {:code "(defn compile* [bound-vars source name opts cb]\n  (let [rdr        (rt/indexing-push-back-reader source 1 name)\n        eof        (js-obj)\n        aenv       (ana/empty-env)\n        sb         (StringBuffer.)\n        the-ns     (or (:ns opts) 'cljs.user)\n        bound-vars (cond-> (merge bound-vars {:*cljs-ns* the-ns})\n                     (:source-map opts) (assoc :*sm-data* (sm-data)))]\n    ((fn compile-loop []\n       (binding [env/*compiler*         (:*compiler* bound-vars)\n                 *eval-fn*              (:*eval-fn* bound-vars)\n                 ana/*cljs-ns*          (:*cljs-ns* bound-vars)\n                 *ns*                   (create-ns (:*cljs-ns* bound-vars))\n                 r/*data-readers*       (:*data-readers* bound-vars)\n                 comp/*source-map-data* (:*sm-data* bound-vars)]\n         (let [res (try\n                     {:value (r/read {:eof eof :read-cond :allow :features #{:cljs}} rdr)}\n                     (catch :default cause\n                       (wrap-error\n                         (ana/error aenv\n                           (str \"Could not compile \" name) cause))))]\n           (if (:error res)\n             (cb res)\n             (let [form (:value res)]\n               (if-not (identical? eof form)\n                 (let [aenv (cond-> (assoc aenv :ns (ana/get-namespace ana/*cljs-ns*))\n                              (:context opts) (assoc :context (:context opts))\n                              (:def-emits-var opts) (assoc :def-emits-var true))\n                       ast  (try\n                              (ana/analyze aenv form nil opts)\n                              (catch :default cause\n                                (wrap-error\n                                  (ana/error aenv\n                                    (str \"Could not compile \" name) cause))))]\n                   (.append sb (with-out-str (comp/emit ast)))\n                   (if (= :ns (:op ast))\n                     (ns-side-effects bound-vars aenv ast opts\n                       (fn [res]\n                         (if (:error res)\n                           (cb res)\n                           (compile-loop))))\n                     (recur)))\n                 (do\n                   (when (:source-map opts)\n                     (append-source-map env/*compiler*\n                       name source sb @comp/*source-map-data* opts))\n                   (cb {:value (.toString sb)})))))))))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.10",
                                        :filename "src/main/cljs/cljs/js.cljs",
                                        :lines [532 578]},
                               :full-name "cljs.js/compile*",
                               :removed {:in "1.7.28",
                                         :last-seen "1.7.10"}},
           "cljs.core/ISwap" {:ns "cljs.core",
                              :name "ISwap",
                              :name-encode "ISwap",
                              :history [["+" "0.0-2173"]],
                              :type "protocol",
                              :full-name-encode "cljs.core/ISwap",
                              :source {:code "(defprotocol ISwap\n  (-swap! [o f] [o f a] [o f a b] [o f a b xs]\n    \"Swaps the value of o to be (apply f current-value-of-atom args).\"))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [873 876]},
                              :methods [{:name "-swap!",
                                         :signature ["[o f]"
                                                     "[o f a]"
                                                     "[o f a b]"
                                                     "[o f a b xs]"],
                                         :docstring "Swaps the value of o to be (apply f current-value-of-atom args)."}],
                              :full-name "cljs.core/ISwap",
                              :docstring "Protocol for adding swapping functionality."},
           "cljs.core/nnext" {:ns "cljs.core",
                              :name "nnext",
                              :signature ["[coll]"],
                              :name-encode "nnext",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/nnext",
                              :source {:code "(defn nnext\n  [coll]\n  (next (next coll)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [1815 1818]},
                              :full-name "cljs.core/nnext",
                              :docstring "Same as (next (next x))"},
           "cljs.core/*print-meta*" {:ns "cljs.core",
                                     :name "*print-meta*",
                                     :name-encode "STARprint-metaSTAR",
                                     :history [["+" "0.0-927"]],
                                     :type "dynamic var",
                                     :full-name-encode "cljs.core/STARprint-metaSTAR",
                                     :source {:code "(def\n  ^{:dynamic true}\n  *print-meta* false)",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/cljs/cljs/core.cljs",
                                              :lines [124 130]},
                                     :full-name "cljs.core/*print-meta*",
                                     :docstring "If set to logical true, when printing an object, its metadata will also\nbe printed in a form that can be read back by the reader.\n\nDefaults to false."},
           "cljs.reader/read-dispatch" {:ns "cljs.reader",
                                        :name "read-dispatch",
                                        :signature ["[rdr _]"],
                                        :name-encode "read-dispatch",
                                        :history [["+" "0.0-927"]
                                                  ["-" "1.9.854"]],
                                        :type "function",
                                        :full-name-encode "cljs.reader/read-dispatch",
                                        :source {:code "(defn read-dispatch\n  [rdr _]\n  (let [ch (read-char rdr)\n        dm (dispatch-macros ch)]\n    (if dm\n      (dm rdr _)\n      (if-let [obj (maybe-read-tagged-type rdr ch)]\n        obj\n        (reader-error rdr \"No dispatch macro for \" ch)))))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.9.671",
                                                 :filename "src/main/cljs/cljs/reader.cljs",
                                                 :lines [255 263]},
                                        :full-name "cljs.reader/read-dispatch",
                                        :removed {:in "1.9.854",
                                                  :last-seen "1.9.671"}},
           "cljs.test/run-block" {:ns "cljs.test",
                                  :name "run-block",
                                  :signature ["[fns]"],
                                  :name-encode "run-block",
                                  :history [["+" "0.0-2814"]],
                                  :type "function",
                                  :full-name-encode "cljs.test/run-block",
                                  :source {:code "(defn run-block\n  [fns]\n  (when-first [f fns]\n    (let [obj (f)]\n      (if (async? obj)\n        (obj (let [d (delay (run-block (rest fns)))]\n               (fn []\n                 (if (realized? d)\n                   (println \"WARNING: Async test called done more than one time.\")\n                   @d))))\n        (recur (cond->> (rest fns)\n                 (::block? (meta obj)) (concat obj)))))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/test.cljs",
                                           :lines [439 456]},
                                  :full-name "cljs.test/run-block",
                                  :docstring "Invoke all functions in fns with no arguments. A fn can optionally\nreturn\n\nan async test - is invoked with a continuation running left fns\n\na seq of fns tagged per block - are invoked immediately after fn"},
           "cljs.analyzer.api/get-options" {:ns "cljs.analyzer.api",
                                            :name "get-options",
                                            :signature ["[]"
                                                        "[state]"],
                                            :name-encode "get-options",
                                            :history [["+" "1.7.10"]],
                                            :type "function",
                                            :full-name-encode "cljs.analyzer.api/get-options",
                                            :source {:code "(defn get-options\n  ([] (get-options (current-state)))\n  ([state]\n   (get @state :options)))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/clojure/cljs/analyzer/api.cljc",
                                                     :lines [102 106]},
                                            :full-name "cljs.analyzer.api/get-options",
                                            :docstring "Return the compiler options from compiler state."},
           "cljs.core/*print-err-fn*" {:ns "cljs.core",
                                       :name "*print-err-fn*",
                                       :name-encode "STARprint-err-fnSTAR",
                                       :history [["+" "1.7.10"]],
                                       :type "dynamic var",
                                       :full-name-encode "cljs.core/STARprint-err-fnSTAR",
                                       :source {:code "(defonce\n  ^{:dynamic true}\n  *print-err-fn* nil)",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/core.cljs",
                                                :lines [88 92]},
                                       :full-name "cljs.core/*print-err-fn*",
                                       :docstring "Each runtime environment provides a different way to print error output.\nWhatever function *print-err-fn* is bound to will be passed any\nStrings which should be printed."},
           "cljs.core/distinct" {:ns "cljs.core",
                                 :name "distinct",
                                 :signature ["[]" "[coll]"],
                                 :name-encode "distinct",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/distinct",
                                 :source {:code "(defn distinct\n  ([]\n    (fn [rf]\n      (let [seen (volatile! #{})]\n        (fn\n          ([] (rf))\n          ([result] (rf result))\n          ([result input]\n            (if (contains? @seen input)\n              result\n              (do (vswap! seen conj input)\n                  (rf result input))))))))\n  ([coll]\n    (let [step (fn step [xs seen]\n                 (lazy-seq\n                   ((fn [[f :as xs] seen]\n                      (when-let [s (seq xs)]\n                        (if (contains? seen f)\n                          (recur (rest s) seen)\n                          (cons f (step (rest s) (conj seen f))))))\n                     xs seen)))]\n      (step coll #{}))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [9705 9728]},
                                 :full-name "cljs.core/distinct",
                                 :docstring "Returns a lazy sequence of the elements of coll with duplicates removed.\nReturns a stateful transducer when no collection is provided."},
           "cljs.reader/wrapping-reader" {:ns "cljs.reader",
                                          :name "wrapping-reader",
                                          :signature ["[sym]"],
                                          :name-encode "wrapping-reader",
                                          :history [["+" "0.0-927"]
                                                    ["-" "1.9.854"]],
                                          :type "function",
                                          :full-name-encode "cljs.reader/wrapping-reader",
                                          :source {:code "(defn wrapping-reader\n  [sym]\n  (fn [rdr _]\n    (list sym (read rdr true nil true))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.9.671",
                                                   :filename "src/main/cljs/cljs/reader.cljs",
                                                   :lines [389 392]},
                                          :full-name "cljs.reader/wrapping-reader",
                                          :removed {:in "1.9.854",
                                                    :last-seen "1.9.671"}},
           "cljs.core/LazyTransformer" {:protocols #{"ISeqable"
                                                     "IMeta"
                                                     "IWithMeta"
                                                     "IEmptyableCollection"
                                                     "IPending"
                                                     "ISequential"
                                                     "ISeq"
                                                     "ICollection"
                                                     "IHash"
                                                     "IPrintWithWriter"
                                                     "INext"
                                                     "IEquiv"},
                                        :ns "cljs.core",
                                        :name "LazyTransformer",
                                        :signature ["[stepper first rest meta]"],
                                        :name-encode "LazyTransformer",
                                        :history [["+" "0.0-2301"]
                                                  ["-" "1.9.562"]],
                                        :type "type",
                                        :full-name-encode "cljs.core/LazyTransformer",
                                        :source {:code "(deftype LazyTransformer [^:mutable stepper ^:mutable first ^:mutable rest meta]\n  Object\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IWithMeta\n  (-with-meta [this new-meta]\n    (LazyTransformer. stepper first rest new-meta))\n\n  IMeta\n  (-meta [this] meta)\n\n  ICollection\n  (-conj [this o]\n    (cons o (-seq this)))\n\n  IEmptyableCollection\n  (-empty [this]\n    ())\n\n  ISequential\n  IEquiv\n  (-equiv [this other]\n    (let [s (-seq this)]\n      (if-not (nil? s)\n        (equiv-sequential this other)\n        (and (sequential? other)\n             (nil? (seq other))))))\n\n  IHash\n  (-hash [this]\n    (hash-ordered-coll this))\n\n  ISeqable\n  (-seq [this]\n    (when-not (nil? stepper)\n      (.step stepper this))\n    (if (nil? rest)\n      nil\n      this))\n\n  ISeq\n  (-first [this]\n    (when-not (nil? stepper)\n      (-seq this))\n    (if (nil? rest)\n      nil\n      first))\n\n  (-rest [this]\n    (when-not (nil? stepper)\n      (-seq this))\n    (if (nil? rest)\n      ()\n      rest))\n\n  INext\n  (-next [this]\n    (when-not (nil? stepper)\n      (-seq this))\n    (if (nil? rest)\n      nil\n      (-seq rest)))\n\n  IPending\n  (-realized? [_]\n    (nil? stepper)))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.9.542",
                                                 :filename "src/main/cljs/cljs/core.cljs",
                                                 :lines [3950 4022]},
                                        :full-name "cljs.core/LazyTransformer",
                                        :removed {:in "1.9.562",
                                                  :last-seen "1.9.542"}},
           "cljs.core/double-array" {:ns "cljs.core",
                                     :name "double-array",
                                     :signature ["[size-or-seq]"
                                                 "[size init-val-or-seq]"],
                                     :name-encode "double-array",
                                     :history [["+" "0.0-1211"]],
                                     :type "function",
                                     :full-name-encode "cljs.core/double-array",
                                     :source {:code "(defn double-array\n  ([size-or-seq]\n     (if (number? size-or-seq)\n       (double-array size-or-seq nil)\n       (into-array size-or-seq)))\n  ([size init-val-or-seq]\n     (let [a (make-array size)]\n       (if (seq? init-val-or-seq)\n         (let [s (seq init-val-or-seq)]\n           (loop [i 0 s s]\n             (if (and s (< i size))\n               (do\n                 (aset a i (first s))\n                 (recur (inc i) (next s)))\n               a)))\n         (do\n           (dotimes [i size]\n             (aset a i init-val-or-seq))\n           a)))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/cljs/cljs/core.cljs",
                                              :lines [3800 3820]},
                                     :full-name "cljs.core/double-array",
                                     :docstring "Creates an array of doubles. Does not coerce array, provided for compatibility\nwith Clojure."},
           "cljs.repl/demunge" {:ns "cljs.repl",
                                :name "demunge",
                                :signature ["[fn-name]"],
                                :name-encode "demunge",
                                :history [["+" "1.10.514"]],
                                :type "function",
                                :full-name-encode "cljs.repl/demunge",
                                :source {:code "(defn demunge\n  [fn-name]\n  (clojure.lang.Compiler/demunge fn-name))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/clojure/cljs/repl.cljc",
                                         :lines [814 818]},
                                :full-name "cljs.repl/demunge",
                                :docstring "Given a string representation of a fn class,\nas in a stack trace element, returns a readable version."},
           "cljs.spec.impl.gen/LazyVar" {:protocols #{"IDeref"},
                                         :ns "cljs.spec.impl.gen",
                                         :name "LazyVar",
                                         :signature ["[f cached]"],
                                         :name-encode "LazyVar",
                                         :history [["+" "1.9.14"]
                                                   ["-" "1.9.542"]],
                                         :type "type",
                                         :full-name-encode "cljs.spec.impl.gen/LazyVar",
                                         :source {:code "(deftype LazyVar [f ^:mutable cached]\n  IDeref\n  (-deref [this]\n    (if-not (nil? cached)\n      cached\n      (let [x (f)]\n        (when-not (nil? x)\n          (set! cached x))\n        x))))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.9.521",
                                                  :filename "src/main/cljs/cljs/spec/impl/gen.cljs",
                                                  :lines [16 24]},
                                         :full-name "cljs.spec.impl.gen/LazyVar",
                                         :removed {:in "1.9.542",
                                                   :last-seen "1.9.521"}},
           "cljs.core/prn" {:ns "cljs.core",
                            :name "prn",
                            :signature ["[& objs]"],
                            :name-encode "prn",
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core/prn",
                            :source {:code "(defn prn\n  [& objs]\n  (pr-with-opts objs (pr-opts))\n  (when *print-newline*\n    (newline (pr-opts))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [10686 10691]},
                            :full-name "cljs.core/prn",
                            :docstring "Same as pr followed by (newline)."},
           "cljs.core/chunked-seq" {:ns "cljs.core",
                                    :name "chunked-seq",
                                    :signature ["[vec i off]"
                                                "[vec node i off]"
                                                "[vec node i off meta]"],
                                    :name-encode "chunked-seq",
                                    :history [["+" "0.0-1424"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/chunked-seq",
                                    :source {:code "(defn chunked-seq\n  ([vec i off] (ChunkedSeq. vec (array-for vec i) i off nil nil))\n  ([vec node i off] (ChunkedSeq. vec node i off nil nil))\n  ([vec node i off meta]\n     (ChunkedSeq. vec node i off meta nil)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [5971 5975]},
                                    :full-name "cljs.core/chunked-seq"},
           "clojure.zip/leftmost" {:ns "clojure.zip",
                                   :name "leftmost",
                                   :signature ["[loc]"],
                                   :name-encode "leftmost",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "clojure.zip/leftmost",
                                   :source {:code "(defn leftmost\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (if (and path (seq l))\n        (with-meta [(first l) (assoc path :l [] :r (concat (rest l) [node] r))] (meta loc))\n        loc)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/clojure/zip.cljs",
                                            :lines [157 163]},
                                   :full-name "clojure.zip/leftmost",
                                   :docstring "Returns the loc of the leftmost sibling of the node at this loc, or self"},
           "cljs.core/nthrest" {:ns "cljs.core",
                                :name "nthrest",
                                :signature ["[coll n]"],
                                :name-encode "nthrest",
                                :history [["+" "0.0-2411"]],
                                :type "function",
                                :full-name-encode "cljs.core/nthrest",
                                :source {:code "(defn nthrest\n  [coll n]\n    (if (implements? IDrop coll)\n      (if (pos? n)\n        (or (-drop coll (Math/ceil n)) ())\n        coll)\n      (loop [n n xs coll]\n        (if-let [xs (and (pos? n) (seq xs))]\n          (recur (dec n) (rest xs))\n          xs))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [1981 1991]},
                                :full-name "cljs.core/nthrest",
                                :docstring "Returns the nth rest of coll, coll when n is 0."},
           "cljs.core/js-in" {:ns "cljs.core",
                              :name "js-in",
                              :signature ["[key obj]"],
                              :name-encode "js-in",
                              :history [["+" "0.0-2411"]],
                              :type "macro",
                              :full-name-encode "cljs.core/js-in",
                              :source {:code "(core/defmacro js-in [key obj]\n  (core/list 'js* \"~{} in ~{}\" key obj))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/clojure/cljs/core.cljc",
                                       :lines [929 930]},
                              :full-name "cljs.core/js-in"},
           "cljs.test/function?" {:ns "cljs.test",
                                  :name "function?",
                                  :signature ["[menv x]"],
                                  :name-encode "functionQMARK",
                                  :history [["+" "1.8.51"]],
                                  :type "function",
                                  :full-name-encode "cljs.test/functionQMARK",
                                  :source {:code "(defn function?\n  [menv x]\n  (and (symbol? x) (:fn-var (ana-api/resolve menv x))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/test.cljc",
                                           :lines [19 23]},
                                  :full-name "cljs.test/function?",
                                  :docstring "Returns true if argument is a function or a symbol that resolves to\na function (not a macro)."},
           "cljs.core/>=" {:return-type boolean,
                           :ns "cljs.core",
                           :name ">=",
                           :signature ["[x]" "[x y]" "[x y & more]"],
                           :name-encode "GTEQ",
                           :history [["+" "0.0-927"]],
                           :type "function/macro",
                           :full-name-encode "cljs.core/GTEQ",
                           :source {:code "(defn ^boolean >=\n  ([x] true)\n  ([x y] (cljs.core/>= x y))\n  ([x y & more]\n   (if (cljs.core/>= x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (cljs.core/>= y (first more)))\n     false)))",
                                    :title "Function code",
                                    :repo "clojurescript",
                                    :tag "r1.12.38",
                                    :filename "src/main/cljs/cljs/core.cljs",
                                    :lines [2750 2760]},
                           :extra-sources [{:code "(core/defmacro ^::ana/numeric >=\n  ([x] true)\n  ([x y] (bool-expr (core/list 'js* \"(~{} >= ~{})\" x y)))\n  ([x y & more] `(and (>= ~x ~y) (>= ~y ~@more))))",
                                            :title "Macro code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/clojure/cljs/core.cljc",
                                            :lines [1155 1158]}],
                           :full-name "cljs.core/>=",
                           :docstring "Returns non-nil if nums are in monotonically non-increasing order,\notherwise false."},
           "clojure.browser.net/websocket-connection" {:ns "clojure.browser.net",
                                                       :name "websocket-connection",
                                                       :signature ["[]"
                                                                   "[auto-reconnect?]"
                                                                   "[auto-reconnect? next-reconnect-fn]"],
                                                       :name-encode "websocket-connection",
                                                       :history [["+"
                                                                  "0.0-2911"]],
                                                       :type "function",
                                                       :full-name-encode "clojure.browser.net/websocket-connection",
                                                       :source {:code "(defn websocket-connection\n  ([]\n     (websocket-connection nil nil))\n  ([auto-reconnect?]\n     (websocket-connection auto-reconnect? nil))\n  ([auto-reconnect? next-reconnect-fn]\n     (WebSocket. auto-reconnect? next-reconnect-fn)))",
                                                                :title "Source code",
                                                                :repo "clojurescript",
                                                                :tag "r1.12.38",
                                                                :filename "src/main/cljs/clojure/browser/net.cljs",
                                                                :lines [175
                                                                        181]},
                                                       :full-name "clojure.browser.net/websocket-connection"},
           "cljs.repl.browser/read-request" {:ns "cljs.repl.browser",
                                             :name "read-request",
                                             :signature ["[rdr]"],
                                             :name-encode "read-request",
                                             :history [["+" "0.0-927"]
                                                       ["-"
                                                        "0.0-1503"]],
                                             :type "function",
                                             :full-name-encode "cljs.repl.browser/read-request",
                                             :source {:code "(defn read-request [rdr]\n  (let [line (.readLine rdr)]\n    (cond (.startsWith line \"POST\") (read-post line rdr)\n          (.startsWith line \"GET\") (read-get line rdr)\n          :else {:method :unknown :content line})))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1450",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [161 165]},
                                             :full-name "cljs.repl.browser/read-request",
                                             :removed {:in "0.0-1503",
                                                       :last-seen "0.0-1450"}},
           "cljs.analyzer.api/remove-ns" {:ns "cljs.analyzer.api",
                                          :name "remove-ns",
                                          :signature ["[ns]"
                                                      "[state ns]"],
                                          :name-encode "remove-ns",
                                          :history [["+" "0.0-3208"]],
                                          :type "function",
                                          :full-name-encode "cljs.analyzer.api/remove-ns",
                                          :source {:code "(defn remove-ns\n  ([ns]\n   (remove-ns env/*compiler* ns))\n  ([state ns]\n   {:pre [(symbol? ns)]}\n   (swap! state update-in [::ana/namespaces] dissoc ns)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/clojure/cljs/analyzer/api.cljc",
                                                   :lines [272 278]},
                                          :full-name "cljs.analyzer.api/remove-ns",
                                          :docstring "Removes the namespace named by the symbol."},
           "cljs.core/default-dispatch-val" {:ns "cljs.core",
                                             :name "default-dispatch-val",
                                             :signature ["[multifn]"],
                                             :name-encode "default-dispatch-val",
                                             :history [["+"
                                                        "0.0-3165"]],
                                             :type "function",
                                             :full-name-encode "cljs.core/default-dispatch-val",
                                             :source {:code "(defn default-dispatch-val\n  [multifn] (-default-dispatch-val multifn))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.12.38",
                                                      :filename "src/main/cljs/cljs/core.cljs",
                                                      :lines [11700
                                                              11702]},
                                             :full-name "cljs.core/default-dispatch-val",
                                             :docstring "Given a multimethod, return its default-dispatch-val."},
           "cljs.reader/macros" {:ns "cljs.reader",
                                 :name "macros",
                                 :signature ["[c]"],
                                 :name-encode "macros",
                                 :history [["+" "0.0-927"]
                                           ["-" "1.9.854"]],
                                 :type "function",
                                 :full-name-encode "cljs.reader/macros",
                                 :source {:code "(defn macros [c]\n  (cond\n   (identical? c \\\") read-string*\n   (identical? c \\:) read-keyword\n   (identical? c \\;) read-comment\n   (identical? c \\') (wrapping-reader 'quote)\n   (identical? c \\@) (wrapping-reader 'deref)\n   (identical? c \\^) read-meta\n   (identical? c \\`) not-implemented\n   (identical? c \\~) not-implemented\n   (identical? c \\() read-list\n   (identical? c \\)) read-unmatched-delimiter\n   (identical? c \\[) read-vector\n   (identical? c \\]) read-unmatched-delimiter\n   (identical? c \\{) read-map\n   (identical? c \\}) read-unmatched-delimiter\n   (identical? c \\\\) read-literal\n   (identical? c \\#) read-dispatch\n   :else nil))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.9.671",
                                          :filename "src/main/cljs/cljs/reader.cljs",
                                          :lines [422 440]},
                                 :full-name "cljs.reader/macros",
                                 :removed {:in "1.9.854",
                                           :last-seen "1.9.671"}},
           "cljs.build.api/target-file-for-cljs-ns" {:return-type File,
                                                     :ns "cljs.build.api",
                                                     :name "target-file-for-cljs-ns",
                                                     :signature ["[ns-sym]"
                                                                 "[ns-sym output-dir]"],
                                                     :name-encode "target-file-for-cljs-ns",
                                                     :history [["+"
                                                                "0.0-2496"]],
                                                     :type "function",
                                                     :full-name-encode "cljs.build.api/target-file-for-cljs-ns",
                                                     :source {:code "(defn ^File target-file-for-cljs-ns\n  ([ns-sym] (closure/target-file-for-cljs-ns ns-sym nil))\n  ([ns-sym output-dir] (closure/target-file-for-cljs-ns ns-sym output-dir)))",
                                                              :title "Source code",
                                                              :repo "clojurescript",
                                                              :tag "r1.12.38",
                                                              :filename "src/main/clojure/cljs/build/api.clj",
                                                              :lines [27
                                                                      35]},
                                                     :full-name "cljs.build.api/target-file-for-cljs-ns",
                                                     :docstring "Given an output directory and a clojurescript namespace return the\ncompilation target file for that namespace.\n\nFor example:\n(target-file-from-cljs-ns \"resources/out\" 'example.core) ->\n<File: \"resources/out/example/core.js\">"},
           "syntax/Inf" {:syntax-equiv {:edn-url nil, :clj-url nil},
                         :ns "syntax",
                         :name "Inf",
                         :name-encode "Inf",
                         :history [["+" "1.9.946"]],
                         :type "symbolic value",
                         :full-name-encode "syntax/Inf",
                         :extra-sources ({:code "(defn- read-symbolic-value\n  [rdr _ opts pending-forms]\n  (let [sym (read* rdr true nil opts pending-forms)]\n    (case sym\n      Inf Double/POSITIVE_INFINITY\n      -Inf Double/NEGATIVE_INFINITY\n      NaN Double/NaN\n      (err/reader-error rdr (str \"Invalid token: ##\" sym)))))",
                                          :title "Reader code",
                                          :repo "tools.reader",
                                          :tag "v1.3.6",
                                          :filename "src/main/clojure/clojure/tools/reader.clj",
                                          :lines [412 419]}
                                         {:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    \\? read-cond\n    \\: read-namespaced-map\n    \\# read-symbolic-value\n    nil))",
                                          :title "Reader table",
                                          :repo "tools.reader",
                                          :tag "v1.3.6",
                                          :filename "src/main/clojure/clojure/tools/reader.clj",
                                          :lines [809 823]}),
                         :full-name "syntax/Inf"},
           "cljs.core/doseq" {:ns "cljs.core",
                              :name "doseq",
                              :signature ["[seq-exprs & body]"],
                              :name-encode "doseq",
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :full-name-encode "cljs.core/doseq",
                              :source {:code "(core/defmacro doseq\n  [seq-exprs & body]\n  (assert-args doseq\n    (vector? seq-exprs) \"a vector for its binding\"\n    (even? (count seq-exprs)) \"an even number of forms in binding vector\")\n  (core/let [err (core/fn [& msg] (throw (ex-info (apply core/str msg) {})))\n             step (core/fn step [recform exprs]\n                    (core/if-not exprs\n                      [true `(do ~@body nil)]\n                      (core/let [k (first exprs)\n                                 v (second exprs)\n\n                                 seqsym (gensym \"seq__\")\n                                 recform (if (core/keyword? k) recform `(recur (next ~seqsym) nil 0 0))\n                                 steppair (step recform (nnext exprs))\n                                 needrec (steppair 0)\n                                 subform (steppair 1)]\n                        (core/cond\n                          (= k :let) [needrec `(let ~v ~subform)]\n                          (= k :while) [false `(when ~v\n                                                 ~subform\n                                                 ~@(core/when needrec [recform]))]\n                          (= k :when) [false `(if ~v\n                                                (do\n                                                  ~subform\n                                                  ~@(core/when needrec [recform]))\n                                                ~recform)]\n                          (core/keyword? k) (err \"Invalid 'doseq' keyword\" k)\n                          :else (core/let [chunksym (with-meta (gensym \"chunk__\")\n                                                      {:tag 'not-native})\n                                           countsym (gensym \"count__\")\n                                           isym     (gensym \"i__\")\n                                           recform-chunk  `(recur ~seqsym ~chunksym ~countsym (unchecked-inc ~isym))\n                                           steppair-chunk (step recform-chunk (nnext exprs))\n                                           subform-chunk  (steppair-chunk 1)]\n                                  [true `(loop [~seqsym   (seq ~v)\n                                                ~chunksym nil\n                                                ~countsym 0\n                                                ~isym     0]\n                                           (if (coercive-boolean (< ~isym ~countsym))\n                                             (let [~k (-nth ~chunksym ~isym)]\n                                               ~subform-chunk\n                                               ~@(core/when needrec [recform-chunk]))\n                                             (when-let [~seqsym (seq ~seqsym)]\n                                               (if (chunked-seq? ~seqsym)\n                                                 (let [c# (chunk-first ~seqsym)]\n                                                   (recur (chunk-rest ~seqsym) c#\n                                                     (count c#) 0))\n                                                 (let [~k (first ~seqsym)]\n                                                   ~subform\n                                                   ~@(core/when needrec [recform]))))))])))))]\n    (nth (step nil (seq seq-exprs)) 1)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/clojure/cljs/core.cljc",
                                       :lines [2536 2590]},
                              :full-name "cljs.core/doseq",
                              :docstring "Repeatedly executes body (presumably for side-effects) with\nbindings and filtering as provided by \"for\".  Does not retain\nthe head of the sequence. Returns nil."},
           "cljs.core/*" {:return-type number,
                          :ns "cljs.core",
                          :name "*",
                          :signature ["[]"
                                      "[x]"
                                      "[x y]"
                                      "[x y & more]"],
                          :name-encode "STAR",
                          :history [["+" "0.0-927"]],
                          :type "function/macro",
                          :full-name-encode "cljs.core/STAR",
                          :source {:code "(defn ^number *\n  ([] 1)\n  ([x] x)\n  ([x y] (cljs.core/* x y))\n  ([x y & more] (reduce * (cljs.core/* x y) more)))",
                                   :title "Function code",
                                   :repo "clojurescript",
                                   :tag "r1.12.38",
                                   :filename "src/main/cljs/cljs/core.cljs",
                                   :lines [2698 2703]},
                          :extra-sources [{:code "(core/defmacro ^::ana/numeric *\n  ([] 1)\n  ([x] (core/list 'js* \"(~{})\" x))\n  ([x y] (core/list 'js* \"(~{} * ~{})\" x y))\n  ([x y & more] `(* (* ~x ~y) ~@more)))",
                                           :title "Macro code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/clojure/cljs/core.cljc",
                                           :lines [1124 1128]}],
                          :full-name "cljs.core/*",
                          :docstring "Returns the product of nums. (*) returns 1."},
           "cljs.core/into" {:ns "cljs.core",
                             :name "into",
                             :signature ["[]"
                                         "[to]"
                                         "[to from]"
                                         "[to xform from]"],
                             :name-encode "into",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/into",
                             :source {:code "(defn into\n  ([] [])\n  ([to] to)\n  ([to from]\n     (if-not (nil? to)\n       (if (implements? IEditableCollection to)\n         (-with-meta (persistent! (reduce -conj! (transient to) from)) (meta to))\n         (reduce -conj to from))\n       (reduce conj to from)))\n  ([to xform from]\n     (if (implements? IEditableCollection to)\n       (let [tm (meta to)\n             rf (fn\n                  ([coll] (-> (persistent! coll) (-with-meta tm)))\n                  ([coll v] (conj! coll v)))]\n         (transduce xform rf (transient to) from))\n       (transduce xform conj to from))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [5336 5354]},
                             :full-name "cljs.core/into",
                             :docstring "Returns a new coll consisting of to-coll with all of the items of\nfrom-coll conjoined. A transducer may be supplied."},
           "cljs.spec.alpha/merge" {:ns "cljs.spec.alpha",
                                    :name "merge",
                                    :signature ["[& pred-forms]"],
                                    :name-encode "merge",
                                    :history [["+" "1.9.542"]],
                                    :type "macro",
                                    :full-name-encode "cljs.spec.alpha/merge",
                                    :source {:code "(defmacro merge\n  [& pred-forms]\n  `(merge-spec-impl '~(mapv #(res &env %) pred-forms) ~(vec pred-forms) nil))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/spec/alpha.cljc",
                                             :lines [512 519]},
                                    :full-name "cljs.spec.alpha/merge",
                                    :docstring "Takes map-validating specs (e.g. 'keys' specs) and\nreturns a spec that returns a conformed map satisfying all of the\nspecs.  Successive conformed values propagate through rest of\npredicates. Unlike 'and', merge can generate maps satisfying the\nunion of the predicates."},
           "cljs.spec.alpha/registry-ref" {:ns "cljs.spec.alpha",
                                           :name "registry-ref",
                                           :name-encode "registry-ref",
                                           :type "var",
                                           :full-name-encode "cljs.spec.alpha/registry-ref",
                                           :source {:code "(defonce registry-ref (atom {}))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/cljs/cljs/spec/alpha.cljc",
                                                    :lines [19]},
                                           :full-name "cljs.spec.alpha/registry-ref",
                                           :history [["+" "1.9.542"]]},
           "cljs.repl.server/state" {:ns "cljs.repl.server",
                                     :name "state",
                                     :name-encode "state",
                                     :type "dynamic var",
                                     :full-name-encode "cljs.repl.server/state",
                                     :source {:code "(def ^:dynamic state nil)",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/clojure/cljs/repl/server.clj",
                                              :lines [19]},
                                     :full-name "cljs.repl.server/state",
                                     :history [["+" "0.0-1503"]]},
           "cljs.core/defmethod" {:ns "cljs.core",
                                  :name "defmethod",
                                  :signature ["[multifn dispatch-val & fn-tail]"],
                                  :name-encode "defmethod",
                                  :history [["+" "0.0-927"]],
                                  :type "macro",
                                  :full-name-encode "cljs.core/defmethod",
                                  :source {:code "(core/defmacro defmethod\n  [multifn dispatch-val & fn-tail]\n  `(-add-method ~(with-meta multifn {:tag 'cljs.core/MultiFn}) ~dispatch-val (fn ~@fn-tail)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/clojure/cljs/core.cljc",
                                           :lines [2809 2812]},
                                  :full-name "cljs.core/defmethod",
                                  :docstring "Creates and installs a new method of multimethod associated with dispatch-value. "},
           "cljs.math/to-radians" {:return-type number,
                                   :ns "cljs.math",
                                   :name "to-radians",
                                   :signature ["[deg]"],
                                   :name-encode "to-radians",
                                   :history [["+" "1.11.50"]],
                                   :type "function",
                                   :full-name-encode "cljs.math/to-radians",
                                   :source {:code "(defn ^number to-radians\n  {:added \"1.11.10\"}\n  [deg]\n  (* deg DEGREES-TO-RADIANS))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/math.cljs",
                                            :lines [126 131]},
                                   :full-name "cljs.math/to-radians",
                                   :docstring "Converts an angle in degrees to an approximate equivalent angle in radians.\nSee: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#toRadians-double-"},
           "closure-warnings/unnecessary-escape" {:ns "closure-warnings",
                                                  :name "unnecessary-escape",
                                                  :name-encode "unnecessary-escape",
                                                  :type "warning",
                                                  :full-name-encode "closure-warnings/unnecessary-escape",
                                                  :full-name "closure-warnings/unnecessary-escape",
                                                  :history [["+"
                                                             "1.10.217"]
                                                            ["-"
                                                             "1.11.50"]],
                                                  :removed {:in "1.11.50",
                                                            :last-seen "1.11.4"}},
           "cljs.core/rest" {:return-type seq,
                             :ns "cljs.core",
                             :name "rest",
                             :signature ["[coll]"],
                             :name-encode "rest",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/rest",
                             :source {:code "(defn ^seq rest\n  [coll]\n  (if-not (nil? coll)\n    (if (implements? ISeq coll)\n      (-rest coll)\n      (let [s (seq coll)]\n        (if s\n          (-rest ^not-native s)\n          ())))\n    ()))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [1290 1301]},
                             :full-name "cljs.core/rest",
                             :docstring "Returns a possibly empty seq of the items after the first. Calls seq on its\nargument."},
           "closure-warnings/conformance-violations" {:ns "closure-warnings",
                                                      :name "conformance-violations",
                                                      :name-encode "conformance-violations",
                                                      :type "warning",
                                                      :full-name-encode "closure-warnings/conformance-violations",
                                                      :full-name "closure-warnings/conformance-violations",
                                                      :history [["+"
                                                                 "1.9.473"]]},
           "cljs.spec.test/->sym" {:ns "cljs.spec.test",
                                   :name "->sym",
                                   :signature ["[x]"],
                                   :name-encode "-GTsym",
                                   :history [["+" "1.9.183"]
                                             ["-" "1.9.542"]],
                                   :type "function",
                                   :full-name-encode "cljs.spec.test/-GTsym",
                                   :source {:code "(defn ->sym\n  [x]\n  (@#'s/->sym x))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.9.521",
                                            :filename "src/main/cljs/cljs/spec/test.cljs",
                                            :lines [35 37]},
                                   :full-name "cljs.spec.test/->sym",
                                   :removed {:in "1.9.542",
                                             :last-seen "1.9.521"}},
           "cljs.reader/unicode-4-pattern" {:ns "cljs.reader",
                                            :name "unicode-4-pattern",
                                            :name-encode "unicode-4-pattern",
                                            :history [["+" "0.0-1424"]
                                                      ["-" "1.9.854"]],
                                            :type "var",
                                            :full-name-encode "cljs.reader/unicode-4-pattern",
                                            :source {:code "(def unicode-4-pattern (re-pattern \"^[0-9A-Fa-f]{4}$\"))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.9.671",
                                                     :filename "src/main/cljs/cljs/reader.cljs",
                                                     :lines [183]},
                                            :full-name "cljs.reader/unicode-4-pattern",
                                            :removed {:in "1.9.854",
                                                      :last-seen "1.9.671"}},
           "clojure.browser.repl/bootstrap" {:ns "clojure.browser.repl",
                                             :name "bootstrap",
                                             :signature ["[]"],
                                             :name-encode "bootstrap",
                                             :history [["+"
                                                        "0.0-3115"]],
                                             :type "function",
                                             :full-name-encode "clojure.browser.repl/bootstrap",
                                             :source {:code "(defn bootstrap\n  []\n  ;; Monkey-patch goog.provide if running under optimizations :none - David\n  (when-not js/COMPILED\n    (set! (.-require__ js/goog) js/goog.require)\n    ;; suppress useless Google Closure error about duplicate provides\n    (set! (.-isProvided_ js/goog) (fn [name] false))\n    ;; provide cljs.user\n    (goog/constructNamespace_ \"cljs.user\")\n    (set! (.-writeScriptTag__ js/goog)\n      (fn [src opt_sourceText]\n        ;; the page is already loaded, we can no longer leverage document.write\n        ;; instead construct script tag elements and append them to the body\n        ;; of the page, to avoid parallel script loading enforce sequential\n        ;; load with a simple load queue\n        (let [loaded (atom false)\n              onload (fn []\n                       (when (and load-queue (false? @loaded))\n                         (swap! loaded not)\n                         (if (zero? (alength load-queue))\n                           (set! load-queue nil)\n                           (.apply js/goog.writeScriptTag__ nil (.shift load-queue)))))]\n          (.appendChild js/document.body\n            (as-> (.createElement js/document \"script\") script\n              (doto script\n                (gobj/set \"type\" \"text/javascript\")\n                (gobj/set \"onload\" onload)\n                (gobj/set \"onreadystatechange\" onload)) ;; IE\n              (if (nil? opt_sourceText)\n                (doto script (gobj/set \"src\" src))\n                (doto script (gdom/setTextContent opt_sourceText))))))))\n    ;; queue or load\n    (set! (.-writeScriptTag_ js/goog)\n      (fn [src opt_sourceText]\n        (if load-queue\n          (.push load-queue #js [src opt_sourceText])\n          (do\n            (set! load-queue #js [])\n            (js/goog.writeScriptTag__ src opt_sourceText)))))\n    ;; In the latest Closure library implementation, there is no goog.writeScriptTag_,\n    ;; to monkey-patch. The behavior of interest is instead in goog.Dependency.prototype.load,\n    ;; which first checks and uses CLOSURE_IMPORT_SCRIPT if defined. So we hook our desired\n    ;; behavior here.\n    (when goog/debugLoader_\n      (set! js/CLOSURE_IMPORT_SCRIPT (.-writeScriptTag_ js/goog)))\n    ;; we must reuse Closure library dev time dependency management, under namespace\n    ;; reload scenarios we simply delete entries from the correct private locations\n    (set! (.-require js/goog)\n      (fn [src reload]\n        (when (= reload \"reload-all\")\n          (set! (.-cljsReloadAll_ js/goog) true))\n        (let [reload? (or reload (.-cljsReloadAll_ js/goog))]\n          (when reload?\n            (if (some? goog/debugLoader_)\n              (let [path (.getPathFromDeps_ goog/debugLoader_ src)]\n                (gobj/remove (.-written_ goog/debugLoader_) path)\n                (gobj/remove (.-written_ goog/debugLoader_)\n                  (str js/goog.basePath path)))\n              (let [path (gobj/get js/goog.dependencies_.nameToPath src)]\n                (gobj/remove js/goog.dependencies_.visited path)\n                (gobj/remove js/goog.dependencies_.written path)\n                (gobj/remove js/goog.dependencies_.written\n                  (str js/goog.basePath path)))))\n          (let [ret (.require__ js/goog src)]\n            (when (= reload \"reload-all\")\n              (set! (.-cljsReloadAll_ js/goog) false))\n            ;; handle requires from Closure Library goog.modules\n            (if (js/goog.isInModuleLoader_)\n              (js/goog.module.getInternal_ src)\n              ret)))))))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.12.38",
                                                      :filename "src/main/cljs/clojure/browser/repl.cljs",
                                                      :lines [162 233]},
                                             :full-name "clojure.browser.repl/bootstrap",
                                             :docstring "Reusable browser REPL bootstrapping. Patches the essential functions\nin goog.base to support re-loading of namespaces after page load."},
           "cljs.spec/assert*" {:ns "cljs.spec",
                                :name "assert*",
                                :signature ["[spec x]"],
                                :name-encode "assertSTAR",
                                :history [["+" "1.9.216"]
                                          ["-" "1.9.542"]],
                                :type "function",
                                :full-name-encode "cljs.spec/assertSTAR",
                                :source {:code "(defn assert*\n  [spec x]\n  (if (valid? spec x)\n    x\n    (let [ed (c/merge (assoc (explain-data* spec [] [] [] x)\n                        ::failure :assertion-failed))]\n      (throw (js/Error.\n              (str \"Spec assertion failed\\n\" (with-out-str (explain-out ed))))))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.9.521",
                                         :filename "src/main/cljs/cljs/spec.cljs",
                                         :lines [1436 1444]},
                                :full-name "cljs.spec/assert*",
                                :docstring "Do not call this directly, use 'assert'.",
                                :removed {:in "1.9.542",
                                          :last-seen "1.9.521"}},
           "closure-warnings/ambiguous-function-decl" {:ns "closure-warnings",
                                                       :name "ambiguous-function-decl",
                                                       :name-encode "ambiguous-function-decl",
                                                       :type "warning",
                                                       :full-name-encode "closure-warnings/ambiguous-function-decl",
                                                       :full-name "closure-warnings/ambiguous-function-decl",
                                                       :history [["+"
                                                                  "0.0-2120"]
                                                                 ["-"
                                                                  "1.10.738"]],
                                                       :removed {:in "1.10.738",
                                                                 :last-seen "1.10.597"}},
           "cljs.spec.alpha/registry" {:ns "cljs.spec.alpha",
                                       :name "registry",
                                       :signature ["[]"],
                                       :name-encode "registry",
                                       :history [["+" "1.9.542"]],
                                       :type "function",
                                       :full-name-encode "cljs.spec.alpha/registry",
                                       :source {:code "(defn registry\n  []\n  @registry-ref)",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/spec/alpha.cljs",
                                                :lines [318 321]},
                                       :full-name "cljs.spec.alpha/registry",
                                       :docstring "returns the registry map, prefer 'get-spec' to lookup a spec by name"},
           "cljs.build.api/node-modules" {:ns "cljs.build.api",
                                          :name "node-modules",
                                          :signature ["[]" "[opts]"],
                                          :name-encode "node-modules",
                                          :history [["+" "1.10.738"]],
                                          :type "function",
                                          :full-name-encode "cljs.build.api/node-modules",
                                          :source {:code "(defn node-modules\n  ([]\n   (node-modules {}))\n  ([opts]\n   (ana-api/with-state (or (ana-api/current-state) (ana-api/empty-state opts))\n     (filter :provides (closure/index-node-modules-dir)))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/clojure/cljs/build/api.clj",
                                                   :lines [303 309]},
                                          :full-name "cljs.build.api/node-modules",
                                          :docstring "Return a sequence of requirable libraries found under node_modules."},
           "cljs.spec.alpha/assert*" {:ns "cljs.spec.alpha",
                                      :name "assert*",
                                      :signature ["[spec x]"],
                                      :name-encode "assertSTAR",
                                      :history [["+" "1.9.542"]],
                                      :type "function",
                                      :full-name-encode "cljs.spec.alpha/assertSTAR",
                                      :source {:code "(defn assert*\n  [spec x]\n  (if (valid? spec x)\n    x\n    (let [ed (c/merge (assoc (explain-data* spec [] [] [] x)\n                        ::failure :assertion-failed))]\n      (throw (js/Error.\n              (str \"Spec assertion failed\\n\" (with-out-str (explain-out ed))))))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/spec/alpha.cljs",
                                               :lines [1498 1506]},
                                      :full-name "cljs.spec.alpha/assert*",
                                      :docstring "Do not call this directly, use 'assert'."},
           "cljs.core/dotimes" {:ns "cljs.core",
                                :name "dotimes",
                                :signature ["[bindings & body]"],
                                :name-encode "dotimes",
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :full-name-encode "cljs.core/dotimes",
                                :source {:code "(core/defmacro dotimes\n  [bindings & body]\n  (core/let [i (first bindings)\n             n (second bindings)]\n    `(let [n# ~n]\n       (loop [~i 0]\n         (when (< ~i n#)\n           ~@body\n           (recur (inc ~i)))))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/clojure/cljs/core.cljc",
                                         :lines [2738 2750]},
                                :full-name "cljs.core/dotimes",
                                :docstring "bindings => name n\n\nRepeatedly executes body (presumably for side-effects) with name\nbound to integers from 0 through n-1."},
           "cljs.core/dedupe" {:ns "cljs.core",
                               :name "dedupe",
                               :signature ["[]" "[coll]"],
                               :name-encode "dedupe",
                               :history [["+" "0.0-2301"]],
                               :type "function",
                               :full-name-encode "cljs.core/dedupe",
                               :source {:code "(defn dedupe\n  ([]\n   (fn [rf]\n     (let [pa (volatile! ::none)]\n       (fn\n         ([] (rf))\n         ([result] (rf result))\n         ([result input]\n            (let [prior @pa]\n              (vreset! pa input)\n              (if (= prior input)\n                result\n                (rf result input))))))))\n  ([coll] (sequence (dedupe) coll)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [11040 11055]},
                               :full-name "cljs.core/dedupe",
                               :docstring "Returns a lazy sequence removing consecutive duplicates in coll.\nReturns a transducer when no collection is provided."},
           "clojure.zip/lefts" {:ns "clojure.zip",
                                :name "lefts",
                                :signature ["[loc]"],
                                :name-encode "lefts",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "clojure.zip/lefts",
                                :source {:code "(defn lefts\n  [loc]\n    (seq (:l (loc 1))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/clojure/zip.cljs",
                                         :lines [87 90]},
                                :full-name "clojure.zip/lefts",
                                :docstring "Returns a seq of the left siblings of this loc"},
           "cljs.spec.gen.alpha/large-integer*" {:ns "cljs.spec.gen.alpha",
                                                 :name "large-integer*",
                                                 :signature ["[& args]"],
                                                 :name-encode "large-integerSTAR",
                                                 :history [["+"
                                                            "1.9.542"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.spec.gen.alpha/large-integerSTAR",
                                                 :source {:code "(lazy-combinators hash-map list map not-empty set vector vector-distinct fmap elements\n  bind choose one-of such-that tuple sample return\n  large-integer* double* frequency shuffle)",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r1.12.38",
                                                          :filename "src/main/cljs/cljs/spec/gen/alpha.cljs",
                                                          :lines [70
                                                                  72]},
                                                 :full-name "cljs.spec.gen.alpha/large-integer*",
                                                 :docstring "Lazy loaded version of clojure.test.check.generators/large-integer*"},
           "cljs.repl.nashorn/tear-down-engine" {:ns "cljs.repl.nashorn",
                                                 :name "tear-down-engine",
                                                 :signature ["[engine]"],
                                                 :name-encode "tear-down-engine",
                                                 :history [["+"
                                                            "1.10.63"]
                                                           ["-"
                                                            "1.10.738"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.repl.nashorn/tear-down-engine",
                                                 :source {:code "(defn tear-down-engine [engine]\n      (eval-str engine \"nashorn_tear_down();\"))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r1.10.597",
                                                          :filename "src/main/clojure/cljs/repl/nashorn.clj",
                                                          :lines [66
                                                                  67]},
                                                 :full-name "cljs.repl.nashorn/tear-down-engine",
                                                 :removed {:in "1.10.738",
                                                           :last-seen "1.10.597"}},
           "cljs.math/tanh" {:return-type number,
                             :ns "cljs.math",
                             :name "tanh",
                             :signature ["[x]"],
                             :name-encode "tanh",
                             :history [["+" "1.11.50"]],
                             :type "function",
                             :full-name-encode "cljs.math/tanh",
                             :source {:code "(defn ^number tanh\n  {:added \"1.11.10\"}\n  [x] (Math/tanh x))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/math.cljs",
                                      :lines [689 697]},
                             :full-name "cljs.math/tanh",
                             :docstring "Returns the hyperbolic tangent of x, sinh(x)/cosh(x).\nIf x is ##NaN => ##NaN\nIf x is zero => zero, with same sign\nIf x is ##Inf => +1.0\nIf x is ##-Inf => -1.0\nSee: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/tanh"},
           "cljs.spec.gen.alpha/string" {:ns "cljs.spec.gen.alpha",
                                         :name "string",
                                         :signature ["[& args]"],
                                         :name-encode "string",
                                         :history [["+" "1.9.542"]],
                                         :type "function",
                                         :full-name-encode "cljs.spec.gen.alpha/string",
                                         :source {:code "(lazy-prims any any-printable boolean char char-alpha char-alphanumeric char-ascii double\n  int keyword keyword-ns large-integer ratio simple-type simple-type-printable\n  string string-ascii string-alphanumeric symbol symbol-ns uuid)",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/cljs/cljs/spec/gen/alpha.cljs",
                                                  :lines [74 76]},
                                         :full-name "cljs.spec.gen.alpha/string",
                                         :docstring "Fn returning clojure.test.check.generators/string"},
           "cljs.spec/conformer" {:ns "cljs.spec",
                                  :name "conformer",
                                  :signature ["[f]" "[f unf]"],
                                  :name-encode "conformer",
                                  :history [["+" "1.9.14"]
                                            ["-" "1.9.542"]],
                                  :type "macro",
                                  :full-name-encode "cljs.spec/conformer",
                                  :source {:code "(defmacro conformer\n  ([f] `(spec-impl '(conformer ~(res &env f)) ~f nil true))\n  ([f unf] `(spec-impl '(conformer ~(res &env f) ~(res &env unf)) ~f nil true ~unf)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.9.521",
                                           :filename "src/main/cljs/cljs/spec.cljc",
                                           :lines [360 366]},
                                  :full-name "cljs.spec/conformer",
                                  :docstring "takes a predicate function with the semantics of conform i.e. it should return either a\n(possibly converted) value or :cljs.spec/invalid, and returns a\nspec that uses it as a predicate/conformer. Optionally takes a\nsecond fn that does unform of result of first",
                                  :removed {:in "1.9.542",
                                            :last-seen "1.9.521"}},
           "cljs.spec.gen.alpha/boolean" {:ns "cljs.spec.gen.alpha",
                                          :name "boolean",
                                          :signature ["[& args]"],
                                          :name-encode "boolean",
                                          :history [["+" "1.9.542"]],
                                          :type "function",
                                          :full-name-encode "cljs.spec.gen.alpha/boolean",
                                          :source {:code "(lazy-prims any any-printable boolean char char-alpha char-alphanumeric char-ascii double\n  int keyword keyword-ns large-integer ratio simple-type simple-type-printable\n  string string-ascii string-alphanumeric symbol symbol-ns uuid)",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/cljs/cljs/spec/gen/alpha.cljs",
                                                   :lines [74 76]},
                                          :full-name "cljs.spec.gen.alpha/boolean",
                                          :docstring "Fn returning clojure.test.check.generators/boolean"},
           "clojure.browser.dom/ensure-element" {:ns "clojure.browser.dom",
                                                 :name "ensure-element",
                                                 :signature ["[e]"],
                                                 :name-encode "ensure-element",
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.browser.dom/ensure-element",
                                                 :source {:code "(defn ensure-element\n  [e]\n  (cond (keyword? e) (get-element e)\n        (string? e) (html->dom e)\n        :else e))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r1.12.38",
                                                          :filename "src/main/cljs/clojure/browser/dom.cljs",
                                                          :lines [107
                                                                  112]},
                                                 :full-name "clojure.browser.dom/ensure-element",
                                                 :docstring "Coerce the argument to a dom element if possible."},
           "cljs.spec/spec" {:ns "cljs.spec",
                             :name "spec",
                             :signature ["[form & {:keys [gen]}]"],
                             :name-encode "spec",
                             :history [["+" "1.9.14"] ["-" "1.9.542"]],
                             :type "macro",
                             :full-name-encode "cljs.spec/spec",
                             :source {:code "(defmacro spec\n  [form & {:keys [gen]}]\n  (when form\n    `(spec-impl '~(res &env form) ~form ~gen nil)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.9.521",
                                      :filename "src/main/cljs/cljs/spec.cljc",
                                      :lines [67 84]},
                             :full-name "cljs.spec/spec",
                             :docstring "Takes a single predicate form, e.g. can be the name of a predicate,\nlike even?, or a fn literal like #(< % 42). Note that it is not\ngenerally necessary to wrap predicates in spec when using the rest\nof the spec macros, only to attach a unique generator\n\nCan also be passed the result of one of the regex ops -\ncat, alt, *, +, ?, in which case it will return a regex-conforming\nspec, useful when nesting an independent regex.\n---\n\nOptionally takes :gen generator-fn, which must be a fn of no args that\nreturns a test.check generator.\n\nReturns a spec.",
                             :removed {:in "1.9.542",
                                       :last-seen "1.9.521"}},
           "cljs.core/defmacro" {:ns "cljs.core",
                                 :name "defmacro",
                                 :signature ["[name doc-string? attr-map? [params*] body]"
                                             "[name doc-string? attr-map? ([params*] body) + attr-map?]"],
                                 :name-encode "defmacro",
                                 :history [["+" "0.0-927"]],
                                 :type "macro",
                                 :full-name-encode "cljs.core/defmacro",
                                 :source {:code "(core/defn defmacro\n  {:arglists '([name doc-string? attr-map? [params*] body]\n               [name doc-string? attr-map? ([params*] body)+ attr-map?])\n   :macro true}\n  [&form &env name & args]\n  (core/let [prefix (core/loop [p (core/list (vary-meta name assoc :macro true)) args args]\n                      (core/let [f (first args)]\n                        (if (core/string? f)\n                          (recur (cons f p) (next args))\n                          (if (map? f)\n                            (recur (cons f p) (next args))\n                            p))))\n             fdecl (core/loop [fd args]\n                     (if (core/string? (first fd))\n                       (recur (next fd))\n                       (if (map? (first fd))\n                         (recur (next fd))\n                         fd)))\n             fdecl (if (vector? (first fdecl))\n                     (core/list fdecl)\n                     fdecl)\n             add-implicit-args (core/fn [fd]\n                                 (core/let [args (first fd)]\n                                   (cons (vec (cons '&form (cons '&env args))) (next fd))))\n             add-args (core/fn [acc ds]\n                        (if (core/nil? ds)\n                          acc\n                          (core/let [d (first ds)]\n                            (if (map? d)\n                              (conj acc d)\n                              (recur (conj acc (add-implicit-args d)) (next ds))))))\n             fdecl (seq (add-args [] fdecl))\n             decl (core/loop [p prefix d fdecl]\n                    (if p\n                      (recur (next p) (cons (first p) d))\n                      d))]\n    `(let [ret# ~(cons `defn decl)]\n       (set! (. ~name ~'-cljs$lang$macro) true)\n       ret#)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/clojure/cljs/core.cljc",
                                          :lines [3383 3424]},
                                 :full-name "cljs.core/defmacro",
                                 :docstring "Like defn, but the resulting function name is declared as a\nmacro and will be used as a macro by the compiler when it is\ncalled."},
           "cljs.core/remove" {:ns "cljs.core",
                               :name "remove",
                               :signature ["[pred]" "[pred coll]"],
                               :name-encode "remove",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/remove",
                               :source {:code "(defn remove\n  ([pred] (filter (complement pred)))\n  ([pred coll]\n     (filter (complement pred) coll)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [5305 5311]},
                               :full-name "cljs.core/remove",
                               :docstring "Returns a lazy sequence of the items in coll for which\n(pred item) returns logical false. pred must be free of side-effects.\nReturns a transducer when no collection is provided."},
           "cljs.test/test-all-vars" {:ns "cljs.test",
                                      :name "test-all-vars",
                                      :signature ["[[quote ns :as form]]"],
                                      :name-encode "test-all-vars",
                                      :history [["+" "0.0-2496"]],
                                      :type "macro",
                                      :full-name-encode "cljs.test/test-all-vars",
                                      :source {:code "(defmacro test-all-vars\n  [[quote ns :as form]]\n  `(run-block\n     (concat (test-all-vars-block ~form)\n             [(fn []\n                (report {:type :end-test-all-vars :ns ~form}))])))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/test.cljc",
                                               :lines [359 366]},
                                      :full-name "cljs.test/test-all-vars",
                                      :docstring "Calls test-vars on every var with :test metadata interned in the\nnamespace, with fixtures."},
           "cljs.core/reset-vals!" {:ns "cljs.core",
                                    :name "reset-vals!",
                                    :signature ["[a new-value]"],
                                    :name-encode "reset-valsBANG",
                                    :history [["+" "1.9.946"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/reset-valsBANG",
                                    :source {:code "(defn reset-vals!\n  {:added \"1.9\"}\n  [a new-value]\n  (if (instance? Atom a)\n    (let [validate (.-validator a)]\n      (when-not (nil? validate)\n        (when-not (validate new-value)\n          (throw (js/Error. \"Validator rejected reference state\"))))\n      (let [old-value (.-state a)]\n        (set! (.-state a) new-value)\n        (when-not (nil? (.-watches a))\n          (-notify-watches a old-value new-value))\n        [old-value new-value]))\n    [(-deref a) (-reset! a new-value)]))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [4583 4598]},
                                    :full-name "cljs.core/reset-vals!",
                                    :docstring "Sets the value of atom to newval. Returns [old new], the value of the\natom before and after the reset."},
           "cljs.core/set-print-fn!" {:ns "cljs.core",
                                      :name "set-print-fn!",
                                      :signature ["[f]"],
                                      :name-encode "set-print-fnBANG",
                                      :history [["+" "0.0-1798"]],
                                      :type "function",
                                      :full-name-encode "cljs.core/set-print-fnBANG",
                                      :source {:code "(defn set-print-fn!\n  [f] (set! *print-fn* f))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [94 96]},
                                      :full-name "cljs.core/set-print-fn!",
                                      :docstring "Set *print-fn* to f."},
           "cljs.core/PersistentArrayMap.HASHMAP_THRESHOLD" {:ns "cljs.core",
                                                             :name "PersistentArrayMap.HASHMAP_THRESHOLD",
                                                             :name-encode "PersistentArrayMapDOTHASHMAP_THRESHOLD",
                                                             :history [["+"
                                                                        "0.0-1211"]
                                                                       ["-"
                                                                        "0.0-2301"]],
                                                             :parent-type "PersistentArrayMap",
                                                             :type "var",
                                                             :full-name-encode "cljs.core/PersistentArrayMapDOTHASHMAP_THRESHOLD",
                                                             :source {:code "(set! cljs.core.PersistentArrayMap.HASHMAP_THRESHOLD 8)",
                                                                      :title "Source code",
                                                                      :repo "clojurescript",
                                                                      :tag "r2280",
                                                                      :filename "src/cljs/cljs/core.cljs",
                                                                      :lines [4672]},
                                                             :full-name "cljs.core/PersistentArrayMap.HASHMAP_THRESHOLD",
                                                             :removed {:in "0.0-2301",
                                                                       :last-seen "0.0-2280"}},
           "cljs.math/pow" {:return-type number,
                            :ns "cljs.math",
                            :name "pow",
                            :signature ["[a b]"],
                            :name-encode "pow",
                            :history [["+" "1.11.50"]],
                            :type "function",
                            :full-name-encode "cljs.math/pow",
                            :source {:code "(defn ^number pow\n  {:added \"1.11.10\"}\n  [a b] (Math/pow a b))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/cljs/cljs/math.cljs",
                                     :lines [486 491]},
                            :full-name "cljs.math/pow",
                            :docstring "Returns the value of a raised to the power of b.\nFor more details on special cases, see:\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/pow"},
           "cljs.core/ns" {:ns "cljs.core",
                           :name "ns",
                           :signature ["[name docstring? attr-map? references*]"],
                           :name-encode "ns",
                           :history [["+" "0.0-927"]],
                           :type "special form",
                           :full-name-encode "cljs.core/ns",
                           :source {:code "(defmethod parse 'ns\n  [_ env [_ name & args :as form] _ opts]\n  (when-not *allow-ns*\n    (throw (error env \"Namespace declarations must appear at the top-level.\")))\n  (when-not (symbol? name)\n    (throw (error env \"Namespaces must be named by a symbol.\")))\n  (let [name (cond-> name (:macros-ns opts) macro-ns-name)]\n    (let [segments (string/split (clojure.core/name name) #\"\\.\")]\n      (when (= 1 (count segments))\n        (warning :single-segment-namespace env {:name name}))\n      (let [segment (some js-reserved segments)]\n        (when (some? segment)\n          (warning :munged-namespace env {:name name})))\n      (find-def-clash env name segments)\n      #?(:clj\n         (when (some (complement util/valid-js-id-start?) segments)\n           (throw\n             (AssertionError.\n               (str \"Namespace \" name \" has a segment starting with an invaild \"\n                    \"JavaScript identifier\"))))))\n    (let [docstring    (when (string? (first args)) (first args))\n          mdocstr      (-> name meta :doc)\n          args         (if (some? docstring) (next args) args)\n          metadata     (when (map? (first args)) (first args))\n          args         (desugar-ns-specs\n                         #?(:clj  (rewrite-cljs-aliases\n                                    (if metadata (next args) args))\n                            :cljs (if (some? metadata) (next args) args)))\n          {:keys [as-aliases] args :libspecs} (nses/elide-aliases-from-ns-specs args)\n          name         (vary-meta name merge metadata)\n          {excludes :excludes core-renames :renames} (parse-ns-excludes env args)\n          core-renames (reduce (fn [m [original renamed]]\n                                 (assoc m renamed (symbol \"cljs.core\" (str original))))\n                         {} core-renames)\n          deps         (atom [])\n          ;; as-aliases can only be used *once* because they are about the reader\n          aliases      (atom {:fns as-aliases :macros as-aliases})\n          spec-parsers {:require        (partial parse-require-spec env false deps aliases)\n                        :require-macros (partial parse-require-spec env true deps aliases)\n                        :use            (comp (partial parse-require-spec env false deps aliases)\n                                          (partial use->require env))\n                        :use-macros     (comp (partial parse-require-spec env true deps aliases)\n                                          (partial use->require env))\n                        :import         (partial parse-import-spec env deps)}\n          valid-forms  (atom #{:use :use-macros :require :require-macros :import})\n          reload       (atom {:use nil :require nil :use-macros nil :require-macros nil})\n          reloads      (atom {})\n          {uses :use requires :require renames :rename\n           use-macros :use-macros require-macros :require-macros\n           rename-macros :rename-macros imports :import :as params}\n          (reduce\n            (fn [m [k & libs :as libspec]]\n              (when-not (#{:use :use-macros :require :require-macros :import} k)\n                (throw (error env (str \"Only :refer-clojure, :require, :require-macros, :use, :use-macros, and :import libspecs supported. Got \" libspec \" instead.\"))))\n              (when-not (@valid-forms k)\n                (throw (error env (str \"Only one \" k \" form is allowed per namespace definition\"))))\n              (swap! valid-forms disj k)\n              ;; check for spec type reloads\n              (when-not (= :import k)\n                (when (some? (some #{:reload} libs))\n                  (swap! reload assoc k :reload))\n                (when (some? (some #{:reload-all} libs))\n                  (swap! reload assoc k :reload-all)))\n              ;; check for individual ns reloads from REPL interactions\n              (when-let [xs (seq (filter #(-> % meta :reload) libs))]\n                (swap! reloads assoc k\n                  (zipmap (map first xs) (map #(-> % meta :reload) xs))))\n              (apply merge-with merge m\n                (map (spec-parsers k)\n                  (remove #{:reload :reload-all} libs))))\n            {} (remove (fn [[r]] (= r :refer-clojure)) args))\n          ;; patch `require-macros` and `use-macros` in Bootstrap for namespaces\n          ;; that require their own macros\n          #?@(:cljs [[require-macros use-macros]\n                     (map (fn [spec-map]\n                            (if (:macros-ns opts)\n                              (let [ns (symbol (subs (str name) 0 (- (count (str name)) 7)))]\n                                (reduce (fn [m [k v]]\n                                          (cond-> m\n                                            (not (symbol-identical? v ns))\n                                            (assoc k v)))\n                                  {} spec-map))\n                              spec-map)) [require-macros use-macros])])]\n      (set! *cljs-ns* name)\n      (let [ns-info\n            {:as-aliases     as-aliases\n             :name           name\n             :doc            (or docstring mdocstr)\n             :excludes       excludes\n             :use-macros     use-macros\n             :require-macros require-macros\n             :rename-macros  rename-macros\n             :uses           uses\n             :requires       requires\n             :renames        (merge renames core-renames)\n             :imports        imports}]\n        (swap! env/*compiler* update-in [::namespaces name] merge ns-info)\n        (merge {:op      :ns\n                :env     env\n                :form    form\n                :deps    (into [] (distinct @deps))\n                :reload  @reload\n                :reloads @reloads}\n          (cond-> ns-info\n            (@reload :use)\n            (update-in [:uses]\n              (fn [m] (with-meta m {(@reload :use) true})))\n            (@reload :require)\n            (update-in [:requires]\n              (fn [m] (with-meta m {(@reload :require) true})))))))))",
                                    :title "Parser code",
                                    :repo "clojurescript",
                                    :tag "r1.12.38",
                                    :filename "src/main/clojure/cljs/analyzer.cljc",
                                    :lines [3241 3350]},
                           :extra-sources ({:code "(defmethod emit* :ns\n  [{:keys [name requires uses require-macros reloads env deps]}]\n  (emitln \"goog.provide('\" (munge name) \"');\")\n  (when-not (= name 'cljs.core)\n    (emitln \"goog.require('cljs.core');\")\n    (when (-> @env/*compiler* :options :emit-constants)\n      (emitln \"goog.require('\" (munge ana/constants-ns-sym) \"');\")))\n  (load-libs requires nil (:require reloads) deps name)\n  (load-libs uses requires (:use reloads) deps name))",
                                            :title "Emitting code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/clojure/cljs/compiler.cljc",
                                            :lines [1379 1387]}),
                           :full-name "cljs.core/ns",
                           :docstring "You must currently use the ns form only with the following caveats\n\n  * You must use the :only form of :use\n  * :require supports :as, :refer, and :rename\n    - all options can be skipped\n    - in this case a symbol can be used as a libspec directly\n      - that is, (:require lib.foo) and (:require [lib.foo]) are both\n        supported and mean the same thing\n    - :rename specifies a map from referred var names to different\n      symbols (and can be used to prevent clashes)\n    - prefix lists are not supported\n  * The only options for :refer-clojure are :exclude and :rename\n  * :import is available for importing Google Closure classes\n    - ClojureScript types and records should be brought in with :use\n      or :require :refer, not :import ed\n  * Macros must be defined in a different compilation stage than the one\n    from where they are consumed. One way to achieve this is to define\n    them in one namespace and use them from another. They are referenced\n    via the :require-macros / :use-macros options to ns\n    - :require-macros and :use-macros support the same forms that\n      :require and :use do\n\nImplicit macro loading: If a namespace is required or used, and that\nnamespace itself requires or uses macros from its own namespace, then\nthe macros will be implicitly required or used using the same\nspecifications. Furthermore, in this case, macro vars may be included\nin a :refer or :only spec. This oftentimes leads to simplified library\nusage, such that the consuming namespace need not be concerned about\nexplicitly distinguishing between whether certain vars are functions\nor macros. For example:\n\n(ns testme.core (:require [cljs.test :as test :refer [test-var deftest]]))\n\nwill result in test/is resolving properly, along with the test-var\nfunction and the deftest macro being available unqualified.\n\nInline macro specification: As a convenience, :require can be given\neither :include-macros true or :refer-macros [syms...]. Both desugar\ninto forms which explicitly load the matching Clojure file containing\nmacros. (This works independently of whether the namespace being\nrequired internally requires or uses its own macros.) For example:\n\n(ns testme.core\n(:require [foo.core :as foo :refer [foo-fn] :include-macros true]\n          [woz.core :as woz :refer [woz-fn] :refer-macros [app jx]]))\n\nis sugar for\n\n(ns testme.core\n(:require [foo.core :as foo :refer [foo-fn]]\n          [woz.core :as woz :refer [woz-fn]])\n(:require-macros [foo.core :as foo]\n                 [woz.core :as woz :refer [app jx]]))\n\nAuto-aliasing clojure namespaces: If a non-existing clojure.* namespace\nis required or used and a matching cljs.* namespace exists, the cljs.*\nnamespace will be loaded and an alias will be automatically established\nfrom the clojure.* namespace to the cljs.* namespace. For example:\n\n(ns testme.core (:require [clojure.test]))\n\nwill be automatically converted to\n\n(ns testme.core (:require [cljs.test :as clojure.test]))"},
           "cljs.core/if-not" {:ns "cljs.core",
                               :name "if-not",
                               :signature ["[test then]"
                                           "[test then else]"],
                               :name-encode "if-not",
                               :history [["+" "0.0-927"]],
                               :type "macro",
                               :full-name-encode "cljs.core/if-not",
                               :source {:code "(defmacro if-not\n  {:added \"1.0\"}\n  ([test then] `(if-not ~test ~then nil))\n  ([test then else]\n   `(if (not ~test) ~then ~else)))",
                                        :title "Source code",
                                        :repo "clojure",
                                        :tag "clojure-1.10.0",
                                        :filename "src/clj/clojure/core.clj",
                                        :lines [767 773]},
                               :full-name "cljs.core/if-not",
                               :docstring "Evaluates test. If logical false, evaluates and returns then expr, \notherwise else expr, if supplied, else nil."},
           "cljs.repl.reflect/macroexpand" {:ns "cljs.repl.reflect",
                                            :name "macroexpand",
                                            :signature ["[form]"],
                                            :name-encode "macroexpand",
                                            :history [["+" "0.0-1503"]],
                                            :type "function",
                                            :full-name-encode "cljs.repl.reflect/macroexpand",
                                            :source {:code "(defn macroexpand\n  [form]\n  (let [mform (analyzer/macroexpand-1 {} form)]\n    (if (identical? form mform)\n      mform\n      (macroexpand mform))))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/clojure/cljs/repl/reflect.clj",
                                                     :lines [40 46]},
                                            :full-name "cljs.repl.reflect/macroexpand",
                                            :docstring "Fully expands a cljs macro form."},
           "cljs.core/string-iter" {:ns "cljs.core",
                                    :name "string-iter",
                                    :signature ["[x]"],
                                    :name-encode "string-iter",
                                    :history [["+" "0.0-2301"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/string-iter",
                                    :source {:code "(defn string-iter [x]\n  (StringIter. x 0))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [4120 4121]},
                                    :full-name "cljs.core/string-iter"},
           "cljs.repl.browser/-main" {:ns "cljs.repl.browser",
                                      :name "-main",
                                      :signature ["[& args]"],
                                      :name-encode "-main",
                                      :history [["+" "0.0-3165"]],
                                      :type "function",
                                      :full-name-encode "cljs.repl.browser/-main",
                                      :source {:code "(defn -main [& args]\n  (apply cli/main repl-env args))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/clojure/cljs/repl/browser.clj",
                                               :lines [495 496]},
                                      :full-name "cljs.repl.browser/-main"},
           "cljs.core/set-print-err-fn!" {:ns "cljs.core",
                                          :name "set-print-err-fn!",
                                          :signature ["[f]"],
                                          :name-encode "set-print-err-fnBANG",
                                          :history [["+" "1.7.10"]],
                                          :type "function",
                                          :full-name-encode "cljs.core/set-print-err-fnBANG",
                                          :source {:code "(defn set-print-err-fn!\n  [f] (set! *print-err-fn* f))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/cljs/cljs/core.cljs",
                                                   :lines [98 100]},
                                          :full-name "cljs.core/set-print-err-fn!",
                                          :docstring "Set *print-err-fn* to f."},
           "compiler-options/closure-property-map-out" {:ns "compiler-options",
                                                        :name "closure-property-map-out",
                                                        :name-encode "closure-property-map-out",
                                                        :type "option",
                                                        :full-name-encode "compiler-options/closure-property-map-out",
                                                        :full-name "compiler-options/closure-property-map-out",
                                                        :history [["+"
                                                                   "1.10.63"]]},
           "repl-options/eval" {:ns "repl-options",
                                :name "eval",
                                :name-encode "eval",
                                :type "option",
                                :full-name-encode "repl-options/eval",
                                :full-name "repl-options/eval",
                                :history [["+" "0.0-2911"]]},
           "cljs.core/hash-double" {:ns "cljs.core",
                                    :name "hash-double",
                                    :signature ["[f]"],
                                    :name-encode "hash-double",
                                    :history [["+" "1.11.132"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/hash-double",
                                    :source {:code "(defn hash-double [f]\n  (let [arr  (doto (js/Float64Array. 1) (aset 0 f))\n        buf  (.-buffer arr)\n        high (.getInt32 (js/DataView. buf 0 4))\n        low  (.getInt32 (js/DataView. buf 4 4))]\n    (hash-long high low)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [966 971]},
                                    :full-name "cljs.core/hash-double"},
           "cljs.js/analyze*" {:ns "cljs.js",
                               :name "analyze*",
                               :signature ["[bound-vars source name opts cb]"],
                               :name-encode "analyzeSTAR",
                               :history [["+" "1.7.10"]
                                         ["-" "1.7.28"]],
                               :type "function",
                               :full-name-encode "cljs.js/analyzeSTAR",
                               :source {:code "(defn analyze* [bound-vars source name opts cb]\n  (let [rdr        (rt/indexing-push-back-reader source 1 name)\n        eof        (js-obj)\n        aenv       (ana/empty-env)\n        the-ns     (or (:ns opts) 'cljs.user)\n        bound-vars (cond-> (merge bound-vars {:*cljs-ns* the-ns})\n                     (:source-map opts) (assoc :*sm-data* (sm-data)))]\n    ((fn analyze-loop []\n       (binding [env/*compiler*         (:*compiler* bound-vars)\n                 ana/*cljs-ns*          (:*cljs-ns* bound-vars)\n                 *ns*                   (create-ns (:*cljs-ns* bound-vars))\n                 r/*data-readers*       (:*data-readers* bound-vars)\n                 comp/*source-map-data* (:*sm-data* bound-vars)]\n         (let [res (try\n                     {:value (r/read {:eof eof :read-cond :allow :features #{:cljs}} rdr)}\n                     (catch :default cause\n                       (wrap-error\n                         (ana/error aenv\n                           (str \"Could not analyze \" name) cause))))]\n           (if (:error res)\n             (cb res)\n             (let [form (:value res)]\n               (if-not (identical? eof form)\n                 (let [aenv (cond-> (assoc aenv :ns (ana/get-namespace ana/*cljs-ns*))\n                              (:context opts) (assoc :context (:context opts))\n                              (:def-emits-var opts) (assoc :def-emits-var true))\n                       res  (try\n                              {:value (ana/analyze aenv form nil opts)}\n                              (catch :default cause\n                                (wrap-error\n                                  (ana/error aenv\n                                    (str \"Could not analyze \" name) cause))))]\n                   (if (:error res)\n                     (cb res)\n                     (let [ast (:value res)]\n                       (if (= :ns (:op ast))\n                         (ns-side-effects bound-vars aenv ast opts\n                           (fn [res]\n                             (if (:error res)\n                               (cb res)\n                               (analyze-loop))))\n                         (recur)))))\n                 (cb {:value nil}))))))))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.7.10",
                                        :filename "src/main/cljs/cljs/js.cljs",
                                        :lines [379 421]},
                               :full-name "cljs.js/analyze*",
                               :removed {:in "1.7.28",
                                         :last-seen "1.7.10"}},
           "cljs.spec.impl.gen/double*" {:ns "cljs.spec.impl.gen",
                                         :name "double*",
                                         :signature ["[& args]"],
                                         :name-encode "doubleSTAR",
                                         :history [["+" "1.9.216"]
                                                   ["-" "1.9.542"]],
                                         :type "function",
                                         :full-name-encode "cljs.spec.impl.gen/doubleSTAR",
                                         :source {:code "(lazy-combinators hash-map list map not-empty set vector vector-distinct fmap elements\n  bind choose one-of such-that tuple sample return\n  large-integer* double* frequency)",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.9.521",
                                                  :filename "src/main/cljs/cljs/spec/impl/gen.cljs",
                                                  :lines [69 71]},
                                         :full-name "cljs.spec.impl.gen/double*",
                                         :docstring "Lazy loaded version of clojure.test.check.generators/double*",
                                         :removed {:in "1.9.542",
                                                   :last-seen "1.9.521"}},
           "cljs.test/assert-any" {:ns "cljs.test",
                                   :name "assert-any",
                                   :signature ["[msg form]"],
                                   :name-encode "assert-any",
                                   :history [["+" "1.8.51"]],
                                   :type "function",
                                   :full-name-encode "cljs.test/assert-any",
                                   :source {:code "(defn assert-any\n  [msg form]\n  (let [{:keys [file line end-line column end-column]} (meta form)]\n    `(let [value# ~form]\n       (if value#\n         (report\n          {:type :pass, :message ~msg,\n           :file ~file :line ~line :end-line ~end-line :column ~column :end-column ~end-column\n           :expected '~form, :actual value#})\n         (report\n          {:type :fail, :message ~msg,\n           :file ~file :line ~line :end-line ~end-line :column ~column :end-column ~end-column\n           :expected '~form, :actual value#}))\n       value#)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/test.cljc",
                                            :lines [48 63]},
                                   :full-name "cljs.test/assert-any",
                                   :docstring "Returns generic assertion code for any test, including macros, Java\nmethod calls, or isolated symbols."},
           "clojure.zip/path" {:ns "clojure.zip",
                               :name "path",
                               :signature ["[loc]"],
                               :name-encode "path",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip/path",
                               :source {:code "(defn path\n  [loc]\n    (:pnodes (loc 1)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/clojure/zip.cljs",
                                        :lines [82 85]},
                               :full-name "clojure.zip/path",
                               :docstring "Returns a seq of nodes leading to this loc"},
           "cljs.core/mapcat" {:ns "cljs.core",
                               :name "mapcat",
                               :signature ["[f]" "[f & colls]"],
                               :name-encode "mapcat",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/mapcat",
                               :source {:code "(defn mapcat\n  {:added \"1.0\"\n   :static true}\n  ([f] (comp (map f) cat))\n  ([f & colls]\n     (apply concat (apply map f colls))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [5266 5274]},
                               :full-name "cljs.core/mapcat",
                               :docstring "Returns the result of applying concat to the result of applying map\nto f and colls.  Thus function f should return a collection. Returns\na transducer when no collections are provided"},
           "cljs.repl.node/platform-path" {:ns "cljs.repl.node",
                                           :name "platform-path",
                                           :signature ["[v]"],
                                           :name-encode "platform-path",
                                           :history [["+" "0.0-2814"]],
                                           :type "function",
                                           :full-name-encode "cljs.repl.node/platform-path",
                                           :source {:code "(defn platform-path [v]\n  (str \"path.join.apply(null, \" (seq->js-array v) \")\"))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/clojure/cljs/repl/node.clj",
                                                    :lines [86 87]},
                                           :full-name "cljs.repl.node/platform-path"},
           "cljs.core/m3-mix-H1" {:return-type number,
                                  :ns "cljs.core",
                                  :name "m3-mix-H1",
                                  :signature ["[h1 k1]"],
                                  :name-encode "m3-mix-H1",
                                  :history [["+" "0.0-2261"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/m3-mix-H1",
                                  :source {:code "(defn ^number m3-mix-H1 [h1 k1]\n  (int (-> (int h1) (bit-xor (int k1)) (int-rotate-left 13) (imul 5) (+ (int 0xe6546b64)))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [944 945]},
                                  :full-name "cljs.core/m3-mix-H1"},
           "cljs.core/IWatchable" {:ns "cljs.core",
                                   :name "IWatchable",
                                   :name-encode "IWatchable",
                                   :implementations #{"Atom"},
                                   :history [["+" "0.0-927"]],
                                   :type "protocol",
                                   :full-name-encode "cljs.core/IWatchable",
                                   :source {:code "(defprotocol IWatchable\n  (-notify-watches [this oldval newval]\n    \"Calls all watchers with this, oldval and newval.\")\n  (-add-watch [this key f]\n    \"Adds a watcher function f to this. Keys must be unique per reference,\n     and can be used to remove the watch with -remove-watch.\")\n  (-remove-watch [this key]\n    \"Removes watcher that corresponds to key from this.\"))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [790 798]},
                                   :methods [{:name "-notify-watches",
                                              :signature ["[this oldval newval]"],
                                              :docstring "Calls all watchers with this, oldval and newval."}
                                             {:name "-add-watch",
                                              :signature ["[this key f]"],
                                              :docstring "Adds a watcher function f to this. Keys must be unique per reference,\n     and can be used to remove the watch with -remove-watch."}
                                             {:name "-remove-watch",
                                              :signature ["[this key]"],
                                              :docstring "Removes watcher that corresponds to key from this."}],
                                   :full-name "cljs.core/IWatchable",
                                   :docstring "Protocol for types that can be watched. Currently only implemented by Atom."},
           "cljs.core/PersistentHashMap.fromArray" {:ns "cljs.core",
                                                    :name "PersistentHashMap.fromArray",
                                                    :signature ["[arr no-clone]"],
                                                    :name-encode "PersistentHashMapDOTfromArray",
                                                    :history [["+"
                                                               "0.0-2719"]],
                                                    :parent-type "PersistentHashMap",
                                                    :type "function",
                                                    :full-name-encode "cljs.core/PersistentHashMapDOTfromArray",
                                                    :source {:code "(set! (.-fromArray PersistentHashMap)\n  (fn [arr ^boolean no-clone]\n    (let [arr (if no-clone arr (aclone arr))\n          len (alength arr)]\n      (loop [i 0 ret (transient (.-EMPTY PersistentHashMap))]\n        (if (< i len)\n          (recur (+ i 2)\n            (-assoc! ret (aget arr i) (aget arr (inc i))))\n          (-persistent! ret))))))",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r1.12.38",
                                                             :filename "src/main/cljs/cljs/core.cljs",
                                                             :lines [8231
                                                                     8239]},
                                                    :full-name "cljs.core/PersistentHashMap.fromArray"},
           "closure-warnings/unused-private-property" {:ns "closure-warnings",
                                                       :name "unused-private-property",
                                                       :name-encode "unused-private-property",
                                                       :type "warning",
                                                       :full-name-encode "closure-warnings/unused-private-property",
                                                       :full-name "closure-warnings/unused-private-property",
                                                       :history [["+"
                                                                  "1.9.473"]
                                                                 ["-"
                                                                  "1.12.35"]],
                                                       :removed {:in "1.12.35",
                                                                 :last-seen "1.11.132"}},
           "cljs.core/run!" {:ns "cljs.core",
                             :name "run!",
                             :signature ["[proc coll]"],
                             :name-encode "runBANG",
                             :history [["+" "0.0-2301"]],
                             :type "function",
                             :full-name-encode "cljs.core/runBANG",
                             :source {:code "(defn run!\n  [proc coll]\n  (reduce #(proc %2) nil coll)\n  nil)",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [11106 11111]},
                             :full-name "cljs.core/run!",
                             :docstring "Runs the supplied procedure (via reduce), for purposes of side\neffects, on successive items in the collection. Returns nil"},
           "warnings/variadic-max-arity" {:ns "warnings",
                                          :name "variadic-max-arity",
                                          :name-encode "variadic-max-arity",
                                          :type "warning",
                                          :full-name-encode "warnings/variadic-max-arity",
                                          :full-name "warnings/variadic-max-arity",
                                          :history [["+" "0.0-2014"]]},
           "cljs.repl.browser/es" {:ns "cljs.repl.browser",
                                   :name "es",
                                   :name-encode "es",
                                   :type "dynamic var",
                                   :full-name-encode "cljs.repl.browser/es",
                                   :source {:code "(def ^:dynamic es nil)",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/clojure/cljs/repl/browser.clj",
                                            :lines [29]},
                                   :full-name "cljs.repl.browser/es",
                                   :history [["+" "0.0-3148"]]},
           "cljs.spec.test.alpha/get-ua-product" {:ns "cljs.spec.test.alpha",
                                                  :name "get-ua-product",
                                                  :signature ["[]"],
                                                  :name-encode "get-ua-product",
                                                  :history [["+"
                                                             "1.9.542"]],
                                                  :type "function",
                                                  :full-name-encode "cljs.spec.test.alpha/get-ua-product",
                                                  :source {:code "(defn get-ua-product []\n  (if (not= \"browser\" *target*)\n    (keyword *target*)\n    (cond\n      product/SAFARI :safari\n      product/CHROME :chrome\n      product/FIREFOX :firefox\n      product/IE :ie)))",
                                                           :title "Source code",
                                                           :repo "clojurescript",
                                                           :tag "r1.12.38",
                                                           :filename "src/main/cljs/cljs/spec/test/alpha.cljs",
                                                           :lines [49
                                                                   56]},
                                                  :full-name "cljs.spec.test.alpha/get-ua-product"},
           "cljs.core/coercive-not=" {:ns "cljs.core",
                                      :name "coercive-not=",
                                      :signature ["[x y]"],
                                      :name-encode "coercive-notEQ",
                                      :history [["+" "0.0-1211"]
                                                ["-" "1.9.493"]
                                                ["+" "1.9.494"]],
                                      :type "macro",
                                      :full-name-encode "cljs.core/coercive-notEQ",
                                      :source {:code "(core/defmacro coercive-not= [x y]\n  (bool-expr (core/list 'js* \"(~{} != ~{})\" x y)))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/clojure/cljs/core.cljc",
                                               :lines [908 909]},
                                      :full-name "cljs.core/coercive-not="},
           "cljs.spec.alpha/exercise" {:ns "cljs.spec.alpha",
                                       :name "exercise",
                                       :signature ["[spec]"
                                                   "[spec n]"
                                                   "[spec n overrides]"],
                                       :name-encode "exercise",
                                       :history [["+" "1.9.542"]],
                                       :type "function",
                                       :full-name-encode "cljs.spec.alpha/exercise",
                                       :source {:code "(defn exercise\n  ([spec] (exercise spec 10))\n  ([spec n] (exercise spec n nil))\n  ([spec n overrides]\n   (map #(vector % (conform spec %)) (gen/sample (gen spec overrides) n))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/spec/alpha.cljs",
                                                :lines [1436 1443]},
                                       :full-name "cljs.spec.alpha/exercise",
                                       :docstring "generates a number (default 10) of values compatible with spec and maps conform over them,\nreturning a sequence of [val conformed-val] tuples. Optionally takes\na generator overrides map as per gen"},
           "compiler-options/preamble" {:ns "compiler-options",
                                        :name "preamble",
                                        :name-encode "preamble",
                                        :type "option",
                                        :full-name-encode "compiler-options/preamble",
                                        :full-name "compiler-options/preamble",
                                        :history [["+" "0.0-2127"]]},
           "cljs.core/IndexedSeqIterator" {:ns "cljs.core",
                                           :name "IndexedSeqIterator",
                                           :signature ["[arr i]"],
                                           :name-encode "IndexedSeqIterator",
                                           :history [["+" "0.0-2371"]],
                                           :type "type",
                                           :full-name-encode "cljs.core/IndexedSeqIterator",
                                           :source {:code "(deftype IndexedSeqIterator [arr ^:mutable i]\n  Object\n  (hasNext [_]\n    (< i (alength arr)))\n  (next [_]\n    (let [ret (aget arr i)]\n      (set! i (inc i))\n      ret)))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/cljs/cljs/core.cljs",
                                                    :lines [1606 1613]},
                                           :full-name "cljs.core/IndexedSeqIterator"},
           "cljs.core/unchecked-inc-int" {:ns "cljs.core",
                                          :name "unchecked-inc-int",
                                          :signature ["[x]"],
                                          :name-encode "unchecked-inc-int",
                                          :history [["+" "0.0-1798"]],
                                          :type "function/macro",
                                          :full-name-encode "cljs.core/unchecked-inc-int",
                                          :source {:code "(defn unchecked-inc-int [x]\n  (cljs.core/unchecked-inc-int x))",
                                                   :title "Function code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/cljs/cljs/core.cljs",
                                                   :lines [2839 2840]},
                                          :extra-sources [{:code "(core/defmacro ^::ana/numeric unchecked-inc-int\n  ([x] `(inc ~x)))",
                                                           :title "Macro code",
                                                           :repo "clojurescript",
                                                           :tag "r1.12.38",
                                                           :filename "src/main/clojure/cljs/core.cljc",
                                                           :lines [1095
                                                                   1096]}],
                                          :full-name "cljs.core/unchecked-inc-int"},
           "cljs.spec.test/with-instrument-disabled" {:ns "cljs.spec.test",
                                                      :name "with-instrument-disabled",
                                                      :signature ["[& body]"],
                                                      :name-encode "with-instrument-disabled",
                                                      :history [["+"
                                                                 "1.9.183"]
                                                                ["-"
                                                                 "1.9.542"]],
                                                      :type "macro",
                                                      :full-name-encode "cljs.spec.test/with-instrument-disabled",
                                                      :source {:code "(defmacro with-instrument-disabled\n  [& body]\n  `(binding [*instrument-enabled* nil]\n     ~@body))",
                                                               :title "Source code",
                                                               :repo "clojurescript",
                                                               :tag "r1.9.521",
                                                               :filename "src/main/cljs/cljs/spec/test.cljc",
                                                               :lines [29
                                                                       33]},
                                                      :full-name "cljs.spec.test/with-instrument-disabled",
                                                      :docstring "Disables instrument's checking of calls, within a scope.",
                                                      :removed {:in "1.9.542",
                                                                :last-seen "1.9.521"}},
           "cljs.spec.alpha/double-in" {:ns "cljs.spec.alpha",
                                        :name "double-in",
                                        :signature ["[& {:keys [infinite? NaN? min max], :or {infinite? true, NaN? true}, :as m}]"],
                                        :name-encode "double-in",
                                        :history [["+" "1.9.542"]],
                                        :type "macro",
                                        :full-name-encode "cljs.spec.alpha/double-in",
                                        :source {:code "(defmacro double-in\n  [& {:keys [infinite? NaN? min max]\n      :or {infinite? true NaN? true}\n      :as m}]\n  `(spec (and c/double?\n           ~@(when-not infinite? '[#(not (infinite? %))])\n           ~@(when-not NaN? '[#(not (js/isNaN %))])\n           ~@(when max `[#(<= % ~max)])\n           ~@(when min `[#(<= ~min %)]))\n     :gen #(gen/double* ~m)))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/cljs/cljs/spec/alpha.cljc",
                                                 :lines [495 510]},
                                        :full-name "cljs.spec.alpha/double-in",
                                        :docstring "Specs a 64-bit floating point number. Options:\n\n :infinite? - whether +/- infinity allowed (default true)\n :NaN?      - whether NaN allowed (default true)\n :min       - minimum value (inclusive, default none)\n :max       - maximum value (inclusive, default none)"},
           "cljs.test/testing-vars-str" {:ns "cljs.test",
                                         :name "testing-vars-str",
                                         :signature ["[m]"],
                                         :name-encode "testing-vars-str",
                                         :history [["+" "0.0-2496"]],
                                         :type "function",
                                         :full-name-encode "cljs.test/testing-vars-str",
                                         :source {:code "(defn testing-vars-str\n  [m]\n  (let [{:keys [file line column]} m]\n    (str\n      (reverse (map #(:name (meta %)) (:testing-vars (get-current-env))))\n      \" (\" file \":\" line (when column (str \":\" column)) \")\")))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/cljs/cljs/test.cljs",
                                                  :lines [289 297]},
                                         :full-name "cljs.test/testing-vars-str",
                                         :docstring "Returns a string representation of the current test.  Renders names\nin *testing-vars* as a list, then the source file and line of\ncurrent assertion."},
           "clojure.zip/rightmost" {:ns "clojure.zip",
                                    :name "rightmost",
                                    :signature ["[loc]"],
                                    :name-encode "rightmost",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "clojure.zip/rightmost",
                                    :source {:code "(defn rightmost\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (if (and path r)\n        (with-meta [(last r) (assoc path :l (apply conj l node (butlast r)) :r nil)] (meta loc))\n        loc)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/clojure/zip.cljs",
                                             :lines [142 148]},
                                    :full-name "clojure.zip/rightmost",
                                    :docstring "Returns the loc of the rightmost sibling of the node at this loc, or self"},
           "cljs.core/PersistentArrayMap.EMPTY" {:ns "cljs.core",
                                                 :name "PersistentArrayMap.EMPTY",
                                                 :name-encode "PersistentArrayMapDOTEMPTY",
                                                 :history [["+"
                                                            "0.0-1211"]],
                                                 :parent-type "PersistentArrayMap",
                                                 :type "var",
                                                 :full-name-encode "cljs.core/PersistentArrayMapDOTEMPTY",
                                                 :source {:code "(set! (.-EMPTY PersistentArrayMap) (PersistentArrayMap. nil 0 (array) empty-unordered-hash))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r1.12.38",
                                                          :filename "src/main/cljs/cljs/core.cljs",
                                                          :lines [7145]},
                                                 :full-name "cljs.core/PersistentArrayMap.EMPTY"},
           "cljs.core/m3-C2" {:ns "cljs.core",
                              :name "m3-C2",
                              :name-encode "m3-C2",
                              :type "var",
                              :full-name-encode "cljs.core/m3-C2",
                              :source {:code "(def m3-C2 (int 0x1b873593))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [939]},
                              :full-name "cljs.core/m3-C2",
                              :history [["+" "0.0-2261"]]},
           "cljs.core/uuid?" {:ns "cljs.core",
                              :name "uuid?",
                              :signature ["[x]"],
                              :name-encode "uuidQMARK",
                              :history [["+" "1.9.75"]],
                              :type "function",
                              :full-name-encode "cljs.core/uuidQMARK",
                              :source {:code "(defn uuid?\n  [x] (implements? IUUID x))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [11762 11764]},
                              :full-name "cljs.core/uuid?",
                              :docstring "Return true if x is a UUID."},
           "cljs.repl.server/read-request" {:ns "cljs.repl.server",
                                            :name "read-request",
                                            :signature ["[rdr]"],
                                            :name-encode "read-request",
                                            :history [["+" "0.0-1503"]],
                                            :type "function",
                                            :full-name-encode "cljs.repl.server/read-request",
                                            :source {:code "(defn read-request [rdr]\n  (if-let [line (.readLine rdr)]\n    (cond\n      (.startsWith line \"POST\") (read-post line rdr)\n      (.startsWith line \"GET\") (read-get line rdr)\n      :else {:method :unknown :content line})\n    {:method :unknown :content nil}))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/clojure/cljs/repl/server.clj",
                                                     :lines [118 124]},
                                            :full-name "cljs.repl.server/read-request"},
           "cljs.test/compose-fixtures" {:ns "cljs.test",
                                         :name "compose-fixtures",
                                         :signature ["[f1 f2]"],
                                         :name-encode "compose-fixtures",
                                         :history [["+" "0.0-2496"]],
                                         :type "function",
                                         :full-name-encode "cljs.test/compose-fixtures",
                                         :source {:code "(defn compose-fixtures\n  [f1 f2]\n  (fn [g] (f1 (fn [] (f2 g)))))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/cljs/cljs/test.cljs",
                                                  :lines [509 515]},
                                         :full-name "cljs.test/compose-fixtures",
                                         :docstring "Composes two fixture functions, creating a new fixture function\nthat combines their behavior.\n\nNOTE: Incompatible with map fixtures."},
           "cljs.repl/load-file" {:ns "cljs.repl",
                                  :name "load-file",
                                  :signature ["[repl-env f]"
                                              "[repl-env f opts]"],
                                  :name-encode "load-file",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.repl/load-file",
                                  :source {:code "(defn load-file\n  ([repl-env f] (load-file repl-env f *repl-opts*))\n  ([repl-env f opts]\n    (if (:output-dir opts)\n      (let [src (cond\n                  (util/url? f) f\n                  (.exists (io/file f)) (io/file f)\n                  :else (io/resource f))\n            compiled (binding [ana/*reload-macros* true]\n                       (cljsc/handle-js-modules opts\n                         (deps/dependency-order\n                           (cljsc/add-dependency-sources [(ana/parse-ns src)] opts))\n                         env/*compiler*)\n                       (cljsc/compile src\n                         (assoc opts\n                           :output-file (cljsc/src-file->target-file src)\n                           :force true\n                           :mode :interactive)))]\n        ;; copy over the original source file if source maps enabled\n        (when-let [ns (and (:source-map opts) (first (:provides compiled)))]\n          (spit\n            (io/file (io/file (util/output-directory opts))\n              (util/ns->relpath ns (util/ext (:source-url compiled))))\n            (slurp src)))\n        ;; need to load dependencies first\n        (let [sources (load-dependencies repl-env (:requires compiled) opts)]\n          (load-cljs-loader repl-env (conj sources compiled) opts))\n        (-evaluate repl-env f 1 (cljsc/add-dep-string opts compiled))\n        (-evaluate repl-env f 1\n          (cljsc/src-file->goog-require src\n            {:wrap true :reload true :macros-ns (:macros-ns compiled)})))\n      (binding [ana/*cljs-ns* ana/*cljs-ns*]\n        (let [res (if (= File/separatorChar (first f)) f (io/resource f))]\n          (assert res (str \"Can't find \" f \" in classpath\"))\n          (load-stream repl-env f res))))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/clojure/cljs/repl.cljc",
                                           :lines [592 626]},
                                  :full-name "cljs.repl/load-file"},
           "cljs.analyzer.api/with-passes" {:ns "cljs.analyzer.api",
                                            :name "with-passes",
                                            :signature ["[passes & body]"],
                                            :name-encode "with-passes",
                                            :history [["+" "1.10.738"]],
                                            :type "macro",
                                            :full-name-encode "cljs.analyzer.api/with-passes",
                                            :source {:code "(defmacro with-passes\n  [passes & body]\n  `(binding [ana/*passes* ~passes]\n     ~@body))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/clojure/cljs/analyzer/api.cljc",
                                                     :lines [119 123]},
                                            :full-name "cljs.analyzer.api/with-passes",
                                            :docstring "Evaluate the body with the provided sequence of compiler passes."},
           "closure-warnings/check-regexp" {:ns "closure-warnings",
                                            :name "check-regexp",
                                            :name-encode "check-regexp",
                                            :type "warning",
                                            :full-name-encode "closure-warnings/check-regexp",
                                            :full-name "closure-warnings/check-regexp",
                                            :history [["+" "0.0-2120"]]},
           "closure-warnings/missing-polyfill" {:ns "closure-warnings",
                                                :name "missing-polyfill",
                                                :name-encode "missing-polyfill",
                                                :type "warning",
                                                :full-name-encode "closure-warnings/missing-polyfill",
                                                :full-name "closure-warnings/missing-polyfill",
                                                :history [["+"
                                                           "1.9.473"]]},
           "compiler-options/closure-warnings" {:ns "compiler-options",
                                                :name "closure-warnings",
                                                :name-encode "closure-warnings",
                                                :type "option",
                                                :full-name-encode "compiler-options/closure-warnings",
                                                :full-name "compiler-options/closure-warnings",
                                                :sub-options-ns "closure-warnings",
                                                :history [["+"
                                                           "0.0-2120"]]},
           "cljs.core/unchecked-subtract" {:return-type number,
                                           :ns "cljs.core",
                                           :name "unchecked-subtract",
                                           :signature ["[x]"
                                                       "[x y]"
                                                       "[x y & more]"],
                                           :name-encode "unchecked-subtract",
                                           :history [["+" "0.0-1798"]],
                                           :type "function/macro",
                                           :full-name-encode "cljs.core/unchecked-subtract",
                                           :source {:code "(defn ^number unchecked-subtract\n  ([x] (cljs.core/unchecked-subtract x))\n  ([x y] (cljs.core/unchecked-subtract x y))\n  ([x y & more] (reduce unchecked-subtract (cljs.core/unchecked-subtract x y) more)))",
                                                    :title "Function code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/cljs/cljs/core.cljs",
                                                    :lines [2867 2872]},
                                           :extra-sources [{:code "(core/defmacro ^::ana/numeric unchecked-subtract\n  ([& xs] `(- ~@xs)))",
                                                            :title "Macro code",
                                                            :repo "clojurescript",
                                                            :tag "r1.12.38",
                                                            :filename "src/main/clojure/cljs/core.cljc",
                                                            :lines [1113
                                                                    1114]}],
                                           :full-name "cljs.core/unchecked-subtract",
                                           :docstring "If no ys are supplied, returns the negation of x, else subtracts\nthe ys from x and returns the result."},
           "clojure.core.protocols/Datafiable" {:ns "clojure.core.protocols",
                                                :name "Datafiable",
                                                :name-encode "Datafiable",
                                                :history [["+"
                                                           "1.10.514"]],
                                                :type "protocol",
                                                :full-name-encode "clojure.core.protocols/Datafiable",
                                                :source {:code "(defprotocol Datafiable\n  :extend-via-metadata true\n  (datafy [o] \"return a representation of o as data (default identity)\"))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1.12.38",
                                                         :filename "src/main/cljs/clojure/core/protocols.cljs",
                                                         :lines [11
                                                                 13]},
                                                :methods [{:name "datafy",
                                                           :signature ["[o]"],
                                                           :docstring "return a representation of o as data (default identity)"}],
                                                :full-name "clojure.core.protocols/Datafiable"},
           "cljs.repl/IParseErrorMessage" {:ns "cljs.repl",
                                           :name "IParseErrorMessage",
                                           :name-encode "IParseErrorMessage",
                                           :history [["+" "0.0-2985"]
                                                     ["-" "0.0-3030"]],
                                           :type "protocol",
                                           :full-name-encode "cljs.repl/IParseErrorMessage",
                                           :source {:code "(defprotocol IParseErrorMessage\n  (-parse-error-message [repl-env message error build-options]\n    \"Given the original JavaScript error message return the string to actually\n     use.\"))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2985",
                                                    :filename "src/clj/cljs/repl.clj",
                                                    :lines [112 115]},
                                           :methods [{:name "-parse-error-message",
                                                      :signature ["[repl-env message error build-options]"],
                                                      :docstring "Given the original JavaScript error message return the string to actually\n     use."}],
                                           :full-name "cljs.repl/IParseErrorMessage",
                                           :removed {:in "0.0-3030",
                                                     :last-seen "0.0-2985"}},
           "cljs.js/load-macros" {:ns "cljs.js",
                                  :name "load-macros",
                                  :signature ["[bound-vars k macros reload reloads opts cb]"],
                                  :name-encode "load-macros",
                                  :history [["+" "1.7.10"]
                                            ["-" "1.7.28"]],
                                  :type "function",
                                  :full-name-encode "cljs.js/load-macros",
                                  :source {:code "(defn load-macros [bound-vars k macros reload reloads opts cb]\n  (if (seq macros)\n    (let [nsym (first (vals macros))\n          k    (or (k reload)\n                   (get-in reloads [k nsym])\n                   (and (= nsym name) (:*reload-macros* bound-vars) :reload))]\n      (require bound-vars nsym k\n        (-> opts\n          (assoc :macros-ns true)\n          (dissoc :context)\n          (dissoc :ns))\n        (fn [res]\n          (if-not (:error res)\n            (load-macros bound-vars k (next macros) reload reloads opts cb)\n            (cb res)))))\n    (cb {:value nil})))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.10",
                                           :filename "src/main/cljs/cljs/js.cljs",
                                           :lines [300 315]},
                                  :full-name "cljs.js/load-macros",
                                  :removed {:in "1.7.28",
                                            :last-seen "1.7.10"}},
           "cljs.repl.nashorn/eval-str" {:ns "cljs.repl.nashorn",
                                         :name "eval-str",
                                         :signature ["[engine s]"],
                                         :name-encode "eval-str",
                                         :history [["+" "0.0-2814"]
                                                   ["-" "1.10.738"]],
                                         :type "function",
                                         :full-name-encode "cljs.repl.nashorn/eval-str",
                                         :source {:code "(defn eval-str [^ScriptEngine engine ^String s]\n      (.eval engine s))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.10.597",
                                                  :filename "src/main/clojure/cljs/repl/nashorn.clj",
                                                  :lines [45 46]},
                                         :full-name "cljs.repl.nashorn/eval-str",
                                         :removed {:in "1.10.738",
                                                   :last-seen "1.10.597"}},
           "closure-warnings/missing-getcssname" {:ns "closure-warnings",
                                                  :name "missing-getcssname",
                                                  :name-encode "missing-getcssname",
                                                  :type "warning",
                                                  :full-name-encode "closure-warnings/missing-getcssname",
                                                  :full-name "closure-warnings/missing-getcssname",
                                                  :history [["+"
                                                             "1.9.473"]
                                                            ["-"
                                                             "1.10.844"]],
                                                  :removed {:in "1.10.844",
                                                            :last-seen "1.10.773"}},
           "cljs.core/->" {:ns "cljs.core",
                           :name "->",
                           :signature ["[x & forms]"],
                           :name-encode "-GT",
                           :history [["+" "0.0-927"]],
                           :type "macro",
                           :full-name-encode "cljs.core/-GT",
                           :source {:code "(defmacro ->\n  {:added \"1.0\"}\n  [x & forms]\n  (loop [x x, forms forms]\n    (if forms\n      (let [form (first forms)\n            threaded (if (seq? form)\n                       (with-meta `(~(first form) ~x ~@(next form)) (meta form))\n                       (list form x))]\n        (recur threaded (next forms)))\n      x)))",
                                    :title "Source code",
                                    :repo "clojure",
                                    :tag "clojure-1.10.0",
                                    :filename "src/clj/clojure/core.clj",
                                    :lines [1677 1691]},
                           :full-name "cljs.core/->",
                           :docstring "Threads the expr through the forms. Inserts x as the\nsecond item in the first form, making a list of it if it is not a\nlist already. If there are more forms, inserts the first form as the\nsecond item in second form, etc."},
           "cljs.core/remove-all-methods" {:ns "cljs.core",
                                           :name "remove-all-methods",
                                           :signature ["[multifn]"],
                                           :name-encode "remove-all-methods",
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core/remove-all-methods",
                                           :source {:code "(defn remove-all-methods\n  [multifn]\n (-reset multifn))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/cljs/cljs/core.cljs",
                                                    :lines [11671
                                                            11674]},
                                           :full-name "cljs.core/remove-all-methods",
                                           :docstring "Removes all of the methods of multimethod."},
           "cljs.spec.gen.alpha/simple-type-printable" {:ns "cljs.spec.gen.alpha",
                                                        :name "simple-type-printable",
                                                        :signature ["[& args]"],
                                                        :name-encode "simple-type-printable",
                                                        :history [["+"
                                                                   "1.9.542"]],
                                                        :type "function",
                                                        :full-name-encode "cljs.spec.gen.alpha/simple-type-printable",
                                                        :source {:code "(lazy-prims any any-printable boolean char char-alpha char-alphanumeric char-ascii double\n  int keyword keyword-ns large-integer ratio simple-type simple-type-printable\n  string string-ascii string-alphanumeric symbol symbol-ns uuid)",
                                                                 :title "Source code",
                                                                 :repo "clojurescript",
                                                                 :tag "r1.12.38",
                                                                 :filename "src/main/cljs/cljs/spec/gen/alpha.cljs",
                                                                 :lines [74
                                                                         76]},
                                                        :full-name "cljs.spec.gen.alpha/simple-type-printable",
                                                        :docstring "Fn returning clojure.test.check.generators/simple-type-printable"},
           "cljs.core/unchecked-add-int" {:return-type number,
                                          :ns "cljs.core",
                                          :name "unchecked-add-int",
                                          :signature ["[]"
                                                      "[x]"
                                                      "[x y]"
                                                      "[x y & more]"],
                                          :name-encode "unchecked-add-int",
                                          :history [["+" "0.0-1798"]],
                                          :type "function/macro",
                                          :full-name-encode "cljs.core/unchecked-add-int",
                                          :source {:code "(defn ^number unchecked-add-int\n  ([] 0)\n  ([x] x)\n  ([x y] (cljs.core/unchecked-add-int x y))\n  ([x y & more] (reduce unchecked-add-int (cljs.core/unchecked-add-int x y) more)))",
                                                   :title "Function code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/cljs/cljs/core.cljs",
                                                   :lines [2812 2817]},
                                          :extra-sources [{:code "(core/defmacro ^::ana/numeric unchecked-add-int\n  ([& xs] `(+ ~@xs)))",
                                                           :title "Macro code",
                                                           :repo "clojurescript",
                                                           :tag "r1.12.38",
                                                           :filename "src/main/clojure/cljs/core.cljc",
                                                           :lines [1080
                                                                   1081]}],
                                          :full-name "cljs.core/unchecked-add-int",
                                          :docstring "Returns the sum of nums. (+) returns 0."},
           "clojure.string/replace-first" {:return-type string,
                                           :ns "clojure.string",
                                           :name "replace-first",
                                           :signature ["[s match replacement]"],
                                           :name-encode "replace-first",
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "clojure.string/replace-first",
                                           :source {:code "(defn ^string replace-first\n  [s match replacement]\n  (.replace s match replacement))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/cljs/clojure/string.cljs",
                                                    :lines [76 98]},
                                           :full-name "clojure.string/replace-first",
                                           :docstring "Replaces the first instance of match with replacement in s.\n\nmatch/replacement can be:\n\nstring / string\npattern / (string or function of match).\n\nSee also replace.\n\nThe replacement is literal (i.e. none of its characters are treated\nspecially) for all cases above except pattern / string.\n\nFor pattern / string, $1, $2, etc. in the replacement string are\nsubstituted with the string that matched the corresponding\nparenthesized group in the pattern.\n\nExample:\n(clojure.string/replace-first \"swap first two words\"\n                              #\"(\\w+)(\\s+)(\\w+)\" \"$3$2$1\")\n-> \"first swap two words\""},
           "cljs.core/reduced?" {:ns "cljs.core",
                                 :name "reduced?",
                                 :signature ["[r]"],
                                 :name-encode "reducedQMARK",
                                 :history [["+" "0.0-1211"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/reducedQMARK",
                                 :source {:code "(defn reduced?\n  [r]\n  (instance? Reduced r))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [1482 1485]},
                                 :full-name "cljs.core/reduced?",
                                 :docstring "Returns true if x is the result of a call to reduced"},
           "clojure.browser.dom/get-value" {:ns "clojure.browser.dom",
                                            :name "get-value",
                                            :signature ["[e]"],
                                            :name-encode "get-value",
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "clojure.browser.dom/get-value",
                                            :source {:code "(defn get-value\n  [e]\n  (.-value (ensure-element e)))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/cljs/clojure/browser/dom.cljs",
                                                     :lines [131 134]},
                                            :full-name "clojure.browser.dom/get-value",
                                            :docstring "Get the value of an element."},
           "clojure.core.reducers/CollFold" {:ns "clojure.core.reducers",
                                             :name "CollFold",
                                             :name-encode "CollFold",
                                             :history [["+"
                                                        "0.0-2120"]],
                                             :type "protocol",
                                             :full-name-encode "clojure.core.reducers/CollFold",
                                             :source {:code "(defprotocol CollFold\n  (coll-fold [coll n combinef reducef]))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.12.38",
                                                      :filename "src/main/cljs/clojure/core/reducers.cljs",
                                                      :lines [46 47]},
                                             :methods [{:name "coll-fold",
                                                        :signature ["[coll n combinef reducef]"],
                                                        :docstring nil}],
                                             :full-name "clojure.core.reducers/CollFold"},
           "compiler-options/nodejs-rt" {:ns "compiler-options",
                                         :name "nodejs-rt",
                                         :name-encode "nodejs-rt",
                                         :type "option",
                                         :full-name-encode "compiler-options/nodejs-rt",
                                         :full-name "compiler-options/nodejs-rt",
                                         :history [["+" "1.10.738"]]},
           "cljs.core/Iterate" {:protocols #{"ISeqable"
                                             "IMeta"
                                             "IWithMeta"
                                             "IEmptyableCollection"
                                             "IPending"
                                             "IReduce"
                                             "ISequential"
                                             "ISeq"
                                             "ICollection"
                                             "IPrintWithWriter"
                                             "INext"},
                                :ns "cljs.core",
                                :name "Iterate",
                                :signature ["[meta f prev-seed seed next]"],
                                :name-encode "Iterate",
                                :history [["+" "1.10.63"]],
                                :type "type",
                                :full-name-encode "cljs.core/Iterate",
                                :source {:code "(deftype Iterate [meta f prev-seed ^:mutable seed ^:mutable next]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n\n  IPending\n  (-realized? [coll]\n    (not (identical? seed UNREALIZED-SEED)))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (Iterate. new-meta f prev-seed seed next)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll]\n    (when (identical? UNREALIZED-SEED seed)\n      (set! seed (f prev-seed)))\n    seed)\n  (-rest [coll]\n    (when (nil? next)\n      (set! next (Iterate. nil f (-first coll) UNREALIZED-SEED nil)))\n    next)\n\n  INext\n  (-next [coll]\n    (-rest coll))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (.-EMPTY List))\n\n  ISequential\n  ISeqable\n  (-seq [coll] coll)\n\n  IReduce\n  (-reduce [coll rf]\n    (let [first (-first coll)\n          v     (f first)]\n      (loop [ret (rf first v) v v]\n        (if (reduced? ret)\n          @ret\n          (let [v (f v)]\n            (recur (rf ret v) v))))))\n  (-reduce [coll rf start]\n    (let [v (-first coll)]\n      (loop [ret (rf start v) v v]\n        (if (reduced? ret)\n          @ret\n          (let [v (f v)]\n            (recur (rf ret v) v)))))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [5150 5207]},
                                :full-name "cljs.core/Iterate"},
           "cljs.nodejs/process" {:ns "cljs.nodejs",
                                  :name "process",
                                  :name-encode "process",
                                  :type "var",
                                  :full-name-encode "cljs.nodejs/process",
                                  :source {:code "(def process (js* \"process\"))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/nodejs.cljs",
                                           :lines [17]},
                                  :full-name "cljs.nodejs/process",
                                  :history [["+" "0.0-927"]]},
           "cljs.core/some->>" {:ns "cljs.core",
                                :name "some->>",
                                :signature ["[expr & forms]"],
                                :name-encode "some-GTGT",
                                :history [["+" "0.0-1798"]],
                                :type "macro",
                                :full-name-encode "cljs.core/some-GTGT",
                                :source {:code "(defmacro some->>\n  {:added \"1.5\"}\n  [expr & forms]\n  (let [g (gensym)\n        steps (map (fn [step] `(if (nil? ~g) nil (->> ~g ~step)))\n                   forms)]\n    `(let [~g ~expr\n           ~@(interleave (repeat g) (butlast steps))]\n       ~(if (empty? steps)\n          g\n          (last steps)))))",
                                         :title "Source code",
                                         :repo "clojure",
                                         :tag "clojure-1.10.0",
                                         :filename "src/clj/clojure/core.clj",
                                         :lines [7598 7610]},
                                :full-name "cljs.core/some->>",
                                :docstring "When expr is not nil, threads it into the first form (via ->>),\nand when that result is not nil, through the next etc"},
           "cljs.core/unchecked-inc" {:ns "cljs.core",
                                      :name "unchecked-inc",
                                      :signature ["[x]"],
                                      :name-encode "unchecked-inc",
                                      :history [["+" "0.0-1798"]],
                                      :type "function/macro",
                                      :full-name-encode "cljs.core/unchecked-inc",
                                      :source {:code "(defn unchecked-inc [x]\n  (cljs.core/unchecked-inc x))",
                                               :title "Function code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [2836 2837]},
                                      :extra-sources [{:code "(core/defmacro ^::ana/numeric unchecked-inc\n  ([x] `(inc ~x)))",
                                                       :title "Macro code",
                                                       :repo "clojurescript",
                                                       :tag "r1.12.38",
                                                       :filename "src/main/clojure/cljs/core.cljc",
                                                       :lines [1092
                                                               1093]}],
                                      :full-name "cljs.core/unchecked-inc"},
           "cljs.core/not=" {:return-type boolean,
                             :ns "cljs.core",
                             :name "not=",
                             :signature ["[x]" "[x y]" "[x y & more]"],
                             :name-encode "notEQ",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/notEQ",
                             :source {:code "(defn ^boolean not=\n  ([x] false)\n  ([x y] (not (= x y)))\n  ([x y & more]\n   (not (apply = x y more))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [4093 4098]},
                             :full-name "cljs.core/not=",
                             :docstring "Same as (not (= obj1 obj2))"},
           "cljs.spec/exercise-fn" {:ns "cljs.spec",
                                    :name "exercise-fn",
                                    :signature ["[sym]"
                                                "[sym n]"
                                                "[sym n fspec]"],
                                    :name-encode "exercise-fn",
                                    :history [["+" "1.9.183"]
                                              ["-" "1.9.542"]],
                                    :type "macro",
                                    :full-name-encode "cljs.spec/exercise-fn",
                                    :source {:code "(defmacro exercise-fn\n  ([sym]\n   `(exercise-fn ~sym 10))\n  ([sym n]\n   `(exercise-fn ~sym ~n nil))\n  ([sym n fspec]\n   (let [sym (cond-> sym\n               (clojure.core/and (sequential? sym)\n                                 (= (first sym) 'quote))\n               second)]\n     `(let [fspec# ~(if-not fspec\n                      `(get-spec '~(:name (resolve &env sym)))\n                      fspec)\n            f#     ~sym]\n        (for [args# (gen/sample (gen (:args fspec#)) ~n)]\n          [args# (apply f# args#)])))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.9.521",
                                             :filename "src/main/cljs/cljs/spec.cljc",
                                             :lines [507 526]},
                                    :full-name "cljs.spec/exercise-fn",
                                    :docstring "exercises the fn named by sym (a symbol) by applying it to\nn (default 10) generated samples of its args spec. When fspec is\nsupplied its arg spec is used, and sym-or-f can be a fn.  Returns a\nsequence of tuples of [args ret]. ",
                                    :removed {:in "1.9.542",
                                              :last-seen "1.9.521"}},
           "cljs.repl.node/errs" {:ns "cljs.repl.node",
                                  :name "errs",
                                  :name-encode "errs",
                                  :type "var",
                                  :full-name-encode "cljs.repl.node/errs",
                                  :source {:code "(def errs (ConcurrentHashMap.))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/clojure/cljs/repl/node.clj",
                                           :lines [29]},
                                  :full-name "cljs.repl.node/errs",
                                  :history [["+" "1.10.217"]]},
           "repl-options/launch-browser" {:ns "repl-options",
                                          :name "launch-browser",
                                          :name-encode "launch-browser",
                                          :type "option",
                                          :full-name-encode "repl-options/launch-browser",
                                          :full-name "repl-options/launch-browser",
                                          :history [["+" "1.10.126"]]},
           "cljs.core/unchecked-subtract-int" {:return-type number,
                                               :ns "cljs.core",
                                               :name "unchecked-subtract-int",
                                               :signature ["[x]"
                                                           "[x y]"
                                                           "[x y & more]"],
                                               :name-encode "unchecked-subtract-int",
                                               :history [["+"
                                                          "0.0-1798"]],
                                               :type "function/macro",
                                               :full-name-encode "cljs.core/unchecked-subtract-int",
                                               :source {:code "(defn ^number unchecked-subtract-int\n  ([x] (cljs.core/unchecked-subtract-int x))\n  ([x y] (cljs.core/unchecked-subtract-int x y))\n  ([x y & more] (reduce unchecked-subtract-int (cljs.core/unchecked-subtract-int x y) more)))",
                                                        :title "Function code",
                                                        :repo "clojurescript",
                                                        :tag "r1.12.38",
                                                        :filename "src/main/cljs/cljs/core.cljs",
                                                        :lines [2874
                                                                2879]},
                                               :extra-sources [{:code "(core/defmacro ^::ana/numeric unchecked-subtract-int\n  ([& xs] `(- ~@xs)))",
                                                                :title "Macro code",
                                                                :repo "clojurescript",
                                                                :tag "r1.12.38",
                                                                :filename "src/main/clojure/cljs/core.cljc",
                                                                :lines [1116
                                                                        1117]}],
                                               :full-name "cljs.core/unchecked-subtract-int",
                                               :docstring "If no ys are supplied, returns the negation of x, else subtracts\nthe ys from x and returns the result."},
           "cljs.core/ex-data" {:ns "cljs.core",
                                :name "ex-data",
                                :signature ["[ex]"],
                                :name-encode "ex-data",
                                :history [["+" "0.0-1576"]],
                                :type "function",
                                :full-name-encode "cljs.core/ex-data",
                                :source {:code "(defn ex-data\n  [ex]\n  (when (instance? ExceptionInfo ex)\n    (.-data ex)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [11815 11820]},
                                :full-name "cljs.core/ex-data",
                                :docstring "Returns exception data (a map) if ex is an ExceptionInfo.\nOtherwise returns nil."},
           "cljs.core/PersistentTreeMapSeq" {:protocols #{"ISeqable"
                                                          "IMeta"
                                                          "IWithMeta"
                                                          "IEmptyableCollection"
                                                          "ICounted"
                                                          "IReduce"
                                                          "ISequential"
                                                          "ISeq"
                                                          "ICollection"
                                                          "IHash"
                                                          "IPrintWithWriter"
                                                          "INext"
                                                          "IEquiv"},
                                             :ns "cljs.core",
                                             :name "PersistentTreeMapSeq",
                                             :signature ["[meta stack ascending? cnt __hash]"],
                                             :name-encode "PersistentTreeMapSeq",
                                             :history [["+"
                                                        "0.0-1211"]],
                                             :type "type",
                                             :full-name-encode "cljs.core/PersistentTreeMapSeq",
                                             :source {:code "(deftype PersistentTreeMapSeq [meta stack ^boolean ascending? cnt ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  ISeqable\n  (-seq [this] this)\n\n  ISequential\n  ISeq\n  (-first [this] (peek stack))\n  (-rest [this]\n    (let [t (first stack)\n          next-stack (tree-map-seq-push (if ascending? (.-right t) (.-left t))\n                                        (next stack)\n                                        ascending?)]\n      (if-not (nil? next-stack)\n        (PersistentTreeMapSeq. nil next-stack ascending? (dec cnt) nil)\n        ())))\n  INext\n  (-next [this]\n    (let [t (first stack)\n          next-stack (tree-map-seq-push (if ascending? (.-right t) (.-left t))\n                                        (next stack)\n                                        ascending?)]\n      (when-not (nil? next-stack)\n        (PersistentTreeMapSeq. nil next-stack ascending? (dec cnt) nil))))\n\n  ICounted\n  (-count [coll]\n    (if (neg? cnt)\n      (inc (count (next coll)))\n      cnt))\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (.-EMPTY List))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (PersistentTreeMapSeq. new-meta stack ascending? cnt __hash)))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.12.38",
                                                      :filename "src/main/cljs/cljs/core.cljs",
                                                      :lines [8389
                                                              8456]},
                                             :full-name "cljs.core/PersistentTreeMapSeq"},
           "cljs.core/js-keys" {:ns "cljs.core",
                                :name "js-keys",
                                :signature ["[obj]"],
                                :name-encode "js-keys",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/js-keys",
                                :source {:code "(defn js-keys\n  [obj]\n  (gobject/getKeys obj))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [2251 2254]},
                                :full-name "cljs.core/js-keys",
                                :docstring "Return the JavaScript keys for an object."},
           "cljs.spec.alpha/keys" {:ns "cljs.spec.alpha",
                                   :name "keys",
                                   :signature ["[& {:keys [req req-un opt opt-un gen]}]"],
                                   :name-encode "keys",
                                   :history [["+" "1.9.542"]],
                                   :type "macro",
                                   :full-name-encode "cljs.spec.alpha/keys",
                                   :source {:code "(defmacro keys\n  [& {:keys [req req-un opt opt-un gen]}]\n  (let [unk #(-> % name keyword)\n        req-keys (filterv keyword? (flatten req))\n        req-un-specs (filterv keyword? (flatten req-un))\n        _ (clojure.core/assert (every? #(clojure.core/and (keyword? %) (namespace %)) (concat req-keys req-un-specs opt opt-un))\n                  \"all keys must be namespace-qualified keywords\")\n        req-specs (into req-keys req-un-specs)\n        req-keys (into req-keys (map unk req-un-specs))\n        opt-keys (into (vec opt) (map unk opt-un))\n        opt-specs (into (vec opt) opt-un)\n        gx (gensym)\n        parse-req (fn [rk f]\n                    (map (fn [x]\n                           (if (keyword? x)\n                             `(contains? ~gx ~(f x))\n                             (walk/postwalk\n                               (fn [y] (if (keyword? y) `(contains? ~gx ~(f y)) y))\n                               x)))\n                         rk))\n        pred-exprs [`(map? ~gx)]\n        pred-exprs (into pred-exprs (parse-req req identity))\n        pred-exprs (into pred-exprs (parse-req req-un unk))\n        keys-pred `(fn* [~gx] (c/and ~@pred-exprs))\n        pred-exprs (mapv (fn [e] `(fn* [~gx] ~e)) pred-exprs)\n        pred-forms (walk/postwalk #(res &env %) pred-exprs)]\n    ;; `(map-spec-impl ~req-keys '~req ~opt '~pred-forms ~pred-exprs ~gen)\n    `(map-spec-impl {:req '~req :opt '~opt :req-un '~req-un :opt-un '~opt-un\n                     :req-keys '~req-keys :req-specs '~req-specs\n                     :opt-keys '~opt-keys :opt-specs '~opt-specs\n                     :pred-forms '~pred-forms\n                     :pred-exprs ~pred-exprs\n                     :keys-pred ~keys-pred\n                     :gfn ~gen})))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/spec/alpha.cljc",
                                            :lines [135 195]},
                                   :full-name "cljs.spec.alpha/keys",
                                   :docstring "Creates and returns a map validating spec. :req and :opt are both\nvectors of namespaced-qualified keywords. The validator will ensure\nthe :req keys are present. The :opt keys serve as documentation and\nmay be used by the generator.\n\nThe :req key vector supports 'and' and 'or' for key groups:\n\n(s/keys :req [::x ::y (or ::secret (and ::user ::pwd))] :opt [::z])\n\nThere are also -un versions of :req and :opt. These allow\nyou to connect unqualified keys to specs.  In each case, fully\nqualfied keywords are passed, which name the specs, but unqualified\nkeys (with the same name component) are expected and checked at\nconform-time, and generated during gen:\n\n(s/keys :req-un [:my.ns/x :my.ns/y])\n\nThe above says keys :x and :y are required, and will be validated\nand generated by specs (if they exist) named :my.ns/x :my.ns/y\nrespectively.\n\nIn addition, the values of *all* namespace-qualified keys will be validated\n(and possibly destructured) by any registered specs. Note: there is\nno support for inline value specification, by design.\n\nOptionally takes :gen generator-fn, which must be a fn of no args that\nreturns a test.check generator."},
           "cljs.repl.browser/browser-eval" {:ns "cljs.repl.browser",
                                             :name "browser-eval",
                                             :signature ["[form]"],
                                             :name-encode "browser-eval",
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.repl.browser/browser-eval",
                                             :source {:code "(defn browser-eval\n  [form]\n  (let [return-value (promise)]\n    (send-for-eval form\n      (fn [val] (deliver return-value val)))\n    (let [ret @return-value]\n      (try\n        (read-string ret)\n        (catch Exception e\n          {:status :error\n           :value (str \"Could not read return value: \" ret)})))))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.12.38",
                                                      :filename "src/main/clojure/cljs/repl/browser.clj",
                                                      :lines [307 323]},
                                             :full-name "cljs.repl.browser/browser-eval",
                                             :docstring "Given a string of JavaScript, evaluate it in the browser and return a map representing the\nresult of the evaluation. The map will contain the keys :type and :value. :type can be\n:success, :exception, or :error. :success means that the JavaScript was evaluated without\nexception and :value will contain the return value of the evaluation. :exception means that\nthere was an exception in the browser while evaluating the JavaScript and :value will\ncontain the error message. :error means that some other error has occured."},
           "clojure.zip/seq-zip" {:ns "clojure.zip",
                                  :name "seq-zip",
                                  :signature ["[root]"],
                                  :name-encode "seq-zip",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.zip/seq-zip",
                                  :source {:code "(defn seq-zip\n  [root]\n    (zipper seq?\n            identity\n            (fn [node children] (with-meta children (meta node)))\n            root))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/clojure/zip.cljs",
                                           :lines [34 40]},
                                  :full-name "clojure.zip/seq-zip",
                                  :docstring "Returns a zipper for nested sequences, given a root sequence"},
           "cljs.spec.test/instrument" {:ns "cljs.spec.test",
                                        :name "instrument",
                                        :signature ["[]"
                                                    "[xs]"
                                                    "[sym-or-syms opts]"],
                                        :name-encode "instrument",
                                        :history [["+" "1.9.183"]
                                                  ["-" "1.9.542"]],
                                        :type "macro",
                                        :full-name-encode "cljs.spec.test/instrument",
                                        :source {:code "(defmacro instrument\n  ([]\n   `(instrument '[~@(#?(:clj  s/speced-vars\n                        :cljs cljs.spec$macros/speced-vars))]))\n  ([xs]\n   `(instrument ~xs nil))\n  ([sym-or-syms opts]\n   (let [syms (sym-or-syms->syms (eval sym-or-syms))\n         opts-sym (gensym \"opts\")]\n     `(let [~opts-sym ~opts]\n        (reduce\n          (fn [ret# [_# f#]]\n            (let [sym# (f#)]\n              (cond-> ret# sym# (conj sym#))))\n          []\n          (->> (zipmap '~syms\n                 [~@(map\n                      (fn [sym]\n                        `(fn [] (instrument-1 '~sym ~opts-sym)))\n                      syms)])\n            (filter #((instrumentable-syms ~opts-sym) (first %)))\n            (distinct-by first)))))))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.9.521",
                                                 :filename "src/main/cljs/cljs/spec/test.cljc",
                                                 :lines [67 125]},
                                        :full-name "cljs.spec.test/instrument",
                                        :docstring "Instruments the vars named by sym-or-syms, a symbol or collection\nof symbols, or all instrumentable vars if sym-or-syms is not\nspecified. If a symbol identifies a namespace then all symbols in that\nnamespace will be enumerated.\n\nIf a var has an :args fn-spec, sets the var's root binding to a\nfn that checks arg conformance (throwing an exception on failure)\nbefore delegating to the original fn.\n\nThe opts map can be used to override registered specs, and/or to\nreplace fn implementations entirely. Opts for symbols not included\nin sym-or-syms are ignored. This facilitates sharing a common\noptions map across many different calls to instrument.\n\nThe opts map may have the following keys:\n\n  :spec     a map from var-name symbols to override specs\n  :stub     a set of var-name symbols to be replaced by stubs\n  :gen      a map from spec names to generator overrides\n  :replace  a map from var-name symbols to replacement fns\n\n:spec overrides registered fn-specs with specs your provide. Use\n:spec overrides to provide specs for libraries that do not have\nthem, or to constrain your own use of a fn to a subset of its\nspec'ed contract.\n\n:stub replaces a fn with a stub that checks :args, then uses the\n:ret spec to generate a return value.\n\n:gen overrides are used only for :stub generation.\n\n:replace replaces a fn with a fn that checks args conformance, then\ninvokes the fn you provide, enabling arbitrary stubbing and mocking.\n\n:spec can be used in combination with :stub or :replace.\n\nReturns a collection of syms naming the vars instrumented.",
                                        :removed {:in "1.9.542",
                                                  :last-seen "1.9.521"}},
           "cljs.core/lazy-transformer" {:ns "cljs.core",
                                         :name "lazy-transformer",
                                         :signature ["[stepper]"],
                                         :name-encode "lazy-transformer",
                                         :history [["+" "0.0-2301"]
                                                   ["-" "1.9.562"]],
                                         :type "function",
                                         :full-name-encode "cljs.core/lazy-transformer",
                                         :source {:code "(defn lazy-transformer [stepper]\n  (LazyTransformer. stepper nil nil nil))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.9.542",
                                                  :filename "src/main/cljs/cljs/core.cljs",
                                                  :lines [3873 3874]},
                                         :full-name "cljs.core/lazy-transformer",
                                         :removed {:in "1.9.562",
                                                   :last-seen "1.9.542"}},
           "cljs.repl.browser/server-state" {:ns "cljs.repl.browser",
                                             :name "server-state",
                                             :name-encode "server-state",
                                             :history [["+" "0.0-927"]
                                                       ["-"
                                                        "0.0-1503"]],
                                             :type "var",
                                             :full-name-encode "cljs.repl.browser/server-state",
                                             :source {:code "(defonce server-state (atom {:socket nil\n                             :connection nil\n                             :promised-conn nil\n                             :return-value-fn nil\n                             :client-js nil}))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1450",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [24 28]},
                                             :full-name "cljs.repl.browser/server-state",
                                             :removed {:in "0.0-1503",
                                                       :last-seen "0.0-1450"}},
           "cljs.core/random-sample" {:ns "cljs.core",
                                      :name "random-sample",
                                      :signature ["[prob]"
                                                  "[prob coll]"],
                                      :name-encode "random-sample",
                                      :history [["+" "0.0-2301"]],
                                      :type "function",
                                      :full-name-encode "cljs.core/random-sample",
                                      :source {:code "(defn random-sample\n  ([prob]\n     (filter (fn [_] (< (rand) prob))))\n  ([prob coll]\n     (filter (fn [_] (< (rand) prob)) coll)))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [11059 11065]},
                                      :full-name "cljs.core/random-sample",
                                      :docstring "Returns items from coll with random probability of prob (0.0 -\n1.0).  Returns a transducer when no collection is provided."},
           "cljs.spec.alpha/every" {:ns "cljs.spec.alpha",
                                    :name "every",
                                    :signature ["[pred & {:keys [into kind count max-count min-count distinct gen-max gen-into gen], :as opts}]"],
                                    :name-encode "every",
                                    :history [["+" "1.9.542"]],
                                    :type "macro",
                                    :full-name-encode "cljs.spec.alpha/every",
                                    :source {:code "(defmacro every\n  [pred & {:keys [into kind count max-count min-count distinct gen-max gen-into gen] :as opts}]\n  (let [desc (::describe opts)\n        nopts (-> opts\n                (dissoc :gen ::describe)\n                (assoc ::kind-form `'~(res &env (:kind opts))\n                       ::describe (clojure.core/or desc `'(every ~(res &env pred) ~@(res-kind &env opts)))))\n        gx (gensym)\n        cpreds (cond-> [(list (clojure.core/or kind `coll?) gx)]\n                 count (conj `(= ~count (c/bounded-count ~count ~gx)))\n\n                 (clojure.core/or min-count max-count)\n                 (conj `(<= (c/or ~min-count 0)\n                          (c/bounded-count (if ~max-count (inc ~max-count) ~min-count) ~gx)\n                          (c/or ~max-count MAX_INT)))\n\n                 distinct\n                 (conj `(c/or (empty? ~gx) (apply distinct? ~gx))))]\n    `(every-impl '~pred ~pred ~(assoc nopts ::cpred `(fn* [~gx] (c/and ~@cpreds))) ~gen)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/spec/alpha.cljc",
                                             :lines [233 279]},
                                    :full-name "cljs.spec.alpha/every",
                                    :docstring "takes a pred and validates collection elements against that pred.\n\nNote that 'every' does not do exhaustive checking, rather it samples\n*coll-check-limit* elements. Nor (as a result) does it do any\nconforming of elements. 'explain' will report at most *coll-error-limit*\nproblems.  Thus 'every' should be suitable for potentially large\ncollections.\n\nTakes several kwargs options that further constrain the collection:\n\n:kind - a pred that the collection type must satisfy, e.g. vector?\n        (default nil) Note that if :kind is specified and :into is\n        not, this pred must generate in order for every to generate.\n:count - specifies coll has exactly this count (default nil)\n:min-count, :max-count - coll has count (<= min-count count max-count) (defaults nil)\n:distinct - all the elements are distinct (default nil)\n\nAnd additional args that control gen\n\n:gen-max - the maximum coll size to generate (default 20)\n:into - one of [], (), {}, #{} - the default collection to generate into\n    (default same as :kind if supplied, else []\n\nOptionally takes :gen generator-fn, which must be a fn of no args that\nreturns a test.check generator\n\nSee also - coll-of, every-kv"},
           "compiler-options/modules" {:ns "compiler-options",
                                       :name "modules",
                                       :name-encode "modules",
                                       :type "option",
                                       :full-name-encode "compiler-options/modules",
                                       :full-name "compiler-options/modules",
                                       :history [["+" "0.0-2911"]]},
           "cljs.core/IVector" {:ns "cljs.core",
                                :name "IVector",
                                :name-encode "IVector",
                                :implementations #{"Subvec"
                                                   "RedNode"
                                                   "BlackNode"
                                                   "PersistentVector"
                                                   "MapEntry"},
                                :history [["+" "0.0-927"]],
                                :type "protocol",
                                :full-name-encode "cljs.core/IVector",
                                :source {:code "(defprotocol IVector\n  (^clj -assoc-n [coll n val]\n    \"Returns a new vector with value val added at position n.\"))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [685 688]},
                                :methods [{:name "-assoc-n",
                                           :signature ["[coll n val]"],
                                           :docstring "Returns a new vector with value val added at position n."}],
                                :full-name "cljs.core/IVector",
                                :docstring "Protocol for adding vector functionality to collections."},
           "cljs.core/iter" {:ns "cljs.core",
                             :name "iter",
                             :signature ["[coll]"],
                             :name-encode "iter",
                             :history [["+" "0.0-2301"]],
                             :type "function",
                             :full-name-encode "cljs.core/iter",
                             :source {:code "(defn iter [coll]\n  (cond\n    (iterable? coll) (-iterator coll)\n    (nil? coll) (nil-iter)\n    (string? coll) (string-iter coll)\n    (array? coll) (array-iter coll)\n    (seqable? coll) (seq-iter coll)\n    :else (throw (js/Error. (str \"Cannot create iterator from \" coll)))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [4159 4166]},
                             :full-name "cljs.core/iter"},
           "cljs.core/persistent!" {:ns "cljs.core",
                                    :name "persistent!",
                                    :signature ["[tcoll]"],
                                    :name-encode "persistentBANG",
                                    :history [["+" "0.0-1211"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/persistentBANG",
                                    :source {:code "(defn persistent!\n  [tcoll]\n  (-persistent! tcoll))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [3908 3913]},
                                    :full-name "cljs.core/persistent!",
                                    :docstring "Returns a new, persistent version of the transient collection, in\nconstant time. The transient collection cannot be used after this\ncall, any such use will throw an exception."},
           "cljs.core/empty" {:ns "cljs.core",
                              :name "empty",
                              :signature ["[coll]"],
                              :name-encode "empty",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/empty",
                              :source {:code "(defn empty\n  [coll]\n  (when-not (nil? coll)\n    (cond\n      (implements? IEmptyableCollection coll)\n      (-empty coll)\n\n      (satisfies? IEmptyableCollection coll)\n      (-empty coll)\n\n      :else nil)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [1849 1860]},
                              :full-name "cljs.core/empty",
                              :docstring "Returns an empty collection of the same category as coll, or nil"},
           "cljs.build.api/compilable->ijs" {:ns "cljs.build.api",
                                             :name "compilable->ijs",
                                             :signature ["[x]"
                                                         "[x opts]"],
                                             :name-encode "compilable-GTijs",
                                             :history [["+"
                                                        "1.10.738"]],
                                             :type "function",
                                             :full-name-encode "cljs.build.api/compilable-GTijs",
                                             :source {:code "(defn compilable->ijs\n  ([x]\n   (compilable->ijs x {}))\n  ([x opts]\n   (closure/-find-sources x opts)))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.12.38",
                                                      :filename "src/main/clojure/cljs/build/api.clj",
                                                      :lines [130 136]},
                                             :full-name "cljs.build.api/compilable->ijs",
                                             :docstring "Given a cljs.closure/Compilable value, return the corresponding\ncljs.closure/IJavaScript value."},
           "cljs.core/re-matches" {:ns "cljs.core",
                                   :name "re-matches",
                                   :signature ["[re s]"],
                                   :name-encode "re-matches",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/re-matches",
                                   :source {:code "(defn re-matches\n  [re s]\n  (if (string? s)\n    (let [matches (.exec re s)]\n      (when (and (not (nil? matches))\n                 (= (aget matches 0) s))\n        (if (== (count ^array matches) 1)\n          (aget matches 0)\n          (vec matches))))\n    (throw (js/TypeError. \"re-matches must match against a string.\"))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [10379 10389]},
                                   :full-name "cljs.core/re-matches",
                                   :docstring "Returns the result of (re-find re s) if re fully matches s."},
           "cljs.spec.test.alpha/unstrument-1" {:ns "cljs.spec.test.alpha",
                                                :name "unstrument-1",
                                                :signature ["[[quote s]]"],
                                                :name-encode "unstrument-1",
                                                :history [["+"
                                                           "1.9.542"]],
                                                :type "macro",
                                                :full-name-encode "cljs.spec.test.alpha/unstrument-1",
                                                :source {:code "(defmacro unstrument-1\n  [[quote s]]\n  (when-let [v (ana-api/resolve &env s)]\n    (when (@instrumented-vars (:name v))\n      (swap! instrumented-vars disj (:name v))\n      `(let [raw# (#'unstrument-1* '~s (var ~s))]\n         (when raw# (set! ~s raw#))\n         '~(:name v)))))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1.12.38",
                                                         :filename "src/main/cljs/cljs/spec/test/alpha.cljc",
                                                         :lines [74
                                                                 81]},
                                                :full-name "cljs.spec.test.alpha/unstrument-1"},
           "syntax/meta" {:syntax-equiv {:edn-url nil, :clj-url nil},
                          :ns "syntax",
                          :name "meta",
                          :name-encode "meta",
                          :history [["+" "0.0-1853"]],
                          :type "syntax",
                          :full-name-encode "syntax/meta",
                          :extra-sources ({:code "(defn- read-meta\n  [rdr _ opts pending-forms]\n  (log-source rdr\n    (let [[line column] (starting-line-col-info rdr)\n          m (desugar-meta (read* rdr true nil opts pending-forms))]\n      (when-not (map? m)\n        (err/throw-bad-metadata rdr m))\n      (let [o (read* rdr true nil opts pending-forms)]\n        (if (instance? IMeta o)\n          (let [m (if (and line (seq? o))\n                    (assoc m :line line :column column)\n                    m)]\n            (if (instance? IObj o)\n              (with-meta o (merge (meta o) m))\n              (reset-meta! o m)))\n          (err/throw-bad-metadata-target rdr o))))))",
                                           :title "Reader code",
                                           :repo "tools.reader",
                                           :tag "v1.3.6",
                                           :filename "src/main/clojure/clojure/tools/reader.clj",
                                           :lines [370 386]}
                                          {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                           :title "Reader table",
                                           :repo "tools.reader",
                                           :tag "v1.3.6",
                                           :filename "src/main/clojure/clojure/tools/reader.clj",
                                           :lines [788 807]}),
                          :full-name "syntax/meta"},
           "clojure.browser.dom/DOMBuilder" {:ns "clojure.browser.dom",
                                             :name "DOMBuilder",
                                             :name-encode "DOMBuilder",
                                             :history [["+" "0.0-927"]],
                                             :type "protocol",
                                             :full-name-encode "clojure.browser.dom/DOMBuilder",
                                             :source {:code "(defprotocol DOMBuilder\n  (-element [this] [this attrs-or-children] [this attrs children]))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.12.38",
                                                      :filename "src/main/cljs/clojure/browser/dom.cljs",
                                                      :lines [17 18]},
                                             :methods [{:name "-element",
                                                        :signature ["[this]"
                                                                    "[this attrs-or-children]"
                                                                    "[this attrs children]"],
                                                        :docstring nil}],
                                             :full-name "clojure.browser.dom/DOMBuilder"},
           "cljs.spec.impl.gen/choose" {:ns "cljs.spec.impl.gen",
                                        :name "choose",
                                        :signature ["[& args]"],
                                        :name-encode "choose",
                                        :history [["+" "1.9.14"]
                                                  ["-" "1.9.542"]],
                                        :type "function",
                                        :full-name-encode "cljs.spec.impl.gen/choose",
                                        :source {:code "(lazy-combinators hash-map list map not-empty set vector vector-distinct fmap elements\n  bind choose one-of such-that tuple sample return\n  large-integer* double* frequency)",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.9.521",
                                                 :filename "src/main/cljs/cljs/spec/impl/gen.cljs",
                                                 :lines [69 71]},
                                        :full-name "cljs.spec.impl.gen/choose",
                                        :docstring "Lazy loaded version of clojure.test.check.generators/choose",
                                        :removed {:in "1.9.542",
                                                  :last-seen "1.9.521"}},
           "syntax/regex" {:syntax-equiv {:edn-url nil, :clj-url nil},
                           :ns "syntax",
                           :name "regex",
                           :name-encode "regex",
                           :history [["+" "0.0-1853"]],
                           :type "syntax",
                           :full-name-encode "syntax/regex",
                           :extra-sources ({:code "(defn read-regex\n  [rdr ch opts pending-forms]\n  (let [sb (StringBuilder.)]\n    (loop [ch (read-char rdr)]\n      (if (identical? \\\" ch)\n        (Pattern/compile (str sb))\n        (if (nil? ch)\n          (err/throw-eof-reading rdr :regex sb)\n          (do\n            (.append sb ch )\n            (when (identical? \\\\ ch)\n              (let [ch (read-char rdr)]\n                (if (nil? ch)\n                  (err/throw-eof-reading rdr :regex sb))\n                (.append sb ch)))\n            (recur (read-char rdr))))))))",
                                            :title "Reader code",
                                            :repo "tools.reader",
                                            :tag "v1.3.6",
                                            :filename "src/main/clojure/clojure/tools/reader.clj",
                                            :lines [84 99]}
                                           {:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    \\? read-cond\n    \\: read-namespaced-map\n    \\# read-symbolic-value\n    nil))",
                                            :title "Reader table",
                                            :repo "tools.reader",
                                            :tag "v1.3.6",
                                            :filename "src/main/clojure/clojure/tools/reader.clj",
                                            :lines [809 823]}),
                           :full-name "syntax/regex"},
           "cljs.core/extend-type" {:ns "cljs.core",
                                    :name "extend-type",
                                    :signature ["[type-sym & impls]"],
                                    :name-encode "extend-type",
                                    :history [["+" "0.0-927"]],
                                    :type "macro",
                                    :full-name-encode "cljs.core/extend-type",
                                    :source {:code "(core/defmacro extend-type\n  [type-sym & impls]\n  (core/let [env &env\n             _ (validate-impls env impls)\n             resolve (partial resolve-var env)\n             impl-map (->impl-map impls)\n             impl-map (if ('#{boolean number} type-sym)\n                        (type-hint-impl-map type-sym impl-map)\n                        impl-map)\n             [type assign-impls] (core/if-let [type (base-type type-sym)]\n                                   [type base-assign-impls]\n                                   [(resolve type-sym) proto-assign-impls])]\n    (core/when (core/and (:extending-base-js-type cljs.analyzer/*cljs-warnings*)\n            (js-base-type type-sym))\n      (cljs.analyzer/warning :extending-base-js-type env\n        {:current-symbol type-sym :suggested-symbol (js-base-type type-sym)}))\n    `(do ~@(mapcat #(assign-impls env resolve type-sym type %) impl-map))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/clojure/cljs/core.cljc",
                                             :lines [1630 1670]},
                                    :full-name "cljs.core/extend-type",
                                    :docstring "Extend a type to a series of protocols. Useful when you are\nsupplying the definitions explicitly inline. Propagates the\ntype as a type hint on the first argument of all fns.\n\ntype-sym may be\n\n * default, meaning the definitions will apply for any value,\n   unless an extend-type exists for one of the more specific\n   cases below.\n * nil, meaning the definitions will apply for the nil value.\n * any of object, boolean, number, string, array, or function,\n   indicating the definitions will apply for values of the\n   associated base JavaScript types. Note that, for example,\n   string should be used instead of js/String.\n * a JavaScript type not covered by the previous list, such\n   as js/RegExp.\n * a type defined by deftype or defrecord.\n\n(extend-type MyType\n  ICounted\n  (-count [c] ...)\n  Foo\n  (bar [x y] ...)\n  (baz ([x] ...) ([x y] ...) ...)"},
           "cljs.core/ISeqable" {:ns "cljs.core",
                                 :name "ISeqable",
                                 :name-encode "ISeqable",
                                 :implementations #{"Subvec"
                                                    "Cycle"
                                                    "PersistentQueue"
                                                    "PersistentHashMap"
                                                    "PersistentTreeSet"
                                                    "PersistentArrayMapSeq"
                                                    "RedNode"
                                                    "EmptyList"
                                                    "ObjMap"
                                                    "Iterate"
                                                    "BlackNode"
                                                    "PersistentVector"
                                                    "ValSeq"
                                                    "IntegerRange"
                                                    "ChunkedCons"
                                                    "Range"
                                                    "PersistentQueueSeq"
                                                    "ChunkedSeq"
                                                    "ArrayNodeSeq"
                                                    "KeySeq"
                                                    "IndexedSeq"
                                                    "PersistentTreeMap"
                                                    "PersistentTreeMapSeq"
                                                    "ES6IteratorSeq"
                                                    "RSeq"
                                                    "PersistentArrayMap"
                                                    "PersistentHashSet"
                                                    "NodeSeq"
                                                    "List"
                                                    "Repeat"
                                                    "Cons"
                                                    "LazySeq"
                                                    "Eduction"
                                                    "MapEntry"},
                                 :history [["+" "0.0-927"]],
                                 :type "protocol",
                                 :full-name-encode "cljs.core/ISeqable",
                                 :source {:code "(defprotocol ISeqable\n  (^clj-or-nil -seq [o]\n    \"Returns a seq of o, or nil if o is empty.\"))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [733 736]},
                                 :methods [{:name "-seq",
                                            :signature ["[o]"],
                                            :docstring "Returns a seq of o, or nil if o is empty."}],
                                 :full-name "cljs.core/ISeqable",
                                 :docstring "Protocol for adding the ability to a type to be transformed into a sequence."},
           "cljs.core/assoc" {:ns "cljs.core",
                              :name "assoc",
                              :signature ["[coll k v]"
                                          "[coll k v & kvs]"],
                              :name-encode "assoc",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/assoc",
                              :source {:code "(defn assoc\n  ([coll k v]\n   (if (implements? IAssociative coll)\n     (-assoc coll k v)\n     (if-not (nil? coll)\n       (-assoc coll k v)\n       (array-map k v))))\n  ([coll k v & kvs]\n     (let [ret (assoc coll k v)]\n       (if kvs\n         (recur ret (first kvs) (second kvs) (nnext kvs))\n         ret))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [2038 2053]},
                              :full-name "cljs.core/assoc",
                              :docstring "assoc[iate]. When applied to a map, returns a new map of the\nsame (hashed/sorted) type, that contains the mapping of key(s) to\nval(s). When applied to a vector, returns a new vector that\ncontains val at index. Note - index must be <= (count vector)."},
           "clojure.browser.repl/xpc-connection" {:ns "clojure.browser.repl",
                                                  :name "xpc-connection",
                                                  :name-encode "xpc-connection",
                                                  :type "var",
                                                  :full-name-encode "clojure.browser.repl/xpc-connection",
                                                  :source {:code "(def xpc-connection (atom nil))",
                                                           :title "Source code",
                                                           :repo "clojurescript",
                                                           :tag "r1.12.38",
                                                           :filename "src/main/cljs/clojure/browser/repl.cljs",
                                                           :lines [37]},
                                                  :full-name "clojure.browser.repl/xpc-connection",
                                                  :history [["+"
                                                             "0.0-927"]]},
           "cljs.core/IDerefWithTimeout" {:ns "cljs.core",
                                          :name "IDerefWithTimeout",
                                          :name-encode "IDerefWithTimeout",
                                          :history [["+" "0.0-927"]],
                                          :type "protocol",
                                          :full-name-encode "cljs.core/IDerefWithTimeout",
                                          :source {:code "(defprotocol IDerefWithTimeout\n  (-deref-with-timeout [o msec timeout-val]))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/cljs/cljs/core.cljs",
                                                   :lines [695 696]},
                                          :methods [{:name "-deref-with-timeout",
                                                     :signature ["[o msec timeout-val]"],
                                                     :docstring nil}],
                                          :full-name "cljs.core/IDerefWithTimeout"},
           "warnings/invalid-protocol-symbol" {:ns "warnings",
                                               :name "invalid-protocol-symbol",
                                               :name-encode "invalid-protocol-symbol",
                                               :type "warning",
                                               :full-name-encode "warnings/invalid-protocol-symbol",
                                               :full-name "warnings/invalid-protocol-symbol",
                                               :history [["+"
                                                          "0.0-2014"]]},
           "syntax/eval" {:syntax-equiv {:edn-url nil, :clj-url nil},
                          :ns "syntax",
                          :name "eval",
                          :name-encode "eval",
                          :history [["+" "0.0-1853"]],
                          :type "syntax",
                          :full-name-encode "syntax/eval",
                          :extra-sources ({:code "(defn- read-eval\n  [rdr _ opts pending-forms]\n  (when-not *read-eval*\n    (err/reader-error rdr \"#= not allowed when *read-eval* is false\"))\n  (eval (read* rdr true nil opts pending-forms)))",
                                           :title "Reader code",
                                           :repo "tools.reader",
                                           :tag "v1.3.6",
                                           :filename "src/main/clojure/clojure/tools/reader.clj",
                                           :lines [589 594]}
                                          {:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    \\? read-cond\n    \\: read-namespaced-map\n    \\# read-symbolic-value\n    nil))",
                                           :title "Reader table",
                                           :repo "tools.reader",
                                           :tag "v1.3.6",
                                           :filename "src/main/clojure/clojure/tools/reader.clj",
                                           :lines [809 823]}),
                          :full-name "syntax/eval"},
           "cljs.core/multi-stepper" {:ns "cljs.core",
                                      :name "multi-stepper",
                                      :signature ["[xform iters]"
                                                  "[xform iters nexts]"],
                                      :name-encode "multi-stepper",
                                      :history [["+" "0.0-2301"]
                                                ["-" "1.9.562"]],
                                      :type "function",
                                      :full-name-encode "cljs.core/multi-stepper",
                                      :source {:code "(defn multi-stepper\n  ([xform iters]\n     (multi-stepper xform iters\n       (make-array (alength iters))))\n  ([xform iters nexts]\n     (letfn [(stepfn\n               ([result]\n                  (let [lt (if (reduced? result)\n                             @result\n                             result)]\n                    (set! (.-stepper lt) nil)\n                    lt))\n               ([result input]\n                  (let [lt result]\n                    (set! (.-first lt) input)\n                    (set! (.-rest lt) (lazy-transformer (.-stepper lt)))\n                    (set! (.-stepper lt) nil)\n                    (.-rest lt))))]\n       (MultiStepper. (xform stepfn) iters nexts))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.9.542",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [3930 3948]},
                                      :full-name "cljs.core/multi-stepper",
                                      :removed {:in "1.9.562",
                                                :last-seen "1.9.542"}},
           "cljs.analyzer.api/default-passes" {:ns "cljs.analyzer.api",
                                               :name "default-passes",
                                               :name-encode "default-passes",
                                               :history [["+"
                                                          "1.10.738"]],
                                               :type "var",
                                               :full-name-encode "cljs.analyzer.api/default-passes",
                                               :source {:code "(def\n  default-passes ana/default-passes)",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.12.38",
                                                        :filename "src/main/clojure/cljs/analyzer/api.cljc",
                                                        :lines [115
                                                                117]},
                                               :full-name "cljs.analyzer.api/default-passes",
                                               :docstring "ClojureScript's default analysis passes."},
           "cljs.repl/repl-title" {:ns "cljs.repl",
                                   :name "repl-title",
                                   :signature ["[]"],
                                   :name-encode "repl-title",
                                   :history [["+" "1.10.145"]],
                                   :type "function",
                                   :full-name-encode "cljs.repl/repl-title",
                                   :source {:code "(defn repl-title []\n  (println \"ClojureScript\" (util/clojurescript-version)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/clojure/cljs/repl.cljc",
                                            :lines [805 806]},
                                   :full-name "cljs.repl/repl-title"},
           "clojure.core.reducers/cat" {:ns "clojure.core.reducers",
                                        :name "cat",
                                        :signature ["[]"
                                                    "[ctor]"
                                                    "[left right]"],
                                        :name-encode "cat",
                                        :history [["+" "0.0-1236"]],
                                        :type "function",
                                        :full-name-encode "clojure.core.reducers/cat",
                                        :source {:code "(defn cat\n  ([] (array))\n  ([ctor]\n     (fn\n       ([] (ctor))\n       ([left right] (cat left right))))\n  ([left right]\n     (cond\n       (zero? (count left)) right\n       (zero? (count right)) left\n       :else\n       (Cat. (+ (count left) (count right)) left right))))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/cljs/clojure/core/reducers.cljs",
                                                 :lines [213 230]},
                                        :full-name "clojure.core.reducers/cat",
                                        :docstring "A high-performance combining fn that yields the catenation of the\nreduced values. The result is reducible, foldable, seqable and\ncounted, providing the identity collections are reducible, seqable\nand counted. The single argument version will build a combining fn\nwith the supplied identity constructor. Tests for identity\nwith (zero? (count x)). See also foldcat."},
           "cljs.core/unchecked-substract" {:return-type number,
                                            :ns "cljs.core",
                                            :name "unchecked-substract",
                                            :signature ["[x]"
                                                        "[x y]"
                                                        "[x y & more]"],
                                            :name-encode "unchecked-substract",
                                            :history [["+" "0.0-1798"]
                                                      ["-" "0.0-2277"]],
                                            :type "function",
                                            :full-name-encode "cljs.core/unchecked-substract",
                                            :source {:code "(defn ^number unchecked-substract\n  ([x] (cljs.core/unchecked-subtract x))\n  ([x y] (cljs.core/unchecked-subtract x y))\n  ([x y & more] (reduce unchecked-substract (cljs.core/unchecked-subtract x y) more)))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2268",
                                                     :filename "src/cljs/cljs/core.cljs",
                                                     :lines [1805
                                                             1810]},
                                            :full-name "cljs.core/unchecked-substract",
                                            :docstring "If no ys are supplied, returns the negation of x, else subtracts\nthe ys from x and returns the result.",
                                            :removed {:in "0.0-2277",
                                                      :last-seen "0.0-2268"}},
           "cljs.core/Iteration" {:protocols #{"ISeqable"
                                               "IReduce"
                                               "ISequential"
                                               "IPrintWithWriter"},
                                  :ns "cljs.core",
                                  :name "Iteration",
                                  :signature ["[xform coll]"],
                                  :name-encode "Iteration",
                                  :history [["+" "0.0-2301"]
                                            ["-" "0.0-2371"]],
                                  :type "type",
                                  :full-name-encode "cljs.core/Iteration",
                                  :source {:code "(deftype Iteration [xform coll]\n   ISequential\n   \n   ISeqable\n   (-seq [_] (seq (sequence xform coll)))\n\n   IReduce\n   (-reduce [_ f init] (transduce xform f init coll))\n\n   IPrintWithWriter\n   (-pr-writer [coll writer opts]\n     (pr-sequential-writer writer pr-writer \"(\" \" \" \")\" opts coll)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2356",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [8192 8203]},
                                  :full-name "cljs.core/Iteration",
                                  :removed {:in "0.0-2371",
                                            :last-seen "0.0-2356"}},
           "clojure.browser.repl/start-evaluator" {:ns "clojure.browser.repl",
                                                   :name "start-evaluator",
                                                   :signature ["[url]"],
                                                   :name-encode "start-evaluator",
                                                   :history [["+"
                                                              "0.0-927"]],
                                                   :type "function",
                                                   :full-name-encode "clojure.browser.repl/start-evaluator",
                                                   :source {:code "(defn start-evaluator\n  [url]\n  (if-let [repl-connection (net/xpc-connection)]\n    (let [connection (net/xhr-connection)\n          repl-connected? (atom false)\n          try-handshake (fn try-handshake []\n                          (when-not @repl-connected?\n                            (net/transmit repl-connection :start-handshake nil)))]\n      (net/connect repl-connection try-handshake)\n\n      (net/register-service repl-connection\n        :ack-handshake\n        (fn [_]\n          (when-not @repl-connected?\n            (reset! repl-connected? true)\n            ;; Now that we're connected to the parent, we can start talking to\n            ;; the server.\n            (send-result connection\n              url (wrap-message nil :ready \"ready\")))))\n\n      (event/listen connection\n        :error\n        (fn [e]\n          (reset! repl-connected? false)\n          (net/transmit repl-connection :reconnect nil)\n          (js/setTimeout try-handshake 1000)))\n\n      (event/listen connection\n        :success\n        (fn [e]\n          (net/transmit\n            repl-connection\n            :evaluate-javascript\n            (.getResponseText (.-currentTarget e) ()))))\n\n      (net/register-service repl-connection\n        :send-result\n        (fn [json]\n          (let [obj    (json/parse json)\n                repl   (gobj/get obj \"repl\")\n                result (gobj/get obj \"result\")]\n            (send-result connection url\n              (wrap-message repl :result result)))))\n\n      (net/register-service repl-connection\n        :print\n        (fn [json]\n          (let [obj  (json/parse json)\n                repl (gobj/get obj \"repl\")\n                str  (gobj/get obj \"str\")]\n            (send-print url (wrap-message repl :print str))))))\n    (js/alert \"No 'xpc' param provided to child iframe.\")))",
                                                            :title "Source code",
                                                            :repo "clojurescript",
                                                            :tag "r1.12.38",
                                                            :filename "src/main/cljs/clojure/browser/repl.cljs",
                                                            :lines [105
                                                                    158]},
                                                   :full-name "clojure.browser.repl/start-evaluator",
                                                   :docstring "Start the REPL server connection process. This process runs inside the\nembedded iframe."},
           "cljs.pprint/setf" {:ns "cljs.pprint",
                               :name "setf",
                               :signature ["[sym new-val]"],
                               :name-encode "setf",
                               :history [["+" "0.0-3255"]],
                               :type "macro",
                               :full-name-encode "cljs.pprint/setf",
                               :source {:code "(defmacro setf\n  [sym new-val]\n  `(swap! @~'this assoc ~sym ~new-val))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/pprint.cljc",
                                        :lines [35 38]},
                               :full-name "cljs.pprint/setf",
                               :docstring "Set the value of the field SYM to NEW-VAL"},
           "cljs.repl.browser/send-for-eval" {:ns "cljs.repl.browser",
                                              :name "send-for-eval",
                                              :signature ["[form return-value-fn]"
                                                          "[conn form return-value-fn]"],
                                              :name-encode "send-for-eval",
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.repl.browser/send-for-eval",
                                              :source {:code "(defn send-for-eval\n  ([form return-value-fn]\n    (send-for-eval @(server/connection) form return-value-fn))\n  ([conn form return-value-fn]\n    (set-return-value-fn return-value-fn)\n    (server/send-and-close conn 200\n      (json/write-str\n        {\"repl\" (thread-name)\n         \"form\" form})\n      \"application/json\")))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.12.38",
                                                       :filename "src/main/clojure/cljs/repl/browser.clj",
                                                       :lines [97 109]},
                                              :full-name "cljs.repl.browser/send-for-eval",
                                              :docstring "Given a form and a return value function, send the form to the\nbrowser for evaluation. The return value function will be called\nwhen the return value is received."},
           "clojure.browser.event/unlisten" {:ns "clojure.browser.event",
                                             :name "unlisten",
                                             :signature ["[src type fn]"
                                                         "[src type fn capture?]"],
                                             :name-encode "unlisten",
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "clojure.browser.event/unlisten",
                                             :source {:code "(defn unlisten\n  ([src type fn]\n     (unlisten src type fn false))\n  ([src type fn capture?]\n     (events/unlisten src\n                      (get (event-types src) type type)\n                      fn\n                      capture?)))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.12.38",
                                                      :filename "src/main/cljs/clojure/browser/event.cljs",
                                                      :lines [64 71]},
                                             :full-name "clojure.browser.event/unlisten"},
           "cljs.core/unsafe-bit-and" {:ns "cljs.core",
                                       :name "unsafe-bit-and",
                                       :signature ["[x y]"
                                                   "[x y & more]"],
                                       :name-encode "unsafe-bit-and",
                                       :history [["+" "0.0-1211"]
                                                 ["-" "1.9.493"]
                                                 ["+" "1.9.494"]],
                                       :type "macro",
                                       :full-name-encode "cljs.core/unsafe-bit-and",
                                       :source {:code "(core/defmacro ^::ana/numeric unsafe-bit-and\n  ([x y] (bool-expr (core/list 'js* \"(~{} & ~{})\" x y)))\n  ([x y & more] `(unsafe-bit-and (unsafe-bit-and ~x ~y) ~@more)))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/clojure/cljs/core.cljc",
                                                :lines [1203 1205]},
                                       :full-name "cljs.core/unsafe-bit-and"},
           "clojure.core.protocols/Navigable" {:ns "clojure.core.protocols",
                                               :name "Navigable",
                                               :name-encode "Navigable",
                                               :history [["+"
                                                          "1.10.514"]],
                                               :type "protocol",
                                               :full-name-encode "clojure.core.protocols/Navigable",
                                               :source {:code "(defprotocol Navigable\n  :extend-via-metadata true\n  (nav [coll k v] \"return (possibly transformed) v in the context of coll and k (a key/index or nil),\ndefaults to returning v.\"))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.12.38",
                                                        :filename "src/main/cljs/clojure/core/protocols.cljs",
                                                        :lines [22 25]},
                                               :methods [{:name "nav",
                                                          :signature ["[coll k v]"],
                                                          :docstring "return (possibly transformed) v in the context of coll and k (a key/index or nil),\ndefaults to returning v."}],
                                               :full-name "clojure.core.protocols/Navigable"},
           "cljs.test/is" {:ns "cljs.test",
                           :name "is",
                           :signature ["[form]" "[form msg]"],
                           :name-encode "is",
                           :history [["+" "0.0-2496"]],
                           :type "macro",
                           :full-name-encode "cljs.test/is",
                           :source {:code "(defmacro is\n  ([form] `(cljs.test/is ~form nil))\n  ([form msg]\n   `(try-expr ~msg ~form)))",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r1.12.38",
                                    :filename "src/main/cljs/cljs/test.cljc",
                                    :lines [174 190]},
                           :full-name "cljs.test/is",
                           :docstring "Generic assertion macro.  'form' is any predicate test.\n'msg' is an optional message to attach to the assertion.\n\nExample: (is (= 4 (+ 2 2)) \"Two plus two should be 4\")\n\nSpecial forms:\n\n(is (thrown? c body)) checks that an instance of c is thrown from\nbody, fails if not; then returns the thing thrown.\n\n(is (thrown-with-msg? c re body)) checks that an instance of c is\nthrown AND that the message on the exception matches (with\nre-find) the regular expression re."},
           "cljs.core/MapEntry" {:protocols #{"IFn"
                                              "ISeqable"
                                              "IMeta"
                                              "IWithMeta"
                                              "IReversible"
                                              "IStack"
                                              "IEmptyableCollection"
                                              "ICounted"
                                              "IReduce"
                                              "ILookup"
                                              "ISequential"
                                              "ICollection"
                                              "IHash"
                                              "IComparable"
                                              "IPrintWithWriter"
                                              "IIndexed"
                                              "IAssociative"
                                              "IVector"
                                              "IFind"
                                              "IEquiv"
                                              "IMapEntry"},
                                 :ns "cljs.core",
                                 :name "MapEntry",
                                 :signature ["[key val __hash]"],
                                 :name-encode "MapEntry",
                                 :history [["+" "1.9.542"]],
                                 :type "type",
                                 :full-name-encode "cljs.core/MapEntry",
                                 :source {:code "(deftype MapEntry [key val ^:mutable __hash]\n  Object\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IMapEntry\n  (-key [node] key)\n  (-val [node] val)\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IMeta\n  (-meta [node] nil)\n\n  IWithMeta\n  (-with-meta [node meta]\n    (with-meta [key val] meta))\n\n  IStack\n  (-peek [node] val)\n\n  (-pop [node] [key])\n\n  ICollection\n  (-conj [node o] [key val o])\n\n  IEmptyableCollection\n  (-empty [node] nil)\n\n  ISequential\n  ISeqable\n  (-seq [node] (IndexedSeq. #js [key val] 0 nil))\n\n  IReversible\n  (-rseq [node] (IndexedSeq. #js [val key] 0 nil))\n\n  ICounted\n  (-count [node] 2)\n\n  IIndexed\n  (-nth [node n]\n    (cond (== n 0) key\n          (== n 1) val\n          :else    (throw (js/Error. \"Index out of bounds\"))))\n\n  (-nth [node n not-found]\n    (cond (== n 0) key\n          (== n 1) val\n          :else    not-found))\n\n  ILookup\n  (-lookup [node k] (-nth node k nil))\n  (-lookup [node k not-found] (-nth node k not-found))\n\n  IAssociative\n  (-assoc [node k v]\n    (assoc [key val] k v))\n  (-contains-key? [node k]\n    (or (== k 0) (== k 1)))\n\n  IFind\n  (-find [node k]\n    (case k\n      0 (MapEntry. 0 key nil)\n      1 (MapEntry. 1 val nil)\n      nil))\n\n  IVector\n  (-assoc-n [node n v]\n    (-assoc-n [key val] n v))\n\n  IReduce\n  (-reduce [node f]\n    (ci-reduce node f))\n\n  (-reduce [node f start]\n    (ci-reduce node f start))\n\n  IFn\n  (-invoke [node k]\n    (-nth node k))\n\n  (-invoke [node k not-found]\n    (-nth node k not-found)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [6790 6883]},
                                 :full-name "cljs.core/MapEntry"},
           "syntax/dot" {:syntax-equiv {:edn-url nil, :clj-url nil},
                         :ns "syntax",
                         :name "dot",
                         :name-encode "dot",
                         :type "special character",
                         :full-name-encode "syntax/dot",
                         :full-name "syntax/dot",
                         :history [["+" "0.0-927"]]},
           "cljs.spec.alpha/*explain-out*" {:ns "cljs.spec.alpha",
                                            :name "*explain-out*",
                                            :name-encode "STARexplain-outSTAR",
                                            :type "dynamic var",
                                            :full-name-encode "cljs.spec.alpha/STARexplain-outSTAR",
                                            :source {:code "(def ^:dynamic *explain-out* explain-printer)",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/cljs/cljs/spec/alpha.cljs",
                                                     :lines [262]},
                                            :full-name "cljs.spec.alpha/*explain-out*",
                                            :history [["+" "1.9.542"]]},
           "cljs.core/do" {:ns "cljs.core",
                           :name "do",
                           :signature ["[exprs*]"],
                           :name-encode "do",
                           :history [["+" "0.0-927"]],
                           :type "special form",
                           :full-name-encode "cljs.core/do",
                           :source {:code "(defmethod parse 'do\n  [op env [_ & exprs :as form] _ _]\n  (let [statements (analyze-do-statements env exprs)]\n    (if (<= (count exprs) 1)\n      (let [ret      (analyze env (first exprs))\n            children [:statements :ret]]\n        {:op :do\n         :env env\n         :form form\n         :statements statements :ret ret\n         :children children})\n      (let [ret-env  (if (= :statement (:context env))\n                       (assoc env :context :statement)\n                       (assoc env :context :return))\n            ret      (analyze ret-env (last exprs))\n            children [:statements :ret]]\n        {:op :do\n         :env env\n         :form form\n         :statements statements\n         :ret ret\n         :children children}))))",
                                    :title "Parser code",
                                    :repo "clojurescript",
                                    :tag "r1.12.38",
                                    :filename "src/main/clojure/cljs/analyzer.cljc",
                                    :lines [2379 2400]},
                           :extra-sources ({:code "(defmethod emit* :do\n  [{:keys [statements ret env]}]\n  (let [context (:context env)]\n    (when (and (seq statements) (= :expr context)) (emitln \"(function (){\"))\n    (doseq [s statements] (emitln s))\n    (emit ret)\n    (when (and (seq statements) (= :expr context)) (emitln \"})()\"))))",
                                            :title "Emitting code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/clojure/cljs/compiler.cljc",
                                            :lines [1060 1066]}),
                           :full-name "cljs.core/do",
                           :docstring "Evaluates the expressions in order and returns the value of\nthe last. If no expressions are supplied, returns nil."},
           "cljs.spec/get-spec" {:ns "cljs.spec",
                                 :name "get-spec",
                                 :signature ["[k]"],
                                 :name-encode "get-spec",
                                 :history [["+" "1.9.75"]
                                           ["-" "1.9.542"]],
                                 :type "function",
                                 :full-name-encode "cljs.spec/get-spec",
                                 :source {:code "(defn get-spec\n  [k]\n  (get (registry) (if (keyword? k) k (->sym k))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.9.521",
                                          :filename "src/main/cljs/cljs/spec.cljs",
                                          :lines [312 315]},
                                 :full-name "cljs.spec/get-spec",
                                 :docstring "Returns spec registered for keyword/symbol/var k, or nil.",
                                 :removed {:in "1.9.542",
                                           :last-seen "1.9.521"}},
           "syntax/unused" {:syntax-equiv {:edn-url nil, :clj-url nil},
                            :ns "syntax",
                            :name "unused",
                            :name-encode "unused",
                            :type "convention",
                            :full-name-encode "syntax/unused",
                            :full-name "syntax/unused",
                            :history [["+" "0.0-927"]]},
           "cljs.test/use-fixtures" {:ns "cljs.test",
                                     :name "use-fixtures",
                                     :signature ["[type & fns]"],
                                     :name-encode "use-fixtures",
                                     :history [["+" "0.0-2498"]],
                                     :type "macro",
                                     :full-name-encode "cljs.test/use-fixtures",
                                     :source {:code "(defmacro use-fixtures [type & fns]\n  (condp = type\n    :once\n    `(def ~'cljs-test-once-fixtures\n       [~@fns])\n    :each\n    `(def ~'cljs-test-each-fixtures\n       [~@fns])\n    :else\n    (throw\n      (#?(:clj Exception. :cljs js/Error.) \"First argument to cljs.test/use-fixtures must be :once or :each\"))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/cljs/cljs/test.cljc",
                                              :lines [432 442]},
                                     :full-name "cljs.test/use-fixtures"},
           "cljs.pprint/float?" {:ns "cljs.pprint",
                                 :name "float?",
                                 :signature ["[n]"],
                                 :name-encode "floatQMARK",
                                 :history [["+" "0.0-3255"]],
                                 :type "function",
                                 :full-name-encode "cljs.pprint/floatQMARK",
                                 :source {:code "(defn float?\n  [n]\n  (and (number? n)\n       (not ^boolean (js/isNaN n))\n       (not (identical? n js/Infinity))\n       (not (== (js/parseFloat n) (js/parseInt n 10)))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/pprint.cljs",
                                          :lines [55 61]},
                                 :full-name "cljs.pprint/float?",
                                 :docstring "Returns true if n is an float."},
           "compiler-options/fn-invoke-direct" {:ns "compiler-options",
                                                :name "fn-invoke-direct",
                                                :name-encode "fn-invoke-direct",
                                                :type "option",
                                                :full-name-encode "compiler-options/fn-invoke-direct",
                                                :full-name "compiler-options/fn-invoke-direct",
                                                :history [["+"
                                                           "1.9.660"]]},
           "cljs.core/PersistentHashMap.fromArrays" {:ns "cljs.core",
                                                     :name "PersistentHashMap.fromArrays",
                                                     :signature ["[ks vs]"],
                                                     :name-encode "PersistentHashMapDOTfromArrays",
                                                     :history [["+"
                                                                "0.0-1211"]],
                                                     :parent-type "PersistentHashMap",
                                                     :type "function",
                                                     :full-name-encode "cljs.core/PersistentHashMapDOTfromArrays",
                                                     :source {:code "(set! (.-fromArrays PersistentHashMap)\n  (fn [ks vs]\n    (let [len (alength ks)]\n      (loop [i 0 ^not-native out (transient (.-EMPTY PersistentHashMap))]\n        (if (< i len)\n          (if (<= (alength vs) i)\n            (throw (js/Error. (str \"No value supplied for key: \" (aget ks i))))\n            (recur (inc i) (-assoc! out (aget ks i) (aget vs i))))\n          (persistent! out))))))",
                                                              :title "Source code",
                                                              :repo "clojurescript",
                                                              :tag "r1.12.38",
                                                              :filename "src/main/cljs/cljs/core.cljs",
                                                              :lines [8241
                                                                      8249]},
                                                     :full-name "cljs.core/PersistentHashMap.fromArrays"},
           "cljs.core/special-symbol?" {:return-type boolean,
                                        :ns "cljs.core",
                                        :name "special-symbol?",
                                        :signature ["[x]"],
                                        :name-encode "special-symbolQMARK",
                                        :history [["+" "0.0-1803"]],
                                        :type "function",
                                        :full-name-encode "cljs.core/special-symbolQMARK",
                                        :source {:code "(defn ^boolean special-symbol?\n  [x]\n  (contains?\n    '#{if def fn* do let* loop* letfn* throw try catch finally\n       recur new set! ns deftype* defrecord* . js* & quote case* var ns*}\n    x))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/cljs/cljs/core.cljs",
                                                 :lines [11880 11886]},
                                        :full-name "cljs.core/special-symbol?",
                                        :docstring "Returns true if x names a special form"},
           "cljs.spec.impl.gen/fmap" {:ns "cljs.spec.impl.gen",
                                      :name "fmap",
                                      :signature ["[& args]"],
                                      :name-encode "fmap",
                                      :history [["+" "1.9.14"]
                                                ["-" "1.9.542"]],
                                      :type "function",
                                      :full-name-encode "cljs.spec.impl.gen/fmap",
                                      :source {:code "(lazy-combinators hash-map list map not-empty set vector vector-distinct fmap elements\n  bind choose one-of such-that tuple sample return\n  large-integer* double* frequency)",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.9.521",
                                               :filename "src/main/cljs/cljs/spec/impl/gen.cljs",
                                               :lines [69 71]},
                                      :full-name "cljs.spec.impl.gen/fmap",
                                      :docstring "Lazy loaded version of clojure.test.check.generators/fmap",
                                      :removed {:in "1.9.542",
                                                :last-seen "1.9.521"}},
           "cljs.repl.browser/constrain-order" {:ns "cljs.repl.browser",
                                                :name "constrain-order",
                                                :signature ["[order f]"],
                                                :name-encode "constrain-order",
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.repl.browser/constrain-order",
                                                :source {:code "(defn constrain-order\n  [order f]\n  (send-via es ordering add-in-order order f)\n  (send-via es ordering run-in-order))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1.12.38",
                                                         :filename "src/main/clojure/cljs/repl/browser.clj",
                                                         :lines [286
                                                                 291]},
                                                :full-name "cljs.repl.browser/constrain-order",
                                                :docstring "Elements to be printed in the REPL will arrive out of order. Ensure\nthat they are printed in the correct order."},
           "cljs.math/log" {:return-type number,
                            :ns "cljs.math",
                            :name "log",
                            :signature ["[a]"],
                            :name-encode "log",
                            :history [["+" "1.11.50"]],
                            :type "function",
                            :full-name-encode "cljs.math/log",
                            :source {:code "(defn ^number log\n  {:added \"1.11.10\"}\n  [a] (Math/log a))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/cljs/cljs/math.cljs",
                                     :lines [149 156]},
                            :full-name "cljs.math/log",
                            :docstring "Returns the natural logarithm (base e) of a.\nIf a is ##NaN or negative => ##NaN\nIf a is ##Inf => ##Inf\nIf a is zero => ##-Inf\nSee: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/log"},
           "cljs.spec.gen.alpha/sample" {:ns "cljs.spec.gen.alpha",
                                         :name "sample",
                                         :signature ["[& args]"],
                                         :name-encode "sample",
                                         :history [["+" "1.9.542"]],
                                         :type "function",
                                         :full-name-encode "cljs.spec.gen.alpha/sample",
                                         :source {:code "(lazy-combinators hash-map list map not-empty set vector vector-distinct fmap elements\n  bind choose one-of such-that tuple sample return\n  large-integer* double* frequency shuffle)",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/cljs/cljs/spec/gen/alpha.cljs",
                                                  :lines [70 72]},
                                         :full-name "cljs.spec.gen.alpha/sample",
                                         :docstring "Lazy loaded version of clojure.test.check.generators/sample"},
           "cljs.js/load-deps" {:ns "cljs.js",
                                :name "load-deps",
                                :signature ["[bound-vars ana-env lib deps cb]"
                                            "[bound-vars ana-env lib deps opts cb]"],
                                :name-encode "load-deps",
                                :history [["+" "1.7.10"]
                                          ["-" "1.7.28"]],
                                :type "function",
                                :full-name-encode "cljs.js/load-deps",
                                :source {:code "(defn load-deps\n  ([bound-vars ana-env lib deps cb]\n   (analyze-deps bound-vars ana-env lib deps nil cb))\n  ([bound-vars ana-env lib deps opts cb]\n   (when (:verbose opts)\n     (debug-prn \"Loading dependencies for\" lib))\n   (binding [ana/*cljs-dep-set* (vary-meta (conj (:*cljs-dep-set* bound-vars) lib)\n                                  update-in [:dep-path] conj lib)]\n     (assert (every? #(not (contains? (:*cljs-dep-set* bound-vars) %)) deps)\n       (str \"Circular dependency detected \"\n         (-> (:*cljs-dep-set* bound-vars) meta :dep-path)))\n     (if (seq deps)\n       (let [dep (first deps)]\n         (require bound-vars dep\n           (-> opts\n             (dissoc :context)\n             (dissoc :ns))\n           (fn [res]\n             (if-not (:error res)\n               (load-deps bound-vars ana-env lib (next deps) opts cb)\n               (cb res)))))\n       (cb {:value nil})))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.10",
                                         :filename "src/main/cljs/cljs/js.cljs",
                                         :lines [236 257]},
                                :full-name "cljs.js/load-deps",
                                :removed {:in "1.7.28",
                                          :last-seen "1.7.10"}},
           "cljs.core/case*" {:ns "cljs.core",
                              :name "case*",
                              :name-encode "caseSTAR",
                              :type "special form",
                              :full-name-encode "cljs.core/caseSTAR",
                              :source {:code "(defmethod parse 'case*\n  [op env [_ sym tests thens default :as form] name _]\n  (assert (symbol? sym) \"case* must switch on symbol\")\n  (assert (every? vector? tests) \"case* tests must be grouped in vectors\")\n  (let [expr-env (assoc env :context :expr)\n        v        (disallowing-recur (analyze expr-env sym))\n        tests    (mapv #(mapv (fn [t] (analyze expr-env t)) %) tests)\n        thens    (mapv #(analyze env %) thens)\n        nodes    (mapv (fn [tests then]\n                         {:op :case-node\n                          ;synthetic node, no :form\n                          :env env\n                          :tests (mapv (fn [test]\n                                         {:op :case-test\n                                          :form (:form test)\n                                          :env expr-env\n                                          :test test\n                                          :children [:test]})\n                                       tests)\n                          :then {:op :case-then\n                                 :form (:form then)\n                                 :env env\n                                 :then then\n                                 :children [:then]}\n                          :children [:tests :then]})\n                       tests\n                       thens)\n        default  (analyze env default)]\n    (assert (every? (fn [t]\n                      (or\n                        (-> t :info :const)\n                        (and (= :const (:op t))\n                             ((some-fn number? string? char?) (:form t)))))\n              (apply concat tests))\n      \"case* tests must be numbers, strings, or constants\")\n    {:env env :op :case :form form\n     :test v :nodes nodes :default default\n     :children [:test :nodes :default]}))",
                                       :title "Parser code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/clojure/cljs/analyzer.cljc",
                                       :lines [1781 1818]},
                              :full-name "cljs.core/case*",
                              :history [["+" "0.0-2227"]]},
           "cljs.core/js-debugger" {:ns "cljs.core",
                                    :name "js-debugger",
                                    :signature ["[]"],
                                    :name-encode "js-debugger",
                                    :history [["+" "0.0-2496"]],
                                    :type "macro",
                                    :full-name-encode "cljs.core/js-debugger",
                                    :source {:code "(core/defmacro js-debugger\n  []\n  (core/list 'do\n             (core/list 'js* \"debugger\")\n             nil))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/clojure/cljs/core.cljc",
                                             :lines [932 937]},
                                    :full-name "cljs.core/js-debugger",
                                    :docstring "Emit JavaScript \"debugger;\" statement"},
           "cljs.core/ns-interns*" {:ns "cljs.core",
                                    :name "ns-interns*",
                                    :signature ["[sym]"],
                                    :name-encode "ns-internsSTAR",
                                    :history [["+" "1.7.10"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/ns-internsSTAR",
                                    :source {:code "(defn ns-interns*\n  [sym]\n  (let [ns-obj (find-ns-obj sym)\n        ns     (Namespace. ns-obj sym)]\n    (letfn [(step [ret k]\n              (let [var-sym (symbol (demunge k))]\n                (assoc ret\n                  var-sym (Var. #(gobject/get ns-obj k)\n                            (symbol (str sym) (str var-sym)) {:ns ns}))))]\n      (reduce step {} (js-keys ns-obj)))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [12164 12175]},
                                    :full-name "cljs.core/ns-interns*",
                                    :docstring "Returns a map of the intern mappings for the namespace.\nBootstrap only."},
           "cljs.repl/default-special-fns" {:ns "cljs.repl",
                                            :name "default-special-fns",
                                            :name-encode "default-special-fns",
                                            :type "var",
                                            :full-name-encode "cljs.repl/default-special-fns",
                                            :source {:code "(def default-special-fns\n  (let [load-file-fn\n        (fn self\n          ([repl-env env form]\n            (self repl-env env form nil))\n          ([repl-env env [_ file :as form] opts]\n            (load-file repl-env file opts)))\n        in-ns-fn\n        (fn self\n          ([repl-env env form]\n           (self repl-env env form nil))\n          ([repl-env env [_ [quote ns-name] :as form] _]\n            ;; guard against craziness like '5 which wreaks havoc\n           (when-not (and (= quote 'quote) (symbol? ns-name))\n             (throw (IllegalArgumentException. \"Argument to in-ns must be a symbol.\")))\n           (when-not (ana/get-namespace ns-name)\n             (swap! env/*compiler* assoc-in [::ana/namespaces ns-name] {:name ns-name})\n             (-evaluate repl-env \"<cljs repl>\" 1\n               (str \"goog.provide('\" (comp/munge ns-name) \"');\")))\n           (set! ana/*cljs-ns* ns-name)))\n        load-fn\n        (fn self\n          ([repl-env env form]\n           (self env repl-env form nil))\n          ([repl-env env [_ & paths :as form] opts]\n           (let [cp-paths (map load-path->cp-path paths)]\n             (run! #(load-file repl-env % opts) cp-paths))))]\n    (wrap-special-fns wrap-self\n     {'in-ns in-ns-fn\n      'clojure.core/in-ns in-ns-fn\n      'load-file load-file-fn\n      'clojure.core/load-file load-file-fn\n      'load-namespace\n      (fn self\n        ([repl-env env form]\n         (self env repl-env form nil))\n        ([repl-env env [_ ns :as form] opts]\n         (load-namespace repl-env ns opts)))\n      'load load-fn\n      'clojure.core/load load-fn})))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/clojure/cljs/repl.cljc",
                                                     :lines [754 793]},
                                            :full-name "cljs.repl/default-special-fns",
                                            :history [["+" "0.0-993"]]},
           "cljs.core/qualified-keyword?" {:ns "cljs.core",
                                           :name "qualified-keyword?",
                                           :signature ["[x]"],
                                           :name-encode "qualified-keywordQMARK",
                                           :history [["+" "1.9.75"]],
                                           :type "function",
                                           :full-name-encode "cljs.core/qualified-keywordQMARK",
                                           :source {:code "(defn qualified-keyword?\n  [x] (boolean (and (keyword? x) (namespace x) true)))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/cljs/cljs/core.cljs",
                                                    :lines [3478 3480]},
                                           :full-name "cljs.core/qualified-keyword?",
                                           :docstring "Return true if x is a keyword with a namespace"},
           "cljs.core/format" {:ns "cljs.core",
                               :name "format",
                               :signature ["[fmt & args]"],
                               :name-encode "format",
                               :history [["+" "0.0-1443"]
                                         ["-" "0.0-1885"]],
                               :type "function",
                               :full-name-encode "cljs.core/format",
                               :source {:code "(defn format\n  [fmt & args]\n  (apply gstring/format fmt args))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1878",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1771 1774]},
                               :full-name "cljs.core/format",
                               :docstring "Formats a string using goog.string.format.",
                               :removed {:in "0.0-1885",
                                         :last-seen "0.0-1878"}},
           "cljs.core/sorted-set" {:ns "cljs.core",
                                   :name "sorted-set",
                                   :signature ["[& keys]"],
                                   :name-encode "sorted-set",
                                   :history [["+" "0.0-1211"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/sorted-set",
                                   :source {:code "(defn sorted-set\n  ([& keys]\n   (reduce -conj (.-EMPTY PersistentTreeSet) keys)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [9676 9679]},
                                   :full-name "cljs.core/sorted-set",
                                   :docstring "Returns a new sorted set with supplied keys."},
           "cljs.core/fnil" {:ns "cljs.core",
                             :name "fnil",
                             :signature ["[f x]"
                                         "[f x y]"
                                         "[f x y z]"],
                             :name-encode "fnil",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/fnil",
                             :source {:code "(defn fnil\n  ([f x]\n   (fn\n     ([a] (f (if (nil? a) x a)))\n     ([a b] (f (if (nil? a) x a) b))\n     ([a b c] (f (if (nil? a) x a) b c))\n     ([a b c & ds] (apply f (if (nil? a) x a) b c ds))))\n  ([f x y]\n   (fn\n     ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))\n     ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) c))\n     ([a b c & ds] (apply f (if (nil? a) x a) (if (nil? b) y b) c ds))))\n  ([f x y z]\n   (fn\n     ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))\n     ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) (if (nil? c) z c)))\n     ([a b c & ds] (apply f (if (nil? a) x a) (if (nil? b) y b) (if (nil? c) z c) ds)))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [4432 4453]},
                             :full-name "cljs.core/fnil",
                             :docstring "Takes a function f, and returns a function that calls f, replacing\na nil first argument to f with the supplied value x. Higher arity\nversions can replace arguments in the second and third\npositions (y, z). Note that the function f can take any number of\narguments, not just the one(s) being nil-patched."},
           "cljs.core/ns*" {:ns "cljs.core",
                            :name "ns*",
                            :name-encode "nsSTAR",
                            :history [["+" "1.9.293"]],
                            :type "special form",
                            :full-name-encode "cljs.core/nsSTAR",
                            :source {:code "(defmethod parse 'ns*\n  [_ env [_ quoted-specs :as form] _ opts]\n  (when-let [not-quoted (->> (remove keyword? quoted-specs)\n                          (remove #(and (seq? %) (= 'quote (first %))) )\n                          first)]\n    (throw (error env (str \"Arguments to \" (name (first quoted-specs))\n                        \" must be quoted. Offending spec: \" not-quoted))))\n  (when-not *allow-ns*\n    (throw (error env (str \"Calls to `\" (name (first quoted-specs))\n                        \"` must appear at the top-level.\"))))\n  (let [specs        (if (= :import (first quoted-specs))\n                       (canonicalize-import-specs quoted-specs)\n                       (canonicalize-specs quoted-specs))\n        name         (-> env :ns :name)\n        args         (desugar-ns-specs\n                       #?(:clj  (list (process-rewrite-form\n                                        specs))\n                          :cljs (list specs)))\n        {:keys [as-aliases] args :libspecs} (nses/elide-aliases-from-ns-specs args)\n        {excludes :excludes core-renames :renames} (parse-ns-excludes env args)\n        core-renames (reduce (fn [m [original renamed]]\n                               (assoc m renamed (symbol \"cljs.core\" (str original))))\n                       {} core-renames)\n        deps         (atom [])\n        ;; as-aliases can only be used *once* because they are about the reader\n        aliases      (atom {:fns as-aliases :macros as-aliases})\n        spec-parsers {:require        (partial parse-require-spec env false deps aliases)\n                      :require-macros (partial parse-require-spec env true deps aliases)\n                      :use            (comp (partial parse-require-spec env false deps aliases)\n                                        (partial use->require env))\n                      :use-macros     (comp (partial parse-require-spec env true deps aliases)\n                                        (partial use->require env))\n                      :import         (partial parse-import-spec env deps)}\n        reload       (atom {:use nil :require nil :use-macros nil :require-macros nil})\n        reloads      (atom {})\n        {uses :use requires :require renames :rename\n         use-macros :use-macros require-macros :require-macros\n         rename-macros :rename-macros imports :import :as params}\n        (reduce\n          (fn [m [k & libs]]\n            ;; check for spec type reloads\n            (when-not (= :import k)\n              (when (some? (some #{:reload} libs))\n                (swap! reload assoc k :reload))\n              (when (some? (some #{:reload-all} libs))\n                (swap! reload assoc k :reload-all)))\n            ;; check for individual ns reloads from REPL interactions\n            (when-some [xs (seq (filter #(-> % meta :reload) libs))]\n              (swap! reloads assoc k\n                (zipmap (map first xs) (map #(-> % meta :reload) xs))))\n            (apply merge-with merge m\n              (map (spec-parsers k)\n                (remove #{:reload :reload-all} libs))))\n          {} (remove (fn [[r]] (= r :refer-clojure)) args))]\n    (set! *cljs-ns* name)\n    (let [require-info\n          {:as-aliases     as-aliases\n           :name           name\n           :excludes       excludes\n           :use-macros     use-macros\n           :require-macros require-macros\n           :rename-macros  rename-macros\n           :uses           uses\n           :requires       requires\n           :renames        (merge renames core-renames)\n           :imports        imports}]\n      (swap! env/*compiler* update-in [::namespaces name] merge-ns-info require-info env)\n      (merge {:op      :ns*\n              :env     env\n              :form    form\n              :deps    (into [] (distinct @deps))\n              :reload  @reload\n              :reloads @reloads}\n        (cond-> require-info\n          (@reload :use)\n          (update-in [:uses]\n            (fn [m] (with-meta m {(@reload :use) true})))\n          (@reload :require)\n          (update-in [:requires]\n            (fn [m] (with-meta m {(@reload :require) true}))))))))",
                                     :title "Parser code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/clojure/cljs/analyzer.cljc",
                                     :lines [3352 3431]},
                            :extra-sources ({:code "(defmethod emit* :ns*\n  [{:keys [name requires uses require-macros reloads env deps]}]\n  (load-libs requires nil (:require reloads) deps name)\n  (load-libs uses requires (:use reloads) deps name)\n  (when (:repl-env env)\n    (emitln \"'nil';\")))",
                                             :title "Emitting code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/clojure/cljs/compiler.cljc",
                                             :lines [1372 1377]}),
                            :full-name "cljs.core/ns*"},
           "cljs.core/update" {:ns "cljs.core",
                               :name "update",
                               :signature ["[m k f]"
                                           "[m k f x]"
                                           "[m k f x y]"
                                           "[m k f x y z]"
                                           "[m k f x y z & more]"],
                               :name-encode "update",
                               :history [["+" "0.0-2411"]],
                               :type "function",
                               :full-name-encode "cljs.core/update",
                               :source {:code "(defn update\n  ([m k f]\n   (assoc m k (f (get m k))))\n  ([m k f x]\n   (assoc m k (f (get m k) x)))\n  ([m k f x y]\n   (assoc m k (f (get m k) x y)))\n  ([m k f x y z]\n   (assoc m k (f (get m k) x y z)))\n  ([m k f x y z & more]\n   (assoc m k (apply f (get m k) x y z more))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [5463 5477]},
                               :full-name "cljs.core/update",
                               :docstring "'Updates' a value in an associative structure, where k is a\nkey and f is a function that will take the old value\nand any supplied args and return the new value, and returns a new\nstructure.  If the key does not exist, nil is passed as the old value."},
           "cljs.core/--destructure-map" {:ns "cljs.core",
                                          :name "--destructure-map",
                                          :signature ["[gmap]"],
                                          :name-encode "--destructure-map",
                                          :history [["+" "1.10.844"]],
                                          :type "function",
                                          :full-name-encode "cljs.core/--destructure-map",
                                          :source {:code "(defn --destructure-map [gmap]\n  (if (implements? ISeq gmap)\n    (if (next gmap)\n      (.createAsIfByAssoc PersistentArrayMap (to-array gmap))\n      (if (seq gmap)\n        (first gmap)\n        (.-EMPTY PersistentArrayMap)))\n    gmap))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/cljs/cljs/core.cljs",
                                                   :lines [4068 4075]},
                                          :full-name "cljs.core/--destructure-map"},
           "warnings/fn-arity" {:ns "warnings",
                                :name "fn-arity",
                                :name-encode "fn-arity",
                                :type "warning",
                                :full-name-encode "warnings/fn-arity",
                                :full-name "warnings/fn-arity",
                                :history [["+" "0.0-1853"]]},
           "cljs.core/this-as" {:ns "cljs.core",
                                :name "this-as",
                                :signature ["[name & body]"],
                                :name-encode "this-as",
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :full-name-encode "cljs.core/this-as",
                                :source {:code "(core/defmacro this-as\n  [name & body]\n  `(let [~name (js-this)]\n     ~@body))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/clojure/cljs/core.cljc",
                                         :lines [1405 1409]},
                                :full-name "cljs.core/this-as",
                                :docstring "Defines a scope where JavaScript's implicit \"this\" is bound to the name provided."},
           "cljs.repl.rhino/rhino-eval" {:ns "cljs.repl.rhino",
                                         :name "rhino-eval",
                                         :signature ["[{:keys [scope], :as repl-env} filename line js]"],
                                         :name-encode "rhino-eval",
                                         :history [["+" "0.0-927"]
                                                   ["-" "1.10.738"]],
                                         :type "function",
                                         :full-name-encode "cljs.repl.rhino/rhino-eval",
                                         :source {:code "(defn rhino-eval\n  [{:keys [scope] :as repl-env} filename line js]\n  (try\n    (let [linenum (or line Integer/MIN_VALUE)]\n      {:status :success\n       :value (eval-result (-eval js repl-env filename linenum))})\n    (catch Throwable ex\n      ;; manually set *e\n      (let [top-level (-> scope\n                        (ScriptableObject/getProperty \"cljs\")\n                        (ScriptableObject/getProperty \"core\"))]\n        (ScriptableObject/putProperty top-level \"_STAR_e\"\n          (Context/javaToJS ex scope))\n        {:status :exception\n         :value  (cljs.repl/ex-str (cljs.repl/ex-triage (Throwable->map ex)))}))))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.10.597",
                                                  :filename "src/main/clojure/cljs/repl/rhino.clj",
                                                  :lines [75 89]},
                                         :full-name "cljs.repl.rhino/rhino-eval",
                                         :removed {:in "1.10.738",
                                                   :last-seen "1.10.597"}},
           "cljs.core/PersistentQueueSeq" {:protocols #{"ISeqable"
                                                        "IMeta"
                                                        "IWithMeta"
                                                        "IEmptyableCollection"
                                                        "ISequential"
                                                        "ISeq"
                                                        "ICollection"
                                                        "IHash"
                                                        "IPrintWithWriter"
                                                        "INext"
                                                        "IEquiv"},
                                           :ns "cljs.core",
                                           :name "PersistentQueueSeq",
                                           :signature ["[meta front rear __hash]"],
                                           :name-encode "PersistentQueueSeq",
                                           :history [["+" "0.0-927"]],
                                           :type "type",
                                           :full-name-encode "cljs.core/PersistentQueueSeq",
                                           :source {:code "(deftype PersistentQueueSeq [meta front rear ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (PersistentQueueSeq. new-meta front rear __hash)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] (first front))\n  (-rest  [coll]\n    (if-let [f1 (next front)]\n      (PersistentQueueSeq. meta f1 rear nil)\n      (if (nil? rear)\n        (-empty coll)\n        (PersistentQueueSeq. meta rear nil nil))))\n\n  INext\n  (-next [coll]\n    (if-let [f1 (next front)]\n      (PersistentQueueSeq. meta f1 rear nil)\n      (when (some? rear)\n        (PersistentQueueSeq. meta rear nil nil))))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (-with-meta (.-EMPTY List) meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  ISeqable\n  (-seq [coll] coll))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/cljs/cljs/core.cljs",
                                                    :lines [6349 6403]},
                                           :full-name "cljs.core/PersistentQueueSeq"},
           "cljs.core/counted?" {:ns "cljs.core",
                                 :name "counted?",
                                 :signature ["[x]"],
                                 :name-encode "countedQMARK",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/countedQMARK",
                                 :source {:code "(defn counted?\n  [x] (satisfies? ICounted x))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [1564 1566]},
                                 :full-name "cljs.core/counted?",
                                 :docstring "Returns true if coll implements count in constant time"},
           "compiler-options/use-only-custom-externs" {:ns "compiler-options",
                                                       :name "use-only-custom-externs",
                                                       :name-encode "use-only-custom-externs",
                                                       :type "option",
                                                       :full-name-encode "compiler-options/use-only-custom-externs",
                                                       :full-name "compiler-options/use-only-custom-externs",
                                                       :history [["+"
                                                                  "0.0-971"]]},
           "repl-options/inits" {:ns "repl-options",
                                 :name "inits",
                                 :name-encode "inits",
                                 :type "option",
                                 :full-name-encode "repl-options/inits",
                                 :full-name "repl-options/inits",
                                 :history [["+" "1.10.63"]]},
           "cljs.repl.browser/read-headers" {:ns "cljs.repl.browser",
                                             :name "read-headers",
                                             :signature ["[rdr]"],
                                             :name-encode "read-headers",
                                             :history [["+" "0.0-927"]
                                                       ["-"
                                                        "0.0-1503"]],
                                             :type "function",
                                             :full-name-encode "cljs.repl.browser/read-headers",
                                             :source {:code "(defn read-headers [rdr]\n  (loop [next-line (.readLine rdr)\n         header-lines []]\n    (if (= \"\" next-line)\n      header-lines                      ;we're done reading headers\n      (recur (.readLine rdr) (conj header-lines next-line)))))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1450",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [136 141]},
                                             :full-name "cljs.repl.browser/read-headers",
                                             :removed {:in "0.0-1503",
                                                       :last-seen "0.0-1450"}},
           "cljs.analyzer.api/warning-enabled?" {:ns "cljs.analyzer.api",
                                                 :name "warning-enabled?",
                                                 :signature ["[warning-type]"],
                                                 :name-encode "warning-enabledQMARK",
                                                 :history [["+"
                                                            "1.7.10"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.analyzer.api/warning-enabledQMARK",
                                                 :source {:code "(defn warning-enabled?\n  [warning-type]\n  (ana/*cljs-warnings* warning-type))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r1.12.38",
                                                          :filename "src/main/clojure/cljs/analyzer/api.cljc",
                                                          :lines [69
                                                                  72]},
                                                 :full-name "cljs.analyzer.api/warning-enabled?",
                                                 :docstring "Test if the given warning-type is enabled."},
           "clojure.string/trimr" {:return-type string,
                                   :ns "clojure.string",
                                   :name "trimr",
                                   :signature ["[s]"],
                                   :name-encode "trimr",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "clojure.string/trimr",
                                   :source {:code "(defn ^string trimr\n  [s]\n  (gstring/trimRight s))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/clojure/string.cljs",
                                            :lines [207 210]},
                                   :full-name "clojure.string/trimr",
                                   :docstring "Removes whitespace from the right side of string."},
           "clojure.core.reducers/take" {:ns "clojure.core.reducers",
                                         :name "take",
                                         :signature ["[n]" "[n coll]"],
                                         :name-encode "take",
                                         :history [["+" "0.0-1236"]],
                                         :type "function",
                                         :full-name-encode "clojure.core.reducers/take",
                                         :source {:code "(defcurried take\n  {}\n  [n coll]\n  (reducer coll\n   (fn [f1]\n     (let [cnt (atom n)]\n       (rfn [f1 k]\n         ([ret k v]\n            (swap! cnt dec)\n            (if (neg? @cnt)\n              (reduced ret)\n              (f1 ret k v))))))))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/cljs/clojure/core/reducers.cljs",
                                                  :lines [164 176]},
                                         :full-name "clojure.core.reducers/take",
                                         :docstring "Ends the reduction of coll after consuming n values."},
           "cljs.repl/IReplEnvOptions" {:ns "cljs.repl",
                                        :name "IReplEnvOptions",
                                        :name-encode "IReplEnvOptions",
                                        :history [["+" "0.0-2719"]],
                                        :type "protocol",
                                        :full-name-encode "cljs.repl/IReplEnvOptions",
                                        :source {:code "(defprotocol IReplEnvOptions\n  (-repl-options [repl-env] \"Return default REPL options for a REPL Env\"))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/clojure/cljs/repl.cljc",
                                                 :lines [115 116]},
                                        :methods [{:name "-repl-options",
                                                   :signature ["[repl-env]"],
                                                   :docstring "Return default REPL options for a REPL Env"}],
                                        :full-name "cljs.repl/IReplEnvOptions"},
           "cljs.core/force" {:ns "cljs.core",
                              :name "force",
                              :signature ["[x]"],
                              :name-encode "force",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/force",
                              :source {:code "(defn force\n  [x]\n  (if (delay? x)\n    (deref x)\n    x))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [10985 10990]},
                              :full-name "cljs.core/force",
                              :docstring "If x is a Delay, returns the (possibly cached) value of its expression, else returns x"},
           "cljs.core/compare-and-set!" {:ns "cljs.core",
                                         :name "compare-and-set!",
                                         :signature ["[a oldval newval]"],
                                         :name-encode "compare-and-setBANG",
                                         :history [["+" "0.0-927"]],
                                         :type "function",
                                         :full-name-encode "cljs.core/compare-and-setBANG",
                                         :source {:code "(defn compare-and-set!\n  [^not-native a oldval newval]\n  (if (= (-deref a) oldval)\n    (do (reset! a newval) true)\n    false))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/cljs/cljs/core.cljs",
                                                  :lines [4645 4652]},
                                         :full-name "cljs.core/compare-and-set!",
                                         :docstring "Atomically sets the value of atom to newval if and only if the\ncurrent value of the atom is equal to oldval. Returns true if\nset happened, else false."},
           "cljs.core/set?" {:ns "cljs.core",
                             :name "set?",
                             :signature ["[x]"],
                             :name-encode "setQMARK",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/setQMARK",
                             :source {:code "(defn set?\n  [x]\n  (if (nil? x)\n    false\n    (satisfies? ISet x)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [2193 2198]},
                             :full-name "cljs.core/set?",
                             :docstring "Returns true if x satisfies ISet"},
           "cljs.core/hash-string" {:ns "cljs.core",
                                    :name "hash-string",
                                    :signature ["[k]"],
                                    :name-encode "hash-string",
                                    :history [["+" "0.0-2261"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/hash-string",
                                    :source {:code "(defn hash-string [k]\n  (when (> string-hash-cache-count 255)\n    (set! string-hash-cache (js-obj))\n    (set! string-hash-cache-count 0))\n  (if (nil? k)\n    0\n    (let [h (unchecked-get string-hash-cache k)]\n      (if (number? h)\n        h\n        (add-to-string-hash-cache k)))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [1013 1022]},
                                    :full-name "cljs.core/hash-string"},
           "cljs.repl.server/set-connection" {:ns "cljs.repl.server",
                                              :name "set-connection",
                                              :signature ["[conn]"],
                                              :name-encode "set-connection",
                                              :history [["+"
                                                         "0.0-1503"]],
                                              :type "function",
                                              :full-name-encode "cljs.repl.server/set-connection",
                                              :source {:code "(defn set-connection\n  [conn]\n  (locking lock\n    (if-let [p (.poll promiseq)]\n      (deliver p conn)\n      (.offer connq conn))))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.12.38",
                                                       :filename "src/main/clojure/cljs/repl/server.clj",
                                                       :lines [37 44]},
                                              :full-name "cljs.repl.server/set-connection",
                                              :docstring "Given a new available connection, poll the promise queue for and deliver\nthe connection. Otherwise put the connection into a FIFO queue."},
           "cljs.spec.gen.alpha/dynaload" {:ns "cljs.spec.gen.alpha",
                                           :name "dynaload",
                                           :signature ["[[quote s]]"],
                                           :name-encode "dynaload",
                                           :history [["+" "1.9.542"]],
                                           :type "macro",
                                           :full-name-encode "cljs.spec.gen.alpha/dynaload",
                                           :source {:code "(defmacro dynaload [[quote s]]\n  `(cljs.spec.gen.alpha/LazyVar.\n     (fn []\n       (if (c/exists? ~s)\n         ~(vary-meta s assoc :cljs.analyzer/no-resolve true)\n         (throw\n           (js/Error.\n             (str \"Var \" '~s \" does not exist, \"\n                  (namespace '~s) \" never required\")))))\n     nil))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/cljs/cljs/spec/gen/alpha.cljc",
                                                    :lines [14 23]},
                                           :full-name "cljs.spec.gen.alpha/dynaload"},
           "cljs.core/Inst" {:ns "cljs.core",
                             :name "Inst",
                             :name-encode "Inst",
                             :implementations #{"js/Date"},
                             :history [["+" "1.9.75"]],
                             :type "protocol",
                             :full-name-encode "cljs.core/Inst",
                             :source {:code "(defprotocol Inst\n  (inst-ms* [inst]))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [1428 1429]},
                             :methods [{:name "inst-ms*",
                                        :signature ["[inst]"],
                                        :docstring nil}],
                             :full-name "cljs.core/Inst"},
           "cljs.core/load-file" {:ns "cljs.core",
                                  :name "load-file",
                                  :signature ["[name]"],
                                  :name-encode "load-file",
                                  :history [["+" "0.0-927"]],
                                  :type "special form (repl)",
                                  :full-name-encode "cljs.core/load-file",
                                  :source {:code "(def default-special-fns\n  (let [load-file-fn\n        (fn self\n          ([repl-env env form]\n            (self repl-env env form nil))\n          ([repl-env env [_ file :as form] opts]\n            (load-file repl-env file opts)))\n        in-ns-fn\n        (fn self\n          ([repl-env env form]\n           (self repl-env env form nil))\n          ([repl-env env [_ [quote ns-name] :as form] _]\n            ;; guard against craziness like '5 which wreaks havoc\n           (when-not (and (= quote 'quote) (symbol? ns-name))\n             (throw (IllegalArgumentException. \"Argument to in-ns must be a symbol.\")))\n           (when-not (ana/get-namespace ns-name)\n             (swap! env/*compiler* assoc-in [::ana/namespaces ns-name] {:name ns-name})\n             (-evaluate repl-env \"<cljs repl>\" 1\n               (str \"goog.provide('\" (comp/munge ns-name) \"');\")))\n           (set! ana/*cljs-ns* ns-name)))\n        load-fn\n        (fn self\n          ([repl-env env form]\n           (self env repl-env form nil))\n          ([repl-env env [_ & paths :as form] opts]\n           (let [cp-paths (map load-path->cp-path paths)]\n             (run! #(load-file repl-env % opts) cp-paths))))]\n    (wrap-special-fns wrap-self\n     {'in-ns in-ns-fn\n      'clojure.core/in-ns in-ns-fn\n      'load-file load-file-fn\n      'clojure.core/load-file load-file-fn\n      'load-namespace\n      (fn self\n        ([repl-env env form]\n         (self env repl-env form nil))\n        ([repl-env env [_ ns :as form] opts]\n         (load-namespace repl-env ns opts)))\n      'load load-fn\n      'clojure.core/load load-fn})))",
                                           :title "repl specials table",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/clojure/cljs/repl.cljc",
                                           :lines [754 793]},
                                  :full-name "cljs.core/load-file",
                                  :repl-only? true,
                                  :docstring "Sequentially read and evaluate the set of forms contained in the file."},
           "syntax/unquote-splicing" {:syntax-equiv {:edn-url nil,
                                                     :clj-url nil},
                                      :ns "syntax",
                                      :name "unquote-splicing",
                                      :name-encode "unquote-splicing",
                                      :history [["+" "0.0-1853"]],
                                      :type "syntax",
                                      :full-name-encode "syntax/unquote-splicing",
                                      :extra-sources ({:code "(defn- read-unquote\n  [rdr comma opts pending-forms]\n  (if-let [ch (peek-char rdr)]\n    (if (identical? \\@ ch)\n      ((wrapping-reader 'clojure.core/unquote-splicing) (doto rdr read-char) \\@ opts pending-forms)\n      ((wrapping-reader 'clojure.core/unquote) rdr \\~ opts pending-forms))))",
                                                       :title "Reader code",
                                                       :repo "tools.reader",
                                                       :tag "v1.3.6",
                                                       :filename "src/main/clojure/clojure/tools/reader.clj",
                                                       :lines [598
                                                               603]}
                                                      {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                                       :title "Reader table",
                                                       :repo "tools.reader",
                                                       :tag "v1.3.6",
                                                       :filename "src/main/clojure/clojure/tools/reader.clj",
                                                       :lines [788
                                                               807]}),
                                      :full-name "syntax/unquote-splicing"},
           "cljs.core/unchecked-dec" {:ns "cljs.core",
                                      :name "unchecked-dec",
                                      :signature ["[x]"],
                                      :name-encode "unchecked-dec",
                                      :history [["+" "0.0-1798"]],
                                      :type "function/macro",
                                      :full-name-encode "cljs.core/unchecked-dec",
                                      :source {:code "(defn unchecked-dec\n  [x]\n  (cljs.core/unchecked-dec x))",
                                               :title "Function code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [2819 2822]},
                                      :extra-sources [{:code "(core/defmacro ^::ana/numeric unchecked-dec\n  ([x] `(dec ~x)))",
                                                       :title "Macro code",
                                                       :repo "clojurescript",
                                                       :tag "r1.12.38",
                                                       :filename "src/main/clojure/cljs/core.cljc",
                                                       :lines [1083
                                                               1084]}],
                                      :full-name "cljs.core/unchecked-dec",
                                      :docstring "Returns a number one less than x, an int."},
           "cljs.core/PersistentVector.EMPTY-NODE" {:ns "cljs.core",
                                                    :name "PersistentVector.EMPTY-NODE",
                                                    :name-encode "PersistentVectorDOTEMPTY-NODE",
                                                    :history [["+"
                                                               "0.0-2301"]],
                                                    :parent-type "PersistentVector",
                                                    :type "var",
                                                    :full-name-encode "cljs.core/PersistentVectorDOTEMPTY-NODE",
                                                    :source {:code "(set! (.-EMPTY-NODE PersistentVector) (VectorNode. nil (make-array 32)))",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r1.12.38",
                                                             :filename "src/main/cljs/cljs/core.cljs",
                                                             :lines [5823]},
                                                    :full-name "cljs.core/PersistentVector.EMPTY-NODE"},
           "clojure.string/escape" {:return-type string,
                                    :ns "clojure.string",
                                    :name "escape",
                                    :signature ["[s cmap]"],
                                    :name-encode "escape",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "clojure.string/escape",
                                    :source {:code "(defn ^string escape\n  [s cmap]\n  (let [buffer (StringBuffer.)\n        length (.-length s)]\n    (loop [index 0]\n      (if (== length index)\n        (. buffer (toString))\n        (let [ch (.charAt s index)\n              replacement (cmap ch)]\n          (if-not (nil? replacement)\n            (.append buffer (str replacement))\n            (.append buffer ch))\n          (recur (inc index)))))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/clojure/string.cljs",
                                             :lines [230 247]},
                                    :full-name "clojure.string/escape",
                                    :docstring "Return a new string, using cmap to escape each character ch\nfrom s as follows:\n\nIf (cmap ch) is nil, append ch to the new string.\nIf (cmap ch) is non-nil, append (str (cmap ch)) instead."},
           "cljs.spec.alpha/and" {:ns "cljs.spec.alpha",
                                  :name "and",
                                  :signature ["[& pred-forms]"],
                                  :name-encode "and",
                                  :history [["+" "1.9.542"]],
                                  :type "macro",
                                  :full-name-encode "cljs.spec.alpha/and",
                                  :source {:code "(defmacro and\n  [& pred-forms]\n  `(and-spec-impl '~(mapv #(res &env %) pred-forms) ~(vec pred-forms) nil))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/spec/alpha.cljc",
                                           :lines [214 222]},
                                  :full-name "cljs.spec.alpha/and",
                                  :docstring "Takes predicate/spec-forms, e.g.\n\n(s/and even? #(< % 42))\n\nReturns a spec that returns the conformed value. Successive\nconformed values propagate through rest of predicates."},
           "compiler-options/recompile-dependents" {:ns "compiler-options",
                                                    :name "recompile-dependents",
                                                    :name-encode "recompile-dependents",
                                                    :type "option",
                                                    :full-name-encode "compiler-options/recompile-dependents",
                                                    :full-name "compiler-options/recompile-dependents",
                                                    :history [["+"
                                                               "0.0-2814"]]},
           "syntax/cond-splicing" {:syntax-equiv {:edn-url nil,
                                                  :clj-url nil},
                                   :ns "syntax",
                                   :name "cond-splicing",
                                   :name-encode "cond-splicing",
                                   :history [["+" "0.0-3190"]],
                                   :type "syntax",
                                   :full-name-encode "syntax/cond-splicing",
                                   :extra-sources ({:code "(defn- read-cond\n  [rdr _ opts pending-forms]\n  (when (not (and opts (#{:allow :preserve} (:read-cond opts))))\n    (throw (RuntimeException. \"Conditional read not allowed\")))\n  (if-let [ch (read-char rdr)]\n    (let [splicing (= ch \\@)\n          ch (if splicing (read-char rdr) ch)]\n      (when splicing\n        (when-not *read-delim*\n          (err/reader-error rdr \"cond-splice not in list\")))\n      (if-let [ch (if (whitespace? ch) (read-past whitespace? rdr) ch)]\n        (if (not= ch \\()\n          (throw (RuntimeException. \"read-cond body must be a list\"))\n          (binding [*suppress-read* (or *suppress-read* (= :preserve (:read-cond opts)))]\n            (if *suppress-read*\n              (reader-conditional (read-list rdr ch opts pending-forms) splicing)\n              (read-cond-delimited rdr splicing opts pending-forms))))\n        (err/throw-eof-in-character rdr)))\n    (err/throw-eof-in-character rdr)))",
                                                    :title "Reader code",
                                                    :repo "tools.reader",
                                                    :tag "v1.3.6",
                                                    :filename "src/main/clojure/clojure/tools/reader.clj",
                                                    :lines [506 524]}
                                                   {:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    \\? read-cond\n    \\: read-namespaced-map\n    \\# read-symbolic-value\n    nil))",
                                                    :title "Reader table",
                                                    :repo "tools.reader",
                                                    :tag "v1.3.6",
                                                    :filename "src/main/clojure/clojure/tools/reader.clj",
                                                    :lines [809 823]}),
                                   :full-name "syntax/cond-splicing"},
           "cljs.core/remove-watch" {:ns "cljs.core",
                                     :name "remove-watch",
                                     :signature ["[iref key]"],
                                     :name-encode "remove-watch",
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "cljs.core/remove-watch",
                                     :source {:code "(defn remove-watch\n  [iref key]\n  (-remove-watch iref key)\n  iref)",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/cljs/cljs/core.cljs",
                                              :lines [10939 10943]},
                                     :full-name "cljs.core/remove-watch",
                                     :docstring "Removes a watch (set by add-watch) from a reference"},
           "cljs.core/m3-hash-unencoded-chars" {:return-type number,
                                                :ns "cljs.core",
                                                :name "m3-hash-unencoded-chars",
                                                :signature ["[in]"],
                                                :name-encode "m3-hash-unencoded-chars",
                                                :history [["+"
                                                           "0.0-2261"]],
                                                :type "function",
                                                :full-name-encode "cljs.core/m3-hash-unencoded-chars",
                                                :source {:code "(defn ^number m3-hash-unencoded-chars [in]\n  (let [h1 (loop [i 1 h1 m3-seed]\n             (if (< i (.-length in))\n               (recur (+ i 2)\n                 (m3-mix-H1 h1\n                   (m3-mix-K1\n                     (bit-or (.charCodeAt in (dec i))\n                       (bit-shift-left (.charCodeAt in i) 16)))))\n               h1))\n        h1 (if (== (bit-and (.-length in) 1) 1)\n             (bit-xor h1 (m3-mix-K1 (.charCodeAt in (dec (.-length in)))))\n             h1)]\n    (m3-fmix h1 (imul 2 (.-length in)))))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1.12.38",
                                                         :filename "src/main/cljs/cljs/core.cljs",
                                                         :lines [973
                                                                 985]},
                                                :full-name "cljs.core/m3-hash-unencoded-chars"},
           "cljs.math/IEEE-remainder" {:return-type number,
                                       :ns "cljs.math",
                                       :name "IEEE-remainder",
                                       :signature ["[dividend divisor]"],
                                       :name-encode "IEEE-remainder",
                                       :history [["+" "1.11.50"]],
                                       :type "function",
                                       :full-name-encode "cljs.math/IEEE-remainder",
                                       :source {:code "(defn ^number IEEE-remainder\n  {:added \"1.11.10\"}\n  [dividend divisor]\n  ;; check for exception values\n  (cond\n    (zero? divisor) ##NaN\n    ^boolean (js/isNaN divisor) ##NaN\n    ;; check if dividend is ##Inf ##-Inf or ##NaN\n    ^boolean (js/isNaN dividend) ##NaN\n    (not ^boolean (js/isFinite dividend)) ##NaN\n    ;; dividend is finish, check if divisor is infinite\n    (not ^boolean (js/isFinite divisor)) dividend\n\n    :default\n    ;; create a buffer large enough for 2 doubles\n    (let [a (js/ArrayBuffer. 16)\n          ;; represent the buffer as a double array\n          d (js/Float64Array. a)\n          ;; represent the buffer as 32 bit ints\n          i (js/Uint32Array. a)]\n      (aset d 0 dividend)\n      (aset d 1 divisor)\n      ;; x gets the dividend high and low ints\n      (let [hx (aget i HI)\n            lx (aget i LO)\n            ;; p gets the divisor high and low ints\n            hp (aget i (+ HI 2))\n            lp (aget i (+ LO 2))\n            ;; sx is the sign bit\n            sx (bit-and hx INT32-NON-SIGN-BIT)\n            ;; strip the sign bit from hp and hx\n            hp (bit-and hp INT32-NON-SIGN-BITS)\n            hx (bit-and hx INT32-NON-SIGN-BITS)\n\n            ;;make x < 2p\n            dividend (if (<= hp 0x7FDFFFFF) (IEEE-fmod dividend (+ divisor divisor)) dividend)]\n        (if (zero? (bit-or (- hx hp) (- lx lp)))\n          (* 0.0 dividend)\n          ;; convert dividend and divisor to absolute values. \n          (let [dividend (Math/abs dividend)\n                divisor (Math/abs divisor)\n                ;; reduce dividend within range of the divisor\n                dividend (if (< hp 0x00200000)\n                           ;; smaller divisor compare 2*dividend to the divisor\n                           (if (> (+ dividend dividend) divisor)\n                             (let [dividend (- dividend divisor)] ;; reduce the dividend\n                               (if (>= (+ dividend dividend) divisor) ;; 2*dividend still larger\n                                 (- dividend divisor) ;; reduce again\n                                 dividend))\n                             dividend)\n                           ;; compare dividend to half the divisor\n                           (let [divisor-half (* 0.5 divisor)]\n                             (if (> dividend divisor-half)\n                               (let [dividend (- dividend divisor)] ;; reduce the dividend\n                                 (if (>= dividend divisor-half) ;; still larger than half divisor\n                                   (- dividend divisor) ;; reduce again\n                                   dividend))\n                               dividend)))]\n            ;; update the buffer with the new dividend value\n            (aset d 0 dividend)\n            ;; calculate a new hi int for the dividend using the saved sign bit\n            (let [hx (bit-xor (aget i HI) sx)]\n              ;; set the dividend with this new sign bit\n              (aset i HI hx)\n              ;; retrieve the updated dividend\n              (aget d 0))))))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/math.cljs",
                                                :lines [335 411]},
                                       :full-name "cljs.math/IEEE-remainder",
                                       :docstring "Returns the remainder per IEEE 754 such that\n remainder = dividend - divisor * n\nwhere n is the integer closest to the exact value of dividend / divisor.\nIf two integers are equally close, then n is the even one.\nIf the remainder is zero, sign will match dividend.\nIf dividend or divisor is ##NaN, or dividend is ##Inf or ##-Inf, or divisor is zero => ##NaN\nIf dividend is finite and divisor is infinite => dividend\n\nMethod: based on fmod return x-[x/p]chopped*p exactlp.\nPorted from: https://github.com/openjdk/jdk/blob/master/src/java.base/share/native/libfdlibm/e_remainder.c\nSee: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#IEEEremainder-double-double-"},
           "cljs.spec.gen.alpha/elements" {:ns "cljs.spec.gen.alpha",
                                           :name "elements",
                                           :signature ["[& args]"],
                                           :name-encode "elements",
                                           :history [["+" "1.9.542"]],
                                           :type "function",
                                           :full-name-encode "cljs.spec.gen.alpha/elements",
                                           :source {:code "(lazy-combinators hash-map list map not-empty set vector vector-distinct fmap elements\n  bind choose one-of such-that tuple sample return\n  large-integer* double* frequency shuffle)",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/cljs/cljs/spec/gen/alpha.cljs",
                                                    :lines [70 72]},
                                           :full-name "cljs.spec.gen.alpha/elements",
                                           :docstring "Lazy loaded version of clojure.test.check.generators/elements"},
           "closure-warnings/check-useless-code" {:ns "closure-warnings",
                                                  :name "check-useless-code",
                                                  :name-encode "check-useless-code",
                                                  :type "warning",
                                                  :full-name-encode "closure-warnings/check-useless-code",
                                                  :full-name "closure-warnings/check-useless-code",
                                                  :history [["+"
                                                             "0.0-2120"]]},
           "syntax/true" {:syntax-equiv {:edn-url nil, :clj-url nil},
                          :ns "syntax",
                          :name "true",
                          :name-encode "true",
                          :history [["+" "0.0-1853"]],
                          :type "special symbol",
                          :full-name-encode "syntax/true",
                          :extra-sources ({:code "(defn- read-symbol\n  [rdr initch]\n  (let [[line column] (starting-line-col-info rdr)]\n    (when-let [token (read-token rdr :symbol initch)]\n      (case token\n\n        ;; special symbols\n        \"nil\" nil\n        \"true\" true\n        \"false\" false\n        \"/\" '/\n\n        (or (when-let [p (parse-symbol token)]\n              (with-meta (symbol (p 0) (p 1))\n                (when line\n                  (merge\n                   (when-let [file (get-file-name rdr)]\n                     {:file file})\n                   (let [[end-line end-column] (ending-line-col-info rdr)]\n                     {:line line\n                      :column column\n                      :end-line end-line\n                      :end-column end-column})))))\n            (err/throw-invalid rdr :symbol token))))))",
                                           :title "Reader code",
                                           :repo "tools.reader",
                                           :tag "v1.3.6",
                                           :filename "src/main/clojure/clojure/tools/reader.clj",
                                           :lines [304 327]}),
                          :full-name "syntax/true"},
           "cljs.core/es6-iterator-seq" {:ns "cljs.core",
                                         :name "es6-iterator-seq",
                                         :signature ["[iter]"],
                                         :name-encode "es6-iterator-seq",
                                         :history [["+" "0.0-2411"]],
                                         :type "function",
                                         :full-name-encode "cljs.core/es6-iterator-seq",
                                         :source {:code "(defn es6-iterator-seq\n  [iter]\n  (let [v (.next iter)]\n    (if (.-done v)\n      nil\n      (ES6IteratorSeq. (.-value v) iter nil))))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/cljs/cljs/core.cljs",
                                                  :lines [1354 1360]},
                                         :full-name "cljs.core/es6-iterator-seq",
                                         :docstring "Given an ES2015+ compatible iterator return a seq."},
           "cljs.js/*eval-fn*" {:ns "cljs.js",
                                :name "*eval-fn*",
                                :name-encode "STAReval-fnSTAR",
                                :history [["+" "1.7.10"]],
                                :type "dynamic var",
                                :full-name-encode "cljs.js/STAReval-fnSTAR",
                                :source {:code "(defonce\n  ^{:dynamic true}\n  *eval-fn*\n  (fn [m]\n    (throw (js/Error. \"No *eval-fn* set\"))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/js.cljs",
                                         :lines [105 119]},
                                :full-name "cljs.js/*eval-fn*",
                                :docstring "Each runtime environment provides various ways to eval JavaScript\nsource. Whatever function *eval-fn* is bound to will be passed a map\ncontaining the following keys:\n\n:source - the source of the library (string)\n:name   - used to unique identify the script (symbol)\n:cache  - if the source was originally ClojureScript, will be given the\n          analysis cache.\n\nThe result of evaluation should be the return value."},
           "cljs.core/IMultiFn" {:ns "cljs.core",
                                 :name "IMultiFn",
                                 :name-encode "IMultiFn",
                                 :implementations #{"MultiFn"},
                                 :history [["+" "0.0-927"]],
                                 :type "protocol",
                                 :full-name-encode "cljs.core/IMultiFn",
                                 :source {:code "(defprotocol IMultiFn\n  (-reset [mf])\n  (-add-method [mf dispatch-val method])\n  (-remove-method [mf dispatch-val])\n  (-prefer-method [mf dispatch-val dispatch-val-y])\n  (-get-method [mf dispatch-val])\n  (-methods [mf])\n  (-prefers [mf])\n  (-default-dispatch-val [mf])\n  (-dispatch-fn [mf]))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [11472 11481]},
                                 :methods [{:name "-reset",
                                            :signature ["[mf]"],
                                            :docstring nil}
                                           {:name "-add-method",
                                            :signature ["[mf dispatch-val method]"],
                                            :docstring nil}
                                           {:name "-remove-method",
                                            :signature ["[mf dispatch-val]"],
                                            :docstring nil}
                                           {:name "-prefer-method",
                                            :signature ["[mf dispatch-val dispatch-val-y]"],
                                            :docstring nil}
                                           {:name "-get-method",
                                            :signature ["[mf dispatch-val]"],
                                            :docstring nil}
                                           {:name "-methods",
                                            :signature ["[mf]"],
                                            :docstring nil}
                                           {:name "-prefers",
                                            :signature ["[mf]"],
                                            :docstring nil}
                                           {:name "-default-dispatch-val",
                                            :signature ["[mf]"],
                                            :docstring nil}
                                           {:name "-dispatch-fn",
                                            :signature ["[mf]"],
                                            :docstring nil}],
                                 :full-name "cljs.core/IMultiFn"},
           "clojure.browser.event/IEventType" {:ns "clojure.browser.event",
                                               :name "IEventType",
                                               :name-encode "IEventType",
                                               :history [["+"
                                                          "0.0-2301"]],
                                               :type "protocol",
                                               :full-name-encode "clojure.browser.event/IEventType",
                                               :source {:code "(defprotocol IEventType\n  (event-types [this]))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.12.38",
                                                        :filename "src/main/cljs/clojure/browser/event.cljs",
                                                        :lines [16 17]},
                                               :methods [{:name "event-types",
                                                          :signature ["[this]"],
                                                          :docstring nil}],
                                               :full-name "clojure.browser.event/IEventType"},
           "cljs.core/HashSetIter" {:ns "cljs.core",
                                    :name "HashSetIter",
                                    :signature ["[iter]"],
                                    :name-encode "HashSetIter",
                                    :history [["+" "1.7.28"]],
                                    :type "type",
                                    :full-name-encode "cljs.core/HashSetIter",
                                    :source {:code "(deftype HashSetIter [iter]\n  Object\n  (hasNext [_]\n    (.hasNext iter))\n  (next [_]\n    (if ^boolean (.hasNext iter)\n      (.-key (.next iter))\n      (throw (js/Error. \"No such element\"))))\n  (remove [_] (js/Error. \"Unsupported operation\")))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [9377 9385]},
                                    :full-name "cljs.core/HashSetIter"},
           "cljs.spec.impl.gen/any" {:ns "cljs.spec.impl.gen",
                                     :name "any",
                                     :signature ["[& args]"],
                                     :name-encode "any",
                                     :history [["+" "1.9.14"]
                                               ["-" "1.9.542"]],
                                     :type "function",
                                     :full-name-encode "cljs.spec.impl.gen/any",
                                     :source {:code "(lazy-prims any any-printable boolean char char-alpha char-alphanumeric char-ascii double\n  int keyword keyword-ns large-integer ratio simple-type simple-type-printable\n  string string-ascii string-alphanumeric symbol symbol-ns uuid)",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.9.521",
                                              :filename "src/main/cljs/cljs/spec/impl/gen.cljs",
                                              :lines [73 75]},
                                     :full-name "cljs.spec.impl.gen/any",
                                     :docstring "Fn returning clojure.test.check.generators/any",
                                     :removed {:in "1.9.542",
                                               :last-seen "1.9.521"}},
           "cljs.math/random" {:return-type number,
                               :ns "cljs.math",
                               :name "random",
                               :signature ["[]"],
                               :name-encode "random",
                               :history [["+" "1.11.50"]],
                               :type "function",
                               :full-name-encode "cljs.math/random",
                               :source {:code "(defn ^number random\n  {:added \"1.11.10\"}\n  [] (Math/random))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/math.cljs",
                                        :lines [508 514]},
                               :full-name "cljs.math/random",
                               :docstring "Returns a positive double between 0.0 and 1.0, chosen pseudorandomly with\napproximately random distribution. Not cryptographically secure. The seed is chosen internally\nand cannot be selected.\nSee: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random"},
           "syntax/js-tag" {:syntax-equiv {:edn-url nil, :clj-url nil},
                            :ns "syntax",
                            :name "js-tag",
                            :name-encode "js-tag",
                            :type "special tag",
                            :full-name-encode "syntax/js-tag",
                            :full-name "syntax/js-tag",
                            :history [["+" "1.10.238"]]},
           "clojure.zip/end?" {:ns "clojure.zip",
                               :name "end?",
                               :signature ["[loc]"],
                               :name-encode "endQMARK",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip/endQMARK",
                               :source {:code "(defn end?\n  [loc]\n    (= :end (loc 1)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/clojure/zip.cljs",
                                        :lines [232 235]},
                               :full-name "clojure.zip/end?",
                               :docstring "Returns true if loc represents the end of a depth-first walk"},
           "cljs.core/halt-when" {:ns "cljs.core",
                                  :name "halt-when",
                                  :signature ["[pred]" "[pred retf]"],
                                  :name-encode "halt-when",
                                  :history [["+" "1.9.456"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/halt-when",
                                  :source {:code "(defn halt-when\n  {:added \"1.9\"}\n  ([pred] (halt-when pred nil))\n  ([pred retf]\n     (fn [rf]\n       (fn\n         ([] (rf))\n         ([result]\n            (if (and (map? result) (contains? result ::halt))\n              (::halt result)\n              (rf result)))\n         ([result input]\n            (if (pred input)\n              (reduced {::halt (if retf (retf (rf result) input) input)})\n              (rf result input)))))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [11016 11038]},
                                  :full-name "cljs.core/halt-when",
                                  :docstring "Returns a transducer that ends transduction when pred returns true\nfor an input. When retf is supplied it must be a fn of 2 arguments -\nit will be passed the (completed) result so far and the input that\ntriggered the predicate, and its return value (if it does not throw\nan exception) will be the return value of the transducer. If retf\nis not supplied, the input that triggered the predicate will be\nreturned. If the predicate never returns true the transduction is\nunaffected."},
           "clojure.string/starts-with?" {:return-type boolean,
                                          :ns "clojure.string",
                                          :name "starts-with?",
                                          :signature ["[s substr]"],
                                          :name-encode "starts-withQMARK",
                                          :history [["+" "1.7.145"]],
                                          :type "function",
                                          :full-name-encode "clojure.string/starts-withQMARK",
                                          :source {:code "(defn ^boolean starts-with?\n  [s substr]\n  (gstring/startsWith s substr))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/cljs/clojure/string.cljs",
                                                   :lines [277 280]},
                                          :full-name "clojure.string/starts-with?",
                                          :docstring "True if s starts with substr."},
           "cljs.test/clear-env!" {:ns "cljs.test",
                                   :name "clear-env!",
                                   :signature ["[]"],
                                   :name-encode "clear-envBANG",
                                   :history [["+" "0.0-2496"]],
                                   :type "function",
                                   :full-name-encode "cljs.test/clear-envBANG",
                                   :source {:code "(defn clear-env! []\n  (set! *current-env* nil))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/test.cljs",
                                            :lines [280 281]},
                                   :full-name "cljs.test/clear-env!"},
           "cljs.analyzer.api/ns-resolve" {:ns "cljs.analyzer.api",
                                           :name "ns-resolve",
                                           :signature ["[ns sym]"
                                                       "[state ns sym]"],
                                           :name-encode "ns-resolve",
                                           :history [["+" "0.0-2496"]],
                                           :type "function",
                                           :full-name-encode "cljs.analyzer.api/ns-resolve",
                                           :source {:code "(defn ns-resolve\n  ([ns sym]\n   (ns-resolve env/*compiler* ns sym))\n  ([state ns sym]\n   {:pre [(symbol? ns) (symbol? sym)]}\n   (get-in @state [::ana/namespaces ns :defs sym])))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/clojure/cljs/analyzer/api.cljc",
                                                    :lines [263 270]},
                                           :full-name "cljs.analyzer.api/ns-resolve",
                                           :docstring "Given a namespace and a symbol return the corresponding var analysis map.\nAnalagous to clojure.core/ns-resolve but returns var analysis map not Var."},
           "cljs.repl/update-require-spec" {:ns "cljs.repl",
                                            :name "update-require-spec",
                                            :signature ["[specs & additions]"],
                                            :name-encode "update-require-spec",
                                            :history [["+" "0.0-2629"]
                                                      ["-" "0.0-2655"]],
                                            :type "function",
                                            :full-name-encode "cljs.repl/update-require-spec",
                                            :source {:code "(defn update-require-spec\n  [specs & additions]\n  (let [[before [requires & other-specs]]\n        (split-with\n          (fn [[x _]] (not= :require x))\n          specs)\n        requires'\n        `(:require\n           ~@(reduce\n               (fn [requires spec]\n                 (merge-require requires spec))\n               (rest requires)\n               additions))]\n    (concat before [requires'] other-specs)))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2644",
                                                     :filename "src/clj/cljs/repl.clj",
                                                     :lines [226 241]},
                                            :full-name "cljs.repl/update-require-spec",
                                            :docstring "Given the specification portion of a ns form and require spec additions\nreturn an updated specification.",
                                            :removed {:in "0.0-2655",
                                                      :last-seen "0.0-2644"}},
           "cljs.test/test-all-vars-block" {:ns "cljs.test",
                                            :name "test-all-vars-block",
                                            :signature ["[[quote ns]]"],
                                            :name-encode "test-all-vars-block",
                                            :history [["+" "0.0-2814"]],
                                            :type "macro",
                                            :full-name-encode "cljs.test/test-all-vars-block",
                                            :source {:code "(defmacro test-all-vars-block\n  ([[quote ns]]\n   `(let [env# (get-current-env)]\n      (concat\n       [(fn []\n          (when (nil? env#)\n            (set-env! (empty-env)))\n          ~(when (ana-api/ns-resolve ns 'cljs-test-once-fixtures)\n             `(update-current-env! [:once-fixtures] assoc '~ns\n                                             ~(symbol (name ns) \"cljs-test-once-fixtures\")))\n          ~(when (ana-api/ns-resolve ns 'cljs-test-each-fixtures)\n             `(update-current-env! [:each-fixtures] assoc '~ns\n                                             ~(symbol (name ns) \"cljs-test-each-fixtures\"))))]\n       (test-vars-block\n        [~@(->> (ana-api/ns-interns ns)\n                (filter (fn [[_ v]] (:test v)))\n                (sort-by (fn [[_ v]] (:line v)))\n                (map (fn [[k _]]\n                       `(var ~(symbol (name ns) (name k))))))])\n       [(fn []\n          (when (nil? env#)\n            (clear-env!)))]))))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/cljs/cljs/test.cljc",
                                                     :lines [336 357]},
                                            :full-name "cljs.test/test-all-vars-block"},
           "clojure.set/superset?" {:ns "clojure.set",
                                    :name "superset?",
                                    :signature ["[set1 set2]"],
                                    :name-encode "supersetQMARK",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "clojure.set/supersetQMARK",
                                    :source {:code "(defn superset? \n  [set1 set2]\n  (and (>= (count set1) (count set2))\n       (every? #(contains? set1 %) set2)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/clojure/set.cljs",
                                             :lines [141 145]},
                                    :full-name "clojure.set/superset?",
                                    :docstring "Is set1 a superset of set2?"},
           "compiler-options/elide-strict" {:ns "compiler-options",
                                            :name "elide-strict",
                                            :name-encode "elide-strict",
                                            :type "option",
                                            :full-name-encode "compiler-options/elide-strict",
                                            :full-name "compiler-options/elide-strict",
                                            :history [["+" "1.10.312"]]},
           "cljs.repl/repl" {:ns "cljs.repl",
                             :name "repl",
                             :signature ["[repl-env & opts]"],
                             :name-encode "repl",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.repl/repl",
                             :source {:code "(defn repl\n  [repl-env & opts]\n  (assert (even? (count opts))\n    \"Arguments after repl-env must be interleaved key value pairs\")\n  (repl* repl-env (apply hash-map opts)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/clojure/cljs/repl.cljc",
                                      :lines [1228 1298]},
                             :full-name "cljs.repl/repl",
                             :docstring "Generic, reusable, read-eval-print loop. By default, reads from *in* using\na c.t.r.reader-types/source-logging-push-back-reader,\nwrites to *out*, and prints exception summaries to *err*. If you use the\ndefault :read hook, *in* must either be an instance of\nc.t.r.reader-types/PushbackReader or duplicate its behavior of both supporting\nunread and collapsing CR, LF, and CRLF into a single \\newline. Options\nare sequential keyword-value pairs. The first argument is the JavaScript\nevaluation environment, the second argument is an extended version of the\nstandard ClojureScript compiler options. In addition to ClojureScript compiler\nbuild options it also take a set of options similar to clojure.main/repl with\nadjustments for ClojureScript evalution and compilation model:\n\nAvailable clojure.main/repl style options and their defaults:\n\n   - :init, function of no arguments, initialization hook called with\n     bindings for set!-able vars in place.\n     default: #()\n\n   - :need-prompt, function of no arguments, called before each\n     read-eval-print except the first, the user will be prompted if it\n     returns true.\n     default: #(if (c.t.r.readers-types/indexing-reader? *in*)\n                 (== (c.t.r.reader-types/get-column-number *in*) 1)\n                 (identity true))\n\n   - :prompt, function of no arguments, prompts for more input.\n     default: repl-prompt\n\n   - :flush, function of no arguments, flushes output\n     default: flush\n\n   - :read, function of two arguments, reads from *in*:\n       - returns its first argument to request a fresh prompt\n         - depending on need-prompt, this may cause the repl to prompt\n           before reading again\n       - returns its second argument to request an exit from the repl\n       - else returns the next object read from the input stream\n     default: repl-read\n\n   - :eval, function of one argument, returns the evaluation of its\n     argument. The eval function must take repl-env, the JavaScript evaluation\n     environment, env, the ClojureScript analysis environment, the form\n     and opts, the standard ClojureScript REPL/compiler options.\n     default: eval\n\n   - :print, function of one argument, prints its argument to the output\n     default: println\n\n   - :caught, function of three arguments, a throwable, called when\n     read, eval, or print throws an exception or error default. The second\n     argument is the JavaScript evaluation environment this permits context\n     sensitive handling if necessary. The third argument is opts, the standard\n     ClojureScript REPL/compiler options. In the case of errors or exception\n     in the JavaScript target, these will be thrown as\n     clojure.lang.IExceptionInfo instances.\n     default: repl-caught\n\n   - :reader, the c.t.r reader to use.\n     default: c.t.r.reader-types/source-logging-push-back-reader\n\n   - :print-no-newline, print without a newline.\n     default: print\n\n   - :source-map-inline, whether inline source maps should be enabled. Most\n     useful in browser context. Implies using a fresh reader for each form.\n     default: true"},
           "repl-options/caught" {:ns "repl-options",
                                  :name "caught",
                                  :name-encode "caught",
                                  :type "option",
                                  :full-name-encode "repl-options/caught",
                                  :full-name "repl-options/caught",
                                  :history [["+" "0.0-2911"]]},
           "compiler-options/target-fn" {:ns "compiler-options",
                                         :name "target-fn",
                                         :name-encode "target-fn",
                                         :type "option",
                                         :full-name-encode "compiler-options/target-fn",
                                         :full-name "compiler-options/target-fn",
                                         :history [["+" "1.10.738"]]},
           "clojure.browser.net/IConnection" {:ns "clojure.browser.net",
                                              :name "IConnection",
                                              :name-encode "IConnection",
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "protocol",
                                              :full-name-encode "clojure.browser.net/IConnection",
                                              :source {:code "(defprotocol IConnection\n  (connect\n    [this]\n    [this opt1]\n    [this opt1 opt2]\n    [this opt1 opt2 opt3])\n  (transmit\n    [this opt]\n    [this opt opt2]\n    [this opt opt2 opt3]\n    [this opt opt2 opt3 opt4]\n    [this opt opt2 opt3 opt4 opt5])\n  (close [this]))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.12.38",
                                                       :filename "src/main/cljs/clojure/browser/net.cljs",
                                                       :lines [31 43]},
                                              :methods [{:name "connect",
                                                         :signature ["[this]"
                                                                     "[this opt1]"
                                                                     "[this opt1 opt2]"
                                                                     "[this opt1 opt2 opt3]"],
                                                         :docstring nil}
                                                        {:name "transmit",
                                                         :signature ["[this opt]"
                                                                     "[this opt opt2]"
                                                                     "[this opt opt2 opt3]"
                                                                     "[this opt opt2 opt3 opt4]"
                                                                     "[this opt opt2 opt3 opt4 opt5]"],
                                                         :docstring nil}
                                                        {:name "close",
                                                         :signature ["[this]"],
                                                         :docstring nil}],
                                              :full-name "clojure.browser.net/IConnection"},
           "cljs.core/let" {:ns "cljs.core",
                            :name "let",
                            :signature ["[bindings & body]"],
                            :name-encode "let",
                            :history [["+" "0.0-927"]],
                            :type "macro",
                            :full-name-encode "cljs.core/let",
                            :source {:code "(core/defmacro let\n  [bindings & body]\n  (assert-args let\n     (vector? bindings) \"a vector for its binding\"\n     (even? (count bindings)) \"an even number of forms in binding vector\")\n  `(let* ~(destructure bindings) ~@body))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/clojure/cljs/core.cljc",
                                     :lines [772 787]},
                            :full-name "cljs.core/let",
                            :docstring "binding => binding-form init-expr\nbinding-form => name, or destructuring-form\ndestructuring-form => map-destructure-form, or seq-destructure-form\n\nEvaluates the exprs in a lexical context in which the symbols in\nthe binding-forms are bound to their respective init-exprs or parts\ntherein.\n\nSee https://clojure.org/reference/special_forms#binding-forms for\nmore information about destructuring."},
           "cljs.core/unchecked-divide-int" {:return-type number,
                                             :ns "cljs.core",
                                             :name "unchecked-divide-int",
                                             :signature ["[x]"
                                                         "[x y]"
                                                         "[x y & more]"],
                                             :name-encode "unchecked-divide-int",
                                             :history [["+"
                                                        "0.0-1798"]],
                                             :type "function/macro",
                                             :full-name-encode "cljs.core/unchecked-divide-int",
                                             :source {:code "(defn ^number unchecked-divide-int\n  ([x] (unchecked-divide-int 1 x))\n  ([x y] (cljs.core/divide x y)) ;; FIXME: waiting on cljs.core//\n  ([x y & more] (reduce unchecked-divide-int (unchecked-divide-int x y) more)))",
                                                      :title "Function code",
                                                      :repo "clojurescript",
                                                      :tag "r1.12.38",
                                                      :filename "src/main/cljs/cljs/core.cljs",
                                                      :lines [2829
                                                              2834]},
                                             :extra-sources [{:code "(core/defmacro ^::ana/numeric unchecked-divide-int\n  ([& xs] `(/ ~@xs)))",
                                                              :title "Macro code",
                                                              :repo "clojurescript",
                                                              :tag "r1.12.38",
                                                              :filename "src/main/clojure/cljs/core.cljc",
                                                              :lines [1089
                                                                      1090]}],
                                             :full-name "cljs.core/unchecked-divide-int",
                                             :docstring "If no denominators are supplied, returns 1/numerator,\nelse returns numerator divided by all of the denominators."},
           "cljs.repl.nashorn/create-engine" {:ns "cljs.repl.nashorn",
                                              :name "create-engine",
                                              :signature ["[]"
                                                          "[{:keys [code-cache], :or {code-cache true}}]"],
                                              :name-encode "create-engine",
                                              :history [["+"
                                                         "0.0-2814"]
                                                        ["-"
                                                         "1.10.738"]],
                                              :type "function",
                                              :full-name-encode "cljs.repl.nashorn/create-engine",
                                              :source {:code "(defn create-engine\n      ([] (create-engine nil))\n      ([{:keys [code-cache] :or {code-cache true}}]\n       (let [args (when code-cache [\"-pcc\"])\n             factories (.getEngineFactories (ScriptEngineManager.))\n             factory (get (zipmap (map #(.getEngineName %) factories) factories) \"Oracle Nashorn\")]\n         (if-let [engine (if-not (empty? args)\n                           (.getScriptEngine ^ScriptEngineFactory factory (into-array args))\n                           (.getScriptEngine ^ScriptEngineFactory factory))]\n           (let [context (.getContext engine)]\n             (.setWriter context *out*)\n             (.setErrorWriter context *err*)\n             engine)\n           (throw (IllegalArgumentException.\n                    \"Cannot find the Nashorn script engine, use a JDK version 8 or higher.\"))))))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.10.597",
                                                       :filename "src/main/clojure/cljs/repl/nashorn.clj",
                                                       :lines [29 43]},
                                              :full-name "cljs.repl.nashorn/create-engine",
                                              :removed {:in "1.10.738",
                                                        :last-seen "1.10.597"}},
           "cljs.core/dorun" {:ns "cljs.core",
                              :name "dorun",
                              :signature ["[coll]" "[n coll]"],
                              :name-encode "dorun",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/dorun",
                              :source {:code "(defn dorun\n  ([coll]\n   (when-let [s (seq coll)]\n     (recur (next s))))\n  ([n coll]\n   (when (and (seq coll) (pos? n))\n     (recur (dec n) (next coll)))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [10345 10356]},
                              :full-name "cljs.core/dorun",
                              :docstring "When lazy sequences are produced via functions that have side\neffects, any effects other than those needed to produce the first\nelement in the seq do not occur until the seq is consumed. dorun can\nbe used to force any effects. Walks through the successive nexts of\nthe seq, does not retain the head and returns nil."},
           "cljs.core/with-redefs" {:ns "cljs.core",
                                    :name "with-redefs",
                                    :signature ["[bindings & body]"],
                                    :name-encode "with-redefs",
                                    :history [["+" "0.0-1806"]],
                                    :type "macro",
                                    :full-name-encode "cljs.core/with-redefs",
                                    :source {:code "(core/defmacro with-redefs\n  [bindings & body]\n  (core/let [names (take-nth 2 bindings)\n             vals (take-nth 2 (drop 1 bindings))\n             orig-val-syms (map (comp gensym #(core/str % \"-orig-val__\") name) names)\n             temp-val-syms (map (comp gensym #(core/str % \"-temp-val__\") name) names)\n             binds (map core/vector names temp-val-syms)\n             resets (reverse (map core/vector names orig-val-syms))\n             bind-value (core/fn [[k v]] (core/list 'set! k v))]\n    `(let [~@(interleave orig-val-syms names)\n           ~@(interleave temp-val-syms vals)]\n       ~@(map bind-value binds)\n       (try\n         ~@body\n         (finally\n           ~@(map bind-value resets))))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/clojure/cljs/core.cljc",
                                             :lines [2258 2284]},
                                    :full-name "cljs.core/with-redefs",
                                    :docstring "binding => var-symbol temp-value-expr\n\nTemporarily redefines vars while executing the body.  The\ntemp-value-exprs will be evaluated and each resulting value will\nreplace in parallel the root value of its var.  After the body is\nexecuted, the root values of all the vars will be set back to their\nold values. Useful for mocking out functions during testing.\n\nNote that under advanced compilation vars are statically resolved,\npreventing with-redef usage.  If var redefinition is desired in a production\nsetting then the var to be redefined must be declared ^:dynamic."},
           "cljs.core/SeqIter" {:ns "cljs.core",
                                :name "SeqIter",
                                :signature ["[_seq _next]"],
                                :name-encode "SeqIter",
                                :history [["+" "0.0-2301"]],
                                :type "type",
                                :full-name-encode "cljs.core/SeqIter",
                                :source {:code "(deftype SeqIter [^:mutable _seq ^:mutable _next]\n  Object\n  (hasNext [_]\n    (if (identical? _seq INIT)\n      (do\n        (set! _seq START)\n        (set! _next (seq _next)))\n      (if (identical? _seq _next)\n        (set! _next (next _seq))))\n    (not (nil? _next)))\n  (next [this]\n    (if-not ^boolean (.hasNext this)\n      (throw (js/Error. \"No such element\"))\n      (do\n        (set! _seq _next)\n        (first _next))))\n  (remove [_] (js/Error. \"Unsupported operation\")))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [4138 4154]},
                                :full-name "cljs.core/SeqIter"},
           "cljs.core/munge" {:ns "cljs.core",
                              :name "munge",
                              :signature ["[name]"],
                              :name-encode "munge",
                              :history [["+" "1.7.10"]],
                              :type "function",
                              :full-name-encode "cljs.core/munge",
                              :source {:code "(defn munge [name]\n  (let [name' (munge-str (str name))\n        name' (cond\n                (identical? name' \"..\") \"_DOT__DOT_\"\n                (js-reserved? name') (str name' \"$\")\n                :else name')]\n    (if (symbol? name)\n      (symbol name')\n      name')))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [12004 12012]},
                              :full-name "cljs.core/munge"},
           "cljs.core/unsigned-bit-shift-right" {:ns "cljs.core",
                                                 :name "unsigned-bit-shift-right",
                                                 :signature ["[x n]"],
                                                 :name-encode "unsigned-bit-shift-right",
                                                 :history [["+"
                                                            "0.0-2080"]],
                                                 :type "function/macro",
                                                 :full-name-encode "cljs.core/unsigned-bit-shift-right",
                                                 :source {:code "(defn unsigned-bit-shift-right\n  [x n] (cljs.core/unsigned-bit-shift-right x n))",
                                                          :title "Function code",
                                                          :repo "clojurescript",
                                                          :tag "r1.12.38",
                                                          :filename "src/main/cljs/cljs/core.cljs",
                                                          :lines [2997
                                                                  2999]},
                                                 :extra-sources [{:code "(core/defmacro ^::ana/numeric unsigned-bit-shift-right [x n]\n  (core/list 'js* \"(~{} >>> ~{})\" x n))",
                                                                  :title "Macro code",
                                                                  :repo "clojurescript",
                                                                  :tag "r1.12.38",
                                                                  :filename "src/main/clojure/cljs/core.cljc",
                                                                  :lines [1240
                                                                          1241]}],
                                                 :full-name "cljs.core/unsigned-bit-shift-right",
                                                 :docstring "Bitwise shift right with zero fill"},
           "cljs.core/iterable?" {:ns "cljs.core",
                                  :name "iterable?",
                                  :signature ["[x]"],
                                  :name-encode "iterableQMARK",
                                  :history [["+" "0.0-2356"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/iterableQMARK",
                                  :source {:code "(defn iterable?\n  [x]\n  (satisfies? IIterable x))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [1229 1232]},
                                  :full-name "cljs.core/iterable?",
                                  :docstring "Return true if x implements IIterable protocol."},
           "cljs.core/pr-str" {:ns "cljs.core",
                               :name "pr-str",
                               :signature ["[& objs]"],
                               :name-encode "pr-str",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/pr-str",
                               :source {:code "(defn pr-str\n  [& objs]\n  (pr-str-with-opts objs (pr-opts)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [10644 10647]},
                               :full-name "cljs.core/pr-str",
                               :docstring "pr to a string, returning it. Fundamental entrypoint to IPrintWithWriter."},
           "cljs.core/IPrintable" {:ns "cljs.core",
                                   :name "IPrintable",
                                   :name-encode "IPrintable",
                                   :implementations #{"Subvec"
                                                      "boolean"
                                                      "string"
                                                      "PersistentQueue"
                                                      "PersistentHashMap"
                                                      "PersistentTreeSet"
                                                      "js/Date"
                                                      "RedNode"
                                                      "EmptyList"
                                                      "ObjMap"
                                                      "BlackNode"
                                                      "PersistentVector"
                                                      "ChunkedCons"
                                                      "Range"
                                                      "ChunkedSeq"
                                                      "ArrayNodeSeq"
                                                      "IndexedSeq"
                                                      "number"
                                                      "PersistentTreeMap"
                                                      "PersistentTreeMapSeq"
                                                      "RSeq"
                                                      "Vector"
                                                      "function"
                                                      "PersistentArrayMap"
                                                      "PersistentHashSet"
                                                      "HashMap"
                                                      "NodeSeq"
                                                      "List"
                                                      "Atom"
                                                      "nil"
                                                      "Cons"
                                                      "LazySeq"
                                                      "array"
                                                      "UUID"},
                                   :history [["+" "0.0-927"]
                                             ["-" "0.0-1798"]],
                                   :type "protocol",
                                   :full-name-encode "cljs.core/IPrintable",
                                   :source {:code "(defprotocol ^:deprecated IPrintable\n  \"Do not use this.  It is kept for backwards compatibility with existing\n   user code that depends on it, but it has been superceded by IPrintWithWriter\n   User code that depends on this should be changed to use -pr-writer instead.\"\n  (-pr-seq [o opts]))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1586",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [253 257]},
                                   :methods [{:name "-pr-seq",
                                              :signature ["[o opts]"],
                                              :docstring nil}],
                                   :full-name "cljs.core/IPrintable",
                                   :docstring "Do not use this.  It is kept for backwards compatibility with existing\n   user code that depends on it, but it has been superceded by IPrintWithWriter\n   User code that depends on this should be changed to use -pr-writer instead.",
                                   :removed {:in "0.0-1798",
                                             :last-seen "0.0-1586"}},
           "cljs.math/scalb" {:return-type number,
                              :ns "cljs.math",
                              :name "scalb",
                              :signature ["[d scaleFactor]"],
                              :name-encode "scalb",
                              :history [["+" "1.11.50"]],
                              :type "function",
                              :full-name-encode "cljs.math/scalb",
                              :source {:code "(defn ^number scalb\n  {:added \"1.11.10\"}\n  [d scaleFactor]\n  (let [[scale-factor\n         scale-increment\n         exp-delta] (if (< scaleFactor 0)\n                      [(Math/max scaleFactor (- MAX_SCALE)) -512 two-to-the-double-scale-down]\n                      [(Math/min scaleFactor MAX_SCALE) 512 two-to-the-double-scale-up])\n        ;; Calculate (scaleFactor % +/-512), 512 = 2^9\n        ;; technique from \"Hacker's Delight\" section 10-2\n        t (unsigned-bit-shift-right (bit-shift-right scale-factor 8) 23)\n        exp-adjust (- (bit-and (+ scale-factor t) 511) t)]\n    (loop [d (* d (power-of-two exp-adjust)) scale-factor (- scale-factor exp-adjust)]\n      (if (zero? scale-factor)\n        d\n        (recur (* d exp-delta) (- scale-factor scale-increment))))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/math.cljs",
                                       :lines [847 869]},
                              :full-name "cljs.math/scalb",
                              :docstring "Returns d * 2^scaleFactor, scaling by a factor of 2. If the exponent\nis between min_Float64_exponent and max_Float64_exponent.\nscaleFactor is an integer\nIf d is ##NaN => ##NaN\nIf d is ##Inf or ##-Inf => ##Inf or ##-Inf respectively\nIf d is zero => zero of same sign as d\nSee: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#nextDown-double-"},
           "warnings/ns-var-clash" {:ns "warnings",
                                    :name "ns-var-clash",
                                    :name-encode "ns-var-clash",
                                    :type "warning",
                                    :full-name-encode "warnings/ns-var-clash",
                                    :full-name "warnings/ns-var-clash",
                                    :history [["+" "0.0-3115"]]},
           "cljs.math/expm1" {:return-type number,
                              :ns "cljs.math",
                              :name "expm1",
                              :signature ["[x]"],
                              :name-encode "expm1",
                              :history [["+" "1.11.50"]],
                              :type "function",
                              :full-name-encode "cljs.math/expm1",
                              :source {:code "(defn ^number expm1\n  {:added \"1.11.10\"}\n  [x] (Math/expm1 x))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/math.cljs",
                                       :lines [707 715]},
                              :full-name "cljs.math/expm1",
                              :docstring "Returns e^x - 1. Near 0, expm1(x)+1 is more accurate to e^x than exp(x).\nIf x is ##NaN => ##NaN\nIf x is ##Inf => #Inf\nIf x is ##-Inf => -1.0\nIf x is zero => x\nSee: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/expm1"},
           "compiler-options/rewrite-polyfills" {:ns "compiler-options",
                                                 :name "rewrite-polyfills",
                                                 :name-encode "rewrite-polyfills",
                                                 :type "option",
                                                 :full-name-encode "compiler-options/rewrite-polyfills",
                                                 :full-name "compiler-options/rewrite-polyfills",
                                                 :history [["+"
                                                            "1.9.562"]]},
           "cljs.build.api/src-file->target-file" {:return-type File,
                                                   :ns "cljs.build.api",
                                                   :name "src-file->target-file",
                                                   :signature ["[src]"
                                                               "[src opts]"
                                                               "[state src opts]"],
                                                   :name-encode "src-file-GTtarget-file",
                                                   :history [["+"
                                                              "0.0-2629"]],
                                                   :type "function",
                                                   :full-name-encode "cljs.build.api/src-file-GTtarget-file",
                                                   :source {:code "(defn ^File src-file->target-file\n  ([src] (src-file->target-file src nil))\n  ([src opts]\n   (src-file->target-file\n     (or (ana-api/current-state) (ana-api/empty-state opts)) src opts))\n  ([state src opts]\n   (ana-api/with-state state\n     (binding [ana/*cljs-warning-handlers* (:warning-handlers opts ana/*cljs-warning-handlers*)]\n       (closure/src-file->target-file src opts)))))",
                                                            :title "Source code",
                                                            :repo "clojurescript",
                                                            :tag "r1.12.38",
                                                            :filename "src/main/clojure/cljs/build/api.clj",
                                                            :lines [66
                                                                    76]},
                                                   :full-name "cljs.build.api/src-file->target-file",
                                                   :docstring "Given a ClojureScript source file return the target file. May optionally\nprovide build options with :output-dir specified."},
           "cljs.core/defprotocol" {:ns "cljs.core",
                                    :name "defprotocol",
                                    :signature ["[psym & doc+methods]"],
                                    :name-encode "defprotocol",
                                    :history [["+" "0.0-927"]],
                                    :type "macro",
                                    :full-name-encode "cljs.core/defprotocol",
                                    :source {:code "(core/defmacro defprotocol\n  [psym & doc+methods]\n  (core/let [p (:name (cljs.analyzer/resolve-var (dissoc &env :locals) psym))\n             [opts methods]\n             (core/loop [opts {:protocol-symbol true}\n                         methods []\n                         sigs doc+methods]\n               (core/if-not (seq sigs)\n                 [opts methods]\n                 (core/let [[head & tail] sigs]\n                   (core/cond\n                     (core/string? head)\n                     (recur (assoc opts :doc head) methods tail)\n                     (core/keyword? head)\n                     (recur (assoc opts head (first tail)) methods (rest tail))\n                     (core/seq? head)\n                     (recur opts (conj methods head) tail)\n                     :else\n                     (throw #?(:clj  (Exception.\n                                       (core/str \"Invalid protocol, \" psym \" received unexpected argument\"))\n                               :cljs (js/Error.\n                                       (core/str \"Invalid protocol, \" psym \" received unexpected argument\"))))\n                     ))))\n             psym (vary-meta psym merge opts)\n             ns-name (core/-> &env :ns :name)\n             fqn (core/fn [n] (symbol (core/str ns-name) (core/str n)))\n             prefix (protocol-prefix p)\n             _ (core/doseq [[mname & arities] methods]\n                 (core/when (some #{0} (map count (filter vector? arities)))\n                   (throw\n                     #?(:clj (Exception.\n                               (core/str \"Invalid protocol, \" psym\n                                 \" defines method \" mname \" with arity 0\"))\n                        :cljs (js/Error.\n                                (core/str \"Invalid protocol, \" psym\n                                  \" defines method \" mname \" with arity 0\"))))))\n             sig->syms (core/fn [sig]\n                         (core/if-not (every? core/symbol? sig)\n                           (mapv (core/fn [arg]\n                                   (core/cond\n                                     (core/symbol? arg) arg\n                                     (core/and (map? arg) (core/some? (:as arg))) (:as arg)\n                                     :else (gensym))) sig)\n                           sig))\n             expand-dyn (core/fn [fname sig]\n                          (core/let [sig (sig->syms sig)\n\n                                     fqn-fname (with-meta (fqn fname) {:cljs.analyzer/no-resolve true})\n                                     fsig (first sig)\n\n                                     ;; construct protocol checks in reverse order\n                                     ;; check the.protocol/fn[\"_\"] for default impl last\n                                     check\n                                     `(let [m# (unchecked-get ~fqn-fname \"_\")]\n                                        (if-not (nil? m#)\n                                          (m# ~@sig)\n                                          (throw\n                                            (missing-protocol\n                                              ~(core/str psym \".\" fname) ~fsig))))\n\n                                     ;; then check protocol on js string,function,array,object (first dynamic check actually executed)\n                                     check\n                                     `(let [x# (if (nil? ~fsig) nil ~fsig)\n                                            m# (unchecked-get ~fqn-fname (goog/typeOf x#))]\n                                        (if-not (nil? m#)\n                                          (m# ~@sig)\n                                          ~check))]\n                            `(~sig ~check)))\n             expand-sig (core/fn [fname dyn-name slot sig]\n                          (core/let [sig (sig->syms sig)\n\n                                     fqn-fname (with-meta (fqn fname) {:cljs.analyzer/no-resolve true})\n                                     fsig (first sig)\n\n                                     ;; check protocol property on object (first check executed)\n                                     check\n                                     `(if (and (not (nil? ~fsig))\n                                               ;; Property access needed here.\n                                               (not (nil? (. ~fsig ~(with-meta (symbol (core/str \"-\" slot)) {:protocol-prop true})))))\n                                        (. ~fsig ~slot ~@sig)\n                                        (~dyn-name ~@sig))\n\n                                     ;; then check protocol fn in metadata (only when protocol is marked with :extend-via-metadata true)\n                                     check\n                                     (core/if-not (:extend-via-metadata opts)\n                                       check\n                                       `(if-let [meta-impl# (-> ~fsig (core/meta) (core/get '~fqn-fname))]\n                                          (meta-impl# ~@sig)\n                                          ~check))]\n                            `(~sig ~check)))\n             psym (core/-> psym\n                    (vary-meta update-in [:jsdoc] conj \"@interface\")\n                    (vary-meta assoc-in [:protocol-info :methods]\n                      (into {}\n                        (map\n                          (core/fn [[fname & sigs]]\n                            (core/let [doc (core/as-> (last sigs) doc\n                                             (core/when (core/string? doc) doc))\n                                       sigs (take-while vector? sigs)]\n                              [(vary-meta fname assoc :doc doc)\n                               (vec sigs)]))\n                          methods)))\n                    ;; for compatibility with Clojure\n                    (vary-meta assoc-in [:sigs]\n                      (into {}\n                        (map\n                          (core/fn [[fname & sigs]]\n                            (core/let [doc (core/as-> (last sigs) doc\n                                             (core/when (core/string? doc) doc))\n                                       sigs (take-while vector? sigs)]\n                              [(keyword fname) {:name fname :arglists (list* sigs) :doc doc}]))\n                          methods))))\n             method (core/fn [[fname & sigs]]\n                      (core/let [doc (core/as-> (last sigs) doc\n                                       (core/when (core/string? doc) doc))\n                                 sigs (take-while vector? sigs)\n                                 amp (core/when (some #{'&} (apply concat sigs))\n                                       (cljs.analyzer/warning\n                                        :protocol-with-variadic-method\n                                        &env {:protocol psym :name fname}))\n                                 _ (core/when-some [existing (core/get (-> &env :ns :defs) fname)]\n                                     (core/when-not (= p (:protocol existing))\n                                       (cljs.analyzer/warning\n                                         :protocol-with-overwriting-method\n                                         {} {:protocol psym :name fname :existing existing})))\n                                 slot (symbol (core/str prefix (munge (name fname))))\n                                 dyn-name (symbol (core/str slot \"$dyn\"))\n                                 fname (vary-meta fname assoc\n                                         :protocol p\n                                         :doc doc)]\n                        `(let [~dyn-name (core/fn\n                                           ~@(map (core/fn [sig]\n                                                    (expand-dyn fname sig))\n                                               sigs))]\n                           (defn ~fname\n                             ~@(map (core/fn [sig]\n                                      (expand-sig fname dyn-name\n                                        (with-meta (symbol (core/str slot \"$arity$\" (count sig)))\n                                          {:protocol-prop true})\n                                        sig))\n                                 sigs)))))]\n    `(do\n       (set! ~'*unchecked-if* true)\n       (def ~psym (~'js* \"function(){}\"))\n       ~@(map method methods)\n       (set! ~'*unchecked-if* false))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/clojure/cljs/core.cljc",
                                             :lines [1998 2182]},
                                    :full-name "cljs.core/defprotocol",
                                    :docstring "A protocol is a named set of named methods and their signatures:\n\n(defprotocol AProtocolName\n  ;optional doc string\n  \"A doc string for AProtocol abstraction\"\n\n;method signatures\n  (bar [this a b] \"bar docs\")\n  (baz [this a] [this a b] [this a b c] \"baz docs\"))\n\nNo implementations are provided. Docs can be specified for the\nprotocol overall and for each method. The above yields a set of\npolymorphic functions and a protocol object. All are\nnamespace-qualified by the ns enclosing the definition The resulting\nfunctions dispatch on the type of their first argument, which is\nrequired and corresponds to the implicit target object ('this' in\nJavaScript parlance). defprotocol is dynamic, has no special compile-time\neffect, and defines no new types.\n\n(defprotocol P\n  (foo [this])\n  (bar-me [this] [this y]))\n\n(deftype Foo [a b c]\n  P\n  (foo [this] a)\n  (bar-me [this] b)\n  (bar-me [this y] (+ c y)))\n\n(bar-me (Foo. 1 2 3) 42)\n=> 45\n\n(foo\n  (let [x 42]\n    (reify P\n      (foo [this] 17)\n      (bar-me [this] x)\n      (bar-me [this y] x))))\n=> 17"},
           "warnings/protocol-duped-method" {:ns "warnings",
                                             :name "protocol-duped-method",
                                             :name-encode "protocol-duped-method",
                                             :type "warning",
                                             :full-name-encode "warnings/protocol-duped-method",
                                             :full-name "warnings/protocol-duped-method",
                                             :history [["+"
                                                        "0.0-2341"]]},
           "cljs.core/ints" {:ns "cljs.core",
                             :name "ints",
                             :signature ["[x]"],
                             :name-encode "ints",
                             :history [["+" "0.0-1798"]],
                             :type "function",
                             :full-name-encode "cljs.core/ints",
                             :source {:code "(defn ints [x] x)",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [2910]},
                             :full-name "cljs.core/ints"},
           "cljs.spec.test/run-all-tests" {:ns "cljs.spec.test",
                                           :name "run-all-tests",
                                           :signature ["[]"],
                                           :name-encode "run-all-tests",
                                           :history [["+" "1.9.14"]
                                                     ["-" "1.9.183"]],
                                           :type "macro",
                                           :full-name-encode "cljs.spec.test/run-all-tests",
                                           :source {:code "(defmacro run-all-tests\n  []\n  `(cljs.spec.test/run-var-tests #?(:clj  ~(spec/speced-vars*)\n                                    :cljs ~(cljs.spec$macros/speced-vars*))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.9.93",
                                                    :filename "src/main/cljs/cljs/spec/test.cljc",
                                                    :lines [26 32]},
                                           :full-name "cljs.spec.test/run-all-tests",
                                           :docstring "Like clojure.test/run-all-tests, but runs test.check tests\nfor all speced vars. Prints per-test results to *out*, and\nreturns a map with :test,:pass,:fail, and :error counts.",
                                           :removed {:in "1.9.183",
                                                     :last-seen "1.9.93"}},
           "cljs.core/assert" {:ns "cljs.core",
                               :name "assert",
                               :signature ["[x]" "[x message]"],
                               :name-encode "assert",
                               :history [["+" "0.0-927"]],
                               :type "macro",
                               :full-name-encode "cljs.core/assert",
                               :source {:code "(core/defmacro assert\n  ([x]\n     (core/when *assert*\n       `(when-not ~x\n          (throw (js/Error. ~(core/str \"Assert failed: \" (core/pr-str x)))))))\n  ([x message]\n     (core/when *assert*\n       `(when-not ~x\n          (throw (js/Error.\n                  (cljs.core/str \"Assert failed: \" ~message \"\\n\" ~(core/pr-str x))))))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/clojure/cljs/core.cljc",
                                        :lines [2436 2447]},
                               :full-name "cljs.core/assert",
                               :docstring "Evaluates expr and throws an exception if it does not evaluate to\nlogical true."},
           "cljs.core/declare" {:ns "cljs.core",
                                :name "declare",
                                :signature ["[& names]"],
                                :name-encode "declare",
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :full-name-encode "cljs.core/declare",
                                :source {:code "(defmacro declare\n  {:added \"1.0\"}\n  [& names] `(do ~@(map #(list 'def (vary-meta % assoc :declared true)) names)))",
                                         :title "Source code",
                                         :repo "clojure",
                                         :tag "clojure-1.10.0",
                                         :filename "src/clj/clojure/core.clj",
                                         :lines [2776 2779]},
                                :full-name "cljs.core/declare",
                                :docstring "defs the supplied var names with no bindings, useful for making forward declarations."},
           "cljs.spec.impl.gen/string-ascii" {:ns "cljs.spec.impl.gen",
                                              :name "string-ascii",
                                              :signature ["[& args]"],
                                              :name-encode "string-ascii",
                                              :history [["+" "1.9.14"]
                                                        ["-"
                                                         "1.9.542"]],
                                              :type "function",
                                              :full-name-encode "cljs.spec.impl.gen/string-ascii",
                                              :source {:code "(lazy-prims any any-printable boolean char char-alpha char-alphanumeric char-ascii double\n  int keyword keyword-ns large-integer ratio simple-type simple-type-printable\n  string string-ascii string-alphanumeric symbol symbol-ns uuid)",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.9.521",
                                                       :filename "src/main/cljs/cljs/spec/impl/gen.cljs",
                                                       :lines [73 75]},
                                              :full-name "cljs.spec.impl.gen/string-ascii",
                                              :docstring "Fn returning clojure.test.check.generators/string-ascii",
                                              :removed {:in "1.9.542",
                                                        :last-seen "1.9.521"}},
           "cljs.repl.node/results" {:ns "cljs.repl.node",
                                     :name "results",
                                     :name-encode "results",
                                     :type "var",
                                     :full-name-encode "cljs.repl.node/results",
                                     :source {:code "(def results (ConcurrentHashMap.))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/clojure/cljs/repl/node.clj",
                                              :lines [27]},
                                     :full-name "cljs.repl.node/results",
                                     :history [["+" "1.10.217"]]},
           "cljs.core/PersistentTreeMap.EMPTY" {:ns "cljs.core",
                                                :name "PersistentTreeMap.EMPTY",
                                                :name-encode "PersistentTreeMapDOTEMPTY",
                                                :history [["+"
                                                           "0.0-1211"]],
                                                :parent-type "PersistentTreeMap",
                                                :type "var",
                                                :full-name-encode "cljs.core/PersistentTreeMapDOTEMPTY",
                                                :source {:code "(set! (.-EMPTY PersistentTreeMap) (PersistentTreeMap. compare nil 0 nil empty-unordered-hash))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1.12.38",
                                                         :filename "src/main/cljs/cljs/core.cljs",
                                                         :lines [9110]},
                                                :full-name "cljs.core/PersistentTreeMap.EMPTY"},
           "cljs.core/fn?" {:ns "cljs.core",
                            :name "fn?",
                            :signature ["[f]"],
                            :name-encode "fnQMARK",
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core/fnQMARK",
                            :source {:code "(defn fn?\n  [f]\n  (or (js-fn? f) (satisfies? Fn f)))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [2069 2072]},
                            :full-name "cljs.core/fn?",
                            :docstring "Return true if f is a JavaScript function or satisfies the Fn protocol."},
           "cljs.compiler.api/with-core-cljs" {:ns "cljs.compiler.api",
                                               :name "with-core-cljs",
                                               :signature ["[]"
                                                           "[opts]"
                                                           "[opts body]"
                                                           "[state opts body]"],
                                               :name-encode "with-core-cljs",
                                               :history [["+"
                                                          "0.0-3255"]],
                                               :type "function",
                                               :full-name-encode "cljs.compiler.api/with-core-cljs",
                                               :source {:code "(defn with-core-cljs\n  ([]\n   (comp/with-core-cljs\n     (when-let [state (ana-api/current-state)]\n       (:options @state))))\n  ([opts] (with-core-cljs opts (fn [])))\n  ([opts body]\n   (with-core-cljs (or (ana-api/current-state) (ana-api/empty-state opts)) opts body))\n  ([state opts body]\n   (ana-api/with-state state\n     (binding [ana/*cljs-warning-handlers* (:warning-handlers opts ana/*cljs-warning-handlers*)]\n       (comp/with-core-cljs opts body)))))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.12.38",
                                                        :filename "src/main/clojure/cljs/compiler/api.clj",
                                                        :lines [35 47]},
                                               :full-name "cljs.compiler.api/with-core-cljs",
                                               :docstring "Ensure that core.cljs has been loaded."},
           "cljs.core/associative?" {:ns "cljs.core",
                                     :name "associative?",
                                     :signature ["[x]"],
                                     :name-encode "associativeQMARK",
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "cljs.core/associativeQMARK",
                                     :source {:code "(defn associative?\n [x] (satisfies? IAssociative x))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/cljs/cljs/core.cljs",
                                              :lines [2200 2202]},
                                     :full-name "cljs.core/associative?",
                                     :docstring "Returns true if coll implements IAssociative"},
           "cljs.repl/canonicalize-specs" {:ns "cljs.repl",
                                           :name "canonicalize-specs",
                                           :signature ["[specs]"],
                                           :name-encode "canonicalize-specs",
                                           :history [["+" "0.0-3148"]
                                                     ["-" "1.9.293"]],
                                           :type "function",
                                           :full-name-encode "cljs.repl/canonicalize-specs",
                                           :source {:code "(defn canonicalize-specs [specs]\n  (letfn [(canonicalize [quoted-spec-or-kw]\n            (if (keyword? quoted-spec-or-kw)\n              quoted-spec-or-kw\n              (as-> (second quoted-spec-or-kw) spec\n                (if (vector? spec) spec [spec]))))]\n    (map canonicalize specs)))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.9.229",
                                                    :filename "src/main/clojure/cljs/repl.cljc",
                                                    :lines [582 588]},
                                           :full-name "cljs.repl/canonicalize-specs",
                                           :removed {:in "1.9.293",
                                                     :last-seen "1.9.229"}},
           "cljs.repl.browser/serve" {:ns "cljs.repl.browser",
                                      :name "serve",
                                      :signature ["[{:keys [host port output-dir], :as opts}]"],
                                      :name-encode "serve",
                                      :history [["+" "1.10.126"]],
                                      :type "function",
                                      :full-name-encode "cljs.repl.browser/serve",
                                      :source {:code "(defn serve [{:keys [host port output-dir] :as opts}]\n  (println \"Serving HTTP on\" host \"port\" port)\n  (binding [ordering (agent {:expecting nil :fns {}})\n            es (Executors/newFixedThreadPool 16)\n            server/state (atom {:socket nil})]\n    (server/start\n      (merge opts\n        {:static-dir (cond-> [\".\" \"out/\"] output-dir (conj output-dir))\n         :gzip? true}))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/clojure/cljs/repl/browser.clj",
                                               :lines [334 342]},
                                      :full-name "cljs.repl.browser/serve"},
           "cljs.repl.rhino/load-javascript" {:ns "cljs.repl.rhino",
                                              :name "load-javascript",
                                              :signature ["[repl-env ns url]"],
                                              :name-encode "load-javascript",
                                              :history [["+"
                                                         "0.0-927"]
                                                        ["-"
                                                         "1.10.738"]],
                                              :type "function",
                                              :full-name-encode "cljs.repl.rhino/load-javascript",
                                              :source {:code "(defn load-javascript [repl-env ns url]\n  (try\n    (with-open [reader (io/reader url)]\n      (-eval reader repl-env (.toString url) 1))\n    ;; TODO: don't show errors for goog/base.js line number 105\n    (catch Throwable ex (println (.getMessage ex)))))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.10.597",
                                                       :filename "src/main/clojure/cljs/repl/rhino.clj",
                                                       :lines [99 104]},
                                              :full-name "cljs.repl.rhino/load-javascript",
                                              :removed {:in "1.10.738",
                                                        :last-seen "1.10.597"}},
           "cljs.repl.browser/thread-name" {:ns "cljs.repl.browser",
                                            :name "thread-name",
                                            :signature ["[]"],
                                            :name-encode "thread-name",
                                            :history [["+" "1.10.238"]],
                                            :type "function",
                                            :full-name-encode "cljs.repl.browser/thread-name",
                                            :source {:code "(defn thread-name []\n  (let [name (.getName (Thread/currentThread))]\n    (if (string/starts-with? name \"nREPL\") \"main\" name)))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/clojure/cljs/repl/browser.clj",
                                                     :lines [32 34]},
                                            :full-name "cljs.repl.browser/thread-name"},
           "cljs.core/IList" {:ns "cljs.core",
                              :name "IList",
                              :name-encode "IList",
                              :implementations #{"EmptyList"
                                                 "List"
                                                 "Cons"},
                              :history [["+" "0.0-1211"]],
                              :type "protocol",
                              :full-name-encode "cljs.core/IList",
                              :source {:code "(defprotocol IList)",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [741 742]},
                              :full-name "cljs.core/IList",
                              :docstring "Marker interface indicating a persistent list"},
           "cljs.core/list*" {:ns "cljs.core",
                              :name "list*",
                              :signature ["[args]"
                                          "[a args]"
                                          "[a b args]"
                                          "[a b c args]"
                                          "[a b c d & more]"],
                              :name-encode "listSTAR",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/listSTAR",
                              :source {:code "(defn list*\n  ([args] (seq args))\n  ([a args] (cons a args))\n  ([a b args] (cons a (cons b args)))\n  ([a b c args] (cons a (cons b (cons c args))))\n  ([a b c d & more]\n     (cons a (cons b (cons c (cons d (spread more)))))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [3890 3898]},
                              :full-name "cljs.core/list*",
                              :docstring "Creates a new list containing the items prepended to the rest, the\nlast of which will be treated as a sequence."},
           "cljs.core/PersistentArrayMap.fromArray" {:ns "cljs.core",
                                                     :name "PersistentArrayMap.fromArray",
                                                     :signature ["[arr no-clone no-check]"],
                                                     :name-encode "PersistentArrayMapDOTfromArray",
                                                     :history [["+"
                                                                "0.0-1798"]],
                                                     :parent-type "PersistentArrayMap",
                                                     :type "function",
                                                     :full-name-encode "cljs.core/PersistentArrayMapDOTfromArray",
                                                     :source {:code "(set! (.-fromArray PersistentArrayMap)\n  (fn [arr ^boolean no-clone ^boolean no-check]\n    (as-> (if no-clone arr (aclone arr)) arr\n      (if no-check\n        arr\n        (let [ret (array)]\n          (loop [i 0]\n            (when (< i (alength arr))\n              (let [k (aget arr i)\n                    v (aget arr (inc i))\n                    idx (array-index-of ret k)]\n                (when (== idx -1)\n                  (.push ret k)\n                  (.push ret v)))\n              (recur (+ i 2))))\n          ret))\n      (let [cnt (/ (alength arr) 2)]\n        (PersistentArrayMap. nil cnt arr nil)))))",
                                                              :title "Source code",
                                                              :repo "clojurescript",
                                                              :tag "r1.12.38",
                                                              :filename "src/main/cljs/cljs/core.cljs",
                                                              :lines [7149
                                                                      7166]},
                                                     :full-name "cljs.core/PersistentArrayMap.fromArray"},
           "repl-options/need-prompt" {:ns "repl-options",
                                       :name "need-prompt",
                                       :name-encode "need-prompt",
                                       :type "option",
                                       :full-name-encode "repl-options/need-prompt",
                                       :full-name "repl-options/need-prompt",
                                       :history [["+" "0.0-2911"]]},
           "cljs.core/js-comment" {:ns "cljs.core",
                                   :name "js-comment",
                                   :signature ["[comment]"],
                                   :name-encode "js-comment",
                                   :history [["+" "1.7.107"]],
                                   :type "macro",
                                   :full-name-encode "cljs.core/js-comment",
                                   :source {:code "(core/defmacro js-comment\n  [comment]\n  (core/let [[x & ys] (string/split comment #\"\\n\")]\n    (core/list 'js*\n      (core/str\n        \"\\n/**\\n\"\n        (core/str \" * \" x \"\\n\")\n        (core/->> ys\n          (map #(core/str \" * \" (string/replace % #\"^   \" \"\") \"\\n\"))\n          (reduce core/str \"\"))\n        \" */\\n\"))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/clojure/cljs/core.cljc",
                                            :lines [939 951]},
                                   :full-name "cljs.core/js-comment",
                                   :docstring "Emit a top-level JavaScript multi-line comment. New lines will create a\nnew comment line. Comment block will be preceded and followed by a newline"},
           "cljs.core/reduce" {:ns "cljs.core",
                               :name "reduce",
                               :signature ["[f coll]" "[f val coll]"],
                               :name-encode "reduce",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/reduce",
                               :source {:code "(defn reduce\n  ([f coll]\n     (cond\n       (implements? IReduce coll)\n       (-reduce coll f)\n\n       (array? coll)\n       (array-reduce coll f)\n\n       (string? coll)\n       (array-reduce coll f)\n\n       (native-satisfies? IReduce coll)\n       (-reduce coll f)\n\n       (iterable? coll)\n       (iter-reduce coll f)\n\n       :else\n       (seq-reduce f coll)))\n  ([f val coll]\n     (cond\n       (implements? IReduce coll)\n       (-reduce coll f val)\n\n       (array? coll)\n       (array-reduce coll f val)\n\n       (string? coll)\n       (array-reduce coll f val)\n\n       (native-satisfies? IReduce coll)\n       (-reduce coll f val)\n\n       (iterable? coll)\n       (iter-reduce coll f val)\n\n       :else\n       (seq-reduce f val coll))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [2587 2634]},
                               :full-name "cljs.core/reduce",
                               :docstring "f should be a function of 2 arguments. If val is not supplied,\nreturns the result of applying f to the first 2 items in coll, then\napplying f to that result and the 3rd item, etc. If coll contains no\nitems, f must accept no arguments as well, and reduce returns the\nresult of calling f with no arguments.  If coll has only 1 item, it\nis returned and f is not called.  If val is supplied, returns the\nresult of applying f to val and the first item in coll, then\napplying f to that result and the 2nd item, etc. If coll contains no\nitems, returns val and f is not called."},
           "cljs.repl/merge-require" {:ns "cljs.repl",
                                      :name "merge-require",
                                      :signature ["[requires [lib :as spec]]"],
                                      :name-encode "merge-require",
                                      :history [["+" "0.0-2629"]
                                                ["-" "0.0-2655"]],
                                      :type "function",
                                      :full-name-encode "cljs.repl/merge-require",
                                      :source {:code "(defn merge-require [requires [lib :as spec]]\n  (let [[before [match & after]]\n        (split-with\n          (fn [[lib' & _]]\n            (not= lib lib'))\n          requires)]\n    (if (nil? match)\n      ;; no match, append to end\n      (concat requires [spec])\n      (if (= match spec)\n        ;; dupe\n        requires\n        ;; merge\n        (concat before [(merge-spec match spec)] after)))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2644",
                                               :filename "src/clj/cljs/repl.clj",
                                               :lines [211 224]},
                                      :full-name "cljs.repl/merge-require",
                                      :removed {:in "0.0-2655",
                                                :last-seen "0.0-2644"}},
           "cljs.core/IDrop" {:ns "cljs.core",
                              :name "IDrop",
                              :name-encode "IDrop",
                              :implementations #{"PersistentArrayMapSeq"
                                                 "PersistentVector"
                                                 "IntegerRange"
                                                 "ChunkedSeq"
                                                 "IndexedSeq"
                                                 "PersistentArrayMap"
                                                 "Repeat"},
                              :history [["+" "1.11.121"]],
                              :type "protocol",
                              :full-name-encode "cljs.core/IDrop",
                              :source {:code "(defprotocol IDrop\n  (^clj-or-nil -drop [coll n]\n    \"Returns a collection that is ISequential, ISeq, and IReduce, or nil if past\n     the end. The number of items to drop n must be > 0. It is also useful if the\n     returned coll implements IDrop for subsequent use in a partition-like scenario.\"))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [889 895]},
                              :methods [{:name "-drop",
                                         :signature ["[coll n]"],
                                         :docstring "Returns a collection that is ISequential, ISeq, and IReduce, or nil if past\n     the end. The number of items to drop n must be > 0. It is also useful if the\n     returned coll implements IDrop for subsequent use in a partition-like scenario."}],
                              :full-name "cljs.core/IDrop",
                              :docstring "Protocol for persistent or algorithmically defined collections to provide a\n  means of dropping N items that is more efficient than sequential walking."},
           "cljs.analyzer.api/ns-publics" {:ns "cljs.analyzer.api",
                                           :name "ns-publics",
                                           :signature ["[ns]"
                                                       "[state ns]"],
                                           :name-encode "ns-publics",
                                           :history [["+" "0.0-2985"]],
                                           :type "function",
                                           :full-name-encode "cljs.analyzer.api/ns-publics",
                                           :source {:code "(defn ns-publics\n  ([ns]\n   (ns-publics env/*compiler* ns))\n  ([state ns]\n   {:pre [(symbol? ns)]}\n   (->> (ns-interns state ns)\n        (remove (fn [[k v]] (:private v)))\n        (into {}))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/clojure/cljs/analyzer/api.cljc",
                                                    :lines [252 261]},
                                           :full-name "cljs.analyzer.api/ns-publics",
                                           :docstring "Given a namespace return all the public var analysis maps. Analagous to\nclojure.core/ns-publics but returns var analysis maps not vars."},
           "clojure.browser.event/has-listener" {:ns "clojure.browser.event",
                                                 :name "has-listener",
                                                 :signature ["[obj opt_type opt_capture]"],
                                                 :name-encode "has-listener",
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.browser.event/has-listener",
                                                 :source {:code "(defn has-listener [obj opt_type opt_capture])",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r1.12.38",
                                                          :filename "src/main/cljs/clojure/browser/event.cljs",
                                                          :lines [96]},
                                                 :full-name "clojure.browser.event/has-listener"},
           "cljs.core/unchecked-dec-int" {:ns "cljs.core",
                                          :name "unchecked-dec-int",
                                          :signature ["[x]"],
                                          :name-encode "unchecked-dec-int",
                                          :history [["+" "0.0-1798"]],
                                          :type "function/macro",
                                          :full-name-encode "cljs.core/unchecked-dec-int",
                                          :source {:code "(defn unchecked-dec-int\n  [x]\n  (cljs.core/unchecked-dec-int x))",
                                                   :title "Function code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/cljs/cljs/core.cljs",
                                                   :lines [2824 2827]},
                                          :extra-sources [{:code "(core/defmacro ^::ana/numeric unchecked-dec-int\n  ([x] `(dec ~x)))",
                                                           :title "Macro code",
                                                           :repo "clojurescript",
                                                           :tag "r1.12.38",
                                                           :filename "src/main/clojure/cljs/core.cljc",
                                                           :lines [1086
                                                                   1087]}],
                                          :full-name "cljs.core/unchecked-dec-int",
                                          :docstring "Returns a number one less than x, an int."},
           "cljs.core/PersistentHashMap.EMPTY" {:ns "cljs.core",
                                                :name "PersistentHashMap.EMPTY",
                                                :name-encode "PersistentHashMapDOTEMPTY",
                                                :history [["+"
                                                           "0.0-1211"]],
                                                :parent-type "PersistentHashMap",
                                                :type "var",
                                                :full-name-encode "cljs.core/PersistentHashMapDOTEMPTY",
                                                :source {:code "(set! (.-EMPTY PersistentHashMap) (PersistentHashMap. nil 0 nil false nil empty-unordered-hash))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1.12.38",
                                                         :filename "src/main/cljs/cljs/core.cljs",
                                                         :lines [8229]},
                                                :full-name "cljs.core/PersistentHashMap.EMPTY"},
           "cljs.pprint/*print-base*" {:ns "cljs.pprint",
                                       :name "*print-base*",
                                       :name-encode "STARprint-baseSTAR",
                                       :history [["+" "0.0-3255"]],
                                       :type "dynamic var",
                                       :full-name-encode "cljs.pprint/STARprint-baseSTAR",
                                       :source {:code "(def ^{:added \"1.2\", :dynamic true} *print-base* 10)",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/pprint.cljs",
                                                :lines [673 676]},
                                       :full-name "cljs.pprint/*print-base*",
                                       :docstring "The base to use for printing integers and rationals."},
           "cljs.core/compare" {:return-type number,
                                :ns "cljs.core",
                                :name "compare",
                                :signature ["[x y]"],
                                :name-encode "compare",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/compare",
                                :source {:code "(defn ^number compare\n  [x y]\n  (cond\n   (identical? x y) 0\n\n   (nil? x) -1\n\n   (nil? y) 1\n\n   (number? x) (if (number? y)\n                 (garray/defaultCompare x y)\n                 (throw (js/Error. (str \"Cannot compare \" x \" to \" y))))\n\n   (satisfies? IComparable x)\n   (-compare x y)\n\n   :else\n   (if (and (or (string? x) (array? x) (true? x) (false? x))\n            (identical? (type x) (type y)))\n     (garray/defaultCompare x y)\n     (throw (js/Error. (str \"Cannot compare \" x \" to \" y))))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [2458 2482]},
                                :full-name "cljs.core/compare",
                                :docstring "Comparator. Returns a negative number, zero, or a positive number\n when x is logically 'less than', 'equal to', or 'greater than'\n y. Uses IComparable if available and google.array.defaultCompare for objects\nof the same type and special-cases nil to be less than any other object."},
           "cljs.spec/&" {:ns "cljs.spec",
                          :name "&",
                          :signature ["[re & preds]"],
                          :name-encode "&",
                          :history [["+" "1.9.14"] ["-" "1.9.542"]],
                          :type "macro",
                          :full-name-encode "cljs.spec/&",
                          :source {:code "(defmacro &\n  [re & preds]\n  (let [pv (vec preds)]\n    `(amp-impl ~re ~pv '~(mapv #(res &env %) pv))))",
                                   :title "Source code",
                                   :repo "clojurescript",
                                   :tag "r1.9.521",
                                   :filename "src/main/cljs/cljs/spec.cljc",
                                   :lines [352 358]},
                          :full-name "cljs.spec/&",
                          :docstring "takes a regex op re, and predicates. Returns a regex-op that consumes\ninput as per re but subjects the resulting value to the\nconjunction of the predicates, and any conforming they might perform.",
                          :removed {:in "1.9.542",
                                    :last-seen "1.9.521"}},
           "cljs.core/contains?" {:ns "cljs.core",
                                  :name "contains?",
                                  :signature ["[coll v]"],
                                  :name-encode "containsQMARK",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/containsQMARK",
                                  :source {:code "(defn contains?\n  [coll v]\n  (cond\n    (implements? IAssociative coll)\n    (-contains-key? coll v)\n\n    (native-satisfies? IAssociative coll)\n    (-contains-key? coll v)\n\n    (identical? (get coll v lookup-sentinel) lookup-sentinel)\n    false\n\n    :else\n    true))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [2410 2428]},
                                  :full-name "cljs.core/contains?",
                                  :docstring "Returns true if key is present in the given collection, otherwise\nreturns false.  Note that for numerically indexed collections like\nvectors and arrays, this tests if the numeric key is within the\nrange of indexes. 'contains?' operates constant or logarithmic time;\nit will not perform a linear search for a value.  See also 'some'."},
           "cljs.spec.test/checkable-syms" {:ns "cljs.spec.test",
                                            :name "checkable-syms",
                                            :signature ["[]" "[opts]"],
                                            :name-encode "checkable-syms",
                                            :history [["+" "1.9.183"]
                                                      ["-" "1.9.542"]],
                                            :type "macro",
                                            :full-name-encode "cljs.spec.test/checkable-syms",
                                            :source {:code "(defmacro checkable-syms\n  ([]\n   `(checkable-syms nil))\n  ([opts]\n   `(let [opts# ~opts]\n      (validate-check-opts opts#)\n      (reduce conj #{}\n        '[~@(filter fn-spec-name? (keys @s/registry-ref))\n          ~@(keys (:spec opts))]))))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.9.521",
                                                     :filename "src/main/cljs/cljs/spec/test.cljc",
                                                     :lines [193 203]},
                                            :full-name "cljs.spec.test/checkable-syms",
                                            :docstring "Given an opts map as per check, returns the set of syms that\ncan be checked.",
                                            :removed {:in "1.9.542",
                                                      :last-seen "1.9.521"}},
           "cljs.core/Stepper" {:ns "cljs.core",
                                :name "Stepper",
                                :signature ["[xform iter]"],
                                :name-encode "Stepper",
                                :history [["+" "0.0-2301"]
                                          ["-" "1.9.562"]],
                                :type "type",
                                :full-name-encode "cljs.core/Stepper",
                                :source {:code "(deftype Stepper [xform iter]\n  Object\n  (step [this lt]\n    (loop []\n      (if (and (not (nil? (.-stepper lt)))\n               (.hasNext iter))\n        (if (reduced? (xform lt (.next iter)))\n          (when-not (nil? (.-rest lt))\n            (set! (.. lt -rest -stepper) nil))\n          (recur))))\n    (when-not (nil? (.-stepper lt))\n      (xform lt))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.9.542",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [3876 3887]},
                                :full-name "cljs.core/Stepper",
                                :removed {:in "1.9.562",
                                          :last-seen "1.9.542"}},
           "cljs.core/prefer-method" {:ns "cljs.core",
                                      :name "prefer-method",
                                      :signature ["[multifn dispatch-val-x dispatch-val-y]"],
                                      :name-encode "prefer-method",
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "cljs.core/prefer-method",
                                      :source {:code "(defn prefer-method\n  [multifn dispatch-val-x dispatch-val-y]\n  (-prefer-method multifn dispatch-val-x dispatch-val-y))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [11681 11685]},
                                      :full-name "cljs.core/prefer-method",
                                      :docstring "Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y\nwhen there is a conflict"},
           "cljs.core/array-seq" {:ns "cljs.core",
                                  :name "array-seq",
                                  :signature ["[array]" "[array i]"],
                                  :name-encode "array-seq",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/array-seq",
                                  :source {:code "(defn array-seq\n  ([array]\n     (prim-seq array 0))\n  ([array i]\n     (prim-seq array i)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [1721 1726]},
                                  :full-name "cljs.core/array-seq",
                                  :docstring "Create a seq from a JavaScript array."},
           "cljs.core/to-array-2d" {:ns "cljs.core",
                                    :name "to-array-2d",
                                    :signature ["[coll]"],
                                    :name-encode "to-array-2d",
                                    :history [["+" "0.0-1211"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/to-array-2d",
                                    :source {:code "(defn to-array-2d\n  [coll]\n    (let [ret (make-array (count coll))]\n      (loop [i 0 xs (seq coll)]\n        (when-not (nil? xs)\n          (aset ret i (to-array (first xs)))\n          (recur (inc i) (next xs))))\n      ret))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [3745 3754]},
                                    :full-name "cljs.core/to-array-2d",
                                    :docstring "Returns a (potentially-ragged) 2-dimensional array\ncontaining the contents of coll."},
           "closure-warnings/j2cl-checks" {:ns "closure-warnings",
                                           :name "j2cl-checks",
                                           :name-encode "j2cl-checks",
                                           :type "warning",
                                           :full-name-encode "closure-warnings/j2cl-checks",
                                           :full-name "closure-warnings/j2cl-checks",
                                           :history [["+" "1.9.473"]]},
           "cljs.repl.nashorn/load-ns" {:ns "cljs.repl.nashorn",
                                        :name "load-ns",
                                        :signature ["[engine ns]"],
                                        :name-encode "load-ns",
                                        :history [["+" "0.0-2814"]
                                                  ["-" "1.10.738"]],
                                        :type "function",
                                        :full-name-encode "cljs.repl.nashorn/load-ns",
                                        :source {:code "(defn load-ns [engine ns]\n      (eval-str engine\n        (format \"goog.require(\\\"%s\\\");\" (comp/munge (first ns)))))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.10.597",
                                                 :filename "src/main/clojure/cljs/repl/nashorn.clj",
                                                 :lines [91 93]},
                                        :full-name "cljs.repl.nashorn/load-ns",
                                        :removed {:in "1.10.738",
                                                  :last-seen "1.10.597"}},
           "cljs.core/find-macros-ns" {:ns "cljs.core",
                                       :name "find-macros-ns",
                                       :signature ["[ns]"],
                                       :name-encode "find-macros-ns",
                                       :history [["+" "1.7.10"]],
                                       :type "function",
                                       :full-name-encode "cljs.core/find-macros-ns",
                                       :source {:code "(defn find-macros-ns\n  [ns]\n  (when (nil? NS_CACHE)\n    (set! NS_CACHE (atom {})))\n  (let [ns-str (str ns)\n        ns (if (not ^boolean (gstring/contains ns-str \"$macros\"))\n             (symbol (str ns-str \"$macros\"))\n             ns)\n        the-ns (get @NS_CACHE ns)]\n    (if-not (nil? the-ns)\n      the-ns\n      (let [ns-obj (find-ns-obj ns)]\n       (when-not (nil? ns-obj)\n         (let [new-ns (create-ns ns ns-obj)]\n           (swap! NS_CACHE assoc ns new-ns)\n           new-ns))))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/core.cljs",
                                                :lines [12199 12216]},
                                       :full-name "cljs.core/find-macros-ns",
                                       :docstring "Returns the macros namespace named by the symbol or nil if it doesn't exist.\nBootstrap only."},
           "cljs.core/ICloneable" {:ns "cljs.core",
                                   :name "ICloneable",
                                   :name-encode "ICloneable",
                                   :implementations #{"Subvec"
                                                      "PersistentQueue"
                                                      "PersistentHashMap"
                                                      "PersistentTreeSet"
                                                      "EmptyList"
                                                      "PersistentVector"
                                                      "IntegerRange"
                                                      "Range"
                                                      "IndexedSeq"
                                                      "PersistentTreeMap"
                                                      "RSeq"
                                                      "PersistentArrayMap"
                                                      "PersistentHashSet"
                                                      "List"
                                                      "Cons"},
                                   :history [["+" "0.0-2134"]],
                                   :type "protocol",
                                   :full-name-encode "cljs.core/ICloneable",
                                   :source {:code "(defprotocol ICloneable\n  (^clj -clone [value]\n    \"Creates a clone of value.\"))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [584 587]},
                                   :methods [{:name "-clone",
                                              :signature ["[value]"],
                                              :docstring "Creates a clone of value."}],
                                   :full-name "cljs.core/ICloneable",
                                   :docstring "Protocol for cloning a value."},
           "warnings/multiple-variadic-overloads" {:ns "warnings",
                                                   :name "multiple-variadic-overloads",
                                                   :name-encode "multiple-variadic-overloads",
                                                   :type "warning",
                                                   :full-name-encode "warnings/multiple-variadic-overloads",
                                                   :full-name "warnings/multiple-variadic-overloads",
                                                   :history [["+"
                                                              "0.0-2014"]]},
           "repl-options/port" {:ns "repl-options",
                                :name "port",
                                :name-encode "port",
                                :type "option",
                                :full-name-encode "repl-options/port",
                                :full-name "repl-options/port",
                                :history [["+" "1.10.63"]]},
           "cljs.repl.browser/create-client-js-file" {:ns "cljs.repl.browser",
                                                      :name "create-client-js-file",
                                                      :signature ["[opts file-path]"],
                                                      :name-encode "create-client-js-file",
                                                      :history [["+"
                                                                 "0.0-927"]
                                                                ["-"
                                                                 "1.10.63"]],
                                                      :type "function",
                                                      :full-name-encode "cljs.repl.browser/create-client-js-file",
                                                      :source {:code "(defn create-client-js-file [opts file-path]\n  (let [file (io/file file-path)]\n    (when (not (.exists file))\n      (spit file (compile-client-js opts)))\n    file))",
                                                               :title "Source code",
                                                               :repo "clojurescript",
                                                               :tag "r1.9.946",
                                                               :filename "src/main/clojure/cljs/repl/browser.clj",
                                                               :lines [236
                                                                       240]},
                                                      :full-name "cljs.repl.browser/create-client-js-file",
                                                      :removed {:in "1.10.63",
                                                                :last-seen "1.9.946"}},
           "cljs.core/*print-length*" {:ns "cljs.core",
                                       :name "*print-length*",
                                       :name-encode "STARprint-lengthSTAR",
                                       :history [["+" "0.0-2060"]],
                                       :type "dynamic var",
                                       :full-name-encode "cljs.core/STARprint-lengthSTAR",
                                       :source {:code "(def\n  ^{:dynamic true\n    :jsdoc [\"@type {null|number}\"]}\n  *print-length* nil)",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/core.cljs",
                                                :lines [148 158]},
                                       :full-name "cljs.core/*print-length*",
                                       :docstring "*print-length* controls how many items of each collection the\nprinter will print. If it is bound to logical false, there is no\nlimit. Otherwise, it must be bound to an integer indicating the maximum\nnumber of items of each collection to print. If a collection contains\nmore items, the printer will print items up to the limit followed by\n'...' to represent the remaining items. The root binding is nil\nindicating no limit."},
           "cljs.spec/fdef" {:ns "cljs.spec",
                             :name "fdef",
                             :signature ["[fn-sym & specs]"],
                             :name-encode "fdef",
                             :history [["+" "1.9.14"] ["-" "1.9.542"]],
                             :type "macro",
                             :full-name-encode "cljs.spec/fdef",
                             :source {:code "(defmacro fdef\n  [fn-sym & specs]\n  (swap! _speced_vars conj (ns-qualify &env fn-sym))\n  `(cljs.spec/def ~fn-sym (fspec ~@specs)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.9.521",
                                      :filename "src/main/cljs/cljs/spec.cljc",
                                      :lines [401 435]},
                             :full-name "cljs.spec/fdef",
                             :docstring "Takes a symbol naming a function, and one or more of the following:\n\n:args A regex spec for the function arguments as they were a list to be\n  passed to apply - in this way, a single spec can handle functions with\n  multiple arities\n:ret A spec for the function's return value\n:fn A spec of the relationship between args and ret - the\n  value passed is {:args conformed-args :ret conformed-ret} and is\n  expected to contain predicates that relate those values\n\nQualifies fn-sym with resolve, or using *ns* if no resolution found.\nRegisters an fspec in the global registry, where it can be retrieved\nby calling get-spec with the var or full-qualified symbol.\n\nOnce registered, function specs are included in doc, checked by\ninstrument, tested by the runner clojure.spec.test/run-tests, and (if\na macro) used to explain errors during macroexpansion.\n\nNote that :fn specs require the presence of :args and :ret specs to\nconform values, and so :fn specs will be ignored if :args or :ret\nare missing.\n\nReturns the qualified fn-sym.\n\nFor example, to register function specs for the symbol function:\n\n(s/fdef clojure.core/symbol\n  :args (s/alt :separate (s/cat :ns string? :n string?)\n               :str string?\n               :sym symbol?)\n  :ret symbol?)",
                             :removed {:in "1.9.542",
                                       :last-seen "1.9.521"}},
           "cljs.repl/*cljs-verbose*" {:ns "cljs.repl",
                                       :name "*cljs-verbose*",
                                       :name-encode "STARcljs-verboseSTAR",
                                       :type "dynamic var",
                                       :full-name-encode "cljs.repl/STARcljs-verboseSTAR",
                                       :source {:code "(def ^:dynamic *cljs-verbose* false)",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/clojure/cljs/repl.cljc",
                                                :lines [34]},
                                       :full-name "cljs.repl/*cljs-verbose*",
                                       :history [["+" "0.0-927"]]},
           "cljs.core/PersistentQueue" {:protocols #{"ISeqable"
                                                     "IMeta"
                                                     "IWithMeta"
                                                     "IStack"
                                                     "IEmptyableCollection"
                                                     "ICounted"
                                                     "ISequential"
                                                     "ISeq"
                                                     "ICollection"
                                                     "IHash"
                                                     "IPrintWithWriter"
                                                     "IIterable"
                                                     "IEquiv"
                                                     "ICloneable"},
                                        :ns "cljs.core",
                                        :name "PersistentQueue",
                                        :signature ["[meta count front rear __hash]"],
                                        :name-encode "PersistentQueue",
                                        :history [["+" "0.0-927"]],
                                        :type "type",
                                        :full-name-encode "cljs.core/PersistentQueue",
                                        :source {:code "(deftype PersistentQueue [meta count front rear ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  ICloneable\n  (-clone [coll] (PersistentQueue. meta count front rear __hash))\n\n  IIterable\n  (-iterator [coll]\n    (PersistentQueueIter. front (-iterator rear)))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (PersistentQueue. new-meta count front rear __hash)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] (first front))\n  (-rest [coll] (rest (seq coll)))\n\n  IStack\n  (-peek [coll] (first front))\n  (-pop [coll]\n    (if front\n      (if-let [f1 (next front)]\n        (PersistentQueue. meta (dec count) f1 rear nil)\n        (PersistentQueue. meta (dec count) (seq rear) [] nil))\n      coll))\n\n  ICollection\n  (-conj [coll o]\n    (if front\n      (PersistentQueue. meta (inc count) front (conj (or rear []) o) nil)\n      (PersistentQueue. meta (inc count) (conj front o) [] nil)))\n\n  IEmptyableCollection\n  (-empty [coll] (-with-meta (.-EMPTY PersistentQueue) meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (let [rear (seq rear)]\n      (if (or front rear)\n        (PersistentQueueSeq. nil front (seq rear) nil))))\n\n  ICounted\n  (-count [coll] count))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/cljs/cljs/core.cljs",
                                                 :lines [6407 6474]},
                                        :full-name "cljs.core/PersistentQueue"},
           "cljs.repl/repl-options" {:ns "cljs.repl",
                                     :name "repl-options",
                                     :signature ["[repl-env]"],
                                     :name-encode "repl-options",
                                     :history [["+" "1.10.63"]],
                                     :type "function",
                                     :full-name-encode "cljs.repl/repl-options",
                                     :source {:code "(defn repl-options [repl-env]\n  (-repl-options repl-env))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/clojure/cljs/repl.cljc",
                                              :lines [118 119]},
                                     :full-name "cljs.repl/repl-options"},
           "cljs.spec.impl.gen/sample" {:ns "cljs.spec.impl.gen",
                                        :name "sample",
                                        :signature ["[& args]"],
                                        :name-encode "sample",
                                        :history [["+" "1.9.14"]
                                                  ["-" "1.9.542"]],
                                        :type "function",
                                        :full-name-encode "cljs.spec.impl.gen/sample",
                                        :source {:code "(lazy-combinators hash-map list map not-empty set vector vector-distinct fmap elements\n  bind choose one-of such-that tuple sample return\n  large-integer* double* frequency)",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.9.521",
                                                 :filename "src/main/cljs/cljs/spec/impl/gen.cljs",
                                                 :lines [69 71]},
                                        :full-name "cljs.spec.impl.gen/sample",
                                        :docstring "Lazy loaded version of clojure.test.check.generators/sample",
                                        :removed {:in "1.9.542",
                                                  :last-seen "1.9.521"}},
           "cljs.spec.alpha/explain-out" {:ns "cljs.spec.alpha",
                                          :name "explain-out",
                                          :signature ["[ed]"],
                                          :name-encode "explain-out",
                                          :history [["+" "1.9.542"]],
                                          :type "function",
                                          :full-name-encode "cljs.spec.alpha/explain-out",
                                          :source {:code "(defn explain-out\n  [ed]\n  (*explain-out* ed))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/cljs/cljs/spec/alpha.cljs",
                                                   :lines [264 268]},
                                          :full-name "cljs.spec.alpha/explain-out",
                                          :docstring "Prints explanation data (per 'explain-data') to *out* using the printer in *explain-out*,\n by default explain-printer."},
           "cljs.spec.alpha/inst-in" {:ns "cljs.spec.alpha",
                                      :name "inst-in",
                                      :signature ["[start end]"],
                                      :name-encode "inst-in",
                                      :history [["+" "1.9.542"]],
                                      :type "macro",
                                      :full-name-encode "cljs.spec.alpha/inst-in",
                                      :source {:code "(defmacro inst-in\n  [start end]\n  `(let [st# (cljs.core/inst-ms ~start)\n         et# (cljs.core/inst-ms ~end)\n         mkdate# (fn [d#] (js/Date. d#))]\n     (spec (and cljs.core/inst? #(inst-in-range? ~start ~end %))\n       :gen (fn []\n              (gen/fmap mkdate#\n                (gen/large-integer* {:min st# :max et#}))))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/spec/alpha.cljc",
                                               :lines [476 486]},
                                      :full-name "cljs.spec.alpha/inst-in",
                                      :docstring "Returns a spec that validates insts in the range from start\n(inclusive) to end (exclusive)."},
           "compiler-options/hashbang" {:ns "compiler-options",
                                        :name "hashbang",
                                        :name-encode "hashbang",
                                        :type "option",
                                        :full-name-encode "compiler-options/hashbang",
                                        :full-name "compiler-options/hashbang",
                                        :history [["+" "0.0-2197"]]},
           "cljs.spec.alpha/?" {:ns "cljs.spec.alpha",
                                :name "?",
                                :signature ["[pred-form]"],
                                :name-encode "QMARK",
                                :history [["+" "1.9.542"]],
                                :type "macro",
                                :full-name-encode "cljs.spec.alpha/QMARK",
                                :source {:code "(defmacro ?\n  [pred-form]\n  `(maybe-impl ~pred-form '~(res &env pred-form)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/spec/alpha.cljc",
                                         :lines [333 337]},
                                :full-name "cljs.spec.alpha/?",
                                :docstring "Returns a regex op that matches zero or one value matching\npred. Produces a single value (not a collection) if matched."},
           "cljs.repl.server/read-post" {:ns "cljs.repl.server",
                                         :name "read-post",
                                         :signature ["[line rdr]"],
                                         :name-encode "read-post",
                                         :history [["+" "0.0-1503"]],
                                         :type "function",
                                         :full-name-encode "cljs.repl.server/read-post",
                                         :source {:code "(defn read-post [line rdr]\n  (let [[_ file _] (str/split line #\" \")\n        {:keys [path ref query-str]} (parse-file-parts file)\n        headers (parse-headers (read-headers rdr))\n        content-length (Integer/parseInt (:content-length headers))\n        content (char-array content-length)]\n    (io! (.read rdr content 0 content-length)\n      {:method :post\n       :path path\n       :ref ref\n       :query-str query-str\n       :headers headers\n       :content (String. content)})))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/clojure/cljs/repl/server.clj",
                                                  :lines [94 106]},
                                         :full-name "cljs.repl.server/read-post"},
           "cljs.core/drop-last" {:ns "cljs.core",
                                  :name "drop-last",
                                  :signature ["[s]" "[n s]"],
                                  :name-encode "drop-last",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/drop-last",
                                  :source {:code "(defn drop-last\n  ([s] (drop-last 1 s))\n  ([n s] (map (fn [x _] x) s (drop n s))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [4913 4916]},
                                  :full-name "cljs.core/drop-last",
                                  :docstring "Return a lazy sequence of all but the last n (default 1) items in coll"},
           "closure-warnings/strict-module-dep-check" {:ns "closure-warnings",
                                                       :name "strict-module-dep-check",
                                                       :name-encode "strict-module-dep-check",
                                                       :type "warning",
                                                       :full-name-encode "closure-warnings/strict-module-dep-check",
                                                       :full-name "closure-warnings/strict-module-dep-check",
                                                       :history [["+"
                                                                  "0.0-2120"]]},
           "cljs.spec.gen.alpha/vector" {:ns "cljs.spec.gen.alpha",
                                         :name "vector",
                                         :signature ["[& args]"],
                                         :name-encode "vector",
                                         :history [["+" "1.9.542"]],
                                         :type "function",
                                         :full-name-encode "cljs.spec.gen.alpha/vector",
                                         :source {:code "(lazy-combinators hash-map list map not-empty set vector vector-distinct fmap elements\n  bind choose one-of such-that tuple sample return\n  large-integer* double* frequency shuffle)",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/cljs/cljs/spec/gen/alpha.cljs",
                                                  :lines [70 72]},
                                         :full-name "cljs.spec.gen.alpha/vector",
                                         :docstring "Lazy loaded version of clojure.test.check.generators/vector"},
           "cljs.core/array?" {:return-type boolean,
                               :ns "cljs.core",
                               :name "array?",
                               :signature ["[x]"],
                               :name-encode "arrayQMARK",
                               :history [["+" "0.0-1798"]],
                               :type "function",
                               :full-name-encode "cljs.core/arrayQMARK",
                               :source {:code "(defn ^boolean array?\n  [x]\n  (if (identical? *target* \"nodejs\")\n    (.isArray js/Array x)\n    (instance? js/Array x)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [246 251]},
                               :full-name "cljs.core/array?",
                               :docstring "Returns true if x is a JavaScript array."},
           "cljs.core/PersistentVector.fromArray" {:ns "cljs.core",
                                                   :name "PersistentVector.fromArray",
                                                   :signature ["[xs no-clone]"],
                                                   :name-encode "PersistentVectorDOTfromArray",
                                                   :history [["+"
                                                              "0.0-1006"]],
                                                   :parent-type "PersistentVector",
                                                   :type "function",
                                                   :full-name-encode "cljs.core/PersistentVectorDOTfromArray",
                                                   :source {:code "(set! (.-fromArray PersistentVector)\n  (fn [xs ^boolean no-clone]\n    (let [l (alength xs)\n          xs (if no-clone xs (aclone xs))]\n      (if (< l 32)\n        (PersistentVector. nil l 5 (.-EMPTY-NODE PersistentVector) xs nil)\n        (let [node (.slice xs 0 32)\n              v (PersistentVector. nil 32 5 (.-EMPTY-NODE PersistentVector) node nil)]\n          (loop [i 32 out (-as-transient v)]\n            (if (< i l)\n              (recur (inc i) (conj! out (aget xs i)))\n              (persistent! out))))))))",
                                                            :title "Source code",
                                                            :repo "clojurescript",
                                                            :tag "r1.12.38",
                                                            :filename "src/main/cljs/cljs/core.cljs",
                                                            :lines [5828
                                                                    5839]},
                                                   :full-name "cljs.core/PersistentVector.fromArray"},
           "cljs.spec.alpha/keys*" {:ns "cljs.spec.alpha",
                                    :name "keys*",
                                    :signature ["[& kspecs]"],
                                    :name-encode "keysSTAR",
                                    :history [["+" "1.9.542"]],
                                    :type "macro",
                                    :full-name-encode "cljs.spec.alpha/keysSTAR",
                                    :source {:code "(defmacro keys*\n  [& kspecs]\n  `(let [mspec# (keys ~@kspecs)]\n     (with-gen (cljs.spec.alpha/& (* (cat ::k keyword? ::v cljs.core/any?)) ::kvs->map mspec#)\n       (fn [] (gen/fmap (fn [m#] (apply concat m#)) (gen mspec#))))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/spec/alpha.cljc",
                                             :lines [451 468]},
                                    :full-name "cljs.spec.alpha/keys*",
                                    :docstring "takes the same arguments as spec/keys and returns a regex op that matches sequences of key/values,\nconverts them into a map, and conforms that map with a corresponding\nspec/keys call:\n\nuser=> (s/conform (s/keys :req-un [::a ::c]) {:a 1 :c 2})\n{:a 1, :c 2}\nuser=> (s/conform (s/keys* :req-un [::a ::c]) [:a 1 :c 2])\n{:a 1, :c 2}\n\nthe resulting regex op can be composed into a larger regex:\n\nuser=> (s/conform (s/cat :i1 integer? :m (s/keys* :req-un [::a ::c]) :i2 integer?) [42 :a 1 :c 2 :d 4 99])\n{:i1 42, :m {:a 1, :c 2, :d 4}, :i2 99}"},
           "compiler-options/warnings" {:ns "compiler-options",
                                        :name "warnings",
                                        :name-encode "warnings",
                                        :type "option",
                                        :full-name-encode "compiler-options/warnings",
                                        :full-name "compiler-options/warnings",
                                        :sub-options-ns "warnings",
                                        :history [["+" "0.0-1443"]]},
           "cljs.core/filterv" {:ns "cljs.core",
                                :name "filterv",
                                :signature ["[pred coll]"],
                                :name-encode "filterv",
                                :history [["+" "0.0-1211"]],
                                :type "function",
                                :full-name-encode "cljs.core/filterv",
                                :source {:code "(defn filterv\n  [pred coll]\n  (-> (reduce (fn [v o] (if (pred o) (conj! v o) v))\n              (transient [])\n              coll)\n      persistent!))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [5372 5379]},
                                :full-name "cljs.core/filterv",
                                :docstring "Returns a vector of the items in coll for which\n(pred item) returns logical true. pred must be free of side-effects."},
           "cljs.core/IComparable" {:ns "cljs.core",
                                    :name "IComparable",
                                    :name-encode "IComparable",
                                    :implementations #{"Subvec"
                                                       "Symbol"
                                                       "js/Date"
                                                       "RedNode"
                                                       "BlackNode"
                                                       "PersistentVector"
                                                       "Keyword"
                                                       "MapEntry"
                                                       "UUID"},
                                    :history [["+" "0.0-1424"]],
                                    :type "protocol",
                                    :full-name-encode "cljs.core/IComparable",
                                    :source {:code "(defprotocol IComparable\n  (^number -compare [x y]\n    \"Returns a negative number, zero, or a positive number when x is logically\n     'less than', 'equal to', or 'greater than' y.\"))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [835 839]},
                                    :methods [{:name "-compare",
                                               :signature ["[x y]"],
                                               :docstring "Returns a negative number, zero, or a positive number when x is logically\n     'less than', 'equal to', or 'greater than' y."}],
                                    :full-name "cljs.core/IComparable",
                                    :docstring "Protocol for values that can be compared."},
           "cljs.reader/read-string" {:ns "cljs.reader",
                                      :name "read-string",
                                      :signature ["[s]" "[opts s]"],
                                      :name-encode "read-string",
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "cljs.reader/read-string",
                                      :source {:code "(defn read-string\n  ([s]\n   (edn/read-string\n     {:readers @*tag-table*\n      :default @*default-data-reader-fn*\n      :eof nil} s))\n  ([opts s]\n   (edn/read-string\n     (update (merge {:default @*default-data-reader-fn*} opts)\n       :readers (fn [m] (merge @*tag-table* m))) s)))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/reader.cljs",
                                               :lines [174 190]},
                                      :full-name "cljs.reader/read-string",
                                      :docstring "Reads one object from the string s.\nReturns nil when s is nil or empty.\n\nReads data in the edn format (subset of Clojure data):\nhttp://edn-format.org\n\nopts is a map as per cljs.tools.reader.edn/read"},
           "cljs.spec/*explain-out*" {:ns "cljs.spec",
                                      :name "*explain-out*",
                                      :name-encode "STARexplain-outSTAR",
                                      :history [["+" "1.9.293"]
                                                ["-" "1.9.542"]],
                                      :type "dynamic var",
                                      :full-name-encode "cljs.spec/STARexplain-outSTAR",
                                      :source {:code "(def ^:dynamic *explain-out* explain-printer)",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.9.521",
                                               :filename "src/main/cljs/cljs/spec.cljs",
                                               :lines [246]},
                                      :full-name "cljs.spec/*explain-out*",
                                      :removed {:in "1.9.542",
                                                :last-seen "1.9.521"}},
           "cljs.core/*global*" {:ns "cljs.core",
                                 :name "*global*",
                                 :name-encode "STARglobalSTAR",
                                 :history [["+" "1.10.738"]],
                                 :type "dynamic var",
                                 :full-name-encode "cljs.core/STARglobalSTAR",
                                 :source {:code "(goog-define\n  ^{:dynamic true}\n  *global* \"default\")",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [50 54]},
                                 :full-name "cljs.core/*global*",
                                 :docstring "Manually set the JavaScript global context. Only \"window\", \"self\"\n, and \"global\" supported. "},
           "cljs.spec.gen.alpha/one-of" {:ns "cljs.spec.gen.alpha",
                                         :name "one-of",
                                         :signature ["[& args]"],
                                         :name-encode "one-of",
                                         :history [["+" "1.9.542"]],
                                         :type "function",
                                         :full-name-encode "cljs.spec.gen.alpha/one-of",
                                         :source {:code "(lazy-combinators hash-map list map not-empty set vector vector-distinct fmap elements\n  bind choose one-of such-that tuple sample return\n  large-integer* double* frequency shuffle)",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/cljs/cljs/spec/gen/alpha.cljs",
                                                  :lines [70 72]},
                                         :full-name "cljs.spec.gen.alpha/one-of",
                                         :docstring "Lazy loaded version of clojure.test.check.generators/one-of"},
           "cljs.reader/unicode-2-pattern" {:ns "cljs.reader",
                                            :name "unicode-2-pattern",
                                            :name-encode "unicode-2-pattern",
                                            :history [["+" "0.0-1424"]
                                                      ["-" "1.9.854"]],
                                            :type "var",
                                            :full-name-encode "cljs.reader/unicode-2-pattern",
                                            :source {:code "(def unicode-2-pattern (re-pattern \"^[0-9A-Fa-f]{2}$\"))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.9.671",
                                                     :filename "src/main/cljs/cljs/reader.cljs",
                                                     :lines [182]},
                                            :full-name "cljs.reader/unicode-2-pattern",
                                            :removed {:in "1.9.854",
                                                      :last-seen "1.9.671"}},
           "cljs.repl/IGetError" {:ns "cljs.repl",
                                  :name "IGetError",
                                  :name-encode "IGetError",
                                  :history [["+" "0.0-2985"]],
                                  :type "protocol",
                                  :full-name-encode "cljs.repl/IGetError",
                                  :source {:code "(defprotocol IGetError\n  (-get-error [repl-env name env build-options]\n    \"Given a symbol representing a var holding an error, an analysis\n     environment, and the REPL/compiler options return the canonical error\n     representation:\n\n     {:value <string>\n      :stacktrace <string>}\n\n    :value should be the host environment JavaScript error message string.\n    :stacktrace should be the host JavaScript environment stacktrace string.\"))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/clojure/cljs/repl.cljc",
                                           :lines [149 159]},
                                  :methods [{:name "-get-error",
                                             :signature ["[repl-env name env build-options]"],
                                             :docstring "Given a symbol representing a var holding an error, an analysis\n     environment, and the REPL/compiler options return the canonical error\n     representation:\n\n     {:value <string>\n      :stacktrace <string>}\n\n    :value should be the host environment JavaScript error message string.\n    :stacktrace should be the host JavaScript environment stacktrace string."}],
                                  :full-name "cljs.repl/IGetError"},
           "cljs.core/CHAR_MAP" {:ns "cljs.core",
                                 :name "CHAR_MAP",
                                 :name-encode "CHAR_MAP",
                                 :type "var",
                                 :full-name-encode "cljs.core/CHAR_MAP",
                                 :source {:code "(def ^{:jsdoc [\"@enum {string}\"]}\n  CHAR_MAP\n  #js {\"-\"    \"_\"\n       \":\"    \"_COLON_\"\n       \"+\"    \"_PLUS_\"\n       \">\"    \"_GT_\"\n       \"<\"    \"_LT_\"\n       \"=\"    \"_EQ_\"\n       \"~\"    \"_TILDE_\"\n       \"!\"    \"_BANG_\"\n       \"@\"    \"_CIRCA_\"\n       \"#\"    \"_SHARP_\"\n       \"'\"    \"_SINGLEQUOTE_\"\n       \"\\\\\\\"\" \"_DOUBLEQUOTE_\"\n       \"%\"    \"_PERCENT_\"\n       \"^\"    \"_CARET_\"\n       \"&\"    \"_AMPERSAND_\"\n       \"*\"    \"_STAR_\"\n       \"|\"    \"_BAR_\"\n       \"{\"    \"_LBRACE_\"\n       \"}\"    \"_RBRACE_\"\n       \"[\"    \"_LBRACK_\"\n       \"]\"    \"_RBRACK_\"\n       \"/\"    \"_SLASH_\"\n       \"\\\\\\\\\" \"_BSLASH_\"\n       \"?\"    \"_QMARK_\"})",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [347 372]},
                                 :full-name "cljs.core/CHAR_MAP",
                                 :history [["+" "1.7.10"]]},
           "cljs.core/Volatile" {:protocols #{"IVolatile"
                                              "IDeref"
                                              "IPrintWithWriter"},
                                 :ns "cljs.core",
                                 :name "Volatile",
                                 :signature ["[state]"],
                                 :name-encode "Volatile",
                                 :history [["+" "0.0-2496"]],
                                 :type "type",
                                 :full-name-encode "cljs.core/Volatile",
                                 :source {:code "(deftype Volatile [^:mutable state]\n  IVolatile\n  (-vreset! [_ new-state]\n    (set! state new-state))\n\n  IDeref\n  (-deref [_] state))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [4672 4678]},
                                 :full-name "cljs.core/Volatile"},
           "cljs.core/check-string-hash-cache" {:ns "cljs.core",
                                                :name "check-string-hash-cache",
                                                :signature ["[k]"],
                                                :name-encode "check-string-hash-cache",
                                                :history [["+"
                                                           "0.0-1424"]
                                                          ["-"
                                                           "0.0-2261"]],
                                                :type "function",
                                                :full-name-encode "cljs.core/check-string-hash-cache",
                                                :source {:code "(defn check-string-hash-cache [k]\n  (when (> string-hash-cache-count 255)\n    (set! string-hash-cache (js-obj))\n    (set! string-hash-cache-count 0))\n  (let [h (aget string-hash-cache k)]\n    (if (number? h)\n      h\n      (add-to-string-hash-cache k))))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r2234",
                                                         :filename "src/cljs/cljs/core.cljs",
                                                         :lines [1147
                                                                 1154]},
                                                :full-name "cljs.core/check-string-hash-cache",
                                                :removed {:in "0.0-2261",
                                                          :last-seen "0.0-2234"}},
           "cljs.spec/every" {:ns "cljs.spec",
                              :name "every",
                              :signature ["[pred & {:keys [into kind count max-count min-count distinct gen-max gen-into gen], :as opts}]"],
                              :name-encode "every",
                              :history [["+" "1.9.85"]
                                        ["-" "1.9.542"]],
                              :type "macro",
                              :full-name-encode "cljs.spec/every",
                              :source {:code "(defmacro every\n  [pred & {:keys [into kind count max-count min-count distinct gen-max gen-into gen] :as opts}]\n  (let [desc (::describe opts)\n        nopts (-> opts\n                (dissoc :gen ::describe)\n                (assoc ::kind-form `'~(res &env (:kind opts))\n                       ::describe (clojure.core/or desc `'(every ~(res &env pred) ~@(res-kind &env opts)))))\n        gx (gensym)\n        cpreds (cond-> [(list (clojure.core/or kind `coll?) gx)]\n                 count (conj `(= ~count (c/bounded-count ~count ~gx)))\n\n                 (clojure.core/or min-count max-count)\n                 (conj `(<= (c/or ~min-count 0)\n                          (c/bounded-count (if ~max-count (inc ~max-count) ~min-count) ~gx)\n                          (c/or ~max-count MAX_INT)))\n\n                 distinct\n                 (conj `(c/or (empty? ~gx) (apply distinct? ~gx))))]\n    `(every-impl '~pred ~pred ~(assoc nopts ::cpred `(fn* [~gx] (c/and ~@cpreds))) ~gen)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.9.521",
                                       :filename "src/main/cljs/cljs/spec.cljc",
                                       :lines [213 259]},
                              :full-name "cljs.spec/every",
                              :docstring "takes a pred and validates collection elements against that pred.\n\nNote that 'every' does not do exhaustive checking, rather it samples\n*coll-check-limit* elements. Nor (as a result) does it do any\nconforming of elements. 'explain' will report at most *coll-error-limit*\nproblems.  Thus 'every' should be suitable for potentially large\ncollections.\n\nTakes several kwargs options that further constrain the collection:\n\n:kind - a pred/spec that the collection type must satisfy, e.g. vector?\n        (default nil) Note that if :kind is specified and :into is\n        not, this pred must generate in order for every to generate.\n:count - specifies coll has exactly this count (default nil)\n:min-count, :max-count - coll has count (<= min-count count max-count) (defaults nil)\n:distinct - all the elements are distinct (default nil)\n\nAnd additional args that control gen\n\n:gen-max - the maximum coll size to generate (default 20)\n:into - one of [], (), {}, #{} - the default collection to generate into\n    (default same as :kind if supplied, else []\n\nOptionally takes :gen generator-fn, which must be a fn of no args that\nreturns a test.check generator\n\nSee also - coll-of, every-kv",
                              :removed {:in "1.9.542",
                                        :last-seen "1.9.521"}},
           "cljs.core/vector?" {:ns "cljs.core",
                                :name "vector?",
                                :signature ["[x]"],
                                :name-encode "vectorQMARK",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/vectorQMARK",
                                :source {:code "(defn vector?\n  [x] (satisfies? IVector x))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [2232 2234]},
                                :full-name "cljs.core/vector?",
                                :docstring "Return true if x satisfies IVector"},
           "cljs.core/defmulti" {:ns "cljs.core",
                                 :name "defmulti",
                                 :signature ["[name docstring? attr-map? dispatch-fn & options]"],
                                 :name-encode "defmulti",
                                 :history [["+" "0.0-927"]],
                                 :type "macro",
                                 :full-name-encode "cljs.core/defmulti",
                                 :source {:code "(core/defmacro defmulti\n  {:arglists '([name docstring? attr-map? dispatch-fn & options])}\n  [mm-name & options]\n  (core/let [docstring   (if (core/string? (first options))\n                           (first options)\n                           nil)\n             options     (if (core/string? (first options))\n                           (next options)\n                           options)\n             m           (if (map? (first options))\n                           (first options)\n                           {})\n             options     (if (map? (first options))\n                           (next options)\n                           options)\n             dispatch-fn (first options)\n             options     (next options)\n             m           (if docstring\n                           (assoc m :doc docstring)\n                           m)\n             m           (if (meta mm-name)\n                           (conj (meta mm-name) m)\n                           m)\n             mm-ns (core/-> &env :ns :name core/str)]\n    (core/when (= (count options) 1)\n      (throw\n        #?(:clj (Exception. \"The syntax for defmulti has changed. Example: (defmulti name dispatch-fn :default dispatch-value)\")\n           :cljs (js/Error. \"The syntax for defmulti has changed. Example: (defmulti name dispatch-fn :default dispatch-value)\"))))\n    (core/let [options (apply core/hash-map options)\n               default (core/get options :default :default)]\n      (check-valid-options options :default :hierarchy)\n      `(defonce ~(with-meta mm-name m)\n         (let [method-table# (atom {})\n               prefer-table# (atom {})\n               method-cache# (atom {})\n               cached-hierarchy# (atom {})\n               hierarchy# (cljs.core/get ~options :hierarchy ((~'js* \"cljs.core.get_global_hierarchy\")))]\n           (cljs.core/MultiFn. (cljs.core/symbol ~mm-ns ~(name mm-name)) ~dispatch-fn ~default hierarchy#\n             method-table# prefer-table# method-cache# cached-hierarchy#))))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/clojure/cljs/core.cljc",
                                          :lines [2762 2807]},
                                 :full-name "cljs.core/defmulti",
                                 :docstring "Creates a new multimethod with the associated dispatch function.\nThe docstring and attribute-map are optional.\n\nOptions are key-value pairs and may be one of:\n  :default    the default dispatch value, defaults to :default\n  :hierarchy  the isa? hierarchy to use for dispatching\n              defaults to the global hierarchy"},
           "syntax/rest" {:syntax-equiv {:edn-url nil, :clj-url nil},
                          :ns "syntax",
                          :name "rest",
                          :name-encode "rest",
                          :type "special character",
                          :full-name-encode "syntax/rest",
                          :full-name "syntax/rest",
                          :history [["+" "0.0-927"]]},
           "cljs.spec/check-asserts?" {:return-type boolean,
                                       :ns "cljs.spec",
                                       :name "check-asserts?",
                                       :signature ["[]"],
                                       :name-encode "check-assertsQMARK",
                                       :history [["+" "1.9.216"]
                                                 ["-" "1.9.542"]],
                                       :type "function",
                                       :full-name-encode "cljs.spec/check-assertsQMARK",
                                       :source {:code "(defn ^boolean check-asserts?\n  []\n  *runtime-asserts*)",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.9.521",
                                                :filename "src/main/cljs/cljs/spec.cljs",
                                                :lines [1423 1426]},
                                       :full-name "cljs.spec/check-asserts?",
                                       :docstring "Returns the value set by check-asserts.",
                                       :removed {:in "1.9.542",
                                                 :last-seen "1.9.521"}},
           "cljs.spec.alpha/coll-of" {:ns "cljs.spec.alpha",
                                      :name "coll-of",
                                      :signature ["[pred & opts]"],
                                      :name-encode "coll-of",
                                      :history [["+" "1.9.542"]],
                                      :type "macro",
                                      :full-name-encode "cljs.spec.alpha/coll-of",
                                      :source {:code "(defmacro coll-of\n  [pred & opts]\n  (let [desc `(coll-of ~(res &env pred) ~@(res-kind &env opts))]\n    `(every ~pred ::conform-all true ::describe '~desc ~@opts)))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/spec/alpha.cljc",
                                               :lines [292 305]},
                                      :full-name "cljs.spec.alpha/coll-of",
                                      :docstring "Returns a spec for a collection of items satisfying pred. Unlike\ngenerator will fill an empty init-coll.\n\nSame options as 'every'. conform will produce a collection\ncorresponding to :into if supplied, else will match the input collection,\navoiding rebuilding when possible.\n\nSame options as 'every'.\n\nSee also - every, map-of"},
           "cljs.core/Keyword" {:protocols #{"IFn"
                                             "IHash"
                                             "INamed"
                                             "IComparable"
                                             "IPrintWithWriter"
                                             "IEquiv"},
                                :ns "cljs.core",
                                :name "Keyword",
                                :signature ["[ns name fqn _hash]"],
                                :name-encode "Keyword",
                                :history [["+" "0.0-1424"]],
                                :type "type",
                                :full-name-encode "cljs.core/Keyword",
                                :source {:code "(deftype Keyword [ns name fqn ^:mutable _hash]\n  Object\n  (toString [_] (str \":\" fqn))\n  (equiv [this other]\n    (-equiv this other))\n\n  IEquiv\n  (-equiv [_ other]\n    (if (instance? Keyword other)\n      (identical? fqn (.-fqn other))\n      false))\n  IFn\n  (-invoke [kw coll]\n    (get coll kw))\n  (-invoke [kw coll not-found]\n    (get coll kw not-found))\n\n  IHash\n  (-hash [this]\n    (caching-hash this hash-keyword _hash))\n\n  INamed\n  (-name [_] name)\n  (-namespace [_] ns)\n\n  IPrintWithWriter\n  (-pr-writer [o writer _] (-write writer (str \":\" fqn))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [3396 3422]},
                                :full-name "cljs.core/Keyword"},
           "cljs.spec.test/summarize-results" {:ns "cljs.spec.test",
                                               :name "summarize-results",
                                               :signature ["[check-results]"
                                                           "[check-results summary-result]"],
                                               :name-encode "summarize-results",
                                               :history [["+"
                                                          "1.9.183"]
                                                         ["-"
                                                          "1.9.542"]],
                                               :type "function",
                                               :full-name-encode "cljs.spec.test/summarize-results",
                                               :source {:code "(defn summarize-results\n  ([check-results] (summarize-results check-results abbrev-result))\n  ([check-results summary-result]\n   (reduce\n     (fn [summary result]\n       (pp/pprint (summary-result result))\n       (-> summary\n         (update :total inc)\n         (update (result-type result) (fnil inc 0))))\n     {:total 0}\n     check-results)))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.9.521",
                                                        :filename "src/main/cljs/cljs/spec/test.cljs",
                                                        :lines [269
                                                                284]},
                                               :full-name "cljs.spec.test/summarize-results",
                                               :docstring "Given a collection of check-results, e.g. from 'check', pretty\nprints the summary-result (default abbrev-result) of each.\n\nReturns a map with :total, the total number of results, plus a\nkey with a count for each different :type of result.",
                                               :removed {:in "1.9.542",
                                                         :last-seen "1.9.521"}},
           "cljs.spec.impl.gen/hash-map" {:ns "cljs.spec.impl.gen",
                                          :name "hash-map",
                                          :signature ["[& args]"],
                                          :name-encode "hash-map",
                                          :history [["+" "1.9.14"]
                                                    ["-" "1.9.542"]],
                                          :type "function",
                                          :full-name-encode "cljs.spec.impl.gen/hash-map",
                                          :source {:code "(lazy-combinators hash-map list map not-empty set vector vector-distinct fmap elements\n  bind choose one-of such-that tuple sample return\n  large-integer* double* frequency)",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.9.521",
                                                   :filename "src/main/cljs/cljs/spec/impl/gen.cljs",
                                                   :lines [69 71]},
                                          :full-name "cljs.spec.impl.gen/hash-map",
                                          :docstring "Lazy loaded version of clojure.test.check.generators/hash-map",
                                          :removed {:in "1.9.542",
                                                    :last-seen "1.9.521"}},
           "cljs.core/List.EMPTY" {:ns "cljs.core",
                                   :name "List.EMPTY",
                                   :name-encode "ListDOTEMPTY",
                                   :history [["+" "0.0-927"]],
                                   :parent-type "List",
                                   :type "var",
                                   :full-name-encode "cljs.core/ListDOTEMPTY",
                                   :source {:code "(set! (.-EMPTY List) (EmptyList. nil))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [3274]},
                                   :full-name "cljs.core/List.EMPTY"},
           "cljs.spec.test.alpha/check-1" {:ns "cljs.spec.test.alpha",
                                           :name "check-1",
                                           :signature ["[[quote s :as qs] f spec opts]"],
                                           :name-encode "check-1",
                                           :history [["+" "1.9.542"]],
                                           :type "macro",
                                           :full-name-encode "cljs.spec.test.alpha/check-1",
                                           :source {:code "(defmacro check-1\n  [[quote s :as qs] f spec opts]\n  (let [{:keys [name] :as v} (when qs (ana-api/resolve &env s))]\n    `(let [s#        '~name\n           v#        ~(when v `(var ~name))\n           spec#     (or ~spec ~(when v `(s/get-spec (var ~name))))\n           re-inst?# (and v# (seq (unstrument '~name)) true)\n           f#        (or ~f (when v# @v#))\n           opts#     ~opts\n           old-tc-ns# \"clojure.test.check\"\n           old-tc-opts-key# (keyword old-tc-ns# \"opts\")\n           [tc-ns# opts#] (if-let [old-tc-opts# (get opts# old-tc-opts-key#)]\n                            [old-tc-ns# (assoc opts# :clojure.spec.test.check/opts\n                                               old-tc-opts#)]\n                            [\"clojure.spec.test.check\" opts#])]\n       (try\n         (cond\n           (nil? f#)\n           {:failure (ex-info \"No fn to spec\" {::s/failure :no-fn})\n            :sym     s# :spec spec#}\n\n           (:args spec#)\n           (let [tcret# (#'quick-check f# spec# opts#)]\n             (#'make-check-result s# spec# tcret#\n                                  (keyword tc-ns# \"ret\")))\n\n           :default\n           {:failure (ex-info \"No :args spec\" {::s/failure :no-args-spec})\n            :sym     s# :spec spec#})\n         (finally\n           (when re-inst?# (instrument '~name)))))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/cljs/cljs/spec/test/alpha.cljc",
                                                    :lines [192 222]},
                                           :full-name "cljs.spec.test.alpha/check-1"},
           "cljs.spec.test.alpha/check-fn" {:ns "cljs.spec.test.alpha",
                                            :name "check-fn",
                                            :signature ["[f spec]"
                                                        "[f spec opts]"],
                                            :name-encode "check-fn",
                                            :history [["+" "1.9.542"]],
                                            :type "macro",
                                            :full-name-encode "cljs.spec.test.alpha/check-fn",
                                            :source {:code "(defmacro check-fn\n  ([f spec]\n   `(check-fn ~f ~spec nil))\n  ([f spec opts]\n   `(let [opts# ~opts]\n      (validate-check-opts opts#)\n      (check-1 nil ~f ~spec opts#))))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/cljs/cljs/spec/test/alpha.cljc",
                                                     :lines [224 232]},
                                            :full-name "cljs.spec.test.alpha/check-fn",
                                            :docstring "Runs generative tests for fn f using spec and opts. See\n'check' for options and return."},
           "clojure.browser.event/dispatch-event" {:ns "clojure.browser.event",
                                                   :name "dispatch-event",
                                                   :signature ["[src event]"],
                                                   :name-encode "dispatch-event",
                                                   :history [["+"
                                                              "0.0-927"]],
                                                   :type "function",
                                                   :full-name-encode "clojure.browser.event/dispatch-event",
                                                   :source {:code "(defn dispatch-event\n  [src event]\n  (events/dispatchEvent src event))",
                                                            :title "Source code",
                                                            :repo "clojurescript",
                                                            :tag "r1.12.38",
                                                            :filename "src/main/cljs/clojure/browser/event.cljs",
                                                            :lines [77
                                                                    79]},
                                                   :full-name "clojure.browser.event/dispatch-event"},
           "clojure.datafy/datafy" {:ns "clojure.datafy",
                                    :name "datafy",
                                    :signature ["[x]"],
                                    :name-encode "datafy",
                                    :history [["+" "1.10.514"]],
                                    :type "function",
                                    :full-name-encode "clojure.datafy/datafy",
                                    :source {:code "(defn datafy\n  [x]\n  (let [v (p/datafy x)]\n    (if (identical? v x)\n      v\n      (if (implements? IWithMeta v)\n        (vary-meta v assoc ::obj x\n                   ;; Circling back to this at a later date per @dnolen\n                   ;; ::class (-> x .-constructor .-name symbol)\n                   )\n        v))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/clojure/datafy.cljs",
                                             :lines [14 29]},
                                    :full-name "clojure.datafy/datafy",
                                    :docstring "Attempts to return x as data.\ndatafy will return the value of clojure.protocols/datafy. If\nthe value has been transformed and the result supports\nmetadata, :clojure.datafy/obj will be set on the metadata to the\noriginal value of x."},
           "closure-warnings/common-js-module-load" {:ns "closure-warnings",
                                                     :name "common-js-module-load",
                                                     :name-encode "common-js-module-load",
                                                     :type "warning",
                                                     :full-name-encode "closure-warnings/common-js-module-load",
                                                     :full-name "closure-warnings/common-js-module-load",
                                                     :history [["+"
                                                                "1.9.473"]
                                                               ["-"
                                                                "1.10.63"]],
                                                     :removed {:in "1.10.63",
                                                               :last-seen "1.9.946"}},
           "cljs.core/print-prefix-map" {:ns "cljs.core",
                                         :name "print-prefix-map",
                                         :signature ["[prefix m print-one writer opts]"],
                                         :name-encode "print-prefix-map",
                                         :history [["+" "1.9.456"]],
                                         :type "function",
                                         :full-name-encode "cljs.core/print-prefix-map",
                                         :source {:code "(defn print-prefix-map [prefix m print-one writer opts]\n  (pr-sequential-writer\n    writer\n    (fn [e w opts]\n      (do (print-one (key e) w opts)\n          (-write w \\space)\n          (print-one (val e) w opts)))\n    (str prefix \"{\") \", \" \"}\"\n    opts (seq m)))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/cljs/cljs/core.cljs",
                                                  :lines [10715 10723]},
                                         :full-name "cljs.core/print-prefix-map"},
           "cljs.core/ns-interns" {:ns "cljs.core",
                                   :name "ns-interns",
                                   :signature ["[quoted-ns]"],
                                   :name-encode "ns-interns",
                                   :history [["+" "0.0-2496"]],
                                   :type "macro",
                                   :full-name-encode "cljs.core/ns-interns",
                                   :source {:code "(core/defmacro ns-interns\n  [quoted-ns]\n  (core/assert (core/and (seq? quoted-ns)\n                 (= (first quoted-ns) 'quote)\n                 (core/symbol? (second quoted-ns)))\n    \"Argument to ns-interns must be a quoted symbol\")\n  (core/let [ns (second quoted-ns)]\n    `(into {}\n       [~@(map\n            (core/fn [[sym _]]\n              `[(symbol ~(name sym)) (var ~(symbol (name ns) (name sym)))])\n            (get-in @env/*compiler* [:cljs.analyzer/namespaces ns :defs]))])))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/clojure/cljs/core.cljc",
                                            :lines [2952 2964]},
                                   :full-name "cljs.core/ns-interns",
                                   :docstring "Returns a map of the intern mappings for the namespace."},
           "clojure.string/split-lines" {:ns "clojure.string",
                                         :name "split-lines",
                                         :signature ["[s]"],
                                         :name-encode "split-lines",
                                         :history [["+" "0.0-927"]],
                                         :type "function",
                                         :full-name-encode "clojure.string/split-lines",
                                         :source {:code "(defn split-lines\n  [s]\n  (split s #\"\\n|\\r\\n\"))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/cljs/clojure/string.cljs",
                                                  :lines [192 195]},
                                         :full-name "clojure.string/split-lines",
                                         :docstring "Splits s on \\n or \\r\\n. Trailing empty lines are not returned."},
           "cljs.test/mapped-line-and-column" {:ns "cljs.test",
                                               :name "mapped-line-and-column",
                                               :signature ["[filename line column]"],
                                               :name-encode "mapped-line-and-column",
                                               :history [["+"
                                                          "0.0-2496"]],
                                               :type "function",
                                               :full-name-encode "cljs.test/mapped-line-and-column",
                                               :source {:code "(defn mapped-line-and-column [filename line column]\n  (let [default [filename line column]]\n    (if-let [source-map (:source-map (get-current-env))]\n      ;; source maps are 0 indexed for lines\n      (if-let [columns (get-in source-map [filename (dec line)])]\n        (vec\n          (map\n            ;; source maps are 0 indexed for columns\n            ;; multiple segments may exist at column\n            ;; just take first\n            (first\n              (if-let [mapping (get columns (dec column))]\n                mapping\n                (second (first columns))))\n            [:source :line :col]))\n        default)\n      default)))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.12.38",
                                                        :filename "src/main/cljs/cljs/test.cljs",
                                                        :lines [388
                                                                404]},
                                               :full-name "cljs.test/mapped-line-and-column"},
           "cljs.js/valid-opts?" {:ns "cljs.js",
                                  :name "valid-opts?",
                                  :signature ["[x]"],
                                  :name-encode "valid-optsQMARK",
                                  :history [["+" "1.7.10"]
                                            ["-" "1.7.48"]],
                                  :type "function",
                                  :full-name-encode "cljs.js/valid-optsQMARK",
                                  :source {:code "(defn valid-opts? [x]\n  (or (nil? x) (map? x)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.28",
                                           :filename "src/main/cljs/cljs/js.cljs",
                                           :lines [47 48]},
                                  :full-name "cljs.js/valid-opts?",
                                  :removed {:in "1.7.48",
                                            :last-seen "1.7.28"}},
           "cljs.spec/every-kv" {:ns "cljs.spec",
                                 :name "every-kv",
                                 :signature ["[kpred vpred & opts]"],
                                 :name-encode "every-kv",
                                 :history [["+" "1.9.85"]
                                           ["-" "1.9.542"]],
                                 :type "macro",
                                 :full-name-encode "cljs.spec/every-kv",
                                 :source {:code "(defmacro every-kv\n  [kpred vpred & opts]\n  (let [desc `(every-kv ~(res &env kpred) ~(res &env vpred) ~@(res-kind &env opts))]\n    `(every (tuple ~kpred ~vpred) ::kfn (fn [i# v#] (nth v# 0)) :into {} ::describe '~desc ~@opts)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.9.521",
                                          :filename "src/main/cljs/cljs/spec.cljc",
                                          :lines [261 270]},
                                 :full-name "cljs.spec/every-kv",
                                 :docstring "like 'every' but takes separate key and val preds and works on associative collections.\n\nSame options as 'every', :into defaults to {}\n\nSee also - map-of",
                                 :removed {:in "1.9.542",
                                           :last-seen "1.9.521"}},
           "cljs.math/signum" {:return-type number,
                               :ns "cljs.math",
                               :name "signum",
                               :signature ["[d]"],
                               :name-encode "signum",
                               :history [["+" "1.11.50"]],
                               :type "function",
                               :full-name-encode "cljs.math/signum",
                               :source {:code "(defn ^number signum\n  {:added \"1.11.10\"}\n  [d]\n  (if (or (zero? d) ^boolean (js/isNaN d))\n    d\n    (copy-sign 1.0 d)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/math.cljs",
                                        :lines [661 670]},
                               :full-name "cljs.math/signum",
                               :docstring "Returns the signum function of d - zero for zero, 1.0 if >0, -1.0 if <0.\nIf d is ##NaN => ##NaN\nIf d is ##Inf or ##-Inf => sign of d\nSee: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#signum-double-"},
           "cljs.spec.gen.alpha/char-ascii" {:ns "cljs.spec.gen.alpha",
                                             :name "char-ascii",
                                             :signature ["[& args]"],
                                             :name-encode "char-ascii",
                                             :history [["+" "1.9.542"]],
                                             :type "function",
                                             :full-name-encode "cljs.spec.gen.alpha/char-ascii",
                                             :source {:code "(lazy-prims any any-printable boolean char char-alpha char-alphanumeric char-ascii double\n  int keyword keyword-ns large-integer ratio simple-type simple-type-printable\n  string string-ascii string-alphanumeric symbol symbol-ns uuid)",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.12.38",
                                                      :filename "src/main/cljs/cljs/spec/gen/alpha.cljs",
                                                      :lines [74 76]},
                                             :full-name "cljs.spec.gen.alpha/char-ascii",
                                             :docstring "Fn returning clojure.test.check.generators/char-ascii"},
           "cljs.core/ident?" {:ns "cljs.core",
                               :name "ident?",
                               :signature ["[x]"],
                               :name-encode "identQMARK",
                               :history [["+" "1.9.75"]],
                               :type "function",
                               :full-name-encode "cljs.core/identQMARK",
                               :source {:code "(defn ident?\n  [x] (or (keyword? x) (symbol? x)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [3454 3456]},
                               :full-name "cljs.core/ident?",
                               :docstring "Return true if x is a symbol or keyword"},
           "cljs.spec/Spec" {:ns "cljs.spec",
                             :name "Spec",
                             :name-encode "Spec",
                             :history [["+" "1.9.14"] ["-" "1.9.542"]],
                             :type "protocol",
                             :full-name-encode "cljs.spec/Spec",
                             :source {:code "(defprotocol Spec\n  (conform* [spec x])\n  (unform* [spec y])\n  (explain* [spec path via in x])\n  (gen* [spec overrides path rmap])\n  (with-gen* [spec gfn])\n  (describe* [spec]))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.9.521",
                                      :filename "src/main/cljs/cljs/spec.cljs",
                                      :lines [39 45]},
                             :methods [{:name "conform*",
                                        :signature ["[spec x]"],
                                        :docstring nil}
                                       {:name "unform*",
                                        :signature ["[spec y]"],
                                        :docstring nil}
                                       {:name "explain*",
                                        :signature ["[spec path via in x]"],
                                        :docstring nil}
                                       {:name "gen*",
                                        :signature ["[spec overrides path rmap]"],
                                        :docstring nil}
                                       {:name "with-gen*",
                                        :signature ["[spec gfn]"],
                                        :docstring nil}
                                       {:name "describe*",
                                        :signature ["[spec]"],
                                        :docstring nil}],
                             :full-name "cljs.spec/Spec",
                             :removed {:in "1.9.542",
                                       :last-seen "1.9.521"}},
           "cljs.core/*ns*" {:ns "cljs.core",
                             :name "*ns*",
                             :name-encode "STARnsSTAR",
                             :history [["+" "1.7.10"]],
                             :type "dynamic var",
                             :full-name-encode "cljs.core/STARnsSTAR",
                             :source {:code "(def\n  ^{:dynamic true\n    :jsdoc [\"@type {*}\"]}\n  *ns* nil)",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [56 60]},
                             :full-name "cljs.core/*ns*",
                             :docstring "Var bound to the current namespace. Only used for bootstrapping."},
           "cljs.repl.browser/loaded-libs" {:ns "cljs.repl.browser",
                                            :name "loaded-libs",
                                            :name-encode "loaded-libs",
                                            :history [["+" "0.0-927"]
                                                      ["-" "0.0-3115"]],
                                            :type "var",
                                            :full-name-encode "cljs.repl.browser/loaded-libs",
                                            :source {:code "(def loaded-libs (atom #{}))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r3058",
                                                     :filename "src/clj/cljs/repl/browser.clj",
                                                     :lines [26]},
                                            :full-name "cljs.repl.browser/loaded-libs",
                                            :removed {:in "0.0-3115",
                                                      :last-seen "0.0-3058"}},
           "cljs.core/areduce" {:ns "cljs.core",
                                :name "areduce",
                                :signature ["[a idx ret init expr]"],
                                :name-encode "areduce",
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :full-name-encode "cljs.core/areduce",
                                :source {:code "(core/defmacro areduce\n  [a idx ret init expr]\n  `(let [a# ~a\n         l# (alength a#)]\n     (loop  [~idx 0 ~ret ~init]\n       (if (< ~idx l#)\n         (recur (inc ~idx) ~expr)\n         ~ret))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/clojure/cljs/core.cljc",
                                         :lines [2726 2736]},
                                :full-name "cljs.core/areduce",
                                :docstring "Reduces an expression across an array a, using an index named idx,\nand return value named ret, initialized to init, setting ret to the\nevaluation of expr at each step, returning ret."},
           "cljs.core/disj" {:ns "cljs.core",
                             :name "disj",
                             :signature ["[coll]"
                                         "[coll k]"
                                         "[coll k & ks]"],
                             :name-encode "disj",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/disj",
                             :source {:code "(defn disj\n  ([coll] coll)\n  ([coll k]\n    (when-not (nil? coll)\n      (-disjoin coll k)))\n  ([coll k & ks]\n    (when-not (nil? coll)\n      (let [ret (disj coll k)]\n        (if ks\n          (recur ret (first ks) (next ks))\n          ret)))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [2158 2170]},
                             :full-name "cljs.core/disj",
                             :docstring "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\ndoes not contain key(s)."},
           "cljs.js/*load-fn*" {:ns "cljs.js",
                                :name "*load-fn*",
                                :name-encode "STARload-fnSTAR",
                                :history [["+" "1.7.10"]],
                                :type "dynamic var",
                                :full-name-encode "cljs.js/STARload-fnSTAR",
                                :source {:code "(defonce\n  ^{:dynamic true}\n  *load-fn*\n  (fn [m cb]\n    (throw (js/Error. \"No *load-fn* set\"))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/js.cljs",
                                         :lines [74 103]},
                                :full-name "cljs.js/*load-fn*",
                                :docstring "Each runtime environment provides a different way to load a library.\nWhatever function *load-fn* is bound to will be passed two arguments - a\nmap and a callback function: The map will have the following keys:\n\n:name   - the name of the library (a symbol)\n:macros - modifier signaling a macros namespace load\n:path   - munged relative library path (a string)\n\nIt is up to the implementor to correctly resolve the corresponding .cljs,\n.cljc, or .js resource (the order must be respected). If :macros is true\nresolution should only consider .clj or .cljc resources (the order must be\nrespected). Upon resolution the callback should be invoked with a map\ncontaining the following keys:\n\n:lang       - the language, :clj or :js\n:source     - the source of the library (a string)\n:file       - optional, the file path, it will be added to AST's :file keyword\n              (but not in :meta)\n:cache      - optional, if a :clj namespace has been precompiled to :js, can\n              give an analysis cache for faster loads.\n:source-map - optional, if a :clj namespace has been precompiled to :js, can\n              give a V3 source map JSON\n\nIf the resource could not be resolved, the callback should be invoked with\nnil."},
           "compiler-options/main" {:ns "compiler-options",
                                    :name "main",
                                    :name-encode "main",
                                    :type "option",
                                    :full-name-encode "compiler-options/main",
                                    :full-name "compiler-options/main",
                                    :history [["+" "0.0-971"]]},
           "closure-warnings/missing-require" {:ns "closure-warnings",
                                               :name "missing-require",
                                               :name-encode "missing-require",
                                               :type "warning",
                                               :full-name-encode "closure-warnings/missing-require",
                                               :full-name "closure-warnings/missing-require",
                                               :history [["+"
                                                          "1.9.473"]]},
           "cljs.core/IEditableCollection" {:ns "cljs.core",
                                            :name "IEditableCollection",
                                            :name-encode "IEditableCollection",
                                            :implementations #{"PersistentHashMap"
                                                               "ObjMap"
                                                               "PersistentVector"
                                                               "PersistentArrayMap"
                                                               "PersistentHashSet"},
                                            :history [["+" "0.0-1211"]],
                                            :type "protocol",
                                            :full-name-encode "cljs.core/IEditableCollection",
                                            :source {:code "(defprotocol IEditableCollection\n  (^clj -as-transient [coll]\n    \"Returns a new, transient version of the collection, in constant time.\"))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/cljs/cljs/core.cljs",
                                                     :lines [800 803]},
                                            :methods [{:name "-as-transient",
                                                       :signature ["[coll]"],
                                                       :docstring "Returns a new, transient version of the collection, in constant time."}],
                                            :full-name "cljs.core/IEditableCollection",
                                            :docstring "Protocol for collections which can transformed to transients."},
           "cljs.core/unchecked-char" {:return-type number,
                                       :ns "cljs.core",
                                       :name "unchecked-char",
                                       :signature ["[x]"],
                                       :name-encode "unchecked-char",
                                       :history [["+" "0.0-1798"]],
                                       :type "function/macro",
                                       :full-name-encode "cljs.core/unchecked-char",
                                       :source {:code "(defn ^number unchecked-char [x] x)",
                                                :title "Function code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/core.cljs",
                                                :lines [2800]},
                                       :extra-sources [{:code "(core/defmacro unchecked-char [x] x)",
                                                        :title "Macro code",
                                                        :repo "clojurescript",
                                                        :tag "r1.12.38",
                                                        :filename "src/main/clojure/cljs/core.cljc",
                                                        :lines [1072]}],
                                       :full-name "cljs.core/unchecked-char"},
           "cljs.core/keyword-identical?" {:ns "cljs.core",
                                           :name "keyword-identical?",
                                           :signature ["[x y]"],
                                           :name-encode "keyword-identicalQMARK",
                                           :history [["+" "0.0-1877"]],
                                           :type "function",
                                           :full-name-encode "cljs.core/keyword-identicalQMARK",
                                           :source {:code "(defn keyword-identical?\n  [x y]\n  (if (identical? x y)\n    true\n    (if (and (keyword? x) (keyword? y))\n      (identical? (.-fqn x) (.-fqn y))\n      false)))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/cljs/cljs/core.cljs",
                                                    :lines [3429 3436]},
                                           :full-name "cljs.core/keyword-identical?",
                                           :docstring "Efficient test to determine that two keywords are identical."},
           "clojure.browser.net/event-types" {:ns "clojure.browser.net",
                                              :name "event-types",
                                              :name-encode "event-types",
                                              :type "var",
                                              :full-name-encode "clojure.browser.net/event-types",
                                              :source {:code "(def event-types\n  (into {}\n        (map\n         (fn [[k v]]\n           [(keyword (.toLowerCase k))\n            v])\n         (merge\n          (js->clj EventType)))))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.12.38",
                                                       :filename "src/main/cljs/clojure/browser/net.cljs",
                                                       :lines [22 29]},
                                              :full-name "clojure.browser.net/event-types",
                                              :history [["+"
                                                         "0.0-927"]]},
           "clojure.string/lower-case" {:return-type string,
                                        :ns "clojure.string",
                                        :name "lower-case",
                                        :signature ["[s]"],
                                        :name-encode "lower-case",
                                        :history [["+" "0.0-927"]],
                                        :type "function",
                                        :full-name-encode "clojure.string/lower-case",
                                        :source {:code "(defn ^string lower-case\n  [s]\n  (.toLowerCase s))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/cljs/clojure/string.cljs",
                                                 :lines [124 127]},
                                        :full-name "clojure.string/lower-case",
                                        :docstring "Converts string to all lower-case."},
           "cljs.math/ceil" {:return-type number,
                             :ns "cljs.math",
                             :name "ceil",
                             :signature ["[a]"],
                             :name-encode "ceil",
                             :history [["+" "1.11.50"]],
                             :type "function",
                             :full-name-encode "cljs.math/ceil",
                             :source {:code "(defn ^number ceil\n  {:added \"1.11.10\"}\n  [a]\n  (if (some? a)\n    (Math/ceil a)\n    (throw (ex-info \"Unexpected Null passed to ceil\" {:fn \"ceil\"}))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/math.cljs",
                                      :lines [413 423]},
                             :full-name "cljs.math/ceil",
                             :docstring "Returns the smallest double greater than or equal to a, and equal to a\nmathematical integer.\nIf a is ##NaN or ##Inf or ##-Inf or already equal to an integer => a\nNote that if a is `nil` then an exception will be thrown. This matches Clojure, rather than js/Math.ceil\nSee: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/ceil"},
           "closure-warnings/violated-module-dep" {:ns "closure-warnings",
                                                   :name "violated-module-dep",
                                                   :name-encode "violated-module-dep",
                                                   :type "warning",
                                                   :full-name-encode "closure-warnings/violated-module-dep",
                                                   :full-name "closure-warnings/violated-module-dep",
                                                   :history [["+"
                                                              "1.9.473"]]},
           "repl-options/print-no-newline" {:ns "repl-options",
                                            :name "print-no-newline",
                                            :name-encode "print-no-newline",
                                            :type "option",
                                            :full-name-encode "repl-options/print-no-newline",
                                            :full-name "repl-options/print-no-newline",
                                            :history [["+" "0.0-2911"]]},
           "cljs.core/*print-fn*" {:ns "cljs.core",
                                   :name "*print-fn*",
                                   :name-encode "STARprint-fnSTAR",
                                   :history [["+" "0.0-927"]],
                                   :type "dynamic var",
                                   :full-name-encode "cljs.core/STARprint-fnSTAR",
                                   :source {:code "(defonce\n  ^{:dynamic true}\n  *print-fn* nil)",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [71 75]},
                                   :full-name "cljs.core/*print-fn*",
                                   :docstring "Each runtime environment provides a different way to print output.\nWhatever function *print-fn* is bound to will be passed any\nStrings which should be printed."},
           "cljs.core/str" {:ns "cljs.core",
                            :name "str",
                            :signature ["[]" "[x]" "[x & ys]"],
                            :name-encode "str",
                            :history [["+" "0.0-927"]],
                            :type "function/macro",
                            :full-name-encode "cljs.core/str",
                            :source {:code "(defn str\n  ([] \"\")\n  ([x] (if (nil? x)\n         \"\"\n         (.join #js [x] \"\")))\n  ([x & ys]\n    (loop [sb (StringBuffer. (str x)) more ys]\n      (if more\n        (recur (. sb  (append (str (first more)))) (next more))\n        (.toString sb)))))",
                                     :title "Function code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [3050 3062]},
                            :extra-sources [{:code "(core/defmacro str\n  ([] \"\")\n  ([x]\n   (if (typed-expr? &env x '#{string})\n     x\n     (string-expr (core/list 'js* \"cljs.core.str.cljs$core$IFn$_invoke$arity$1(~{})\" x))))\n  ([x & ys]\n   (core/let [interpolate (core/fn [x]\n                            (if (typed-expr? &env x '#{string clj-nil})\n                              \"~{}\"\n                              \"cljs.core.str.cljs$core$IFn$_invoke$arity$1(~{})\"))\n              strs        (core/->> (core/list* x ys)\n                            (map interpolate)\n                            (interpose \",\")\n                            (apply core/str))]\n     (string-expr (list* 'js* (core/str \"[\" strs \"].join('')\") x ys)))))",
                                             :title "Macro code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/clojure/cljs/core.cljc",
                                             :lines [852 867]}],
                            :full-name "cljs.core/str",
                            :docstring "With no args, returns the empty string. With one arg x, returns\nx.toString().  (str nil) returns the empty string. With more than\none arg, returns the concatenation of the str values of the args."},
           "cljs.core/ISequential" {:ns "cljs.core",
                                    :name "ISequential",
                                    :name-encode "ISequential",
                                    :implementations #{"Subvec"
                                                       "Cycle"
                                                       "PersistentQueue"
                                                       "PersistentArrayMapSeq"
                                                       "RedNode"
                                                       "EmptyList"
                                                       "Iterate"
                                                       "BlackNode"
                                                       "PersistentVector"
                                                       "ValSeq"
                                                       "IntegerRange"
                                                       "ChunkedCons"
                                                       "Range"
                                                       "PersistentQueueSeq"
                                                       "ChunkedSeq"
                                                       "ArrayNodeSeq"
                                                       "KeySeq"
                                                       "IndexedSeq"
                                                       "PersistentTreeMapSeq"
                                                       "RSeq"
                                                       "NodeSeq"
                                                       "List"
                                                       "Repeat"
                                                       "Cons"
                                                       "LazySeq"
                                                       "Eduction"
                                                       "MapEntry"},
                                    :history [["+" "0.0-927"]],
                                    :type "protocol",
                                    :full-name-encode "cljs.core/ISequential",
                                    :source {:code "(defprotocol ISequential)",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [738 739]},
                                    :full-name "cljs.core/ISequential",
                                    :docstring "Marker interface indicating a persistent collection of sequential items"},
           "cljs.core/try*" {:ns "cljs.core",
                             :name "try*",
                             :name-encode "trySTAR",
                             :history [["+" "0.0-927"]
                                       ["-" "0.0-1933"]],
                             :type "special form",
                             :full-name-encode "cljs.core/trySTAR",
                             :source {:code "(defmethod parse 'try*\n  [op env [_ & body :as form] name]\n  (let [body (vec body)\n        catchenv (update-in env [:context] #(if (= :expr %) :return %))\n        tail (peek body)\n        fblock (when (and (seq? tail) (= 'finally (first tail)))\n                  (rest tail))\n        finally (when fblock\n                  (analyze (assoc env :context :statement) `(do ~@fblock)))\n        body (if finally (pop body) body)\n        tail (peek body)\n        cblock (when (and (seq? tail)\n                          (= 'catch (first tail)))\n                 (rest tail))\n        name (first cblock)\n        locals (:locals catchenv)\n        locals (if name\n                 (assoc locals name\n                   {:name name\n                    :line (get-line name env)\n                    :column (get-col name env)})\n                 locals)\n        catch (when cblock\n                (analyze (assoc catchenv :locals locals) `(do ~@(rest cblock))))\n        body (if name (pop body) body)\n        try (analyze (if (or name finally) catchenv env) `(do ~@body))]\n    (when name (assert (not (namespace name)) \"Can't qualify symbol in catch\"))\n    {:env env :op :try* :form form\n     :try try\n     :finally finally\n     :name name\n     :catch catch\n     :children [try catch finally]}))",
                                      :title "Parser code",
                                      :repo "clojurescript",
                                      :tag "r1913",
                                      :filename "src/clj/cljs/analyzer.clj",
                                      :lines [280 312]},
                             :full-name "cljs.core/try*",
                             :removed {:in "0.0-1933",
                                       :last-seen "0.0-1913"}},
           "cljs.spec.impl.gen/symbol-ns" {:ns "cljs.spec.impl.gen",
                                           :name "symbol-ns",
                                           :signature ["[& args]"],
                                           :name-encode "symbol-ns",
                                           :history [["+" "1.9.14"]
                                                     ["-" "1.9.542"]],
                                           :type "function",
                                           :full-name-encode "cljs.spec.impl.gen/symbol-ns",
                                           :source {:code "(lazy-prims any any-printable boolean char char-alpha char-alphanumeric char-ascii double\n  int keyword keyword-ns large-integer ratio simple-type simple-type-printable\n  string string-ascii string-alphanumeric symbol symbol-ns uuid)",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.9.521",
                                                    :filename "src/main/cljs/cljs/spec/impl/gen.cljs",
                                                    :lines [73 75]},
                                           :full-name "cljs.spec.impl.gen/symbol-ns",
                                           :docstring "Fn returning clojure.test.check.generators/symbol-ns",
                                           :removed {:in "1.9.542",
                                                     :last-seen "1.9.521"}},
           "closure-warnings/inferred-const-checks" {:ns "closure-warnings",
                                                     :name "inferred-const-checks",
                                                     :name-encode "inferred-const-checks",
                                                     :type "warning",
                                                     :full-name-encode "closure-warnings/inferred-const-checks",
                                                     :full-name "closure-warnings/inferred-const-checks",
                                                     :history [["+"
                                                                "1.9.473"]
                                                               ["-"
                                                                "1.9.908"]],
                                                     :removed {:in "1.9.908",
                                                               :last-seen "1.9.854"}},
           "cljs.pprint/pprint-newline" {:ns "cljs.pprint",
                                         :name "pprint-newline",
                                         :signature ["[kind]"],
                                         :name-encode "pprint-newline",
                                         :history [["+" "0.0-3255"]],
                                         :type "function",
                                         :full-name-encode "cljs.pprint/pprint-newline",
                                         :source {:code "(defn pprint-newline\n  [kind]\n  (check-enumerated-arg kind #{:linear :miser :fill :mandatory})\n  (nl *out* kind))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/cljs/cljs/pprint.cljs",
                                                  :lines [844 853]},
                                         :full-name "cljs.pprint/pprint-newline",
                                         :docstring "Print a conditional newline to a pretty printing stream. kind specifies if the\nnewline is :linear, :miser, :fill, or :mandatory.\n\nThis function is intended for use when writing custom dispatch functions.\n\nOutput is sent to *out* which must be a pretty printing writer."},
           "cljs.spec.impl.gen/any-printable" {:ns "cljs.spec.impl.gen",
                                               :name "any-printable",
                                               :signature ["[& args]"],
                                               :name-encode "any-printable",
                                               :history [["+"
                                                          "1.9.14"]
                                                         ["-"
                                                          "1.9.542"]],
                                               :type "function",
                                               :full-name-encode "cljs.spec.impl.gen/any-printable",
                                               :source {:code "(lazy-prims any any-printable boolean char char-alpha char-alphanumeric char-ascii double\n  int keyword keyword-ns large-integer ratio simple-type simple-type-printable\n  string string-ascii string-alphanumeric symbol symbol-ns uuid)",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.9.521",
                                                        :filename "src/main/cljs/cljs/spec/impl/gen.cljs",
                                                        :lines [73 75]},
                                               :full-name "cljs.spec.impl.gen/any-printable",
                                               :docstring "Fn returning clojure.test.check.generators/any-printable",
                                               :removed {:in "1.9.542",
                                                         :last-seen "1.9.521"}},
           "closure-warnings/non-standard-jsdoc" {:ns "closure-warnings",
                                                  :name "non-standard-jsdoc",
                                                  :name-encode "non-standard-jsdoc",
                                                  :type "warning",
                                                  :full-name-encode "closure-warnings/non-standard-jsdoc",
                                                  :full-name "closure-warnings/non-standard-jsdoc",
                                                  :history [["+"
                                                             "0.0-2120"]]},
           "cljs.core/key-test" {:ns "cljs.core",
                                 :name "key-test",
                                 :signature ["[key other]"],
                                 :name-encode "key-test",
                                 :history [["+" "0.0-1424"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/key-test",
                                 :source {:code "(defn key-test [key other]\n  (cond\n    (identical? key other) true\n    (keyword-identical? key other) true\n    :else (= key other)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [7183 7187]},
                                 :full-name "cljs.core/key-test"},
           "cljs.core/set" {:ns "cljs.core",
                            :name "set",
                            :signature ["[coll]"],
                            :name-encode "set",
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core/set",
                            :source {:code "(defn set\n  [coll]\n  (if (set? coll)\n    (with-meta coll nil)\n    (let [in (seq coll)]\n      (cond\n        (nil? in) #{}\n\n        (and (instance? IndexedSeq in) (zero? (.-i in)))\n        (.createAsIfByAssoc PersistentHashSet (.-arr in))\n\n        :else\n        (loop [^not-native in  in\n               ^not-native out (-as-transient #{})]\n          (if-not (nil? in)\n            (recur (next in) (-conj! out (-first in)))\n            (persistent! out)))))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [9651 9668]},
                            :full-name "cljs.core/set",
                            :docstring "Returns a set of the distinct elements of coll."},
           "cljs.analyzer.api/default-warning-handler" {:ns "cljs.analyzer.api",
                                                        :name "default-warning-handler",
                                                        :signature ["[warning-type env extra]"],
                                                        :name-encode "default-warning-handler",
                                                        :history [["+"
                                                                   "1.7.10"]],
                                                        :type "function",
                                                        :full-name-encode "cljs.analyzer.api/default-warning-handler",
                                                        :source {:code "(defn default-warning-handler\n  [warning-type env extra]\n  (ana/default-warning-handler warning-type env extra))",
                                                                 :title "Source code",
                                                                 :repo "clojurescript",
                                                                 :tag "r1.12.38",
                                                                 :filename "src/main/clojure/cljs/analyzer/api.cljc",
                                                                 :lines [74
                                                                         79]},
                                                        :full-name "cljs.analyzer.api/default-warning-handler",
                                                        :docstring "The default warning handler.\n\nOutputs the warning messages to *err*."},
           "cljs.spec.alpha/+" {:ns "cljs.spec.alpha",
                                :name "+",
                                :signature ["[pred-form]"],
                                :name-encode "PLUS",
                                :history [["+" "1.9.542"]],
                                :type "macro",
                                :full-name-encode "cljs.spec.alpha/PLUS",
                                :source {:code "(defmacro +\n  [pred-form]\n  `(rep+impl '~(res &env pred-form) ~pred-form))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/spec/alpha.cljc",
                                         :lines [327 331]},
                                :full-name "cljs.spec.alpha/+",
                                :docstring "Returns a regex op that matches one or more values matching\npred. Produces a vector of matches"},
           "cljs.repl.nashorn/load-js-file" {:ns "cljs.repl.nashorn",
                                             :name "load-js-file",
                                             :signature ["[engine file]"],
                                             :name-encode "load-js-file",
                                             :history [["+"
                                                        "0.0-2814"]
                                                       ["-"
                                                        "1.10.738"]],
                                             :type "function",
                                             :full-name-encode "cljs.repl.nashorn/load-js-file",
                                             :source {:code "(defn load-js-file [engine file]\n      (eval-str engine (format \"nashorn_load(\\\"%s\\\");\" file)))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.10.597",
                                                      :filename "src/main/clojure/cljs/repl/nashorn.clj",
                                                      :lines [69 70]},
                                             :full-name "cljs.repl.nashorn/load-js-file",
                                             :removed {:in "1.10.738",
                                                       :last-seen "1.10.597"}},
           "cljs.core/obj-map" {:ns "cljs.core",
                                :name "obj-map",
                                :signature ["[& keyvals]"],
                                :name-encode "obj-map",
                                :history [["+" "0.0-1443"]],
                                :type "function",
                                :full-name-encode "cljs.core/obj-map",
                                :source {:code "(defn obj-map\n  [& keyvals]\n  (let [ks  (array)\n        obj (js-obj)]\n    (loop [kvs (seq keyvals)]\n      (if kvs\n        (do (.push ks (first kvs))\n            (gobject/set obj (first kvs) (second kvs))\n            (recur (nnext kvs)))\n        (.fromObject ObjMap ks obj)))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [9145 9156]},
                                :full-name "cljs.core/obj-map",
                                :docstring "keyval => key val\nReturns a new object map with supplied mappings."},
           "clojure.browser.repl/load-queue" {:ns "clojure.browser.repl",
                                              :name "load-queue",
                                              :name-encode "load-queue",
                                              :type "var",
                                              :full-name-encode "clojure.browser.repl/load-queue",
                                              :source {:code "(def load-queue nil)",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.12.38",
                                                       :filename "src/main/cljs/clojure/browser/repl.cljs",
                                                       :lines [160]},
                                              :full-name "clojure.browser.repl/load-queue",
                                              :history [["+"
                                                         "0.0-3115"]]},
           "cljs.core/print" {:ns "cljs.core",
                              :name "print",
                              :name-encode "print",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/print",
                              :source {:code "(def print\n  (fn cljs-core-print [& objs]\n    (pr-with-opts objs (assoc (pr-opts) :readably false))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [10662 10667]},
                              :full-name "cljs.core/print",
                              :docstring "Prints the object(s) using string-print.\nprint and println produce output for human consumption."},
           "cljs.core/ArrayNode" {:protocols #{"IIterable"},
                                  :ns "cljs.core",
                                  :name "ArrayNode",
                                  :signature ["[edit cnt arr]"],
                                  :name-encode "ArrayNode",
                                  :history [["+" "0.0-1211"]],
                                  :type "type",
                                  :full-name-encode "cljs.core/ArrayNode",
                                  :source {:code "(deftype ArrayNode [edit ^:mutable cnt ^:mutable arr]\n  Object\n  (inode-assoc [inode shift hash key val added-leaf?]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if (nil? node)\n        (ArrayNode. nil (inc cnt) (clone-and-set arr idx (.inode-assoc (.-EMPTY BitmapIndexedNode) (+ shift 5) hash key val added-leaf?)))\n        (let [n (.inode-assoc node (+ shift 5) hash key val added-leaf?)]\n          (if (identical? n node)\n            inode\n            (ArrayNode. nil cnt (clone-and-set arr idx n)))))))\n\n  (inode-without [inode shift hash key]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if-not (nil? node)\n        (let [n (.inode-without node (+ shift 5) hash key)]\n          (cond\n            (identical? n node)\n            inode\n\n            (nil? n)\n            (if (<= cnt 8)\n              (pack-array-node inode nil idx)\n              (ArrayNode. nil (dec cnt) (clone-and-set arr idx n)))\n\n            :else\n            (ArrayNode. nil cnt (clone-and-set arr idx n))))\n        inode)))\n\n  (inode-lookup [inode shift hash key not-found]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if-not (nil? node)\n        (.inode-lookup node (+ shift 5) hash key not-found)\n        not-found)))\n\n  (inode-find [inode shift hash key not-found]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if-not (nil? node)\n        (.inode-find node (+ shift 5) hash key not-found)\n        not-found)))\n\n  (inode-seq [inode]\n    (create-array-node-seq arr))\n\n  (ensure-editable [inode e]\n    (if (identical? e edit)\n      inode\n      (ArrayNode. e cnt (aclone arr))))\n\n  (inode-assoc! [inode edit shift hash key val added-leaf?]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if (nil? node)\n        (let [editable (edit-and-set inode edit idx (.inode-assoc! (.-EMPTY BitmapIndexedNode) edit (+ shift 5) hash key val added-leaf?))]\n          (set! (.-cnt editable) (inc (.-cnt editable)))\n          editable)\n        (let [n (.inode-assoc! node edit (+ shift 5) hash key val added-leaf?)]\n          (if (identical? n node)\n            inode\n            (edit-and-set inode edit idx n))))))\n\n  (inode-without! [inode edit shift hash key removed-leaf?]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if (nil? node)\n        inode\n        (let [n (.inode-without! node edit (+ shift 5) hash key removed-leaf?)]\n          (cond\n            (identical? n node)\n            inode\n\n            (nil? n)\n            (if (<= cnt 8)\n              (pack-array-node inode edit idx)\n              (let [editable (edit-and-set inode edit idx n)]\n                (set! (.-cnt editable) (dec (.-cnt editable)))\n                editable))\n\n            :else\n            (edit-and-set inode edit idx n))))))\n\n  (kv-reduce [inode f init]\n    (let [len (alength arr)]           ; actually 32\n      (loop [i 0 init init]\n        (if (< i len)\n          (let [node (aget arr i)]\n            (if-not (nil? node)\n              (let [init (.kv-reduce node f init)]\n                (if (reduced? init)\n                  init\n                  (recur (inc i) init)))\n              (recur (inc i) init)))\n          init))))\n\n IIterable\n (-iterator [coll]\n    (ArrayNodeIterator. arr 0 nil)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [7696 7795]},
                                  :full-name "cljs.core/ArrayNode"},
           "cljs.core/type" {:ns "cljs.core",
                             :name "type",
                             :signature ["[x]"],
                             :name-encode "type",
                             :history [["+" "0.0-971"]],
                             :type "function",
                             :full-name-encode "cljs.core/type",
                             :source {:code "(defn type\n  [x]\n  (when-not (nil? x)\n    (.-constructor x)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [317 321]},
                             :full-name "cljs.core/type",
                             :docstring "Return x's constructor."},
           "clojure.string/blank?" {:return-type boolean,
                                    :ns "clojure.string",
                                    :name "blank?",
                                    :signature ["[s]"],
                                    :name-encode "blankQMARK",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "clojure.string/blankQMARK",
                                    :source {:code "(defn ^boolean blank?\n  [s]\n  (gstring/isEmptyOrWhitespace (gstring/makeSafe s)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/clojure/string.cljs",
                                             :lines [225 228]},
                                    :full-name "clojure.string/blank?",
                                    :docstring "True if s is nil, empty, or contains only whitespace."},
           "cljs.spec/abbrev" {:ns "cljs.spec",
                               :name "abbrev",
                               :signature ["[form]"],
                               :name-encode "abbrev",
                               :history [["+" "1.9.14"]
                                         ["-" "1.9.542"]],
                               :type "function",
                               :full-name-encode "cljs.spec/abbrev",
                               :source {:code "(defn abbrev [form]\n  (cond\n    (seq? form)\n    (walk/postwalk (fn [form]\n                     (cond\n                       (c/and (symbol? form) (namespace form))\n                       (-> form name symbol)\n\n                       (c/and (seq? form) (= 'fn (first form)) (= '[%] (second form)))\n                       (last form)\n\n                       :else form))\n                   form)\n\n    (c/and (symbol? form) (namespace form))\n    (-> form name symbol)\n\n    :else form))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.9.521",
                                        :filename "src/main/cljs/cljs/spec.cljs",
                                        :lines [168 185]},
                               :full-name "cljs.spec/abbrev",
                               :removed {:in "1.9.542",
                                         :last-seen "1.9.521"}},
           "syntax/keyword" {:syntax-equiv {:edn-url nil,
                                            :clj-url nil},
                             :ns "syntax",
                             :name "keyword",
                             :name-encode "keyword",
                             :history [["+" "0.0-1853"]],
                             :type "syntax",
                             :full-name-encode "syntax/keyword",
                             :extra-sources ({:code "(defn- read-keyword\n  [reader initch opts pending-forms]\n  (let [ch (read-char reader)]\n    (if-not (whitespace? ch)\n      (let [token (read-token reader :keyword ch)\n            s (parse-symbol token)]\n        (if s\n          (let [^String ns (s 0)\n                ^String name (s 1)]\n            (if (identical? \\: (nth token 0))\n              (if ns\n                (let [ns (resolve-alias (symbol (subs ns 1)))]\n                  (if ns\n                    (keyword (str ns) name)\n                    (err/throw-invalid reader :keyword (str \\: token))))\n                (keyword (str *ns*) (subs name 1)))\n              (keyword ns name)))\n          (err/throw-invalid reader :keyword (str \\: token))))\n      (err/throw-single-colon reader))))",
                                              :title "Reader code",
                                              :repo "tools.reader",
                                              :tag "v1.3.6",
                                              :filename "src/main/clojure/clojure/tools/reader.clj",
                                              :lines [344 362]}
                                             {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                              :title "Reader table",
                                              :repo "tools.reader",
                                              :tag "v1.3.6",
                                              :filename "src/main/clojure/clojure/tools/reader.clj",
                                              :lines [788 807]}),
                             :full-name "syntax/keyword"},
           "cljs.reader/maybe-read-tagged-type" {:ns "cljs.reader",
                                                 :name "maybe-read-tagged-type",
                                                 :signature ["[rdr initch]"],
                                                 :name-encode "maybe-read-tagged-type",
                                                 :history [["+"
                                                            "0.0-1236"]
                                                           ["-"
                                                            "1.9.854"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.reader/maybe-read-tagged-type",
                                                 :source {:code "(defn maybe-read-tagged-type\n  [rdr initch]\n  (let [tag (read-symbol rdr initch)\n        pfn (get @*tag-table* (str tag))\n        dfn @*default-data-reader-fn*]\n    (cond\n     pfn (pfn (read rdr true nil false))\n     dfn (dfn tag (read rdr true nil false))\n     :else (reader-error rdr\n                         \"Could not find tag parser for \" (str tag)\n                         \" in \" (pr-str (keys @*tag-table*))))))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r1.9.671",
                                                          :filename "src/main/cljs/cljs/reader.cljs",
                                                          :lines [608
                                                                  618]},
                                                 :full-name "cljs.reader/maybe-read-tagged-type",
                                                 :removed {:in "1.9.854",
                                                           :last-seen "1.9.671"}},
           "cljs.core/js-inline-comment" {:ns "cljs.core",
                                          :name "js-inline-comment",
                                          :signature ["[comment]"],
                                          :name-encode "js-inline-comment",
                                          :history [["+" "1.7.107"]],
                                          :type "macro",
                                          :full-name-encode "cljs.core/js-inline-comment",
                                          :source {:code "(core/defmacro js-inline-comment\n  [comment]\n  (core/list 'js* (core/str \"/**\" comment \"*/\")))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/clojure/cljs/core.cljc",
                                                   :lines [959 962]},
                                          :full-name "cljs.core/js-inline-comment",
                                          :docstring "Emit an inline JavaScript comment."},
           "cljs.core/IChunkedSeq" {:ns "cljs.core",
                                    :name "IChunkedSeq",
                                    :name-encode "IChunkedSeq",
                                    :implementations #{"IntegerRange"
                                                       "ChunkedCons"
                                                       "Range"
                                                       "ChunkedSeq"},
                                    :history [["+" "0.0-1424"]],
                                    :type "protocol",
                                    :full-name-encode "cljs.core/IChunkedSeq",
                                    :source {:code "(defprotocol IChunkedSeq\n  (-chunked-first [coll]\n    \"Returns the first chunk in coll.\")\n  (-chunked-rest [coll]\n    \"Return a new collection of coll with the first chunk removed.\"))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [846 851]},
                                    :methods [{:name "-chunked-first",
                                               :signature ["[coll]"],
                                               :docstring "Returns the first chunk in coll."}
                                              {:name "-chunked-rest",
                                               :signature ["[coll]"],
                                               :docstring "Return a new collection of coll with the first chunk removed."}],
                                    :full-name "cljs.core/IChunkedSeq",
                                    :docstring "Protocol for accessing a collection as sequential chunks."},
           "clojure.browser.dom/append" {:ns "clojure.browser.dom",
                                         :name "append",
                                         :signature ["[parent & children]"],
                                         :name-encode "append",
                                         :history [["+" "0.0-927"]],
                                         :type "function",
                                         :full-name-encode "clojure.browser.dom/append",
                                         :source {:code "(defn append [parent & children]\n  (apply gdom/append parent children)\n  parent)",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/cljs/clojure/browser/dom.cljs",
                                                  :lines [13 15]},
                                         :full-name "clojure.browser.dom/append"},
           "cljs.core/take-last" {:ns "cljs.core",
                                  :name "take-last",
                                  :signature ["[n coll]"],
                                  :name-encode "take-last",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/take-last",
                                  :source {:code "(defn take-last\n  [n coll]\n  (loop [s (seq coll), lead (seq (drop n coll))]\n    (if lead\n      (recur (next s) (next lead))\n      s)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [4918 4925]},
                                  :full-name "cljs.core/take-last",
                                  :docstring "Returns a seq of the last n items in coll.  Depending on the type\nof coll may be no better than linear time.  For vectors, see also subvec."},
           "cljs.core/js-symbol?" {:ns "cljs.core",
                                   :name "js-symbol?",
                                   :signature ["[x]"],
                                   :name-encode "js-symbolQMARK",
                                   :history [["+" "1.10.738"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/js-symbolQMARK",
                                   :source {:code "(defn js-symbol?\n  [x]\n  (or (identical? (goog/typeOf x) \"symbol\")\n      (and (exists? js/Symbol)\n           (instance? js/Symbol x))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [544 549]},
                                   :full-name "cljs.core/js-symbol?",
                                   :docstring "Returns true if x is an instance of Symbol"},
           "cljs.spec.gen.alpha/list" {:ns "cljs.spec.gen.alpha",
                                       :name "list",
                                       :signature ["[& args]"],
                                       :name-encode "list",
                                       :history [["+" "1.9.542"]],
                                       :type "function",
                                       :full-name-encode "cljs.spec.gen.alpha/list",
                                       :source {:code "(lazy-combinators hash-map list map not-empty set vector vector-distinct fmap elements\n  bind choose one-of such-that tuple sample return\n  large-integer* double* frequency shuffle)",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/spec/gen/alpha.cljs",
                                                :lines [70 72]},
                                       :full-name "cljs.spec.gen.alpha/list",
                                       :docstring "Lazy loaded version of clojure.test.check.generators/list"},
           "closure-warnings/strict-missing-properties" {:ns "closure-warnings",
                                                         :name "strict-missing-properties",
                                                         :name-encode "strict-missing-properties",
                                                         :type "warning",
                                                         :full-name-encode "closure-warnings/strict-missing-properties",
                                                         :full-name "closure-warnings/strict-missing-properties",
                                                         :history [["+"
                                                                    "1.10.217"]]},
           "clojure.edn/read" {:ns "clojure.edn",
                               :name "read",
                               :signature ["[reader]"
                                           "[opts reader]"
                                           "[reader eof-error? eof opts]"],
                               :name-encode "read",
                               :history [["+" "1.10.514"]],
                               :type "function",
                               :full-name-encode "clojure.edn/read",
                               :source {:code "(defn read\n  ([reader]\n   (reader/read reader))\n  ([opts reader]\n   (reader/read opts reader))\n  ([reader eof-error? eof opts]\n   (reader/read reader eof-error? eof opts)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/clojure/edn.cljs",
                                        :lines [20 42]},
                               :full-name "clojure.edn/read",
                               :docstring "Reads the first object from an cljs.tools.reader.reader-types/IPushbackReader.\nReturns the object read. If EOF, throws if eof-error? is true otherwise returns eof.\nIf no reader is provided, *in* will be used.\n\nReads data in the edn format (subset of Clojure data):\nhttp://edn-format.org\n\ncljs.tools.reader.edn/read doesn't depend on dynamic Vars, all configuration\nis done by passing an opt map.\n\nopts is a map that can include the following keys:\n:eof - value to return on end-of-file. When not supplied, eof throws an exception.\n:readers  - a map of tag symbols to data-reader functions to be considered before default-data-readers.\n           When not supplied, only the default-data-readers will be used.\n:default - A function of two args, that will, if present and no reader is found for a tag,\n           be called with the tag and the value."},
           "cljs.spec.gen.alpha/gen-for-pred" {:ns "cljs.spec.gen.alpha",
                                               :name "gen-for-pred",
                                               :signature ["[pred]"],
                                               :name-encode "gen-for-pred",
                                               :history [["+"
                                                          "1.9.542"]],
                                               :type "function",
                                               :full-name-encode "cljs.spec.gen.alpha/gen-for-pred",
                                               :source {:code "(defn gen-for-pred\n  [pred]\n  (if (set? pred)\n    (elements pred)\n    (get @gen-builtins pred)))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.12.38",
                                                        :filename "src/main/cljs/cljs/spec/gen/alpha.cljs",
                                                        :lines [144
                                                                149]},
                                               :full-name "cljs.spec.gen.alpha/gen-for-pred",
                                               :docstring "Given a predicate, returns a built-in generator if one exists."},
           "cljs.core/key->js" {:ns "cljs.core",
                                :name "key->js",
                                :signature ["[k]" "[k primitive-fn]"],
                                :name-encode "key-GTjs",
                                :history [["+" "0.0-1798"]],
                                :type "function",
                                :full-name-encode "cljs.core/key-GTjs",
                                :source {:code "(defn key->js\n  ([k] (key->js k clj->js))\n  ([k primitive-fn]\n   (cond\n     (satisfies? IEncodeJS k) (-clj->js k)\n     (or (string? k)\n         (number? k)\n         (keyword? k)\n         (symbol? k)) (primitive-fn k)\n     :default (pr-str k))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [11163 11172]},
                                :full-name "cljs.core/key->js"},
           "cljs.spec/explain-printer" {:ns "cljs.spec",
                                        :name "explain-printer",
                                        :signature ["[ed]"],
                                        :name-encode "explain-printer",
                                        :history [["+" "1.9.293"]
                                                  ["-" "1.9.542"]],
                                        :type "function",
                                        :full-name-encode "cljs.spec/explain-printer",
                                        :source {:code "(defn explain-printer\n  [ed]\n  (if ed\n    (print\n      (with-out-str\n        ;;(prn {:ed ed})\n        (doseq [{:keys [path pred val reason via in] :as prob} (::problems ed)]\n          (when-not (empty? in)\n            (print \"In:\" (pr-str in) \"\"))\n          (print \"val: \")\n          (pr val)\n          (print \" fails\")\n          (when-not (empty? via)\n            (print \" spec:\" (pr-str (last via))))\n          (when-not (empty? path)\n            (print \" at:\" (pr-str path)))\n          (print \" predicate: \")\n          (pr (abbrev pred))\n          (when reason (print \", \" reason))\n          (doseq [[k v] prob]\n            (when-not (#{:path :pred :val :reason :via :in} k)\n              (print \"\\n\\t\" (pr-str k) \" \")\n              (pr v)))\n          (newline))\n        (doseq [[k v] ed]\n          (when-not (#{::problems} k)\n            (print (pr-str k) \" \")\n            (pr v)\n            (newline)))))\n    (println \"Success!\")))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.9.521",
                                                 :filename "src/main/cljs/cljs/spec.cljs",
                                                 :lines [214 244]},
                                        :full-name "cljs.spec/explain-printer",
                                        :docstring "Default printer for explain-data. nil indicates a successful validation.",
                                        :removed {:in "1.9.542",
                                                  :last-seen "1.9.521"}},
           "cljs.repl.browser/setup" {:ns "cljs.repl.browser",
                                      :name "setup",
                                      :signature ["[{:keys [working-dir launch-browser server-state], :as repl-env} {:keys [output-dir], :as opts}]"],
                                      :name-encode "setup",
                                      :history [["+" "0.0-2665"]],
                                      :type "function",
                                      :full-name-encode "cljs.repl.browser/setup",
                                      :source {:code "(defn setup [{:keys [working-dir launch-browser server-state] :as repl-env} {:keys [output-dir] :as opts}]\n  (locking lock\n    (when-not (:socket @server-state)\n      (binding [browser-state (:browser-state repl-env)\n                ordering (:ordering repl-env)\n                es (:es repl-env)\n                server/state (:server-state repl-env)]\n        (swap! browser-state\n          (fn [old]\n            (assoc old :client-js\n              (cljsc/create-client-js-file\n                {:optimizations :simple\n                 :output-dir working-dir}\n                (io/file working-dir \"brepl_client.js\"))\n              :closure-defines (:closure-defines opts))))\n        ;; TODO: this could be cleaner if compiling forms resulted in a\n        ;; :output-to file with the result of compiling those forms - David\n        (when (and output-dir (not (.exists (io/file output-dir \"clojure\" \"browser\" \"repl\" \"preload.js\"))))\n          (let [target (io/file output-dir \"brepl_deps.js\")]\n            (util/mkdirs target)\n            (spit target\n              (build/build\n                '[(require '[clojure.browser.repl.preload])]\n                (merge (dissoc (select-keys opts cljsc/known-opts) :modules)\n                  {:opts-cache \"brepl_opts.edn\"})))))\n        (server/start repl-env)\n        (let [base-url (str \"http://\" (:host repl-env) \":\" (:port repl-env))]\n          (if launch-browser\n            (maybe-browse-url base-url)\n            (println (waiting-to-connect-message base-url)))))))\n  (.put outs (thread-name) *out*)\n  (swap! server-state update :listeners inc))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/clojure/cljs/repl/browser.clj",
                                               :lines [366 397]},
                                      :full-name "cljs.repl.browser/setup"},
           "cljs.core/TransientHashMap" {:protocols #{"IFn"
                                                      "ITransientCollection"
                                                      "ICounted"
                                                      "ILookup"
                                                      "ITransientAssociative"
                                                      "ITransientMap"},
                                         :ns "cljs.core",
                                         :name "TransientHashMap",
                                         :signature ["[edit root count has-nil? nil-val]"],
                                         :name-encode "TransientHashMap",
                                         :history [["+" "0.0-1211"]],
                                         :type "type",
                                         :full-name-encode "cljs.core/TransientHashMap",
                                         :source {:code "(deftype TransientHashMap [^:mutable ^boolean edit\n                           ^:mutable root\n                           ^:mutable count\n                           ^:mutable ^boolean has-nil?\n                           ^:mutable nil-val]\n  Object\n  (conj! [tcoll o]\n    (if edit\n      (cond\n        (map-entry? o)\n        (.assoc! tcoll (key o) (val o))\n\n        (vector? o)\n        (.assoc! tcoll (o 0) (o 1))\n\n        :else\n        (loop [es (seq o) tcoll tcoll]\n          (if-let [e (first es)]\n            (recur (next es)\n                   (.assoc! tcoll (key e) (val e)))\n            tcoll)))\n      (throw (js/Error. \"conj! after persistent\"))))\n\n  (assoc! [tcoll k v]\n    (if edit\n      (if (nil? k)\n        (do (if (identical? nil-val v)\n              nil\n              (set! nil-val v))\n            (if has-nil?\n              nil\n              (do (set! count (inc count))\n                  (set! has-nil? true)))\n            tcoll)\n        (let [added-leaf? (Box. false)\n              node        (-> (if (nil? root)\n                                (.-EMPTY BitmapIndexedNode)\n                                root)\n                              (.inode-assoc! edit 0 (hash k) k v added-leaf?))]\n          (if (identical? node root)\n            nil\n            (set! root node))\n          (if ^boolean (.-val added-leaf?)\n            (set! count (inc count)))\n          tcoll))\n      (throw (js/Error. \"assoc! after persistent!\"))))\n\n  (without! [tcoll k]\n    (if edit\n      (if (nil? k)\n        (if has-nil?\n          (do (set! has-nil? false)\n              (set! nil-val nil)\n              (set! count (dec count))\n              tcoll)\n          tcoll)\n        (if (nil? root)\n          tcoll\n          (let [removed-leaf? (Box. false)\n                node (.inode-without! root edit 0 (hash k) k removed-leaf?)]\n            (if (identical? node root)\n              nil\n              (set! root node))\n            (if ^boolean (.-val removed-leaf?)\n              (set! count (dec count)))\n            tcoll)))\n      (throw (js/Error. \"dissoc! after persistent!\"))))\n\n  (persistent! [tcoll]\n    (if edit\n      (do (set! edit nil)\n          (PersistentHashMap. nil count root has-nil? nil-val nil))\n      (throw (js/Error. \"persistent! called twice\"))))\n\n  ICounted\n  (-count [coll]\n    (if edit\n      count\n      (throw (js/Error. \"count after persistent!\"))))\n\n  ILookup\n  (-lookup [tcoll k]\n    (if (nil? k)\n      (if has-nil?\n        nil-val)\n      (if (nil? root)\n        nil\n        (.inode-lookup root 0 (hash k) k))))\n\n  (-lookup [tcoll k not-found]\n    (if (nil? k)\n      (if has-nil?\n        nil-val\n        not-found)\n      (if (nil? root)\n        not-found\n        (.inode-lookup root 0 (hash k) k not-found))))\n\n  ITransientCollection\n  (-conj! [tcoll val] (.conj! tcoll val))\n\n  (-persistent! [tcoll] (.persistent! tcoll))\n\n  ITransientAssociative\n  (-assoc! [tcoll key val] (.assoc! tcoll key val))\n\n  ITransientMap\n  (-dissoc! [tcoll key] (.without! tcoll key))\n\n  IFn\n  (-invoke [tcoll key]\n    (-lookup tcoll key))\n  (-invoke [tcoll key not-found]\n    (-lookup tcoll key not-found)))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/cljs/cljs/core.cljs",
                                                  :lines [8265 8378]},
                                         :full-name "cljs.core/TransientHashMap"},
           "clojure.set/intersection" {:ns "clojure.set",
                                       :name "intersection",
                                       :signature ["[s1]"
                                                   "[s1 s2]"
                                                   "[s1 s2 & sets]"],
                                       :name-encode "intersection",
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "clojure.set/intersection",
                                       :source {:code "(defn intersection\n  ([s1] s1)\n  ([s1 s2]\n     (if (< (count s2) (count s1))\n       (recur s2 s1)\n       (reduce (fn [result item]\n                   (if (contains? s2 item)\n\t\t     result\n                     (disj result item)))\n\t       s1 s1)))\n  ([s1 s2 & sets] \n     (let [bubbled-sets (bubble-max-key #(- (count %)) (conj sets s2 s1))]\n       (reduce intersection (first bubbled-sets) (rest bubbled-sets)))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/clojure/set.cljs",
                                                :lines [31 44]},
                                       :full-name "clojure.set/intersection",
                                       :docstring "Return a set that is the intersection of the input sets"},
           "cljs.core/Single" {:ns "cljs.core",
                               :name "Single",
                               :signature ["[val]"],
                               :name-encode "Single",
                               :history [["+" "1.9.562"]],
                               :type "type",
                               :full-name-encode "cljs.core/Single",
                               :source {:code "(deftype Single [^:mutable val]\n  Object\n  (add [this o]\n    (if (identical? val NONE)\n      (do\n        (set! val o)\n        this)\n      (Many. #js [val o])))\n  (remove [this]\n    (if (identical? val NONE)\n      (throw (js/Error. (str \"Removing object from empty buffer\")))\n      (let [ret val]\n        (set! val NONE)\n        ret)))\n  (isEmpty [this]\n    (identical? val NONE))\n  (toString [this]\n    (str \"Single: \" val)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [4182 4199]},
                               :full-name "cljs.core/Single"},
           "warnings/invalid-arithmetic" {:ns "warnings",
                                          :name "invalid-arithmetic",
                                          :name-encode "invalid-arithmetic",
                                          :type "warning",
                                          :full-name-encode "warnings/invalid-arithmetic",
                                          :full-name "warnings/invalid-arithmetic",
                                          :history [["+" "0.0-2067"]]},
           "cljs.js/atom?" {:ns "cljs.js",
                            :name "atom?",
                            :signature ["[x]"],
                            :name-encode "atomQMARK",
                            :history [["+" "1.7.10"] ["-" "1.7.48"]],
                            :type "function",
                            :full-name-encode "cljs.js/atomQMARK",
                            :source {:code "(defn atom? [x]\n  (instance? Atom x))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.7.28",
                                     :filename "src/main/cljs/cljs/js.cljs",
                                     :lines [41 42]},
                            :full-name "cljs.js/atom?",
                            :removed {:in "1.7.48",
                                      :last-seen "1.7.28"}},
           "cljs.test/async?" {:ns "cljs.test",
                               :name "async?",
                               :signature ["[x]"],
                               :name-encode "asyncQMARK",
                               :history [["+" "0.0-2814"]],
                               :type "function",
                               :full-name-encode "cljs.test/asyncQMARK",
                               :source {:code "(defn async?\n  [x]\n  (satisfies? IAsyncTest x))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/test.cljs",
                                        :lines [434 437]},
                               :full-name "cljs.test/async?",
                               :docstring "Returns whether x implements IAsyncTest."},
           "cljs.core/fnext" {:ns "cljs.core",
                              :name "fnext",
                              :signature ["[coll]"],
                              :name-encode "fnext",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/fnext",
                              :source {:code "(defn fnext\n  [coll]\n  (first (next coll)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [1810 1813]},
                              :full-name "cljs.core/fnext",
                              :docstring "Same as (first (next x))"},
           "cljs.core/apply" {:ns "cljs.core",
                              :name "apply",
                              :signature ["[f args]"
                                          "[f x args]"
                                          "[f x y args]"
                                          "[f x y z args]"
                                          "[f a b c d & args]"],
                              :name-encode "apply",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/apply",
                              :source {:code "(defn apply\n  ([f args]\n   (if (.-cljs$lang$applyTo f)\n     (let [fixed-arity (.-cljs$lang$maxFixedArity f)\n           bc (bounded-count (inc fixed-arity) args)]\n       (if (<= bc fixed-arity)\n         (apply-to f bc args)\n         (.cljs$lang$applyTo f args)))\n     (apply-to-simple f (seq args))))\n  ([f x args]\n   (if (.-cljs$lang$applyTo f)\n     (let [arglist (list* x args)\n           fixed-arity (.-cljs$lang$maxFixedArity f)\n           bc (inc (bounded-count fixed-arity args))]\n       (if (<= bc fixed-arity)\n         (apply-to f bc arglist)\n         (.cljs$lang$applyTo f arglist)))\n     (apply-to-simple f x (seq args))))\n  ([f x y args]\n   (if (.-cljs$lang$applyTo f)\n     (let [arglist (list* x y args)\n           fixed-arity (.-cljs$lang$maxFixedArity f)\n           bc (+ 2 (bounded-count (dec fixed-arity) args))]\n       (if (<= bc fixed-arity)\n         (apply-to f bc arglist)\n         (.cljs$lang$applyTo f arglist)))\n     (apply-to-simple f x y (seq args))))\n  ([f x y z args]\n   (if (.-cljs$lang$applyTo f)\n     (let [arglist (list* x y z args)\n           fixed-arity (.-cljs$lang$maxFixedArity f)\n           bc (+ 3 (bounded-count (- fixed-arity 2) args))]\n       (if (<= bc fixed-arity)\n         (apply-to f bc arglist)\n         (.cljs$lang$applyTo f arglist)))\n     (apply-to-simple f x y z (seq args))))\n  ([f a b c d & args]\n   (if (.-cljs$lang$applyTo f)\n     (let [spread-args (spread args)\n           arglist (cons a (cons b (cons c (cons d spread-args))))\n           fixed-arity (.-cljs$lang$maxFixedArity f)\n           bc (+ 4 (bounded-count (- fixed-arity 3) spread-args))]\n       (if (<= bc fixed-arity)\n         (apply-to f bc arglist)\n         (.cljs$lang$applyTo f arglist)))\n     (apply-to-simple f a b c d (spread args)))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [4016 4062]},
                              :full-name "cljs.core/apply",
                              :docstring "Applies fn f to the argument list formed by prepending intervening arguments to args."},
           "clojure.walk/prewalk" {:ns "clojure.walk",
                                   :name "prewalk",
                                   :signature ["[f form]"],
                                   :name-encode "prewalk",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "clojure.walk/prewalk",
                                   :source {:code "(defn prewalk\n  {:added \"1.1\"}\n  [f form]\n  (walk (partial prewalk f) identity (f form)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/clojure/walk.cljs",
                                            :lines [62 66]},
                                   :full-name "clojure.walk/prewalk",
                                   :docstring "Like postwalk, but does pre-order traversal."},
           "cljs.core/flatten" {:ns "cljs.core",
                                :name "flatten",
                                :signature ["[x]"],
                                :name-encode "flatten",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/flatten",
                                :source {:code "(defn flatten\n  [x]\n  (filter #(not (sequential? %))\n          (rest (tree-seq sequential? seq x))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [5328 5334]},
                                :full-name "cljs.core/flatten",
                                :docstring "Takes any nested combination of sequential things (lists, vectors,\netc.) and returns their contents as a single, flat sequence.\n(flatten nil) returns nil."},
           "cljs.js/valid-name?" {:ns "cljs.js",
                                  :name "valid-name?",
                                  :signature ["[x]"],
                                  :name-encode "valid-nameQMARK",
                                  :history [["+" "1.7.10"]
                                            ["-" "1.7.48"]],
                                  :type "function",
                                  :full-name-encode "cljs.js/valid-nameQMARK",
                                  :source {:code "(defn valid-name? [x]\n  (or (nil? x) (symbol? x) (string? x)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.7.28",
                                           :filename "src/main/cljs/cljs/js.cljs",
                                           :lines [44 45]},
                                  :full-name "cljs.js/valid-name?",
                                  :removed {:in "1.7.48",
                                            :last-seen "1.7.28"}},
           "cljs.spec.gen.alpha/hash-map" {:ns "cljs.spec.gen.alpha",
                                           :name "hash-map",
                                           :signature ["[& args]"],
                                           :name-encode "hash-map",
                                           :history [["+" "1.9.542"]],
                                           :type "function",
                                           :full-name-encode "cljs.spec.gen.alpha/hash-map",
                                           :source {:code "(lazy-combinators hash-map list map not-empty set vector vector-distinct fmap elements\n  bind choose one-of such-that tuple sample return\n  large-integer* double* frequency shuffle)",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/cljs/cljs/spec/gen/alpha.cljs",
                                                    :lines [70 72]},
                                           :full-name "cljs.spec.gen.alpha/hash-map",
                                           :docstring "Lazy loaded version of clojure.test.check.generators/hash-map"},
           "cljs.core/eval" {:ns "cljs.core",
                             :name "eval",
                             :signature ["[form]"],
                             :name-encode "eval",
                             :history [["+" "1.10.191"]],
                             :type "function",
                             :full-name-encode "cljs.core/eval",
                             :source {:code "(defn eval\n  [form]\n  (*eval* form))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [12320 12325]},
                             :full-name "cljs.core/eval",
                             :docstring "Evaluates the form data structure (not text!) and returns the result.\nDelegates to cljs.core/*eval*. Intended for use in self-hosted ClojureScript,\nwhich sets up an implementation of cljs.core/*eval* for that environment."},
           "cljs.core/get" {:ns "cljs.core",
                            :name "get",
                            :signature ["[o k]" "[o k not-found]"],
                            :name-encode "get",
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core/get",
                            :source {:code "(defn get\n  ([o k]\n    (when-not (nil? o)\n      (cond\n        (implements? ILookup o)\n        (-lookup o k)\n\n        (array? o)\n        (when (and (some? k) (< k (.-length o)))\n          (aget o (int k)))\n\n        (string? o)\n        (when (and (some? k) (< -1 k (.-length o)))\n          (.charAt o (int k)))\n\n        (native-satisfies? ILookup o)\n        (-lookup o k)\n\n        :else nil)))\n  ([o k not-found]\n    (if-not (nil? o)\n      (cond\n        (implements? ILookup o)\n        (-lookup o k not-found)\n\n        (array? o)\n        (if (and (some? k) (< -1 k (.-length o)))\n          (aget o (int k))\n          not-found)\n\n        (string? o)\n        (if (and (some? k) (< -1 k (.-length o)))\n          (.charAt o (int k))\n          not-found)\n\n        (native-satisfies? ILookup o)\n        (-lookup o k not-found)\n\n        :else not-found)\n      not-found)))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [1993 2034]},
                            :full-name "cljs.core/get",
                            :docstring "Returns the value mapped to key, not-found or nil if key not present\nin associative collection, set, string, array, or ILookup instance."},
           "cljs.repl/skip-whitespace" {:ns "cljs.repl",
                                        :name "skip-whitespace",
                                        :signature ["[s]"],
                                        :name-encode "skip-whitespace",
                                        :history [["+" "0.0-2719"]],
                                        :type "function",
                                        :full-name-encode "cljs.repl/skip-whitespace",
                                        :source {:code "(defn skip-whitespace\n  [s]\n  (loop [c (readers/read-char s)]\n    (case c\n      \\newline :line-start\n      nil :stream-end\n      \\; (do (readers/read-line s) :line-start)\n      (if (or (Character/isWhitespace c) (identical? c \\,))\n        (recur (readers/read-char s))\n        (do (readers/unread s c) :body)))))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/clojure/cljs/repl.cljc",
                                                 :lines [66 83]},
                                        :full-name "cljs.repl/skip-whitespace",
                                        :docstring "Skips whitespace characters on stream s. Returns :line-start, :stream-end,\nor :body to indicate the relative location of the next character on s.\nInterprets comma as whitespace and semicolon as comment to end of line.\nDoes not interpret #! as comment to end of line because only one\ncharacter of lookahead is available. The stream must either be an\ninstance of LineNumberingPushbackReader or duplicate its behavior of both\nsupporting .unread and collapsing all of CR, LF, and CRLF to a single\n\\newline."},
           "cljs.analyzer.api/with-warning-handlers" {:ns "cljs.analyzer.api",
                                                      :name "with-warning-handlers",
                                                      :signature ["[handlers & body]"],
                                                      :name-encode "with-warning-handlers",
                                                      :history [["+"
                                                                 "1.10.738"]],
                                                      :type "macro",
                                                      :full-name-encode "cljs.analyzer.api/with-warning-handlers",
                                                      :source {:code "(defmacro with-warning-handlers\n  [handlers & body]\n  `(ana/with-warning-handlers ~handlers\n     ~@body))",
                                                               :title "Source code",
                                                               :repo "clojurescript",
                                                               :tag "r1.12.38",
                                                               :filename "src/main/clojure/cljs/analyzer/api.cljc",
                                                               :lines [81
                                                                       89]},
                                                      :full-name "cljs.analyzer.api/with-warning-handlers",
                                                      :docstring "Helper macro for custom handling of emitted warnings. Handlers should be\na vector of functions. The signature of these functions is\n[warn-type env warn-info]. warn-type is a keyword describing the warning,\nenv is the analysis environment, and warn-info is a map of extra useful\ninformation for a particular warning type."},
           "cljs.core/char" {:ns "cljs.core",
                             :name "char",
                             :signature ["[x]"],
                             :name-encode "char",
                             :history [["+" "0.0-1798"]],
                             :type "function",
                             :full-name-encode "cljs.core/char",
                             :source {:code "(defn char\n  [x]\n  (cond\n    (number? x) (.fromCharCode js/String x)\n    (and (string? x) (== (.-length x) 1)) x\n    :else (throw (js/Error. \"Argument to char must be a character or number\"))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [2787 2793]},
                             :full-name "cljs.core/char",
                             :docstring "Coerce to char"},
           "cljs.core/tagged-literal" {:ns "cljs.core",
                                       :name "tagged-literal",
                                       :signature ["[tag form]"],
                                       :name-encode "tagged-literal",
                                       :history [["+" "0.0-3255"]],
                                       :type "function",
                                       :full-name-encode "cljs.core/tagged-literal",
                                       :source {:code "(defn tagged-literal\n  [tag form]\n  {:pre [(symbol? tag)]}\n  (TaggedLiteral. tag form))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/core.cljs",
                                                :lines [11940 11945]},
                                       :full-name "cljs.core/tagged-literal",
                                       :docstring "Construct a data representation of a tagged literal from a\ntag symbol and a form."},
           "cljs.core/.." {:ns "cljs.core",
                           :name "..",
                           :signature ["[x form]" "[x form & more]"],
                           :name-encode "DOTDOT",
                           :history [["+" "0.0-927"]],
                           :type "macro",
                           :full-name-encode "cljs.core/DOTDOT",
                           :source {:code "(defmacro ..\n  {:added \"1.0\"}\n  ([x form] `(. ~x ~form))\n  ([x form & more] `(.. (. ~x ~form) ~@more)))",
                                    :title "Source code",
                                    :repo "clojure",
                                    :tag "clojure-1.10.0",
                                    :filename "src/clj/clojure/core.clj",
                                    :lines [1659 1675]},
                           :full-name "cljs.core/..",
                           :docstring "form => fieldName-symbol or (instanceMethodName-symbol args*)\n\nExpands into a member access (.) of the first member on the first\nargument, followed by the next member on the result, etc. For\ninstance:\n\n(.. System (getProperties) (get \"os.name\"))\n\nexpands to:\n\n(. (. System (getProperties)) (get \"os.name\"))\n\nbut is easier to write, read, and understand."},
           "cljs.core/floats" {:ns "cljs.core",
                               :name "floats",
                               :signature ["[x]"],
                               :name-encode "floats",
                               :history [["+" "0.0-1798"]],
                               :type "function",
                               :full-name-encode "cljs.core/floats",
                               :source {:code "(defn floats [x] x)",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [2911]},
                               :full-name "cljs.core/floats"},
           "cljs.core/Range" {:protocols #{"IChunkedNext"
                                           "ISeqable"
                                           "IMeta"
                                           "IWithMeta"
                                           "IEmptyableCollection"
                                           "IReduce"
                                           "ISequential"
                                           "ISeq"
                                           "ICollection"
                                           "IHash"
                                           "IPrintWithWriter"
                                           "IChunkedSeq"
                                           "IIterable"
                                           "INext"
                                           "IEquiv"
                                           "ICloneable"},
                              :ns "cljs.core",
                              :name "Range",
                              :signature ["[meta start end step chunk chunk-next __hash]"],
                              :name-encode "Range",
                              :history [["+" "0.0-927"]],
                              :type "type",
                              :full-name-encode "cljs.core/Range",
                              :source {:code "(deftype Range [meta start end step ^:mutable chunk ^:mutable chunk-next ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n  (forceChunk [coll]\n    (when (nil? chunk)\n      (let [arr (make-array 32)\n            val (loop [n 0 val start]\n                  (if (< n 32)\n                    (do\n                      (aset arr n val)\n                      (let [n (inc n)\n                            val (+ val step)]\n                        (if (if (pos? step) (< val end) (> val end))\n                          (recur n val)\n                          (set! chunk (array-chunk arr 0 n)))))\n                    val))]\n        (when (nil? chunk)\n          (set! chunk (array-chunk arr 0 32))\n          (when (if (pos? step) (< val end) (> val end))\n            (set! chunk-next (Range. nil val end step nil nil nil)))))))\n\n  ICloneable\n  (-clone [_] (Range. meta start end step chunk chunk-next __hash))\n\n  IWithMeta\n  (-with-meta [rng new-meta]\n    (if (identical? new-meta meta)\n      rng\n      (Range. new-meta start end step chunk chunk-next __hash)))\n\n  IMeta\n  (-meta [rng] meta)\n\n  ISeqable\n  (-seq [rng] rng)\n\n  ISeq\n  (-first [rng] start)\n  (-rest [rng]\n    (let [s (-next rng)]\n      (if (nil? s)\n        ()\n        s)))\n\n  IIterable\n  (-iterator [_]\n    (RangeIterator. start end step))\n\n  INext\n  (-next [rng]\n    (if (pos? step)\n      (when (< (+ start step) end)\n        (Range. nil (+ start step) end step nil nil nil))\n      (when (> (+ start step) end)\n        (Range. nil (+ start step) end step nil nil nil))))\n\n  IChunkedSeq\n  (-chunked-first [rng]\n    (.forceChunk rng)\n    chunk)\n  (-chunked-rest [rng]\n    (.forceChunk rng)\n    (if (nil? chunk-next)\n      ()\n      chunk-next))\n\n  IChunkedNext\n  (-chunked-next [rng]\n    (seq (-chunked-rest rng)))\n\n  ICollection\n  (-conj [rng o] (cons o rng))\n\n  IEmptyableCollection\n  (-empty [rng] (.-EMPTY List))\n\n  ISequential\n  IEquiv\n  (-equiv [rng other] (equiv-sequential rng other))\n\n  IHash\n  (-hash [rng] (caching-hash rng hash-ordered-coll __hash))\n\n  IReduce\n  (-reduce [rng f] (seq-reduce f rng))\n  (-reduce [rng f init]\n    (loop [i start ret init]\n      (if (if (pos? step) (< i end) (> i end))\n        (let [ret (f ret i)]\n          (if (reduced? ret)\n            @ret\n            (recur (+ i step) ret)))\n        ret))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [10082 10185]},
                              :full-name "cljs.core/Range"},
           "cljs.spec/nonconforming" {:ns "cljs.spec",
                                      :name "nonconforming",
                                      :signature ["[spec]"],
                                      :name-encode "nonconforming",
                                      :history [["+" "1.9.456"]
                                                ["-" "1.9.542"]],
                                      :type "function",
                                      :full-name-encode "cljs.spec/nonconforming",
                                      :source {:code "(defn nonconforming\n  [spec]\n  (let [spec (specize spec)]\n    (reify\n     Specize\n     (specize* [s] s)\n     (specize* [s _] s)\n\n     Spec\n     (conform* [_ x] (let [ret (conform* spec x)]\n                       (if (invalid? ret)\n                         ::invalid\n                         x)))\n     (unform* [_ x] (unform* spec x))\n     (explain* [_ path via in x] (explain* spec path via in x))\n     (gen* [_ overrides path rmap] (gen* spec overrides path rmap))\n     (with-gen* [_ gfn] (nonconforming (with-gen* spec gfn)))\n     (describe* [_] `(nonconforming ~(describe* spec))))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.9.521",
                                               :filename "src/main/cljs/cljs/spec.cljs",
                                               :lines [1328 1347]},
                                      :full-name "cljs.spec/nonconforming",
                                      :docstring "takes a spec and returns a spec that has the same properties except\n'conform' returns the original (not the conformed) value. Note, will specize regex ops.",
                                      :removed {:in "1.9.542",
                                                :last-seen "1.9.521"}},
           "cljs.core/zero?" {:return-type boolean,
                              :ns "cljs.core",
                              :name "zero?",
                              :signature ["[x]"],
                              :name-encode "zeroQMARK",
                              :history [["+" "0.0-927"]],
                              :type "function/macro",
                              :full-name-encode "cljs.core/zeroQMARK",
                              :source {:code "(defn ^boolean zero?\n  [x]\n  (cljs.core/zero? x))",
                                       :title "Function code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [3025 3028]},
                              :extra-sources [{:code "(core/defmacro ^::ana/numeric zero? [x]\n  `(== ~x 0))",
                                               :title "Macro code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/clojure/cljs/core.cljc",
                                               :lines [1171 1172]}],
                              :full-name "cljs.core/zero?",
                              :docstring "Returns true if num is zero, else false"},
           "cljs.core/identity" {:ns "cljs.core",
                                 :name "identity",
                                 :signature ["[x]"],
                                 :name-encode "identity",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/identity",
                                 :source {:code "(defn identity\n  [x] x)",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [2650 2652]},
                                 :full-name "cljs.core/identity",
                                 :docstring "Returns its argument."},
           "cljs.math/log1p" {:return-type number,
                              :ns "cljs.math",
                              :name "log1p",
                              :signature ["[x]"],
                              :name-encode "log1p",
                              :history [["+" "1.11.50"]],
                              :type "function",
                              :full-name-encode "cljs.math/log1p",
                              :source {:code "(defn ^number log1p\n  {:added \"1.11.10\"}\n  [x] (Math/log1p x))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/math.cljs",
                                       :lines [717 725]},
                              :full-name "cljs.math/log1p",
                              :docstring "Returns ln(1+x). For small values of x, log1p(x) is more accurate than\nlog(1.0+x).\nIf x is ##NaN or ##-Inf or < -1 => ##NaN\nIf x is -1 => ##-Inf\nIf x is ##Inf => ##Inf\nSee: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/log1p"},
           "cljs.repl.browser/parse-file" {:ns "cljs.repl.browser",
                                           :name "parse-file",
                                           :signature ["[{:keys [host host-port port], :as repl-env} file {:keys [asset-path], :as opts}]"],
                                           :name-encode "parse-file",
                                           :history [["+" "0.0-3053"]
                                                     ["-" "1.7.10"]],
                                           :type "function",
                                           :full-name-encode "cljs.repl.browser/parse-file",
                                           :source {:code "(defn parse-file [{:keys [host host-port port] :as repl-env} file {:keys [asset-path] :as opts}]\n  (let [base-url-pattern (Pattern/compile (str \"http://\" host \":\" (or host-port port) \"/\"))]\n    (if (re-find base-url-pattern file)\n      (-> file\n        (string/replace base-url-pattern \"\")\n        (string/replace\n          (Pattern/compile\n            (str \"^\" (or asset-path (util/output-directory opts)) \"/\")) \"\"))\n      (if-let [asset-root (:asset-root opts)]\n        (string/replace file asset-root \"\")\n        (throw\n          (ex-info (str \"Could not relativize URL \" file)\n            {:type :parse-stacktrace\n             :reason :relativize-url}))))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r3308",
                                                    :filename "src/main/clojure/cljs/repl/browser.clj",
                                                    :lines [230 243]},
                                           :full-name "cljs.repl.browser/parse-file",
                                           :removed {:in "1.7.10",
                                                     :last-seen "0.0-3308"}},
           "cljs.core/load" {:ns "cljs.core",
                             :name "load",
                             :signature ["[& paths]"],
                             :name-encode "load",
                             :history [["+" "1.9.456"]],
                             :type "special form (repl)",
                             :full-name-encode "cljs.core/load",
                             :source {:code "(def default-special-fns\n  (let [load-file-fn\n        (fn self\n          ([repl-env env form]\n            (self repl-env env form nil))\n          ([repl-env env [_ file :as form] opts]\n            (load-file repl-env file opts)))\n        in-ns-fn\n        (fn self\n          ([repl-env env form]\n           (self repl-env env form nil))\n          ([repl-env env [_ [quote ns-name] :as form] _]\n            ;; guard against craziness like '5 which wreaks havoc\n           (when-not (and (= quote 'quote) (symbol? ns-name))\n             (throw (IllegalArgumentException. \"Argument to in-ns must be a symbol.\")))\n           (when-not (ana/get-namespace ns-name)\n             (swap! env/*compiler* assoc-in [::ana/namespaces ns-name] {:name ns-name})\n             (-evaluate repl-env \"<cljs repl>\" 1\n               (str \"goog.provide('\" (comp/munge ns-name) \"');\")))\n           (set! ana/*cljs-ns* ns-name)))\n        load-fn\n        (fn self\n          ([repl-env env form]\n           (self env repl-env form nil))\n          ([repl-env env [_ & paths :as form] opts]\n           (let [cp-paths (map load-path->cp-path paths)]\n             (run! #(load-file repl-env % opts) cp-paths))))]\n    (wrap-special-fns wrap-self\n     {'in-ns in-ns-fn\n      'clojure.core/in-ns in-ns-fn\n      'load-file load-file-fn\n      'clojure.core/load-file load-file-fn\n      'load-namespace\n      (fn self\n        ([repl-env env form]\n         (self env repl-env form nil))\n        ([repl-env env [_ ns :as form] opts]\n         (load-namespace repl-env ns opts)))\n      'load load-fn\n      'clojure.core/load load-fn})))",
                                      :title "repl specials table",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/clojure/cljs/repl.cljc",
                                      :lines [754 793]},
                             :full-name "cljs.core/load",
                             :repl-only? true,
                             :docstring "Loads Clojure code from resources in classpath. A path is interpreted as\nclasspath-relative if it begins with a slash or relative to the root\ndirectory for the current namespace otherwise."},
           "compiler-options/package-json-resolution" {:ns "compiler-options",
                                                       :name "package-json-resolution",
                                                       :name-encode "package-json-resolution",
                                                       :type "option",
                                                       :full-name-encode "compiler-options/package-json-resolution",
                                                       :full-name "compiler-options/package-json-resolution",
                                                       :history [["+"
                                                                  "1.10.191"]]},
           "cljs.core/first" {:ns "cljs.core",
                              :name "first",
                              :signature ["[coll]"],
                              :name-encode "first",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/first",
                              :source {:code "(defn first\n  [coll]\n  (when-not (nil? coll)\n    (if (implements? ISeq coll)\n      (-first coll)\n      (let [s (seq coll)]\n        (when-not (nil? s)\n          (-first s))))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [1279 1288]},
                              :full-name "cljs.core/first",
                              :docstring "Returns the first item in the collection. Calls seq on its\nargument. If coll is nil, returns nil."},
           "cljs.core/*print-fn-bodies*" {:ns "cljs.core",
                                          :name "*print-fn-bodies*",
                                          :name-encode "STARprint-fn-bodiesSTAR",
                                          :history [["+" "1.9.854"]],
                                          :type "dynamic var",
                                          :full-name-encode "cljs.core/STARprint-fn-bodiesSTAR",
                                          :source {:code "(def\n  ^{:dynamic true}\n  *print-fn-bodies* false)",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/cljs/cljs/core.cljs",
                                                   :lines [173 177]},
                                          :full-name "cljs.core/*print-fn-bodies*",
                                          :docstring "*print-fns-bodies* controls whether functions print their source or\n only their names."},
           "cljs.reader/ratio-pattern" {:ns "cljs.reader",
                                        :name "ratio-pattern",
                                        :name-encode "ratio-pattern",
                                        :history [["+" "0.0-927"]
                                                  ["-" "1.9.854"]],
                                        :type "var",
                                        :full-name-encode "cljs.reader/ratio-pattern",
                                        :source {:code "(def ratio-pattern (re-pattern \"^([-+]?[0-9]+)/([0-9]+)$\"))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.9.671",
                                                 :filename "src/main/cljs/cljs/reader.cljs",
                                                 :lines [100]},
                                        :full-name "cljs.reader/ratio-pattern",
                                        :removed {:in "1.9.854",
                                                  :last-seen "1.9.671"}},
           "cljs.core/println-str" {:ns "cljs.core",
                                    :name "println-str",
                                    :signature ["[& objs]"],
                                    :name-encode "println-str",
                                    :history [["+" "0.0-1011"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/println-str",
                                    :source {:code "(defn println-str\n  [& objs]\n  (prn-str-with-opts objs (assoc (pr-opts) :readably false)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [10681 10684]},
                                    :full-name "cljs.core/println-str",
                                    :docstring "println to a string, returning it"},
           "cljs.spec/check-asserts" {:ns "cljs.spec",
                                      :name "check-asserts",
                                      :signature ["[flag]"],
                                      :name-encode "check-asserts",
                                      :history [["+" "1.9.216"]
                                                ["-" "1.9.542"]],
                                      :type "function",
                                      :full-name-encode "cljs.spec/check-asserts",
                                      :source {:code "(defn check-asserts\n  [^boolean flag]\n  (set! *runtime-asserts* flag))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.9.521",
                                               :filename "src/main/cljs/cljs/spec.cljs",
                                               :lines [1428 1434]},
                                      :full-name "cljs.spec/check-asserts",
                                      :docstring "Enable or disable spec asserts that have been compiled\nwith '*compile-asserts*' true.  See 'assert'.\nInitially set to boolean value of cljs.spec/*runtime-asserts*.\nDefaults to false.",
                                      :removed {:in "1.9.542",
                                                :last-seen "1.9.521"}},
           "cljs.core/>" {:return-type boolean,
                          :ns "cljs.core",
                          :name ">",
                          :signature ["[x]" "[x y]" "[x y & more]"],
                          :name-encode "GT",
                          :history [["+" "0.0-927"]],
                          :type "function/macro",
                          :full-name-encode "cljs.core/GT",
                          :source {:code "(defn ^boolean >\n  ([x] true)\n  ([x y] (cljs.core/> x y))\n  ([x y & more]\n   (if (cljs.core/> x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (cljs.core/> y (first more)))\n     false)))",
                                   :title "Function code",
                                   :repo "clojurescript",
                                   :tag "r1.12.38",
                                   :filename "src/main/cljs/cljs/core.cljs",
                                   :lines [2738 2748]},
                          :extra-sources [{:code "(core/defmacro ^::ana/numeric >\n  ([x] true)\n  ([x y] (bool-expr (core/list 'js* \"(~{} > ~{})\" x y)))\n  ([x y & more] `(and (> ~x ~y) (> ~y ~@more))))",
                                           :title "Macro code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/clojure/cljs/core.cljc",
                                           :lines [1150 1153]}],
                          :full-name "cljs.core/>",
                          :docstring "Returns non-nil if nums are in monotonically decreasing order,\notherwise false."},
           "cljs.repl/IPrintStacktrace" {:ns "cljs.repl",
                                         :name "IPrintStacktrace",
                                         :name-encode "IPrintStacktrace",
                                         :history [["+" "0.0-2843"]],
                                         :type "protocol",
                                         :full-name-encode "cljs.repl/IPrintStacktrace",
                                         :source {:code "(defprotocol IPrintStacktrace\n  (-print-stacktrace [repl-env stacktrace error build-options]\n    \"Implementing REPL evaluation environments are given the opportunity to\n     print the mapped stacktrace themselves. This permits further processing.\"))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/clojure/cljs/repl.cljc",
                                                  :lines [176 179]},
                                         :methods [{:name "-print-stacktrace",
                                                    :signature ["[repl-env stacktrace error build-options]"],
                                                    :docstring "Implementing REPL evaluation environments are given the opportunity to\n     print the mapped stacktrace themselves. This permits further processing."}],
                                         :full-name "cljs.repl/IPrintStacktrace"},
           "cljs.core/juxt" {:ns "cljs.core",
                             :name "juxt",
                             :signature ["[f]"
                                         "[f g]"
                                         "[f g h]"
                                         "[f g h & fs]"],
                             :name-encode "juxt",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/juxt",
                             :source {:code "(defn juxt\n  ([f]\n     (fn\n       ([] (vector (f)))\n       ([x] (vector (f x)))\n       ([x y] (vector (f x y)))\n       ([x y z] (vector (f x y z)))\n       ([x y z & args] (vector (apply f x y z args)))))\n  ([f g]\n     (fn\n       ([] (vector (f) (g)))\n       ([x] (vector (f x) (g x)))\n       ([x y] (vector (f x y) (g x y)))\n       ([x y z] (vector (f x y z) (g x y z)))\n       ([x y z & args] (vector (apply f x y z args) (apply g x y z args)))))\n  ([f g h]\n     (fn\n       ([] (vector (f) (g) (h)))\n       ([x] (vector (f x) (g x) (h x)))\n       ([x y] (vector (f x y) (g x y) (h x y)))\n       ([x y z] (vector (f x y z) (g x y z) (h x y z)))\n       ([x y z & args] (vector (apply f x y z args) (apply g x y z args) (apply h x y z args)))))\n  ([f g h & fs]\n     (let [fs (list* f g h fs)]\n       (fn\n         ([] (reduce #(conj %1 (%2)) [] fs))\n         ([x] (reduce #(conj %1 (%2 x)) [] fs))\n         ([x y] (reduce #(conj %1 (%2 x y)) [] fs))\n         ([x y z] (reduce #(conj %1 (%2 x y z)) [] fs))\n         ([x y z & args] (reduce #(conj %1 (apply %2 x y z args)) [] fs))))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [10309 10343]},
                             :full-name "cljs.core/juxt",
                             :docstring "Takes a set of functions and returns a fn that is the juxtaposition\nof those fns.  The returned fn takes a variable number of args, and\nreturns a vector containing the result of applying each fn to the\nargs (left-to-right).\n((juxt a b c) x) => [(a x) (b x) (c x)]"},
           "cljs.pprint/*print-suppress-namespaces*" {:ns "cljs.pprint",
                                                      :name "*print-suppress-namespaces*",
                                                      :name-encode "STARprint-suppress-namespacesSTAR",
                                                      :history [["+"
                                                                 "0.0-3255"]],
                                                      :type "dynamic var",
                                                      :full-name-encode "cljs.pprint/STARprint-suppress-namespacesSTAR",
                                                      :source {:code "(def ^{:added \"1.2\", :dynamic true} *print-suppress-namespaces* nil)",
                                                               :title "Source code",
                                                               :repo "clojurescript",
                                                               :tag "r1.12.38",
                                                               :filename "src/main/cljs/cljs/pprint.cljs",
                                                               :lines [658
                                                                       662]},
                                                      :full-name "cljs.pprint/*print-suppress-namespaces*",
                                                      :docstring "Don't print namespaces with symbols. This is particularly useful when\npretty printing the results of macro expansions"},
           "cljs.spec/map-of" {:ns "cljs.spec",
                               :name "map-of",
                               :signature ["[kpred vpred & opts]"],
                               :name-encode "map-of",
                               :history [["+" "1.9.14"]
                                         ["-" "1.9.542"]],
                               :type "macro",
                               :full-name-encode "cljs.spec/map-of",
                               :source {:code "(defmacro map-of\n  [kpred vpred & opts]\n  (let [desc `(map-of ~(res &env kpred) ~(res &env vpred) ~@(res-kind &env opts))]\n    `(every-kv ~kpred ~vpred ::conform-all true :kind map? ::describe '~desc ~@opts)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.9.521",
                                        :filename "src/main/cljs/cljs/spec.cljc",
                                        :lines [287 299]},
                               :full-name "cljs.spec/map-of",
                               :docstring "Returns a spec for a map whose keys satisfy kpred and vals satisfy\nvpred. Unlike 'every-kv', map-of will exhaustively conform every\nvalue.\n\nSame options as 'every', :kind defaults to map?, with the addition of:\n\n:conform-keys - conform keys as well as values (default false)\n\nSee also - every-kv",
                               :removed {:in "1.9.542",
                                         :last-seen "1.9.521"}},
           "cljs.core/max" {:return-type number,
                            :ns "cljs.core",
                            :name "max",
                            :signature ["[x]" "[x y]" "[x y & more]"],
                            :name-encode "max",
                            :history [["+" "0.0-927"]],
                            :type "function/macro",
                            :full-name-encode "cljs.core/max",
                            :source {:code "(defn ^number max\n  ([x] x)\n  ([x y] (cljs.core/max x y))\n  ([x y & more]\n   (reduce max (cljs.core/max x y) more)))",
                                     :title "Function code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [2771 2776]},
                            :extra-sources [{:code "(core/defmacro ^::ana/numeric max\n  ([x] x)\n  ([x y] `(let [x# ~x, y# ~y]\n            (~'js* \"((~{} > ~{}) ? ~{} : ~{})\" x# y# x# y#)))\n  ([x y & more] `(max (max ~x ~y) ~@more)))",
                                             :title "Macro code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/clojure/cljs/core.cljc",
                                             :lines [1180 1184]}],
                            :full-name "cljs.core/max",
                            :docstring "Returns the greatest of the nums."},
           "cljs.core/completing" {:ns "cljs.core",
                                   :name "completing",
                                   :signature ["[f]" "[f cf]"],
                                   :name-encode "completing",
                                   :history [["+" "0.0-2341"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/completing",
                                   :source {:code "(defn completing\n  ([f] (completing f identity))\n  ([f cf]\n    (fn\n      ([] (f))\n      ([x] (cf x))\n      ([x y] (f x y)))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [2654 2663]},
                                   :full-name "cljs.core/completing",
                                   :docstring "Takes a reducing function f of 2 args and returns a fn suitable for\ntransduce by adding an arity-1 signature that calls cf (default -\nidentity) on the result argument."},
           "cljs.core/transduce" {:ns "cljs.core",
                                  :name "transduce",
                                  :signature ["[xform f coll]"
                                              "[xform f init coll]"],
                                  :name-encode "transduce",
                                  :history [["+" "0.0-2301"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/transduce",
                                  :source {:code "(defn transduce\n  ([xform f coll] (transduce xform f (f) coll))\n  ([xform f init coll]\n     (let [f (xform f)\n           ret (reduce f init coll)]\n       (f ret))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [2665 2678]},
                                  :full-name "cljs.core/transduce",
                                  :docstring "reduce with a transformation of f (xf). If init is not\nsupplied, (f) will be called to produce it. f should be a reducing\nstep function that accepts both 1 and 2 arguments, if it accepts\nonly 2 you can add the arity-1 with 'completing'. Returns the result\nof applying (the transformed) xf to init and the first item in coll,\nthen applying xf to that result and the 2nd item, etc. If coll\ncontains no items, returns init and f is not called. Note that\ncertain transforms may inject or skip items."},
           "cljs.pprint/set-pprint-dispatch" {:ns "cljs.pprint",
                                              :name "set-pprint-dispatch",
                                              :signature ["[function]"],
                                              :name-encode "set-pprint-dispatch",
                                              :history [["+"
                                                         "0.0-3255"]],
                                              :type "function",
                                              :full-name-encode "cljs.pprint/set-pprint-dispatch",
                                              :source {:code "(defn set-pprint-dispatch\n  [function]\n  (set! *print-pprint-dispatch* function)\n  nil)",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.12.38",
                                                       :filename "src/main/cljs/cljs/pprint.cljs",
                                                       :lines [827
                                                               830]},
                                              :full-name "cljs.pprint/set-pprint-dispatch"},
           "cljs.repl.server/parse-file-parts" {:ns "cljs.repl.server",
                                                :name "parse-file-parts",
                                                :signature ["[file]"],
                                                :name-encode "parse-file-parts",
                                                :history [["+"
                                                           "1.9.854"]],
                                                :type "function",
                                                :full-name-encode "cljs.repl.server/parse-file-parts",
                                                :source {:code "(defn parse-file-parts [file]\n  ;; This is a port of java.net.URL.Parts, which is package private.\n  (let [ref-idx (str/index-of file \"#\")\n        [file ref] (if ref-idx\n                     [(subs file 0 ref-idx) (subs file (inc ref-idx))]\n                     [file nil])\n        q-idx (str/last-index-of file \\?)]\n    (merge {:ref ref}\n           (if q-idx\n             {:path (subs file 0 q-idx)\n              :query-str (subs file (inc q-idx))}\n             {:path file}))))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1.12.38",
                                                         :filename "src/main/clojure/cljs/repl/server.clj",
                                                         :lines [62
                                                                 73]},
                                                :full-name "cljs.repl.server/parse-file-parts"},
           "cljs.test/test-var" {:ns "cljs.test",
                                 :name "test-var",
                                 :signature ["[v]"],
                                 :name-encode "test-var",
                                 :history [["+" "0.0-2496"]],
                                 :type "function",
                                 :full-name-encode "cljs.test/test-var",
                                 :source {:code "(defn test-var\n  [v]\n  (run-block (test-var-block v)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/test.cljs",
                                          :lines [496 500]},
                                 :full-name "cljs.test/test-var",
                                 :docstring "If v has a function in its :test metadata, calls that function,\nadd v to :testing-vars property of env."},
           "cljs.core/with-out-str" {:ns "cljs.core",
                                     :name "with-out-str",
                                     :signature ["[& body]"],
                                     :name-encode "with-out-str",
                                     :history [["+" "0.0-1535"]],
                                     :type "macro",
                                     :full-name-encode "cljs.core/with-out-str",
                                     :source {:code "(core/defmacro with-out-str\n  [& body]\n  `(let [sb# (goog.string/StringBuffer.)]\n     (binding [cljs.core/*print-newline* true\n               cljs.core/*print-fn* (fn [x#] (.append sb# x#))]\n       ~@body)\n     (cljs.core/str sb#)))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/clojure/cljs/core.cljc",
                                              :lines [2893 2902]},
                                     :full-name "cljs.core/with-out-str",
                                     :docstring "Evaluates exprs in a context in which *print-fn* is bound to .append\non a fresh StringBuffer.  Returns the string created by any nested\nprinting calls."},
           "cljs.core/*3" {:ns "cljs.core",
                           :name "*3",
                           :name-encode "STAR3",
                           :history [["+" "0.0-927"]],
                           :type "dynamic var",
                           :full-name-encode "cljs.core/STAR3",
                           :source {:code "(def\n  ^{:dynamic true}\n  *3)",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r1.12.38",
                                    :filename "src/main/cljs/cljs/core.cljs",
                                    :lines [217 220]},
                           :full-name "cljs.core/*3",
                           :docstring "bound in a repl thread to the third most recent value printed"},
           "cljs.core/IntegerRangeChunk" {:protocols #{"ICounted"
                                                       "ISeq"
                                                       "IChunk"
                                                       "IIndexed"},
                                          :ns "cljs.core",
                                          :name "IntegerRangeChunk",
                                          :signature ["[start step count]"],
                                          :name-encode "IntegerRangeChunk",
                                          :history [["+" "1.10.844"]],
                                          :type "type",
                                          :full-name-encode "cljs.core/IntegerRangeChunk",
                                          :source {:code "(deftype IntegerRangeChunk [start step count]\n  ICounted\n  (-count [coll] count)\n\n  ISeq\n  (-first [coll] start)\n\n  IIndexed\n  (-nth [coll i]\n    (+ start (* i step)))\n  (-nth [coll i not-found]\n    (if (and (>= i 0) (< i count))\n      (+ start (* i step))\n      not-found))\n\n  IChunk\n  (-drop-first [coll]\n    (if (<= count 1)\n      (throw (js/Error. \"-drop-first of empty chunk\"))\n      (IntegerRangeChunk. (+ start step) step (dec count)))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/cljs/cljs/core.cljs",
                                                   :lines [9916 9935]},
                                          :full-name "cljs.core/IntegerRangeChunk"},
           "cljs.core/memfn" {:ns "cljs.core",
                              :name "memfn",
                              :signature ["[name & args]"],
                              :name-encode "memfn",
                              :history [["+" "0.0-1443"]],
                              :type "macro",
                              :full-name-encode "cljs.core/memfn",
                              :source {:code "(core/defmacro memfn\n  [name & args]\n  (core/let [t (with-meta (gensym \"target\")\n                 (meta name))]\n    `(fn [~t ~@args]\n       (. ~t (~name ~@args)))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/clojure/cljs/core.cljc",
                                       :lines [380 389]},
                              :full-name "cljs.core/memfn",
                              :docstring "Expands into code that creates a fn that expects to be passed an\nobject and any args and calls the named instance method on the\nobject passing the args. Use when you want to treat a JavaScript\nmethod as a first-class fn."},
           "cljs.core/IEncodeClojure" {:ns "cljs.core",
                                       :name "IEncodeClojure",
                                       :name-encode "IEncodeClojure",
                                       :history [["+" "0.0-1552"]],
                                       :type "protocol",
                                       :full-name-encode "cljs.core/IEncodeClojure",
                                       :source {:code "(defprotocol IEncodeClojure\n  (-js->clj [x options] \"Transforms JavaScript values to Clojure\"))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/core.cljs",
                                                :lines [11202 11203]},
                                       :methods [{:name "-js->clj",
                                                  :signature ["[x options]"],
                                                  :docstring "Transforms JavaScript values to Clojure"}],
                                       :full-name "cljs.core/IEncodeClojure"},
           "cljs.spec/+" {:ns "cljs.spec",
                          :name "+",
                          :signature ["[pred-form]"],
                          :name-encode "PLUS",
                          :history [["+" "1.9.14"] ["-" "1.9.542"]],
                          :type "macro",
                          :full-name-encode "cljs.spec/PLUS",
                          :source {:code "(defmacro +\n  [pred-form]\n  `(rep+impl '~(res &env pred-form) ~pred-form))",
                                   :title "Source code",
                                   :repo "clojurescript",
                                   :tag "r1.9.521",
                                   :filename "src/main/cljs/cljs/spec.cljc",
                                   :lines [307 311]},
                          :full-name "cljs.spec/+",
                          :docstring "Returns a regex op that matches one or more values matching\npred. Produces a vector of matches",
                          :removed {:in "1.9.542",
                                    :last-seen "1.9.521"}},
           "cljs.js/eval-str*" {:ns "cljs.js",
                                :name "eval-str*",
                                :signature ["[bound-vars source name opts cb]"],
                                :name-encode "eval-strSTAR",
                                :history [["+" "1.7.10"]
                                          ["-" "1.7.28"]],
                                :type "function",
                                :full-name-encode "cljs.js/eval-strSTAR",
                                :source {:code "(defn eval-str* [bound-vars source name opts cb]\n  (let [rdr        (rt/indexing-push-back-reader source 1 name)\n        eof        (js-obj)\n        aenv       (ana/empty-env)\n        sb         (StringBuffer.)\n        the-ns     (or (:ns opts) 'cljs.user)\n        bound-vars (cond-> (merge bound-vars {:*cljs-ns* the-ns})\n                     (:source-map opts) (assoc :*sm-data* (sm-data)))]\n    (when (:verbose opts) (debug-prn \"Evaluating\" name))\n    ((fn compile-loop [ns]\n       (binding [env/*compiler*         (:*compiler* bound-vars)\n                 *eval-fn*              (:*eval-fn* bound-vars)\n                 ana/*cljs-ns*          ns\n                 *ns*                   (create-ns ns)\n                 r/*data-readers*       (:*data-readers* bound-vars)\n                 comp/*source-map-data* (:*sm-data* bound-vars)]\n         (let [res (try\n                     {:value (r/read {:eof eof :read-cond :allow :features #{:cljs}} rdr)}\n                     (catch :default cause\n                       (wrap-error\n                         (ana/error aenv\n                           (str \"Could not eval \" name) cause))))]\n           (if (:error res)\n             (cb res)\n             (let [form (:value res)]\n               (if-not (identical? eof form)\n                 (let [aenv (cond-> (assoc aenv :ns (ana/get-namespace ns))\n                              (:context opts) (assoc :context (:context opts))\n                              (:def-emits-var opts) (assoc :def-emits-var true))\n                       res  (try\n                              {:value (ana/analyze aenv form nil opts)}\n                              (catch :default cause\n                                (wrap-error\n                                  (ana/error aenv\n                                    (str \"Could not eval \" name) cause))))]\n                   (if (:error res)\n                     (cb res)\n                     (let [ast (:value res)\n                           ns' ana/*cljs-ns*]\n                      (if (= :ns (:op ast))\n                        (do\n                          (.append sb\n                            (str \"goog.provide(\\\"\" (munge (:name ast)) \"\\\");\\n\"))\n                          (ns-side-effects true bound-vars aenv ast opts\n                            (fn [res]\n                              (if (:error res)\n                                (cb res)\n                                (compile-loop ns')))))\n                        (do\n                          (.append sb (with-out-str (comp/emit ast)))\n                          (recur ns'))))))\n                 (do\n                   (when (:source-map opts)\n                     (append-source-map env/*compiler*\n                       name source sb @comp/*source-map-data* opts))\n                   (let [js-source (.toString sb)\n                         evalm     {:lang   :clj\n                                    :name   name\n                                    :path   (ns->relpath name)\n                                    :source js-source\n                                    :cache  (get-in env/*compiler* [::ana/namespaces name])}\n                         complete  (fn [res]\n                                     (if (:error res)\n                                       (cb res)\n                                       (do\n                                         (when (:verbose opts)\n                                           (debug-prn js-source))\n                                         (let [res (try\n                                                     {:ns ns :value (*eval-fn* evalm)}\n                                                     (catch :default cause\n                                                       (wrap-error (ana/error aenv \"ERROR\" cause))))]\n                                           (cb res)))))]\n                     (if-let [f (:cache-source opts)]\n                       (f evalm complete)\n                       (complete {:value nil}))))))))))\n      (:*cljs-ns* bound-vars))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.7.10",
                                         :filename "src/main/cljs/cljs/js.cljs",
                                         :lines [623 698]},
                                :full-name "cljs.js/eval-str*",
                                :removed {:in "1.7.28",
                                          :last-seen "1.7.10"}},
           "cljs.core/TransientArrayMap" {:protocols #{"IFn"
                                                       "ITransientCollection"
                                                       "ICounted"
                                                       "ILookup"
                                                       "ITransientAssociative"
                                                       "ITransientMap"},
                                          :ns "cljs.core",
                                          :name "TransientArrayMap",
                                          :signature ["[editable? len arr]"],
                                          :name-encode "TransientArrayMap",
                                          :history [["+" "0.0-1211"]],
                                          :type "type",
                                          :full-name-encode "cljs.core/TransientArrayMap",
                                          :source {:code "(deftype TransientArrayMap [^:mutable ^boolean editable?\n                            ^:mutable len\n                            arr]\n  ICounted\n  (-count [tcoll]\n    (if editable?\n      (quot len 2)\n      (throw (js/Error. \"count after persistent!\"))))\n\n  ILookup\n  (-lookup [tcoll k]\n    (-lookup tcoll k nil))\n\n  (-lookup [tcoll k not-found]\n    (if editable?\n      (let [idx (array-map-index-of tcoll k)]\n        (if (== idx -1)\n          not-found\n          (aget arr (inc idx))))\n      (throw (js/Error. \"lookup after persistent!\"))))\n\n  ITransientCollection\n  (-conj! [tcoll o]\n    (if editable?\n      (cond\n        (map-entry? o)\n        (-assoc! tcoll (key o) (val o))\n\n        (vector? o)\n        (-assoc! tcoll (o 0) (o 1))\n\n        :else\n        (loop [es (seq o) tcoll tcoll]\n          (if-let [e (first es)]\n            (recur (next es)\n                   (-assoc! tcoll (key e) (val e)))\n            tcoll)))\n      (throw (js/Error. \"conj! after persistent!\"))))\n\n  (-persistent! [tcoll]\n    (if editable?\n      (do (set! editable? false)\n          (PersistentArrayMap. nil (quot len 2) arr nil))\n      (throw (js/Error. \"persistent! called twice\"))))\n\n  ITransientAssociative\n  (-assoc! [tcoll key val]\n    (if editable?\n      (let [idx (array-map-index-of tcoll key)]\n        (if (== idx -1)\n          (if (<= (+ len 2) (* 2 (.-HASHMAP-THRESHOLD PersistentArrayMap)))\n            (do (set! len (+ len 2))\n                (.push arr key)\n                (.push arr val)\n                tcoll)\n            (assoc! (array->transient-hash-map len arr) key val))\n          (if (identical? val (aget arr (inc idx)))\n            tcoll\n            (do (aset arr (inc idx) val)\n                tcoll))))\n      (throw (js/Error. \"assoc! after persistent!\"))))\n\n  ITransientMap\n  (-dissoc! [tcoll key]\n    (if editable?\n      (let [idx (array-map-index-of tcoll key)]\n        (when (>= idx 0)\n          (aset arr idx (aget arr (- len 2)))\n          (aset arr (inc idx) (aget arr (dec len)))\n          (doto arr .pop .pop)\n          (set! len (- len 2)))\n        tcoll)\n      (throw (js/Error. \"dissoc! after persistent!\"))))\n\n  IFn\n  (-invoke [tcoll key]\n    (-lookup tcoll key nil))\n  (-invoke [tcoll key not-found]\n    (-lookup tcoll key not-found)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/cljs/cljs/core.cljs",
                                                   :lines [7273 7351]},
                                          :full-name "cljs.core/TransientArrayMap"},
           "cljs.core/cond->>" {:ns "cljs.core",
                                :name "cond->>",
                                :signature ["[expr & clauses]"],
                                :name-encode "cond-GTGT",
                                :history [["+" "0.0-1798"]],
                                :type "macro",
                                :full-name-encode "cljs.core/cond-GTGT",
                                :source {:code "(defmacro cond->>\n  {:added \"1.5\"}\n  [expr & clauses]\n  (assert (even? (count clauses)))\n  (let [g (gensym)\n        steps (map (fn [[test step]] `(if ~test (->> ~g ~step) ~g))\n                   (partition 2 clauses))]\n    `(let [~g ~expr\n           ~@(interleave (repeat g) (butlast steps))]\n       ~(if (empty? steps)\n          g\n          (last steps)))))",
                                         :title "Source code",
                                         :repo "clojure",
                                         :tag "clojure-1.10.0",
                                         :filename "src/clj/clojure/core.clj",
                                         :lines [7555 7570]},
                                :full-name "cljs.core/cond->>",
                                :docstring "Takes an expression and a set of test/form pairs. Threads expr (via ->>)\nthrough each form for which the corresponding test expression\nis true.  Note that, unlike cond branching, cond->> threading does not short circuit\nafter the first true test expression."},
           "cljs.core/number?" {:return-type boolean,
                                :ns "cljs.core",
                                :name "number?",
                                :signature ["[x]"],
                                :name-encode "numberQMARK",
                                :history [["+" "0.0-927"]],
                                :type "function/macro",
                                :full-name-encode "cljs.core/numberQMARK",
                                :source {:code "(defn ^boolean number?\n  [x]\n  (cljs.core/number? x))",
                                         :title "Function code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [253 256]},
                                :extra-sources [{:code "(core/defmacro number? [x]\n  (bool-expr (core/list 'js* \"typeof ~{} === 'number'\" x)))",
                                                 :title "Macro code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/clojure/cljs/core.cljc",
                                                 :lines [1010 1011]}],
                                :full-name "cljs.core/number?",
                                :docstring "Returns true if x is a JavaScript number."},
           "cljs.spec/explain" {:ns "cljs.spec",
                                :name "explain",
                                :signature ["[spec x]"],
                                :name-encode "explain",
                                :history [["+" "1.9.14"]
                                          ["-" "1.9.542"]],
                                :type "function",
                                :full-name-encode "cljs.spec/explain",
                                :source {:code "(defn explain\n  [spec x]\n  (explain-out (explain-data spec x)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.9.521",
                                         :filename "src/main/cljs/cljs/spec.cljs",
                                         :lines [254 257]},
                                :full-name "cljs.spec/explain",
                                :docstring "Given a spec and a value that fails to conform, prints an explanation to *out*.",
                                :removed {:in "1.9.542",
                                          :last-seen "1.9.521"}},
           "cljs.core/array" {:return-type array,
                              :ns "cljs.core",
                              :name "array",
                              :signature ["[var-args]"],
                              :name-encode "array",
                              :history [["+" "0.0-927"]],
                              :type "function/macro",
                              :full-name-encode "cljs.core/array",
                              :source {:code "(defn ^array array\n  ;;array is a special case, don't emulate this doc string\n  [var-args]            ;; [& items]\n  (let [a (js/Array. (alength (cljs.core/js-arguments)))]\n    (loop [i 0]\n      (if (< i (alength a))\n        (do\n          (aset a i (aget (cljs.core/js-arguments) i))\n          (recur (inc i)))\n        a))))",
                                       :title "Function code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [447 457]},
                              :extra-sources [{:code "(core/defmacro array [& rest]\n  (core/let [xs-str (core/->> (repeat \"~{}\")\n                      (take (count rest))\n                      (interpose \",\")\n                      (apply core/str))]\n    (vary-meta\n      (list* 'js* (core/str \"[\" xs-str \"]\") rest)\n      assoc :tag 'array)))",
                                               :title "Macro code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/clojure/cljs/core.cljc",
                                               :lines [2592 2599]}],
                              :full-name "cljs.core/array",
                              :docstring "Creates a new javascript array.\n@param {...*} var_args"},
           "cljs.core/nthnext" {:ns "cljs.core",
                                :name "nthnext",
                                :signature ["[coll n]"],
                                :name-encode "nthnext",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/nthnext",
                                :source {:code "(defn nthnext\n  [coll n]\n  (if (implements? IDrop coll)\n    (if (pos? n)\n      (-drop coll (Math/ceil n))\n      (seq coll))\n    (loop [n n xs (seq coll)]\n      (if (and xs (pos? n))\n        (recur (dec n) (next xs))\n        xs))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [3036 3046]},
                                :full-name "cljs.core/nthnext",
                                :docstring "Returns the nth next of coll, (seq coll) when n is 0."},
           "cljs.core/re-pattern" {:ns "cljs.core",
                                   :name "re-pattern",
                                   :signature ["[s]"],
                                   :name-encode "re-pattern",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/re-pattern",
                                   :source {:code "(defn re-pattern\n  [s]\n  (if (instance? js/RegExp s)\n    s\n    (let [[prefix flags] (re-find #\"^\\(\\?([idmsux]*)\\)\" s)\n          pattern (subs s (if (nil? prefix)\n                            0\n                            (count ^string prefix)))]\n      (js/RegExp. pattern (or flags \"\")))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [10426 10435]},
                                   :full-name "cljs.core/re-pattern",
                                   :docstring "Returns an instance of RegExp which has compiled the provided string."},
           "cljs.core/missing-protocol" {:ns "cljs.core",
                                         :name "missing-protocol",
                                         :signature ["[proto obj]"],
                                         :name-encode "missing-protocol",
                                         :history [["+" "0.0-927"]],
                                         :type "function",
                                         :full-name-encode "cljs.core/missing-protocol",
                                         :source {:code "(defn missing-protocol [proto obj]\n  (let [ty (type obj)\n        ty (if (and ty (.-cljs$lang$type ty))\n             (.-cljs$lang$ctorStr ty)\n             (goog/typeOf obj))]\n   (js/Error.\n     (.join (array \"No protocol method \" proto\n                   \" defined for type \" ty \": \" obj) \"\"))))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/cljs/cljs/core.cljs",
                                                  :lines [323 330]},
                                         :full-name "cljs.core/missing-protocol"},
           "clojure.browser.dom/set-text" {:ns "clojure.browser.dom",
                                           :name "set-text",
                                           :signature ["[e s]"],
                                           :name-encode "set-text",
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "clojure.browser.dom/set-text",
                                           :source {:code "(defn set-text\n  [e s]\n  (gdom/setTextContent (ensure-element e) s))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/cljs/clojure/browser/dom.cljs",
                                                    :lines [124 129]},
                                           :full-name "clojure.browser.dom/set-text",
                                           :docstring "Set the text content for the passed element returning the\nelement. If a keyword is passed in the place of e, the element with\nthat id will be used and returned."},
           "cljs.test/js-line-and-column" {:ns "cljs.test",
                                           :name "js-line-and-column",
                                           :signature ["[stack-element]"],
                                           :name-encode "js-line-and-column",
                                           :history [["+" "0.0-2496"]],
                                           :type "function",
                                           :full-name-encode "cljs.test/js-line-and-column",
                                           :source {:code "(defn js-line-and-column [stack-element]\n  \"Returns a 2-element vector containing the line and\n  column encoded at the end of a stack element string.\n  A line or column will be represented as NaN if not\n  parsesable.\"\n  (let [parts (.split stack-element \":\")\n        cnt   (count parts)]\n    (if (> cnt 1)\n      [(js/parseInt (nth parts (- cnt 2)) 10)\n       (js/parseInt (nth parts (dec cnt)) 10)]\n      [##NaN ##NaN])))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/cljs/cljs/test.cljs",
                                                    :lines [366 376]},
                                           :full-name "cljs.test/js-line-and-column"},
           "cljs.core/copy-arguments" {:ns "cljs.core",
                                       :name "copy-arguments",
                                       :signature ["[dest]"],
                                       :name-encode "copy-arguments",
                                       :history [["+" "1.7.10"]],
                                       :type "macro",
                                       :full-name-encode "cljs.core/copy-arguments",
                                       :source {:code "(core/defmacro copy-arguments [dest]\n  `(let [len# (alength (js-arguments))]\n     (loop [i# 0]\n       (when (< i# len#)\n         (.push ~dest (unchecked-get (js-arguments) i#))\n         (recur (inc i#))))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/clojure/cljs/core.cljc",
                                                :lines [3166 3171]},
                                       :full-name "cljs.core/copy-arguments"},
           "clojure.zip/up" {:ns "clojure.zip",
                             :name "up",
                             :signature ["[loc]"],
                             :name-encode "up",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "clojure.zip/up",
                             :source {:code "(defn up\n  [loc]\n    (let [[node {l :l, ppath :ppath, pnodes :pnodes r :r, changed? :changed?, :as path}] loc]\n      (when pnodes\n        (let [pnode (peek pnodes)]\n          (with-meta (if changed?\n                       [(make-node loc pnode (concat l (cons node r))) \n                        (and ppath (assoc ppath :changed? true))]\n                       [pnode ppath])\n                     (meta loc))))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/clojure/zip.cljs",
                                      :lines [111 122]},
                             :full-name "clojure.zip/up",
                             :docstring "Returns the loc of the parent of the node at this loc, or nil if at\nthe top"},
           "cljs.spec.impl.gen/char-ascii" {:ns "cljs.spec.impl.gen",
                                            :name "char-ascii",
                                            :signature ["[& args]"],
                                            :name-encode "char-ascii",
                                            :history [["+" "1.9.14"]
                                                      ["-" "1.9.542"]],
                                            :type "function",
                                            :full-name-encode "cljs.spec.impl.gen/char-ascii",
                                            :source {:code "(lazy-prims any any-printable boolean char char-alpha char-alphanumeric char-ascii double\n  int keyword keyword-ns large-integer ratio simple-type simple-type-printable\n  string string-ascii string-alphanumeric symbol symbol-ns uuid)",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.9.521",
                                                     :filename "src/main/cljs/cljs/spec/impl/gen.cljs",
                                                     :lines [73 75]},
                                            :full-name "cljs.spec.impl.gen/char-ascii",
                                            :docstring "Fn returning clojure.test.check.generators/char-ascii",
                                            :removed {:in "1.9.542",
                                                      :last-seen "1.9.521"}},
           "cljs.analyzer.api/parse-ns" {:ns "cljs.analyzer.api",
                                         :name "parse-ns",
                                         :signature ["[src]"
                                                     "[src opts]"
                                                     "[src dest opts]"
                                                     "[state src dest opts]"],
                                         :name-encode "parse-ns",
                                         :history [["+" "0.0-3208"]],
                                         :type "function",
                                         :full-name-encode "cljs.analyzer.api/parse-ns",
                                         :source {:code "   (defn parse-ns\n     ([src] (parse-ns src nil nil))\n     ([src opts] (parse-ns src nil opts))\n     ([src dest opts]\n      (parse-ns (or (current-state) (empty-state opts)) src dest opts))\n     ([state src dest opts]\n      (env/with-compiler-env state\n        (binding [ana/*cljs-warning-handlers* (:warning-handlers opts ana/*cljs-warning-handlers*)]\n          (ana/parse-ns src dest opts)))))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/clojure/cljs/analyzer/api.cljc",
                                                  :lines [151 168]},
                                         :full-name "cljs.analyzer.api/parse-ns",
                                         :docstring "Helper for parsing only the essential namespace information from a\n   ClojureScript source file and returning a cljs.closure/IJavaScript compatible\n   map _not_ a namespace AST node.\n\n   By default does not load macros or perform any analysis of dependencies. If\n   opts parameter provided :analyze-deps and :load-macros keys their values will\n   be used for *analyze-deps* and *load-macros* bindings respectively. This\n   function does _not_ side-effect the ambient compilation environment unless\n   requested via opts where :restore is false."},
           "cljs.core/IWithMeta" {:ns "cljs.core",
                                  :name "IWithMeta",
                                  :name-encode "IWithMeta",
                                  :implementations #{"Subvec"
                                                     "Symbol"
                                                     "Cycle"
                                                     "PersistentQueue"
                                                     "PersistentHashMap"
                                                     "PersistentTreeSet"
                                                     "PersistentArrayMapSeq"
                                                     "RedNode"
                                                     "EmptyList"
                                                     "ObjMap"
                                                     "MetaFn"
                                                     "Iterate"
                                                     "BlackNode"
                                                     "PersistentVector"
                                                     "ValSeq"
                                                     "IntegerRange"
                                                     "ChunkedCons"
                                                     "Range"
                                                     "PersistentQueueSeq"
                                                     "ChunkedSeq"
                                                     "ArrayNodeSeq"
                                                     "KeySeq"
                                                     "IndexedSeq"
                                                     "PersistentTreeMap"
                                                     "PersistentTreeMapSeq"
                                                     "RSeq"
                                                     "PersistentArrayMap"
                                                     "PersistentHashSet"
                                                     "NodeSeq"
                                                     "List"
                                                     "Repeat"
                                                     "Cons"
                                                     "Var"
                                                     "LazySeq"
                                                     "MapEntry"},
                                  :history [["+" "0.0-927"]],
                                  :type "protocol",
                                  :full-name-encode "cljs.core/IWithMeta",
                                  :source {:code "(defprotocol IWithMeta\n  (^clj -with-meta [o meta]\n    \"Returns a new object with value of o and metadata meta added to it.\"))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [703 706]},
                                  :methods [{:name "-with-meta",
                                             :signature ["[o meta]"],
                                             :docstring "Returns a new object with value of o and metadata meta added to it."}],
                                  :full-name "cljs.core/IWithMeta",
                                  :docstring "Protocol for adding metadata to an object."},
           "cljs.core/bit-and-not" {:ns "cljs.core",
                                    :name "bit-and-not",
                                    :signature ["[x y]"
                                                "[x y & more]"],
                                    :name-encode "bit-and-not",
                                    :history [["+" "0.0-927"]],
                                    :type "function/macro",
                                    :full-name-encode "cljs.core/bit-and-not",
                                    :source {:code "(defn bit-and-not\n  ([x y] (cljs.core/bit-and-not x y))\n  ([x y & more]\n     (reduce bit-and-not (cljs.core/bit-and-not x y) more)))",
                                             :title "Function code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [2955 2959]},
                                    :extra-sources [{:code "(core/defmacro ^::ana/numeric bit-and-not\n  ([x y] (core/list 'js* \"(~{} & ~~{})\" x y))\n  ([x y & more] `(bit-and-not (bit-and-not ~x ~y) ~@more)))",
                                                     :title "Macro code",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/clojure/cljs/core.cljc",
                                                     :lines [1218
                                                             1220]}],
                                    :full-name "cljs.core/bit-and-not",
                                    :docstring "Bitwise and with complement"},
           "clojure.string/triml" {:return-type string,
                                   :ns "clojure.string",
                                   :name "triml",
                                   :signature ["[s]"],
                                   :name-encode "triml",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "clojure.string/triml",
                                   :source {:code "(defn ^string triml\n  [s]\n  (gstring/trimLeft s))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/clojure/string.cljs",
                                            :lines [202 205]},
                                   :full-name "clojure.string/triml",
                                   :docstring "Removes whitespace from the left side of string."},
           "cljs.core/chunk-append" {:ns "cljs.core",
                                     :name "chunk-append",
                                     :signature ["[b x]"],
                                     :name-encode "chunk-append",
                                     :history [["+" "0.0-1424"]],
                                     :type "function",
                                     :full-name-encode "cljs.core/chunk-append",
                                     :source {:code "(defn chunk-append [b x]\n  (.add b x))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/cljs/cljs/core.cljs",
                                              :lines [3716 3717]},
                                     :full-name "cljs.core/chunk-append"},
           "cljs.core/resolve" {:ns "cljs.core",
                                :name "resolve",
                                :signature ["[quoted-sym]"],
                                :name-encode "resolve",
                                :history [["+" "1.9.655"]],
                                :type "macro",
                                :full-name-encode "cljs.core/resolve",
                                :source {:code "(core/defmacro resolve\n  [quoted-sym]\n  (core/assert\n    (core/and (seq? quoted-sym)\n              (= 'quote (first quoted-sym)))\n    \"Argument to resolve must be a quoted symbol\")\n  (core/let [sym (second quoted-sym)\n             env &env\n             [var meta] (try\n                          (core/let [var (ana/resolve-var env sym (ana/confirm-var-exists-throw)) ]\n                            [var (ana/var-meta var)])\n                          (catch #?@(:clj [Throwable t] :cljs [:default e])\n                              [(ana/resolve-var env sym) nil]))\n             resolved (vary-meta (:name var) assoc ::ana/no-resolve true)]\n    `(when (exists? ~resolved)\n       (cljs.core/Var. (fn [] ~resolved) '~resolved ~meta))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/clojure/cljs/core.cljc",
                                         :lines [3429 3445]},
                                :full-name "cljs.core/resolve",
                                :docstring "Returns the var to which a symbol will be resolved in the namespace else nil."},
           "cljs.core/simple-symbol?" {:ns "cljs.core",
                                       :name "simple-symbol?",
                                       :signature ["[x]"],
                                       :name-encode "simple-symbolQMARK",
                                       :history [["+" "1.9.75"]],
                                       :type "function",
                                       :full-name-encode "cljs.core/simple-symbolQMARK",
                                       :source {:code "(defn simple-symbol?\n  [x] (and (symbol? x) (nil? (namespace x))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/core.cljs",
                                                :lines [3466 3468]},
                                       :full-name "cljs.core/simple-symbol?",
                                       :docstring "Return true if x is a symbol without a namespace"},
           "cljs.core/equiv-map" {:ns "cljs.core",
                                  :name "equiv-map",
                                  :signature ["[x y]"],
                                  :name-encode "equiv-map",
                                  :history [["+" "1.9.655"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/equiv-map",
                                  :source {:code "(defn equiv-map\n  [x y]\n  (boolean\n    (when (and (map? y) (not (record? y)))\n      ; assume all maps are counted\n      (when (== (count x) (count y))\n        (if (satisfies? IKVReduce x)\n          (reduce-kv\n            (fn [_ k v]\n              (if (= (get y k never-equiv) v)\n                true\n                (reduced false)))\n            true x)\n          (every?\n            (fn [xkv]\n              (= (get y (first xkv) never-equiv) (second xkv)))\n            x))))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [6489 6506]},
                                  :full-name "cljs.core/equiv-map",
                                  :docstring "Test map equivalence. Returns true if x equals y, otherwise returns false."},
           "clojure.string/ends-with?" {:return-type boolean,
                                        :ns "clojure.string",
                                        :name "ends-with?",
                                        :signature ["[s substr]"],
                                        :name-encode "ends-withQMARK",
                                        :history [["+" "1.7.145"]],
                                        :type "function",
                                        :full-name-encode "clojure.string/ends-withQMARK",
                                        :source {:code "(defn ^boolean ends-with?\n  [s substr]\n  (gstring/endsWith s substr))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/cljs/clojure/string.cljs",
                                                 :lines [282 285]},
                                        :full-name "clojure.string/ends-with?",
                                        :docstring "True if s ends with substr."},
           "cljs.core/bitpos" {:ns "cljs.core",
                               :name "bitpos",
                               :signature ["[hash shift]"],
                               :name-encode "bitpos",
                               :history [["+" "0.0-1211"]
                                         ["-" "1.9.493"]
                                         ["+" "1.9.494"]],
                               :type "macro",
                               :full-name-encode "cljs.core/bitpos",
                               :source {:code "(core/defmacro bitpos [hash shift]\n  (core/list 'js* \"(1 << ~{})\" `(mask ~hash ~shift)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/clojure/cljs/core.cljc",
                                        :lines [1251 1252]},
                               :full-name "cljs.core/bitpos"},
           "cljs.spec.impl.gen/cat" {:ns "cljs.spec.impl.gen",
                                     :name "cat",
                                     :signature ["[& gens]"],
                                     :name-encode "cat",
                                     :history [["+" "1.9.14"]
                                               ["-" "1.9.542"]],
                                     :type "function",
                                     :full-name-encode "cljs.spec.impl.gen/cat",
                                     :source {:code "(defn cat\n  [& gens]\n  (fmap #(apply concat %)\n    (apply tuple gens)))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.9.521",
                                              :filename "src/main/cljs/cljs/spec/impl/gen.cljs",
                                              :lines [77 82]},
                                     :full-name "cljs.spec.impl.gen/cat",
                                     :docstring "Returns a generator of a sequence catenated from results of\ngens, each of which should generate something sequential.",
                                     :removed {:in "1.9.542",
                                               :last-seen "1.9.521"}},
           "warnings/unsupported-preprocess-value" {:ns "warnings",
                                                    :name "unsupported-preprocess-value",
                                                    :name-encode "unsupported-preprocess-value",
                                                    :type "warning",
                                                    :full-name-encode "warnings/unsupported-preprocess-value",
                                                    :full-name "warnings/unsupported-preprocess-value",
                                                    :history [["+"
                                                               "1.7.48"]]},
           "compiler-options/output-dir" {:ns "compiler-options",
                                          :name "output-dir",
                                          :name-encode "output-dir",
                                          :type "option",
                                          :full-name-encode "compiler-options/output-dir",
                                          :full-name "compiler-options/output-dir",
                                          :history [["+" "0.0-971"]]},
           "cljs.core/PersistentHashSet.createAsIfByAssoc" {:ns "cljs.core",
                                                            :name "PersistentHashSet.createAsIfByAssoc",
                                                            :signature ["[items]"],
                                                            :name-encode "PersistentHashSetDOTcreateAsIfByAssoc",
                                                            :history [["+"
                                                                       "1.9.456"]],
                                                            :parent-type "PersistentHashSet",
                                                            :type "function",
                                                            :full-name-encode "cljs.core/PersistentHashSetDOTcreateAsIfByAssoc",
                                                            :source {:code "(set! (.-createAsIfByAssoc PersistentHashSet)\n      (fn [items]\n        (let [len (alength items)\n              t (-as-transient (.-EMPTY PersistentHashSet))]\n          (dotimes [i len] (-conj! t (aget items i)))\n          (-persistent! t))))",
                                                                     :title "Source code",
                                                                     :repo "clojurescript",
                                                                     :tag "r1.12.38",
                                                                     :filename "src/main/cljs/cljs/core.cljs",
                                                                     :lines [9500
                                                                             9505]},
                                                            :full-name "cljs.core/PersistentHashSet.createAsIfByAssoc"},
           "syntax/character" {:syntax-equiv {:edn-url nil,
                                              :clj-url nil},
                               :ns "syntax",
                               :name "character",
                               :name-encode "character",
                               :history [["+" "0.0-1853"]],
                               :type "syntax",
                               :full-name-encode "syntax/character",
                               :extra-sources ({:code "(defn- read-char*\n  [rdr backslash opts pending-forms]\n  (let [ch (read-char rdr)]\n    (if-not (nil? ch)\n      (let [token (if (or (macro-terminating? ch)\n                          (whitespace? ch))\n                    (str ch)\n                    (read-token rdr :character ch))\n            token-len (count token)]\n        (cond\n\n         (== 1 token-len)  (Character/valueOf (nth token 0))\n\n         (= token \"newline\") \\newline\n         (= token \"space\") \\space\n         (= token \"tab\") \\tab\n         (= token \"backspace\") \\backspace\n         (= token \"formfeed\") \\formfeed\n         (= token \"return\") \\return\n\n         (.startsWith token \"u\")\n         (let [c (read-unicode-char token 1 4 16)\n               ic (int c)]\n           (if (and (> ic upper-limit)\n                    (< ic lower-limit))\n             (err/throw-invalid-character-literal rdr (Integer/toString ic 16))\n             c))\n\n         (.startsWith token \"o\")\n         (let [len (dec token-len)]\n           (if (> len 3)\n             (err/throw-invalid-octal-len rdr token)\n             (let [uc (read-unicode-char token 1 len 8)]\n               (if (> (int uc) 0377)\n                 (err/throw-bad-octal-number rdr)\n                 uc))))\n\n         :else (err/throw-unsupported-character rdr token)))\n      (err/throw-eof-in-character rdr))))",
                                                :title "Reader code",
                                                :repo "tools.reader",
                                                :tag "v1.3.6",
                                                :filename "src/main/clojure/clojure/tools/reader.clj",
                                                :lines [138 177]}
                                               {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                                :title "Reader table",
                                                :repo "tools.reader",
                                                :tag "v1.3.6",
                                                :filename "src/main/clojure/clojure/tools/reader.clj",
                                                :lines [788 807]}),
                               :full-name "syntax/character"},
           "cljs.spec.gen.alpha/string-ascii" {:ns "cljs.spec.gen.alpha",
                                               :name "string-ascii",
                                               :signature ["[& args]"],
                                               :name-encode "string-ascii",
                                               :history [["+"
                                                          "1.9.542"]],
                                               :type "function",
                                               :full-name-encode "cljs.spec.gen.alpha/string-ascii",
                                               :source {:code "(lazy-prims any any-printable boolean char char-alpha char-alphanumeric char-ascii double\n  int keyword keyword-ns large-integer ratio simple-type simple-type-printable\n  string string-ascii string-alphanumeric symbol symbol-ns uuid)",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.12.38",
                                                        :filename "src/main/cljs/cljs/spec/gen/alpha.cljs",
                                                        :lines [74 76]},
                                               :full-name "cljs.spec.gen.alpha/string-ascii",
                                               :docstring "Fn returning clojure.test.check.generators/string-ascii"},
           "cljs.core/print-meta?" {:ns "cljs.core",
                                    :name "print-meta?",
                                    :signature ["[opts obj]"],
                                    :name-encode "print-metaQMARK",
                                    :history [["+" "1.7.10"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/print-metaQMARK",
                                    :source {:code "(defn print-meta? [opts obj]\n  (and (boolean (get opts :meta))\n       (implements? IMeta obj)\n       (not (nil? (meta obj)))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [10494 10497]},
                                    :full-name "cljs.core/print-meta?"},
           "syntax/unreadable" {:syntax-equiv {:edn-url nil,
                                               :clj-url nil},
                                :ns "syntax",
                                :name "unreadable",
                                :name-encode "unreadable",
                                :history [["+" "0.0-1853"]],
                                :type "syntax",
                                :full-name-encode "syntax/unreadable",
                                :extra-sources ({:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    \\? read-cond\n    \\: read-namespaced-map\n    \\# read-symbolic-value\n    nil))",
                                                 :title "Reader table",
                                                 :repo "tools.reader",
                                                 :tag "v1.3.6",
                                                 :filename "src/main/clojure/clojure/tools/reader.clj",
                                                 :lines [809 823]}),
                                :full-name "syntax/unreadable"},
           "cljs.core/regexp?" {:ns "cljs.core",
                                :name "regexp?",
                                :signature ["[x]"],
                                :name-encode "regexpQMARK",
                                :history [["+" "0.0-1424"]],
                                :type "function",
                                :full-name-encode "cljs.core/regexpQMARK",
                                :source {:code "(defn regexp?\n  [x]\n  (instance? js/RegExp x))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [10374 10377]},
                                :full-name "cljs.core/regexp?",
                                :docstring "Returns true if x is a JavaScript RegExp instance."},
           "cljs.spec.test.alpha/check" {:ns "cljs.spec.test.alpha",
                                         :name "check",
                                         :signature ["[]"
                                                     "[sym-or-syms]"
                                                     "[sym-or-syms opts]"],
                                         :name-encode "check",
                                         :history [["+" "1.9.542"]],
                                         :type "macro",
                                         :full-name-encode "cljs.spec.test.alpha/check",
                                         :source {:code "(defmacro check\n  ([]\n   `(check ^::no-eval '~(checkable-syms*)))\n  ([sym-or-syms]\n   `(check ~sym-or-syms nil))\n  ([sym-or-syms opts]\n   (let [syms (sym-or-syms->syms (form->sym-or-syms sym-or-syms))\n         opts-sym (gensym \"opts\")]\n     `(if (and (cljs.core/exists? clojure.test.check)\n               (cljs.core/exists? clojure.test.check.properties))\n        (let [~opts-sym ~opts]\n          [~@(->> syms\n                  (filter (checkable-syms* opts))\n                  (map\n                   (fn [sym]\n                     (do `(check-1 '~sym nil nil ~opts-sym)))))])\n        (throw\n         (js/Error. (str \"Require clojure.test.check and \"\n                         \"clojure.test.check.properties before calling check.\")))))))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/cljs/cljs/spec/test/alpha.cljc",
                                                  :lines [258 309]},
                                         :full-name "cljs.spec.test.alpha/check",
                                         :docstring "Run generative tests for spec conformance on vars named by\nsym-or-syms, a symbol or collection of symbols. If sym-or-syms\nis not specified, check all checkable vars. If a symbol identifies a\nnamespace then all symbols in that namespace will be enumerated.\n\nThe opts map includes the following optional keys, where stc\naliases clojure.spec.test.check:\n\n::stc/opts  opts to flow through test.check/quick-check\n:gen        map from spec names to generator overrides\n\nThe ::stc/opts include :num-tests in addition to the keys\ndocumented by test.check. Generator overrides are passed to\nspec/gen when generating function args.\n\nReturns a lazy sequence of check result maps with the following\nkeys\n\n:spec       the spec tested\n:sym        optional symbol naming the var tested\n:failure    optional test failure\n::stc/ret   optional value returned by test.check/quick-check\n\nThe value for :failure can be any exception. Exceptions thrown by\nspec itself will have an ::s/failure value in ex-data:\n\n:check-failed   at least one checked return did not conform\n:no-args-spec   no :args spec provided\n:no-fn          no fn provided\n:no-fspec       no fspec provided\n:no-gen         unable to generate :args\n:instrument     invalid args detected by instrument\n"},
           "clojure.string/split" {:ns "clojure.string",
                                   :name "split",
                                   :signature ["[s re]"
                                               "[s re limit]"],
                                   :name-encode "split",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "clojure.string/split",
                                   :source {:code "(defn split\n  ([s re]\n     (split s re 0))\n    ([s re limit]\n     (discard-trailing-if-needed limit\n       (if (identical? \"/(?:)/\" (str re))\n         (split-with-empty-regex s limit)\n         (if (< limit 1)\n           (vec (.split (str s) re))\n           (loop [s s\n                  limit limit\n                  parts []]\n             (if (== 1 limit)\n               (conj parts s)\n               (let [m (re-find re s)]\n                 (if-not (nil? m)\n                   (let [index (.indexOf s m)]\n                     (recur (.substring s (+ index (count m)))\n                       (dec limit)\n                       (conj parts (.substring s 0 index))))\n                   (conj parts s))))))))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/clojure/string.cljs",
                                            :lines [167 190]},
                                   :full-name "clojure.string/split",
                                   :docstring "Splits string on a regular expression. Optional argument limit is\nthe maximum number of parts. Not lazy. Returns vector of the parts.\nTrailing empty strings are not returned - pass limit of -1 to return all."},
           "cljs.spec.alpha/speced-vars" {:ns "cljs.spec.alpha",
                                          :name "speced-vars",
                                          :signature ["[]"],
                                          :name-encode "speced-vars",
                                          :history [["+" "1.9.542"]],
                                          :type "function",
                                          :full-name-encode "cljs.spec.alpha/speced-vars",
                                          :source {:code "(defn speced-vars []\n  @_speced_vars)",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/cljs/cljs/spec/alpha.cljc",
                                                   :lines [65 66]},
                                          :full-name "cljs.spec.alpha/speced-vars"},
           "cljs.reader/read-4-chars" {:ns "cljs.reader",
                                       :name "read-4-chars",
                                       :signature ["[reader]"],
                                       :name-encode "read-4-chars",
                                       :history [["+" "0.0-1424"]
                                                 ["-" "1.9.854"]],
                                       :type "function",
                                       :full-name-encode "cljs.reader/read-4-chars",
                                       :source {:code "(defn read-4-chars [reader]\n  (.toString\n    (StringBuffer.\n      (read-char reader)\n      (read-char reader)\n      (read-char reader)\n      (read-char reader))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.9.671",
                                                :filename "src/main/cljs/cljs/reader.cljs",
                                                :lines [174 180]},
                                       :full-name "cljs.reader/read-4-chars",
                                       :removed {:in "1.9.854",
                                                 :last-seen "1.9.671"}},
           "cljs.pprint/with-pprint-dispatch" {:ns "cljs.pprint",
                                               :name "with-pprint-dispatch",
                                               :signature ["[function & body]"],
                                               :name-encode "with-pprint-dispatch",
                                               :history [["+"
                                                          "0.0-3255"]],
                                               :type "macro",
                                               :full-name-encode "cljs.pprint/with-pprint-dispatch",
                                               :source {:code "(defmacro with-pprint-dispatch\n  [function & body]\n  `(cljs.core/binding [cljs.pprint/*print-pprint-dispatch* ~function]\n     ~@body))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.12.38",
                                                        :filename "src/main/cljs/cljs/pprint.cljc",
                                                        :lines [157
                                                                161]},
                                               :full-name "cljs.pprint/with-pprint-dispatch",
                                               :docstring "Execute body with the pretty print dispatch function bound to function."},
           "cljs.core/iteration" {:ns "cljs.core",
                                  :name "iteration",
                                  :signature ["[step & {:keys [somef vf kf initk], :or {vf identity, kf identity, somef some?, initk nil}}]"],
                                  :name-encode "iteration",
                                  :history [["+" "0.0-2301"]
                                            ["-" "0.0-2371"]
                                            ["+" "1.11.50"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/iteration",
                                  :source {:code "(defn iteration\n  {:added \"1.11\"}\n  [step & {:keys [somef vf kf initk]\n           :or {vf identity\n                kf identity\n                somef some?\n                initk nil}}]\n  (reify\n    ISeqable\n    (-seq [_]\n      ((fn next [ret]\n         (when (somef ret)\n           (cons (vf ret)\n             (when-some [k (kf ret)]\n               (lazy-seq (next (step k)))))))\n       (step initk)))\n    IReduce\n    (-reduce [_ rf init]\n      (loop [acc init\n             ret (step initk)]\n        (if (somef ret)\n          (let [acc (rf acc (vf ret))]\n            (if (reduced? acc)\n              @acc\n              (if-some [k (kf ret)]\n                (recur acc (step k))\n                acc)))\n          acc)))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [11113 11154]},
                                  :full-name "cljs.core/iteration",
                                  :docstring "Creates a seqable/reducible via repeated calls to step,\na function of some (continuation token) 'k'. The first call to step\nwill be passed initk, returning 'ret'. Iff (somef ret) is true,\n(vf ret) will be included in the iteration, else iteration will\nterminate and vf/kf will not be called. If (kf ret) is non-nil it\nwill be passed to the next step call, else iteration will terminate.\nThis can be used e.g. to consume APIs that return paginated or batched data.\n step - (possibly impure) fn of 'k' -> 'ret'\n :somef - fn of 'ret' -> logical true/false, default 'some?'\n :vf - fn of 'ret' -> 'v', a value produced by the iteration, default 'identity'\n :kf - fn of 'ret' -> 'next-k' or nil (signaling 'do not continue'), default 'identity'\n :initk - the first value passed to step, default 'nil'\nIt is presumed that step with non-initk is unreproducible/non-idempotent.\nIf step with initk is unreproducible it is on the consumer to not consume twice."},
           "cljs.core/simple-ident?" {:ns "cljs.core",
                                      :name "simple-ident?",
                                      :signature ["[x]"],
                                      :name-encode "simple-identQMARK",
                                      :history [["+" "1.9.75"]],
                                      :type "function",
                                      :full-name-encode "cljs.core/simple-identQMARK",
                                      :source {:code "(defn simple-ident?\n  [x] (and (ident? x) (nil? (namespace x))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [3458 3460]},
                                      :full-name "cljs.core/simple-ident?",
                                      :docstring "Return true if x is a symbol or keyword without a namespace"},
           "cljs.core/hash-map" {:ns "cljs.core",
                                 :name "hash-map",
                                 :signature ["[& keyvals]"],
                                 :name-encode "hash-map",
                                 :history [["+" "0.0-927"]],
                                 :type "function/macro",
                                 :full-name-encode "cljs.core/hash-map",
                                 :source {:code "(defn hash-map\n  [& keyvals]\n  (loop [in (seq keyvals), out (transient (.-EMPTY PersistentHashMap))]\n    (if in\n      (let [in' (next in)]\n        (if (nil? in')\n          (throw (js/Error. (str \"No value supplied for key: \" (first in))))\n          (recur (next in') (assoc! out (first in) (first in')) )))\n      (persistent! out))))",
                                          :title "Function code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [9114 9124]},
                                 :extra-sources [{:code "(core/defmacro hash-map\n  ([] `(.-EMPTY cljs.core/PersistentHashMap))\n  ([& kvs]\n   (core/let [pairs (map\n                      (core/fn [pair]\n                        (remove #{::missing} pair))\n                      (partition 2 2 (repeat ::missing) kvs))\n              ks    (map first pairs)\n              vs    (map second (take-while #(= 2 (count %)) pairs))]\n     (vary-meta\n       `(.fromArrays cljs.core/PersistentHashMap (array ~@ks) (array ~@vs))\n       assoc :tag 'cljs.core/PersistentHashMap))))",
                                                  :title "Macro code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/clojure/cljs/core.cljc",
                                                  :lines [2649 2660]}],
                                 :full-name "cljs.core/hash-map",
                                 :docstring "keyval => key val\nReturns a new hash map with supplied mappings."},
           "cljs.core/mapv" {:ns "cljs.core",
                             :name "mapv",
                             :signature ["[f coll]"
                                         "[f c1 c2]"
                                         "[f c1 c2 c3]"
                                         "[f c1 c2 c3 & colls]"],
                             :name-encode "mapv",
                             :history [["+" "0.0-1211"]],
                             :type "function",
                             :full-name-encode "cljs.core/mapv",
                             :source {:code "(defn mapv\n  ([f coll]\n     (-> (reduce (fn [v o] (conj! v (f o))) (transient []) coll)\n         persistent!))\n  ([f c1 c2]\n     (into [] (map f c1 c2)))\n  ([f c1 c2 c3]\n     (into [] (map f c1 c2 c3)))\n  ([f c1 c2 c3 & colls]\n     (into [] (apply map f c1 c2 c3 colls))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [5356 5370]},
                             :full-name "cljs.core/mapv",
                             :docstring "Returns a vector consisting of the result of applying f to the\nset of first items of each coll, followed by applying f to the set\nof second items in each coll, until any one of the colls is\nexhausted.  Any remaining items in other colls are ignored. Function\nf should accept number-of-colls arguments."},
           "cljs.core/rem" {:ns "cljs.core",
                            :name "rem",
                            :signature ["[n d]"],
                            :name-encode "rem",
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core/rem",
                            :source {:code "(defn rem\n  [n d]\n  (let [q (quot n d)]\n    (- n (* d q))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [2931 2935]},
                            :full-name "cljs.core/rem",
                            :docstring "remainder of dividing numerator by denominator."},
           "cljs.core/IRecord" {:ns "cljs.core",
                                :name "IRecord",
                                :name-encode "IRecord",
                                :history [["+" "0.0-927"]],
                                :type "protocol",
                                :full-name-encode "cljs.core/IRecord",
                                :source {:code "(defprotocol IRecord)",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [744 745]},
                                :full-name "cljs.core/IRecord",
                                :docstring "Marker interface indicating a record object"},
           "cljs.spec.alpha/conform" {:ns "cljs.spec.alpha",
                                      :name "conform",
                                      :signature ["[spec x]"],
                                      :name-encode "conform",
                                      :history [["+" "1.9.542"]],
                                      :type "function",
                                      :full-name-encode "cljs.spec.alpha/conform",
                                      :source {:code "(defn conform\n  [spec x]\n  (conform* (specize spec) x))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/spec/alpha.cljs",
                                               :lines [168 172]},
                                      :full-name "cljs.spec.alpha/conform",
                                      :docstring "Given a spec and a value, returns :cljs.spec.alpha/invalid if value does\nnot match spec, else the (possibly destructured) value."},
           "cljs.core/unsafe-cast" {:ns "cljs.core",
                                    :name "unsafe-cast",
                                    :signature ["[t x]"],
                                    :name-encode "unsafe-cast",
                                    :history [["+" "1.7.107"]],
                                    :type "macro",
                                    :full-name-encode "cljs.core/unsafe-cast",
                                    :source {:code "(core/defmacro unsafe-cast\n  [t x]\n  (core/let [cast-expr (core/str \"~{} = /** @type {\" t \"} */ (~{})\")]\n    (core/list 'js* cast-expr x x)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/clojure/cljs/core.cljc",
                                             :lines [953 957]},
                                    :full-name "cljs.core/unsafe-cast",
                                    :docstring "EXPERIMENTAL: Subject to change. Unsafely cast a value to a different type."},
           "clojure.edn/read-string" {:ns "clojure.edn",
                                      :name "read-string",
                                      :signature ["[s]" "[opts s]"],
                                      :name-encode "read-string",
                                      :history [["+" "1.10.514"]],
                                      :type "function",
                                      :full-name-encode "clojure.edn/read-string",
                                      :source {:code "(defn read-string\n  ([s]\n   (reader/read-string s))\n  ([opts s]\n   (reader/read-string opts s)))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/clojure/edn.cljs",
                                               :lines [44 55]},
                                      :full-name "clojure.edn/read-string",
                                      :docstring "Reads one object from the string s.\nReturns nil when s is nil or empty.\n\nReads data in the edn format (subset of Clojure data):\nhttp://edn-format.org\n\nopts is a map as per cljs.tools.reader.edn/read"},
           "warnings/protocol-with-variadic-method" {:ns "warnings",
                                                     :name "protocol-with-variadic-method",
                                                     :name-encode "protocol-with-variadic-method",
                                                     :type "warning",
                                                     :full-name-encode "warnings/protocol-with-variadic-method",
                                                     :full-name "warnings/protocol-with-variadic-method",
                                                     :history [["+"
                                                                "1.7.166"]]},
           "cljs.core/RangedIterator" {:ns "cljs.core",
                                       :name "RangedIterator",
                                       :signature ["[i base arr v start end]"],
                                       :name-encode "RangedIterator",
                                       :history [["+" "0.0-2371"]],
                                       :type "type",
                                       :full-name-encode "cljs.core/RangedIterator",
                                       :source {:code "(deftype RangedIterator [^:mutable i ^:mutable base ^:mutable arr v start end]\n  Object\n  (hasNext [this]\n    (< i end))\n  (next [this]\n    (when (== (- i base) 32)\n      (set! arr (unchecked-array-for v i))\n      (set! base (+ base 32)))\n    (let [ret (aget arr (bit-and i 0x01f))]\n      (set! i (inc i))\n      ret)))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/core.cljs",
                                                :lines [5578 5588]},
                                       :full-name "cljs.core/RangedIterator"},
           "cljs.math/negate-exact" {:return-type number,
                                     :ns "cljs.math",
                                     :name "negate-exact",
                                     :signature ["[a]"],
                                     :name-encode "negate-exact",
                                     :history [["+" "1.11.50"]],
                                     :type "function",
                                     :full-name-encode "cljs.math/negate-exact",
                                     :source {:code "(defn ^number negate-exact\n  {:added \"1.11.10\"}\n  [a]\n  (if (or (> a js/Number.MAX_SAFE_INTEGER) (< a js/Number.MIN_SAFE_INTEGER))\n    (throw (ex-info \"Integer overflow\" {:fn \"negate-exact\"}))\n    (- a)))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/cljs/cljs/math.cljs",
                                              :lines [559 565]},
                                     :full-name "cljs.math/negate-exact",
                                     :docstring "Returns the negation of a, throws ArithmeticException on overflow. "},
           "cljs.core/volatile!" {:ns "cljs.core",
                                  :name "volatile!",
                                  :signature ["[val]"],
                                  :name-encode "volatileBANG",
                                  :history [["+" "0.0-2496"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/volatileBANG",
                                  :source {:code "(defn volatile!\n  [val]\n  (Volatile. val))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [4680 4683]},
                                  :full-name "cljs.core/volatile!",
                                  :docstring "Creates and returns a Volatile with an initial value of val."},
           "cljs.core/constantly" {:ns "cljs.core",
                                   :name "constantly",
                                   :signature ["[x]"],
                                   :name-encode "constantly",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/constantly",
                                   :source {:code "(defn constantly\n  [x] (fn [& args] x))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [4370 4372]},
                                   :full-name "cljs.core/constantly",
                                   :docstring "Returns a function that takes any number of arguments and returns x."},
           "cljs.test/*current-env*" {:ns "cljs.test",
                                      :name "*current-env*",
                                      :name-encode "STARcurrent-envSTAR",
                                      :type "dynamic var",
                                      :full-name-encode "cljs.test/STARcurrent-envSTAR",
                                      :source {:code "(def ^:dynamic *current-env* nil)",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/test.cljs",
                                               :lines [269]},
                                      :full-name "cljs.test/*current-env*",
                                      :history [["+" "0.0-2496"]]},
           "clojure.browser.dom/get-element" {:ns "clojure.browser.dom",
                                              :name "get-element",
                                              :signature ["[id]"],
                                              :name-encode "get-element",
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "clojure.browser.dom/get-element",
                                              :source {:code "(defn get-element [id]\n  (gdom/getElement (name id)))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.12.38",
                                                       :filename "src/main/cljs/clojure/browser/dom.cljs",
                                                       :lines [98 99]},
                                              :full-name "clojure.browser.dom/get-element"},
           "cljs.core/PersistentQueueIter" {:ns "cljs.core",
                                            :name "PersistentQueueIter",
                                            :signature ["[fseq riter]"],
                                            :name-encode "PersistentQueueIter",
                                            :history [["+" "1.7.28"]],
                                            :type "type",
                                            :full-name-encode "cljs.core/PersistentQueueIter",
                                            :source {:code "(deftype PersistentQueueIter [^:mutable fseq riter]\n  Object\n  (hasNext [_]\n    (or (and (some? fseq) (seq fseq)) (and (some? riter) (.hasNext riter))))\n  (next [_]\n    (cond\n      (some? fseq)\n      (let [ret (first fseq)]\n        (set! fseq (next fseq))\n        ret)\n      (and (some? riter) ^boolean (.hasNext riter))\n      (.next riter)\n      :else (throw (js/Error. \"No such element\"))))\n  (remove [_] (js/Error. \"Unsupported operation\")))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/cljs/cljs/core.cljs",
                                                     :lines [6334
                                                             6347]},
                                            :full-name "cljs.core/PersistentQueueIter"},
           "cljs.core/UUID" {:protocols #{"IUUID"
                                          "IHash"
                                          "IComparable"
                                          "IPrintWithWriter"
                                          "IEquiv"},
                             :ns "cljs.core",
                             :name "UUID",
                             :signature ["[uuid __hash]"],
                             :name-encode "UUID",
                             :history [["+" "0.0-1424"]],
                             :type "type",
                             :full-name-encode "cljs.core/UUID",
                             :source {:code "(deftype UUID [uuid ^:mutable __hash]\n  IUUID\n\n  Object\n  (toString [_] uuid)\n  (equiv [this other]\n    (-equiv this other))\n\n  IEquiv\n  (-equiv [_ other]\n    (and (implements? IUUID other) (identical? uuid (.-uuid other))))\n\n  IPrintWithWriter\n  (-pr-writer [_ writer _]\n    (-write writer (str \"#uuid \\\"\" uuid \"\\\"\")))\n\n  IHash\n  (-hash [this]\n    (when (nil? __hash)\n      (set! __hash (hash uuid)))\n    __hash)\n\n  IComparable\n  (-compare [this other]\n    (if (instance? UUID other)\n      (garray/defaultCompare uuid (.-uuid other))\n      (throw (js/Error. (str \"Cannot compare \" this \" to \" other))))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [11711 11737]},
                             :full-name "cljs.core/UUID"},
           "warnings/overload-arity" {:ns "warnings",
                                      :name "overload-arity",
                                      :name-encode "overload-arity",
                                      :type "warning",
                                      :full-name-encode "warnings/overload-arity",
                                      :full-name "warnings/overload-arity",
                                      :history [["+" "0.0-2014"]]},
           "clojure.core.reducers/reduce" {:ns "clojure.core.reducers",
                                           :name "reduce",
                                           :signature ["[f coll]"
                                                       "[f init coll]"],
                                           :name-encode "reduce",
                                           :history [["+" "0.0-1236"]],
                                           :type "function",
                                           :full-name-encode "clojure.core.reducers/reduce",
                                           :source {:code "(defn reduce\n  ([f coll] (reduce f (f) coll))\n  ([f init coll]\n     (if (map? coll)\n       (-kv-reduce coll f init)\n       (cond\n         (nil? coll) init\n         (array? coll) (#'array-reduce coll f init)\n         :else (-reduce coll f init)))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/cljs/clojure/core/reducers.cljs",
                                                    :lines [33 44]},
                                           :full-name "clojure.core.reducers/reduce",
                                           :docstring "Like core/reduce except:\n  When init is not provided, (f) is used.\n  Maps are reduced with reduce-kv"},
           "cljs.core/and" {:ns "cljs.core",
                            :name "and",
                            :signature ["[]" "[x]" "[x & next]"],
                            :name-encode "and",
                            :history [["+" "0.0-927"]],
                            :type "macro",
                            :full-name-encode "cljs.core/and",
                            :source {:code "(core/defmacro and\n  ([] true)\n  ([x] x)\n  ([x & next]\n   `(let [and# ~x]\n      (if and# (and ~@next) and#))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/clojure/cljs/core.cljc",
                                     :lines [877 886]},
                            :full-name "cljs.core/and",
                            :docstring "Evaluates exprs one at a time, from left to right. If a form\nreturns logical false (nil or false), and returns that value and\ndoesn't evaluate any of the other expressions, otherwise it returns\nthe value of the last expr. (and) returns true."},
           "cljs.js/js-eval" {:ns "cljs.js",
                              :name "js-eval",
                              :signature ["[{:keys [source], :as resource}]"],
                              :name-encode "js-eval",
                              :history [["+" "1.7.10"]],
                              :type "function",
                              :full-name-encode "cljs.js/js-eval",
                              :source {:code "(defn js-eval\n  [{:keys [source] :as resource}]\n  (js/eval source))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/js.cljs",
                                       :lines [121 124]},
                              :full-name "cljs.js/js-eval",
                              :docstring "A default JavaScript evaluation function."},
           "clojure.browser.repl/wrap-message" {:ns "clojure.browser.repl",
                                                :name "wrap-message",
                                                :signature ["[repl t data]"],
                                                :name-encode "wrap-message",
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "clojure.browser.repl/wrap-message",
                                                :source {:code "(defn wrap-message [repl t data]\n  (pr-str\n    {:repl repl\n     :type t\n     :content data\n     :order (swap! order inc)}))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1.12.38",
                                                         :filename "src/main/cljs/clojure/browser/repl.cljs",
                                                         :lines [98
                                                                 103]},
                                                :full-name "clojure.browser.repl/wrap-message"},
           "cljs.spec/speced-vars*" {:ns "cljs.spec",
                                     :name "speced-vars*",
                                     :signature ["[]" "[ns-syms]"],
                                     :name-encode "speced-varsSTAR",
                                     :history [["+" "1.9.14"]
                                               ["-" "1.9.183"]],
                                     :type "function",
                                     :full-name-encode "cljs.spec/speced-varsSTAR",
                                     :source {:code "(defn speced-vars*\n  ([]\n    (speced-vars* nil))\n  ([ns-syms]\n   (let [ns-match? (if (seq ns-syms)\n                     (set (map second ns-syms))\n                     (constantly true))]\n     (reduce\n       (fn [ret sym]\n         (if (ns-match? (symbol (namespace sym)))\n           (conj ret (list 'var sym))\n           ret))\n       #{} @_speced_vars))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.9.93",
                                              :filename "src/main/cljs/cljs/spec.cljc",
                                              :lines [323 335]},
                                     :full-name "cljs.spec/speced-vars*",
                                     :removed {:in "1.9.183",
                                               :last-seen "1.9.93"}},
           "cljs.core/parse-boolean" {:ns "cljs.core",
                                      :name "parse-boolean",
                                      :signature ["[s]"],
                                      :name-encode "parse-boolean",
                                      :history [["+" "1.11.50"]],
                                      :type "function",
                                      :full-name-encode "cljs.core/parse-boolean",
                                      :source {:code "(defn parse-boolean\n  [s]\n  (if (string? s)\n    (case s\n      \"true\" true\n      \"false\" false\n      nil)\n    (throw (js/Error. (parsing-err s)))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [12279 12288]},
                                      :full-name "cljs.core/parse-boolean",
                                      :docstring "Parse strings \"true\" or \"false\" and return a boolean, or nil if invalid. Note that this explicitly\nexcludes strings with different cases, or space characters."},
           "cljs.reader/deregister-tag-parser!" {:ns "cljs.reader",
                                                 :name "deregister-tag-parser!",
                                                 :signature ["[tag]"],
                                                 :name-encode "deregister-tag-parserBANG",
                                                 :history [["+"
                                                            "0.0-1424"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.reader/deregister-tag-parserBANG",
                                                 :source {:code "(defn deregister-tag-parser!\n  [tag]\n  (let [old-parser (get @*tag-table* tag)]\n    (swap! *tag-table* dissoc tag)\n    old-parser))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r1.12.38",
                                                          :filename "src/main/cljs/cljs/reader.cljs",
                                                          :lines [198
                                                                  202]},
                                                 :full-name "cljs.reader/deregister-tag-parser!"},
           "clojure.reflect/print-doc" {:ns "clojure.reflect",
                                        :name "print-doc",
                                        :signature ["[{:keys [name method-params doc]}]"],
                                        :name-encode "print-doc",
                                        :history [["+" "0.0-1503"]],
                                        :type "function",
                                        :full-name-encode "clojure.reflect/print-doc",
                                        :source {:code "(defn print-doc [{:keys [name method-params doc]}]\n  (when-not (empty? name)\n    (println name)\n    (println method-params)\n    (println doc)))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/cljs/clojure/reflect.cljs",
                                                 :lines [47 51]},
                                        :full-name "clojure.reflect/print-doc"},
           "clojure.browser.event/unlisten-by-key" {:ns "clojure.browser.event",
                                                    :name "unlisten-by-key",
                                                    :signature ["[key]"],
                                                    :name-encode "unlisten-by-key",
                                                    :history [["+"
                                                               "0.0-927"]],
                                                    :type "function",
                                                    :full-name-encode "clojure.browser.event/unlisten-by-key",
                                                    :source {:code "(defn unlisten-by-key\n  [key]\n  (events/unlistenByKey key))",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r1.12.38",
                                                             :filename "src/main/cljs/clojure/browser/event.cljs",
                                                             :lines [73
                                                                     75]},
                                                    :full-name "clojure.browser.event/unlisten-by-key"},
           "cljs.core/new" {:ns "cljs.core",
                            :name "new",
                            :signature ["[Constructor. args*]"
                                        "[Constructor args*]"],
                            :name-encode "new",
                            :history [["+" "0.0-927"]],
                            :type "special form",
                            :full-name-encode "cljs.core/new",
                            :source {:code "(defmethod parse 'new\n  [_ env [_ ctor & args :as form] _ _]\n  (disallowing-recur\n   (let [enve (assoc env :context :expr)\n         ctorexpr (analyze enve ctor)\n         ctor-var (when (#{:var :local :js-var} (:op ctorexpr))\n                    (resolve-existing-var env ctor))\n         record-args\n         (when (and (:record ctor-var) (not (-> ctor meta :internal-ctor)))\n           (repeat 3 (analyze enve nil)))\n         argexprs (into (vec (map #(analyze enve %) args)) record-args)\n         known-num-fields (:num-fields ctor-var)\n         argc (count args)]\n     (when (and (not (-> ctor meta :internal-ctor))\n                (some? known-num-fields)\n                (not (or (= known-num-fields argc)\n                         (and (:record ctor-var)\n                              (= (+ 2 known-num-fields) argc)))))\n       (warning :fn-arity env {:argc argc :ctor ctor}))\n     {:env env :op :new :form form :class ctorexpr :args argexprs\n      :children [:class :args]\n      :tag (let [tag (-> ctorexpr :info :tag)]\n             (if (and (js-tag? tag)\n                      (not (prim-ctor? tag)))\n               'js ; some foreign thing, drop the prefix\n               (let [name (-> ctorexpr :info :name)]\n                 (or (js-prim-ctor->tag name) name))))})))",
                                     :title "Parser code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/clojure/cljs/analyzer.cljc",
                                     :lines [2599 2625]},
                            :extra-sources ({:code "(defmethod emit* :new\n  [{ctor :class :keys [args env]}]\n  (emit-wrap env\n             (emits \"(new \" ctor \"(\"\n                    (comma-sep args)\n                    \"))\")))",
                                             :title "Emitting code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/clojure/cljs/compiler.cljc",
                                             :lines [1256 1261]}),
                            :full-name "cljs.core/new",
                            :docstring "The args, if any, are evaluated from left to right, and\npassed to the JavaScript constructor. The constructed object is\nreturned."},
           "compiler-options/closure-variable-map-in" {:ns "compiler-options",
                                                       :name "closure-variable-map-in",
                                                       :name-encode "closure-variable-map-in",
                                                       :type "option",
                                                       :full-name-encode "compiler-options/closure-variable-map-in",
                                                       :full-name "compiler-options/closure-variable-map-in",
                                                       :history [["+"
                                                                  "1.10.63"]]},
           "cljs.core/try" {:ns "cljs.core",
                            :name "try",
                            :signature ["[expr* catch-clause* finally-clause?]"],
                            :name-encode "try",
                            :history [["+" "0.0-927"]],
                            :type "special form",
                            :full-name-encode "cljs.core/try",
                            :source {:code "(defmethod parse 'try\n  [op env [_ & body :as form] name _]\n  (let [catchenv (update-in env [:context] #(if (= :expr %) :return %))\n        catch? (every-pred seq? #(= (first %) 'catch))\n        default? (every-pred catch? #(= (second %) :default))\n        finally? (every-pred seq? #(= (first %) 'finally))\n\n        {:keys [body cblocks dblock fblock]}\n        (loop [parser {:state :start :forms body\n                       :body [] :cblocks [] :dblock nil :fblock nil}]\n          (if (seq? (:forms parser))\n            (let [[form & forms*] (:forms parser)\n                  parser* (assoc parser :forms forms*)]\n              (case (:state parser)\n                :start (cond\n                         (catch? form) (recur (assoc parser :state :catches))\n                         (finally? form) (recur (assoc parser :state :finally))\n                         :else (recur (update-in parser* [:body] conj form)))\n                :catches (cond\n                           (default? form) (recur (assoc parser* :dblock form :state :finally))\n                           (catch? form) (recur (update-in parser* [:cblocks] conj form))\n                           (finally? form) (recur (assoc parser :state :finally))\n                           :else (throw (error env \"Invalid try form\")))\n                :finally (recur (assoc parser* :fblock form :state :done))\n                :done (throw (error env \"Unexpected form after finally\"))))\n            parser))\n\n        finally (when (seq fblock)\n                  (-> (disallowing-recur (analyze (assoc env :context :statement) `(do ~@(rest fblock))))\n                      (assoc :body? true)))\n        e (when (or (seq cblocks) dblock) (gensym \"e\"))\n        default (if-let [[_ _ name & cb] dblock]\n                  `(cljs.core/let [~name ~e] ~@cb)\n                  `(throw ~e))\n        cblock (if (seq cblocks)\n                 `(cljs.core/cond\n                   ~@(mapcat\n                      (fn [[_ type name & cb]]\n                        (when name (assert (not (namespace name)) \"Can't qualify symbol in catch\"))\n                        `[(cljs.core/instance? ~type ~e)\n                          (cljs.core/let [~name ~e] ~@cb)])\n                      cblocks)\n                   :else ~default)\n                 default)\n        locals (:locals catchenv)\n        locals (if e\n                 (assoc locals e\n                        {:name e\n                         :line (get-line e env)\n                         :column (get-col e env)\n                         ;; :local is required for {:op :local ...} nodes\n                         ;; but previously we had no way to figure this out\n                         ;; for `catch` locals, by adding it here we can recover\n                         ;; it later\n                         :local :catch})\n                 locals)\n        catch (when cblock\n                (disallowing-recur (analyze (assoc catchenv :locals locals) cblock)))\n        try (disallowing-recur (analyze (if (or e finally) catchenv env) `(do ~@body)))]\n\n    {:env env :op :try :form form\n     :body (assoc try :body? true)\n     :finally finally\n     :name e\n     :catch catch\n     :children (vec\n                 (concat [:body]\n                         (when catch\n                           [:catch])\n                         (when finally\n                           [:finally])))}))",
                                     :title "Parser code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/clojure/cljs/analyzer.cljc",
                                     :lines [1834 1904]},
                            :extra-sources ({:code "(defmethod emit* :try\n  [{try :body :keys [env catch name finally]}]\n  (let [context (:context env)]\n    (if (or name finally)\n      (do\n        (when (= :expr context)\n          (emits \"(function (){\"))\n        (emits \"try{\" try \"}\")\n        (when name\n          (emits \"catch (\" (munge name) \"){\" catch \"}\"))\n        (when finally\n          (assert (not= :const (:op (ana/unwrap-quote finally))) \"finally block cannot contain constant\")\n          (emits \"finally {\" finally \"}\"))\n        (when (= :expr context)\n          (emits \"})()\")))\n      (emits try))))",
                                             :title "Emitting code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/clojure/cljs/compiler.cljc",
                                             :lines [1068 1083]}),
                            :full-name "cljs.core/try",
                            :docstring "catch-clause => (catch classname name expr*)\nfinally-clause => (finally expr*)\nCatches and handles JavaScript exceptions."},
           "cljs.repl.nashorn/init-engine" {:ns "cljs.repl.nashorn",
                                            :name "init-engine",
                                            :signature ["[engine {:keys [output-dir], :as opts} debug]"],
                                            :name-encode "init-engine",
                                            :history [["+" "0.0-2814"]
                                                      ["-" "1.10.738"]],
                                            :type "function",
                                            :full-name-encode "cljs.repl.nashorn/init-engine",
                                            :source {:code "(defn init-engine [engine {:keys [output-dir] :as opts} debug]\n      (eval-str engine (format \"var CLJS_DEBUG = %s;\" (boolean debug)))\n      (eval-str engine (format \"var CLJS_OUTPUT_DIR = \\\"%s\\\";\" output-dir))\n      (eval-resource engine \"goog/base.js\" debug)\n      (eval-resource engine \"goog/deps.js\" debug)\n      (eval-resource engine \"cljs/bootstrap_nashorn.js\" debug)\n      (eval-str engine\n        (format \"goog.global.CLOSURE_UNCOMPILED_DEFINES = %s;\"\n          (json/write-str (:closure-defines opts))))\n      engine)",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.10.597",
                                                     :filename "src/main/clojure/cljs/repl/nashorn.clj",
                                                     :lines [55 64]},
                                            :full-name "cljs.repl.nashorn/init-engine",
                                            :removed {:in "1.10.738",
                                                      :last-seen "1.10.597"}},
           "cljs.build.api/goog-dep-string" {:ns "cljs.build.api",
                                             :name "goog-dep-string",
                                             :signature ["[opts ijs]"],
                                             :name-encode "goog-dep-string",
                                             :history [["+"
                                                        "0.0-3291"]],
                                             :type "function",
                                             :full-name-encode "cljs.build.api/goog-dep-string",
                                             :source {:code "(defn goog-dep-string\n  [opts ijs]\n  (closure/add-dep-string opts ijs))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.12.38",
                                                      :filename "src/main/clojure/cljs/build/api.clj",
                                                      :lines [103 107]},
                                             :full-name "cljs.build.api/goog-dep-string",
                                             :docstring "Given compiler options and a IJavaScript instance return the corresponding\ngoog.addDependency string"},
           "cljs.core/iterate" {:ns "cljs.core",
                                :name "iterate",
                                :signature ["[f x]"],
                                :name-encode "iterate",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/iterate",
                                :source {:code "(defn iterate\n  {:added \"1.0\"}\n  [f x] (Iterate. nil f nil x nil))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [5209 5212]},
                                :full-name "cljs.core/iterate",
                                :docstring "Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects"},
           "cljs.spec/double-in" {:ns "cljs.spec",
                                  :name "double-in",
                                  :signature ["[& {:keys [infinite? NaN? min max], :or {infinite? true, NaN? true}, :as m}]"],
                                  :name-encode "double-in",
                                  :history [["+" "1.9.293"]
                                            ["-" "1.9.542"]],
                                  :type "macro",
                                  :full-name-encode "cljs.spec/double-in",
                                  :source {:code "(defmacro double-in\n  [& {:keys [infinite? NaN? min max]\n      :or {infinite? true NaN? true}\n      :as m}]\n  `(spec (and c/double?\n           ~@(when-not infinite? '[#(not (infinite? %))])\n           ~@(when-not NaN? '[#(not (js/isNaN %))])\n           ~@(when max `[#(<= % ~max)])\n           ~@(when min `[#(<= ~min %)]))\n     :gen #(gen/double* ~m)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.9.521",
                                           :filename "src/main/cljs/cljs/spec.cljc",
                                           :lines [481 496]},
                                  :full-name "cljs.spec/double-in",
                                  :docstring "Specs a 64-bit floating point number. Options:\n\n :infinite? - whether +/- infinity allowed (default true)\n :NaN?      - whether NaN allowed (default true)\n :min       - minimum value (inclusive, default none)\n :max       - maximum value (inclusive, default none)",
                                  :removed {:in "1.9.542",
                                            :last-seen "1.9.521"}},
           "cljs.core/lazy-seq" {:ns "cljs.core",
                                 :name "lazy-seq",
                                 :signature ["[& body]"],
                                 :name-encode "lazy-seq",
                                 :history [["+" "0.0-927"]],
                                 :type "macro",
                                 :full-name-encode "cljs.core/lazy-seq",
                                 :source {:code "(core/defmacro lazy-seq\n  [& body]\n  `(new cljs.core/LazySeq nil (fn [] ~@body) nil nil))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/clojure/cljs/core.cljc",
                                          :lines [2242 2248]},
                                 :full-name "cljs.core/lazy-seq",
                                 :docstring "Takes a body of expressions that returns an ISeq or nil, and yields\na ISeqable object that will invoke the body only the first time seq\nis called, and will cache the result and return it on all subsequent\nseq calls."},
           "cljs.test/update-current-env!" {:ns "cljs.test",
                                            :name "update-current-env!",
                                            :signature ["[ks f & args]"],
                                            :name-encode "update-current-envBANG",
                                            :history [["+" "0.0-2496"]],
                                            :type "function",
                                            :full-name-encode "cljs.test/update-current-envBANG",
                                            :source {:code "(defn update-current-env! [ks f & args]\n  (set! *current-env* (apply update-in (get-current-env) ks f args)))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/cljs/cljs/test.cljs",
                                                     :lines [274 275]},
                                            :full-name "cljs.test/update-current-env!"},
           "cljs.spec.impl.gen/quick-check" {:ns "cljs.spec.impl.gen",
                                             :name "quick-check",
                                             :signature ["[& args]"],
                                             :name-encode "quick-check",
                                             :history [["+" "1.9.14"]
                                                       ["-" "1.9.542"]],
                                             :type "function",
                                             :full-name-encode "cljs.spec.impl.gen/quick-check",
                                             :source {:code "(defn quick-check\n  [& args]\n  (apply @quick-check-ref args))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.9.521",
                                                      :filename "src/main/cljs/cljs/spec/impl/gen.cljs",
                                                      :lines [29 31]},
                                             :full-name "cljs.spec.impl.gen/quick-check",
                                             :removed {:in "1.9.542",
                                                       :last-seen "1.9.521"}},
           "cljs.spec/?" {:ns "cljs.spec",
                          :name "?",
                          :signature ["[pred-form]"],
                          :name-encode "QMARK",
                          :history [["+" "1.9.14"] ["-" "1.9.542"]],
                          :type "macro",
                          :full-name-encode "cljs.spec/QMARK",
                          :source {:code "(defmacro ?\n  [pred-form]\n  `(maybe-impl ~pred-form '~pred-form))",
                                   :title "Source code",
                                   :repo "clojurescript",
                                   :tag "r1.9.521",
                                   :filename "src/main/cljs/cljs/spec.cljc",
                                   :lines [313 317]},
                          :full-name "cljs.spec/?",
                          :docstring "Returns a regex op that matches zero or one value matching\npred. Produces a single value (not a collection) if matched.",
                          :removed {:in "1.9.542",
                                    :last-seen "1.9.521"}},
           "cljs.core/bounded-count" {:ns "cljs.core",
                                      :name "bounded-count",
                                      :signature ["[n coll]"],
                                      :name-encode "bounded-count",
                                      :history [["+" "1.9.85"]],
                                      :type "function",
                                      :full-name-encode "cljs.core/bounded-count",
                                      :source {:code "(defn bounded-count\n  {:added \"1.9\"}\n  [n coll]\n  (if (counted? coll)\n    (count coll)\n    (loop [i 0 s (seq coll)]\n      (if (and (not (nil? s)) (< i n))\n        (recur (inc i) (next s))\n        i))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [3844 3854]},
                                      :full-name "cljs.core/bounded-count",
                                      :docstring "If coll is counted? returns its count, else will count at most the first n\nelements of coll using its seq"},
           "cljs.core/IndexedSeq" {:protocols #{"ISeqable"
                                                "IMeta"
                                                "IWithMeta"
                                                "IReversible"
                                                "IEmptyableCollection"
                                                "ICounted"
                                                "IReduce"
                                                "ISequential"
                                                "ISeq"
                                                "ICollection"
                                                "IHash"
                                                "IDrop"
                                                "ASeq"
                                                "IPrintWithWriter"
                                                "IIndexed"
                                                "IIterable"
                                                "INext"
                                                "IEquiv"
                                                "ICloneable"},
                                   :ns "cljs.core",
                                   :name "IndexedSeq",
                                   :signature ["[arr i meta]"],
                                   :name-encode "IndexedSeq",
                                   :history [["+" "0.0-927"]],
                                   :type "type",
                                   :full-name-encode "cljs.core/IndexedSeq",
                                   :source {:code "(deftype IndexedSeq [arr i meta]\n  Object\n  (toString [coll]\n   (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  ICloneable\n  (-clone [_] (IndexedSeq. arr i meta))\n\n  ISeqable\n  (-seq [this]\n    (when (< i (alength arr))\n      this))\n\n  IMeta\n  (-meta [coll] meta)\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (IndexedSeq. arr i new-meta)))\n\n  ASeq\n  ISeq\n  (-first [_] (aget arr i))\n  (-rest [_] (if (< (inc i) (alength arr))\n               (IndexedSeq. arr (inc i) nil)\n               (list)))\n\n  INext\n  (-next [_] (if (< (inc i) (alength arr))\n               (IndexedSeq. arr (inc i) nil)\n               nil))\n\n  IDrop\n  (-drop [coll n]\n    (if (pos? n)\n      (if (< (+ i n) (alength arr))\n        (IndexedSeq. arr (+ i n) nil)\n        nil)\n      coll))\n\n  ICounted\n  (-count [_]\n    (max 0 (- (alength arr) i)))\n\n  IIndexed\n  (-nth [coll n]\n    (let [i (+ n i)]\n      (if (and (<= 0 i) (< i (alength arr)))\n        (aget arr i)\n        (throw (js/Error. \"Index out of bounds\")))))\n  (-nth [coll n not-found]\n    (let [i (+ n i)]\n      (if (and (<= 0 i) (< i (alength arr)))\n        (aget arr i)\n        not-found)))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IIterable\n  (-iterator [coll]\n    (IndexedSeqIterator. arr i))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (.-EMPTY List))\n\n  IReduce\n  (-reduce [coll f]\n    (array-reduce arr f (aget arr i) (inc i)))\n  (-reduce [coll f start]\n    (array-reduce arr f start i))\n\n  IHash\n  (-hash [coll] (hash-ordered-coll coll))\n\n  IReversible\n  (-rseq [coll]\n    (let [c (-count coll)]\n      (if (pos? c)\n        (RSeq. coll (dec c) nil)))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [1615 1709]},
                                   :full-name "cljs.core/IndexedSeq"},
           "cljs.repl.server/parse-headers" {:ns "cljs.repl.server",
                                             :name "parse-headers",
                                             :signature ["[header-lines]"],
                                             :name-encode "parse-headers",
                                             :history [["+"
                                                        "0.0-1503"]],
                                             :type "function",
                                             :full-name-encode "cljs.repl.server/parse-headers",
                                             :source {:code "(defn parse-headers\n  [header-lines]\n  (apply hash-map\n    (mapcat\n      (fn [line]\n        (let [[k v] (str/split line #\":\" 2)]\n          [(keyword (str/lower-case k)) (str/triml v)]))\n      header-lines)))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.12.38",
                                                      :filename "src/main/clojure/cljs/repl/server.clj",
                                                      :lines [76 84]},
                                             :full-name "cljs.repl.server/parse-headers",
                                             :docstring "Parse the headers of an HTTP POST request."},
           "cljs.core/KeySeq" {:protocols #{"ISeqable"
                                            "IMeta"
                                            "IWithMeta"
                                            "IEmptyableCollection"
                                            "IReduce"
                                            "ISequential"
                                            "ISeq"
                                            "ICollection"
                                            "IHash"
                                            "IPrintWithWriter"
                                            "INext"
                                            "IEquiv"},
                               :ns "cljs.core",
                               :name "KeySeq",
                               :signature ["[mseq _meta]"],
                               :name-encode "KeySeq",
                               :history [["+" "0.0-1820"]],
                               :type "type",
                               :full-name-encode "cljs.core/KeySeq",
                               :source {:code "(deftype KeySeq [^not-native mseq _meta]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IMeta\n  (-meta [coll] _meta)\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta _meta)\n      coll\n      (KeySeq. mseq new-meta)))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ICollection\n  (-conj [coll o]\n    (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (.-EMPTY List))\n\n  IHash\n  (-hash [coll] (hash-ordered-coll coll))\n\n  ISeq\n  (-first [coll]\n    (let [^not-native me (-first mseq)]\n      (-key me)))\n\n  (-rest [coll]\n    (let [nseq (if (satisfies? INext mseq)\n                 (-next mseq)\n                 (next mseq))]\n      (if-not (nil? nseq)\n        (KeySeq. nseq nil)\n        ())))\n\n  INext\n  (-next [coll]\n    (let [nseq (if (satisfies? INext mseq)\n                 (-next mseq)\n                 (next mseq))]\n      (when-not (nil? nseq)\n        (KeySeq. nseq nil))))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [9177 9241]},
                               :full-name "cljs.core/KeySeq"},
           "cljs.core/js-iterable?" {:ns "cljs.core",
                                     :name "js-iterable?",
                                     :signature ["[x]"],
                                     :name-encode "js-iterableQMARK",
                                     :history [["+" "1.10.738"]],
                                     :type "function",
                                     :full-name-encode "cljs.core/js-iterableQMARK",
                                     :source {:code "(defn js-iterable?\n  [x]\n  (and (not (nil? x))\n       (not (nil? (js* \"~{}[~{}]\" x ITER_SYMBOL)))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/cljs/cljs/core.cljs",
                                              :lines [1234 1238]},
                                     :full-name "cljs.core/js-iterable?",
                                     :docstring "Return true if x has a JavaScript iterator property"},
           "cljs.core/next" {:return-type seq,
                             :ns "cljs.core",
                             :name "next",
                             :signature ["[coll]"],
                             :name-encode "next",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/next",
                             :source {:code "(defn ^seq next\n  [coll]\n  (when-not (nil? coll)\n    (if (implements? INext coll)\n      (-next coll)\n      (seq (rest coll)))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [1303 1310]},
                             :full-name "cljs.core/next",
                             :docstring "Returns a seq of the items after the first. Calls seq on its\nargument.  If there are no more items, returns nil"},
           "cljs.core/*print-readably*" {:ns "cljs.core",
                                         :name "*print-readably*",
                                         :name-encode "STARprint-readablySTAR",
                                         :history [["+" "0.0-927"]],
                                         :type "dynamic var",
                                         :full-name-encode "cljs.core/STARprint-readablySTAR",
                                         :source {:code "(def\n  ^{:dynamic true}\n  *print-readably* true)",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/cljs/cljs/core.cljs",
                                                  :lines [116 122]},
                                         :full-name "cljs.core/*print-readably*",
                                         :docstring "When set to logical false, strings and characters will be printed with\nnon-alphanumeric characters converted to the appropriate escape sequences.\n\nDefaults to true"},
           "cljs.repl.node/read-response" {:return-type String,
                                           :ns "cljs.repl.node",
                                           :name "read-response",
                                           :signature ["[in]"],
                                           :name-encode "read-response",
                                           :history [["+" "0.0-2629"]],
                                           :type "function",
                                           :full-name-encode "cljs.repl.node/read-response",
                                           :source {:code "(defn ^String read-response [^BufferedReader in]\n  (let [sb (StringBuilder.)]\n    (loop [sb sb c (.read in)]\n      (case c\n        -1 (throw (IOException. \"Stream closed\"))\n         0 (str sb)\n         (do\n           (.append sb (char c))\n           (recur sb (.read in)))))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/clojure/cljs/repl/node.clj",
                                                    :lines [51 59]},
                                           :full-name "cljs.repl.node/read-response"},
           "cljs.repl.browser/repl-client-js" {:ns "cljs.repl.browser",
                                               :name "repl-client-js",
                                               :signature ["[]"],
                                               :name-encode "repl-client-js",
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.repl.browser/repl-client-js",
                                               :source {:code "(defn repl-client-js []\n  (slurp (:client-js @browser-state)))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.12.38",
                                                        :filename "src/main/clojure/cljs/repl/browser.clj",
                                                        :lines [117
                                                                118]},
                                               :full-name "cljs.repl.browser/repl-client-js"},
           "compiler-options/source-map" {:ns "compiler-options",
                                          :name "source-map",
                                          :name-encode "source-map",
                                          :type "option",
                                          :full-name-encode "compiler-options/source-map",
                                          :full-name "compiler-options/source-map",
                                          :history [["+" "0.0-1798"]]},
           "cljs.core/booleans" {:ns "cljs.core",
                                 :name "booleans",
                                 :signature ["[x]"],
                                 :name-encode "booleans",
                                 :history [["+" "0.0-1798"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/booleans",
                                 :source {:code "(defn booleans [x] x)",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [2906]},
                                 :full-name "cljs.core/booleans"},
           "cljs.core/not-native" {:ns "cljs.core",
                                   :name "not-native",
                                   :name-encode "not-native",
                                   :type "var",
                                   :full-name-encode "cljs.core/not-native",
                                   :source {:code "(def not-native nil)",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [232]},
                                   :full-name "cljs.core/not-native",
                                   :history [["+" "0.0-1798"]]},
           "cljs.repl.browser/parse-headers" {:ns "cljs.repl.browser",
                                              :name "parse-headers",
                                              :signature ["[header-lines]"],
                                              :name-encode "parse-headers",
                                              :history [["+"
                                                         "0.0-927"]
                                                        ["-"
                                                         "0.0-1503"]],
                                              :type "function",
                                              :full-name-encode "cljs.repl.browser/parse-headers",
                                              :source {:code "(defn parse-headers\n  [header-lines]\n  (apply hash-map\n   (mapcat\n    (fn [line]\n      (let [[k v] (str/split line #\":\" 2)]\n        [(keyword (str/lower-case k)) (str/triml v)]))\n    header-lines)))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1450",
                                                       :filename "src/clj/cljs/repl/browser.clj",
                                                       :lines [116
                                                               124]},
                                              :full-name "cljs.repl.browser/parse-headers",
                                              :docstring "Parse the headers of an HTTP POST request.",
                                              :removed {:in "0.0-1503",
                                                        :last-seen "0.0-1450"}},
           "cljs.core/last" {:ns "cljs.core",
                             :name "last",
                             :signature ["[s]"],
                             :name-encode "last",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/last",
                             :source {:code "(defn last\n  [s]\n  (let [sn (next s)]\n    (if-not (nil? sn)\n      (recur sn)\n      (first s))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [1820 1826]},
                             :full-name "cljs.core/last",
                             :docstring "Return the last item in coll, in linear time"},
           "cljs.core/pr-str*" {:ns "cljs.core",
                                :name "pr-str*",
                                :signature ["[obj]"],
                                :name-encode "pr-strSTAR",
                                :history [["+" "0.0-1806"]],
                                :type "function",
                                :full-name-encode "cljs.core/pr-strSTAR",
                                :source {:code "(defn pr-str*\n  [^not-native obj]\n  (let [sb (StringBuffer.)\n        writer (StringBufferWriter. sb)]\n    (-pr-writer obj writer (pr-opts))\n    (-flush writer)\n    (str sb)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [904 912]},
                                :full-name "cljs.core/pr-str*",
                                :docstring "Support so that collections can implement toString without\nloading all the printing machinery."},
           "repl-options/repl-requires" {:ns "repl-options",
                                         :name "repl-requires",
                                         :name-encode "repl-requires",
                                         :type "option",
                                         :full-name-encode "repl-options/repl-requires",
                                         :full-name "repl-options/repl-requires",
                                         :history [["+" "0.0-3115"]]},
           "cljs.core/letfn*" {:ns "cljs.core",
                               :name "letfn*",
                               :name-encode "letfnSTAR",
                               :history [["+" "0.0-1236"]],
                               :type "special form",
                               :full-name-encode "cljs.core/letfnSTAR",
                               :source {:code "(defmethod parse 'letfn*\n  [op env [_ bindings & exprs :as form] name _]\n  (when-not (and (vector? bindings) (even? (count bindings)))\n    (throw (error env \"bindings must be vector of even number of elements\")))\n  (let [n->fexpr (into {} (map (juxt first second) (partition 2 bindings)))\n        names    (keys n->fexpr)\n        context  (:context env)\n        ;; first pass to collect information for recursive references\n        [meth-env bes]\n        (reduce (fn [[{:keys [locals] :as env} bes] n]\n                  (let [ret-tag (-> n meta :tag)\n                        fexpr (no-warn (analyze env (n->fexpr n)))\n                        be (cond->\n                             {:op :binding\n                              :name n\n                              :form n\n                              :env env\n                              :fn-var true\n                              :line (get-line n env)\n                              :column (get-col n env)\n                              :local :letfn\n                              :shadow (handle-symbol-local n (locals n))\n                              :variadic? (:variadic? fexpr)\n                              :max-fixed-arity (:max-fixed-arity fexpr)\n                              :method-params (map :params (:methods fexpr))}\n                             ret-tag (assoc :ret-tag ret-tag))]\n                    [(assoc-in env [:locals n] be)\n                     (conj bes be)]))\n                [env []] names)\n        meth-env (assoc meth-env :context :expr)\n        ;; the real pass\n        [meth-env bes]\n        (reduce (fn [[meth-env bes] {:keys [name shadow] :as be}]\n                  (let [env (assoc-in meth-env [:locals name] shadow)\n                        fexpr (analyze env (n->fexpr name))\n                        be' (assoc be\n                              :init fexpr\n                              :variadic? (:variadic? fexpr)\n                              :max-fixed-arity (:max-fixed-arity fexpr)\n                              :method-params (map :params (:methods fexpr))\n                              :children [:init])]\n                    [(assoc-in env [:locals name] be')\n                     (conj bes be')]))\n          [meth-env []] bes)\n        expr (-> (analyze (assoc meth-env :context (if (= :expr context) :return context)) `(do ~@exprs))\n                 (assoc :body? true))]\n    {:env env :op :letfn :bindings bes :body expr :form form\n     :children [:bindings :body]}))",
                                        :title "Parser code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/clojure/cljs/analyzer.cljc",
                                        :lines [2324 2371]},
                               :extra-sources ({:code "(defmethod emit* :letfn\n  [{expr :body :keys [bindings env]}]\n  (let [context (:context env)]\n    (when (= :expr context) (emits \"(function (){\"))\n    (doseq [{:keys [init] :as binding} bindings]\n      (emitln \"var \" (munge binding) \" = \" init \";\"))\n    (emits expr)\n    (when (= :expr context) (emits \"})()\"))))",
                                                :title "Emitting code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/clojure/cljs/compiler.cljc",
                                                :lines [1125 1132]}),
                               :full-name "cljs.core/letfn*"},
           "cljs.core/random-uuid" {:ns "cljs.core",
                                    :name "random-uuid",
                                    :signature ["[]"],
                                    :name-encode "random-uuid",
                                    :history [["+" "0.0-3308"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/random-uuid",
                                    :source {:code "(defn random-uuid\n  []\n  (letfn [(^string quad-hex []\n            (let [unpadded-hex ^string (.toString (rand-int 65536) 16)]\n              (case (count unpadded-hex)\n                1 (str \"000\" unpadded-hex)\n                2 (str \"00\" unpadded-hex)\n                3 (str \"0\" unpadded-hex)\n                unpadded-hex)))]\n    (let [ver-tripple-hex ^string (.toString (bit-or 0x4000 (bit-and 0x0fff (rand-int 65536))) 16)\n          res-tripple-hex ^string (.toString (bit-or 0x8000 (bit-and 0x3fff (rand-int 65536))) 16)]\n      (uuid\n        (str (quad-hex) (quad-hex) \"-\" (quad-hex) \"-\"\n             ver-tripple-hex \"-\" res-tripple-hex \"-\"\n             (quad-hex) (quad-hex) (quad-hex))))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [11745 11760]},
                                    :full-name "cljs.core/random-uuid",
                                    :docstring "Returns a pseudo-randomly generated UUID instance (i.e. type 4)."},
           "cljs.core/bit-shift-left" {:ns "cljs.core",
                                       :name "bit-shift-left",
                                       :signature ["[x n]"],
                                       :name-encode "bit-shift-left",
                                       :history [["+" "0.0-927"]],
                                       :type "function/macro",
                                       :full-name-encode "cljs.core/bit-shift-left",
                                       :source {:code "(defn bit-shift-left\n  [x n] (cljs.core/bit-shift-left x n))",
                                                :title "Function code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/core.cljs",
                                                :lines [2985 2987]},
                                       :extra-sources [{:code "(core/defmacro ^::ana/numeric bit-shift-left [x n]\n  (core/list 'js* \"(~{} << ~{})\" x n))",
                                                        :title "Macro code",
                                                        :repo "clojurescript",
                                                        :tag "r1.12.38",
                                                        :filename "src/main/clojure/cljs/core.cljc",
                                                        :lines [1231
                                                                1232]}],
                                       :full-name "cljs.core/bit-shift-left",
                                       :docstring "Bitwise shift left"},
           "cljs.core/update-vals" {:ns "cljs.core",
                                    :name "update-vals",
                                    :signature ["[m f]"],
                                    :name-encode "update-vals",
                                    :history [["+" "1.11.50"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/update-vals",
                                    :source {:code "(defn update-vals\n  {:added \"1.11\"}\n  [m f]\n  (with-meta\n    (persistent!\n      (reduce-kv (fn [acc k v] (assoc! acc k (f v)))\n                 (if (implements? IEditableCollection m)\n                   (transient m)\n                   (transient {}))\n                 m))\n    (meta m)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [12071 12084]},
                                    :full-name "cljs.core/update-vals",
                                    :docstring "m f => {k (f v) ...}\nGiven a map m and a function f of 1-argument, returns a new map where the keys of m\nare mapped to result of applying f to the corresponding values of m."},
           "clojure.string/reverse" {:return-type string,
                                     :ns "clojure.string",
                                     :name "reverse",
                                     :signature ["[s]"],
                                     :name-encode "reverse",
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "clojure.string/reverse",
                                     :source {:code "(defn ^string reverse\n  [s]\n  (-> (.replace s re-surrogate-pair \"$2$1\")\n      (.. (split \"\") (reverse) (join \"\"))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/cljs/clojure/string.cljs",
                                              :lines [21 25]},
                                     :full-name "clojure.string/reverse",
                                     :docstring "Returns s with its characters reversed."},
           "cljs.core/*unchecked-arrays*" {:ns "cljs.core",
                                           :name "*unchecked-arrays*",
                                           :name-encode "STARunchecked-arraysSTAR",
                                           :type "var",
                                           :full-name-encode "cljs.core/STARunchecked-arraysSTAR",
                                           :source {:code "(def *unchecked-arrays* false)",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/cljs/cljs/core.cljs",
                                                    :lines [30]},
                                           :full-name "cljs.core/*unchecked-arrays*",
                                           :history [["+" "1.9.854"]]},
           "closure-warnings/deprecated-annotations" {:ns "closure-warnings",
                                                      :name "deprecated-annotations",
                                                      :name-encode "deprecated-annotations",
                                                      :type "warning",
                                                      :full-name-encode "closure-warnings/deprecated-annotations",
                                                      :full-name "closure-warnings/deprecated-annotations",
                                                      :history [["+"
                                                                 "1.9.473"]]},
           "cljs.spec/*coll-error-limit*" {:ns "cljs.spec",
                                           :name "*coll-error-limit*",
                                           :name-encode "STARcoll-error-limitSTAR",
                                           :history [["+" "1.9.85"]
                                                     ["-" "1.9.542"]],
                                           :type "dynamic var",
                                           :full-name-encode "cljs.spec/STARcoll-error-limitSTAR",
                                           :source {:code "(def ^:dynamic *coll-error-limit*\n  \"The number of errors reported by explain in a collection spec'ed with 'every'\"\n  20)",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.9.521",
                                                    :filename "src/main/cljs/cljs/spec.cljs",
                                                    :lines [35 37]},
                                           :full-name "cljs.spec/*coll-error-limit*",
                                           :removed {:in "1.9.542",
                                                     :last-seen "1.9.521"}},
           "cljs.core/min" {:return-type number,
                            :ns "cljs.core",
                            :name "min",
                            :signature ["[x]" "[x y]" "[x y & more]"],
                            :name-encode "min",
                            :history [["+" "0.0-927"]],
                            :type "function/macro",
                            :full-name-encode "cljs.core/min",
                            :source {:code "(defn ^number min\n  ([x] x)\n  ([x y] (cljs.core/min x y))\n  ([x y & more]\n   (reduce min (cljs.core/min x y) more)))",
                                     :title "Function code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [2778 2783]},
                            :extra-sources [{:code "(core/defmacro ^::ana/numeric min\n  ([x] x)\n  ([x y] `(let [x# ~x, y# ~y]\n            (~'js* \"((~{} < ~{}) ? ~{} : ~{})\" x# y# x# y#)))\n  ([x y & more] `(min (min ~x ~y) ~@more)))",
                                             :title "Macro code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/clojure/cljs/core.cljc",
                                             :lines [1186 1190]}],
                            :full-name "cljs.core/min",
                            :docstring "Returns the least of the nums."},
           "cljs.reader/escape-char" {:ns "cljs.reader",
                                      :name "escape-char",
                                      :signature ["[buffer reader]"],
                                      :name-encode "escape-char",
                                      :history [["+" "0.0-927"]
                                                ["-" "1.9.854"]],
                                      :type "function",
                                      :full-name-encode "cljs.reader/escape-char",
                                      :source {:code "(defn escape-char\n  [buffer reader]\n  (let [ch (read-char reader)\n        mapresult (escape-char-map ch)]\n    (if mapresult\n      mapresult\n      (cond\n        (identical? ch \\x)\n        (->> (read-2-chars reader)\n          (validate-unicode-escape unicode-2-pattern reader ch)\n          (make-unicode-char))\n\n        (identical? ch \\u)\n        (->> (read-4-chars reader)\n          (validate-unicode-escape unicode-4-pattern reader ch)\n          (make-unicode-char))\n\n        (numeric? ch)\n        (.fromCharCode js/String ch)\n\n        :else\n        (reader-error reader \"Unexpected unicode escape \\\\\" ch )))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.9.671",
                                               :filename "src/main/cljs/cljs/reader.cljs",
                                               :lines [194 215]},
                                      :full-name "cljs.reader/escape-char",
                                      :removed {:in "1.9.854",
                                                :last-seen "1.9.671"}},
           "cljs.reader/read-raw-string*" {:ns "cljs.reader",
                                           :name "read-raw-string*",
                                           :signature ["[reader _]"],
                                           :name-encode "read-raw-stringSTAR",
                                           :history [["+" "0.0-2261"]
                                                     ["-" "1.9.854"]],
                                           :type "function",
                                           :full-name-encode "cljs.reader/read-raw-stringSTAR",
                                           :source {:code "(defn read-raw-string*\n  [reader _]\n  (loop [buffer (gstring/StringBuffer.)\n         ch (read-char reader)]\n    (cond\n      (nil? ch) (reader-error reader \"EOF while reading\")\n      (identical? \"\\\\\" ch) (do (.append buffer ch)\n                             (let [nch (read-char reader)]\n                               (if (nil? nch)\n                                 (reader-error reader \"EOF while reading\")\n                                 (recur (doto buffer (.append nch))\n                                        (read-char reader)))))\n      (identical? \"\\\"\" ch) (.toString buffer)\n      :else (recur (doto buffer (.append ch)) (read-char reader)))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.9.671",
                                                    :filename "src/main/cljs/cljs/reader.cljs",
                                                    :lines [316 329]},
                                           :full-name "cljs.reader/read-raw-string*",
                                           :removed {:in "1.9.854",
                                                     :last-seen "1.9.671"}},
           "cljs.analyzer.api/enabled-warnings" {:ns "cljs.analyzer.api",
                                                 :name "enabled-warnings",
                                                 :signature ["[]"],
                                                 :name-encode "enabled-warnings",
                                                 :history [["+"
                                                            "1.10.738"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.analyzer.api/enabled-warnings",
                                                 :source {:code "(defn enabled-warnings\n  []\n  ana/*cljs-warnings*)",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r1.12.38",
                                                          :filename "src/main/clojure/cljs/analyzer/api.cljc",
                                                          :lines [97
                                                                  100]},
                                                 :full-name "cljs.analyzer.api/enabled-warnings",
                                                 :docstring "Get the enabled warning types."},
           "cljs.core/INext" {:ns "cljs.core",
                              :name "INext",
                              :name-encode "INext",
                              :implementations #{"Cycle"
                                                 "PersistentArrayMapSeq"
                                                 "EmptyList"
                                                 "Iterate"
                                                 "ValSeq"
                                                 "IntegerRange"
                                                 "ChunkedCons"
                                                 "Range"
                                                 "PersistentQueueSeq"
                                                 "ChunkedSeq"
                                                 "ArrayNodeSeq"
                                                 "KeySeq"
                                                 "IndexedSeq"
                                                 "PersistentTreeMapSeq"
                                                 "RSeq"
                                                 "NodeSeq"
                                                 "List"
                                                 "Repeat"
                                                 "Cons"
                                                 "LazySeq"},
                              :history [["+" "0.0-1424"]],
                              :type "protocol",
                              :full-name-encode "cljs.core/INext",
                              :source {:code "(defprotocol INext\n  (^clj-or-nil -next [coll]\n    \"Returns a new collection of coll without the first item. In contrast to\n     rest, it should return nil if there are no more items, e.g.\n     (next []) => nil\n     (next nil) => nil\"))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [630 636]},
                              :methods [{:name "-next",
                                         :signature ["[coll]"],
                                         :docstring "Returns a new collection of coll without the first item. In contrast to\n     rest, it should return nil if there are no more items, e.g.\n     (next []) => nil\n     (next nil) => nil"}],
                              :full-name "cljs.core/INext",
                              :docstring "Protocol for accessing the next items of a collection."},
           "syntax/auto-gensym" {:syntax-equiv {:edn-url nil,
                                                :clj-url nil},
                                 :ns "syntax",
                                 :name "auto-gensym",
                                 :name-encode "auto-gensym",
                                 :type "special character",
                                 :full-name-encode "syntax/auto-gensym",
                                 :full-name "syntax/auto-gensym",
                                 :history [["+" "0.0-927"]]},
           "cljs.reader/read-map" {:ns "cljs.reader",
                                   :name "read-map",
                                   :signature ["[rdr _]"],
                                   :name-encode "read-map",
                                   :history [["+" "0.0-927"]
                                             ["-" "1.9.854"]],
                                   :type "function",
                                   :full-name-encode "cljs.reader/read-map",
                                   :source {:code "(defn read-map\n  [rdr _]\n  (let [l (read-delimited-list \"}\" rdr true)\n        c (alength l)]\n    (when (odd? c)\n      (reader-error rdr \"Map literal must contain an even number of forms\"))\n    (if (<= c (* 2 (.-HASHMAP-THRESHOLD PersistentArrayMap)))\n      (.createWithCheck PersistentArrayMap l)\n      (.createWithCheck PersistentHashMap l))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.9.671",
                                            :filename "src/main/cljs/cljs/reader.cljs",
                                            :lines [283 291]},
                                   :full-name "cljs.reader/read-map",
                                   :removed {:in "1.9.854",
                                             :last-seen "1.9.671"}},
           "cljs.spec/instrument-all" {:ns "cljs.spec",
                                       :name "instrument-all",
                                       :signature ["[]"],
                                       :name-encode "instrument-all",
                                       :history [["+" "1.9.14"]
                                                 ["-" "1.9.183"]],
                                       :type "macro",
                                       :full-name-encode "cljs.spec/instrument-all",
                                       :source {:code "(defmacro instrument-all\n  []\n  `(do\n     ~@(map #(list 'cljs.spec/instrument %) (speced-vars*))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.9.93",
                                                :filename "src/main/cljs/cljs/spec.cljc",
                                                :lines [474 478]},
                                       :full-name "cljs.spec/instrument-all",
                                       :docstring "Call instrument for all speced-vars. Idempotent.",
                                       :removed {:in "1.9.183",
                                                 :last-seen "1.9.93"}},
           "cljs.core/tap>" {:return-type boolean,
                             :ns "cljs.core",
                             :name "tap>",
                             :signature ["[x]"],
                             :name-encode "tapGT",
                             :history [["+" "1.10.63"]],
                             :type "function",
                             :full-name-encode "cljs.core/tapGT",
                             :source {:code "(defn ^boolean tap>\n  [x]\n  (maybe-init-tapset)\n  (*exec-tap-fn*\n    (fn []\n      (doseq [tap @tapset]\n        (try\n          (tap x)\n          (catch js/Error ex))))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [12060 12069]},
                             :full-name "cljs.core/tap>",
                             :docstring "Sends x to any taps. Returns the result of *exec-tap-fn*, a Boolean value."},
           "cljs.core/seq" {:return-type seq,
                            :ns "cljs.core",
                            :name "seq",
                            :signature ["[coll]"],
                            :name-encode "seq",
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core/seq",
                            :source {:code "(defn ^seq seq\n  [coll]\n  (when-not (nil? coll)\n    (cond\n      (implements? ISeqable coll)\n      (-seq coll)\n\n      (array? coll)\n      (when-not (zero? (alength coll))\n        (IndexedSeq. coll 0 nil))\n\n      (string? coll)\n      (when-not (zero? (.-length coll))\n        (IndexedSeq. coll 0 nil))\n\n      (js-iterable? coll)\n      (es6-iterator-seq\n        (.call (gobject/get coll ITER_SYMBOL) coll))\n\n      (native-satisfies? ISeqable coll)\n      (-seq coll)\n\n      :else (throw (js/Error. (str coll \" is not ISeqable\"))))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [1252 1277]},
                            :full-name "cljs.core/seq",
                            :docstring "Returns a seq on the collection. If the collection is\nempty, returns nil.  (seq nil) returns nil. seq also works on\nStrings."},
           "cljs.core/defrecord*" {:ns "cljs.core",
                                   :name "defrecord*",
                                   :name-encode "defrecordSTAR",
                                   :history [["+" "0.0-927"]],
                                   :type "special form",
                                   :full-name-encode "cljs.core/defrecordSTAR",
                                   :source {:code "(defmethod parse 'defrecord*\n  [_ env form _ _]\n  (parse-type :defrecord env form) )",
                                            :title "Parser code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/clojure/cljs/analyzer.cljc",
                                            :lines [3474 3476]},
                                   :extra-sources ({:code "(defmethod emit* :defrecord\n  [{:keys [t fields pmasks body protocols]}]\n  (let [fields (concat (map munge fields) '[__meta __extmap __hash])]\n    (emitln \"\")\n    (emitln \"/**\")\n    (emitln \"* @constructor\")\n    (doseq [protocol protocols]\n      (emitln \" * @implements {\" (munge (str protocol)) \"}\"))\n    (emitln \"*/\")\n    (emitln (munge t) \" = (function (\" (comma-sep fields) \"){\")\n    (doseq [fld fields]\n      (emitln \"this.\" fld \" = \" fld \";\"))\n    (doseq [[pno pmask] pmasks]\n      (emitln \"this.cljs$lang$protocol_mask$partition\" pno \"$ = \" pmask \";\"))\n    (emitln \"});\")\n    (emit body)))",
                                                    :title "Emitting code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/clojure/cljs/compiler.cljc",
                                                    :lines [1406 1421]}),
                                   :full-name "cljs.core/defrecord*"},
           "cljs.core/*print-newline*" {:ns "cljs.core",
                                        :name "*print-newline*",
                                        :name-encode "STARprint-newlineSTAR",
                                        :history [["+" "0.0-2060"]],
                                        :type "dynamic var",
                                        :full-name-encode "cljs.core/STARprint-newlineSTAR",
                                        :source {:code "(def\n  ^{:dynamic true}\n  *print-newline* true)",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/cljs/cljs/core.cljs",
                                                 :lines [109 114]},
                                        :full-name "cljs.core/*print-newline*",
                                        :docstring "When set to logical false will drop newlines from printing calls.\nThis is to work around the implicit newlines emitted by standard JavaScript\nconsole objects."},
           "cljs.spec.alpha/form" {:ns "cljs.spec.alpha",
                                   :name "form",
                                   :signature ["[spec]"],
                                   :name-encode "form",
                                   :history [["+" "1.9.542"]],
                                   :type "function",
                                   :full-name-encode "cljs.spec.alpha/form",
                                   :source {:code "(defn form\n  [spec]\n  ;;TODO - incorporate gens\n  (describe* (specize spec)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/spec/alpha.cljs",
                                            :lines [181 185]},
                                   :full-name "cljs.spec.alpha/form",
                                   :docstring "returns the spec as data"},
           "cljs.spec.test.alpha/get-env" {:ns "cljs.spec.test.alpha",
                                           :name "get-env",
                                           :signature ["[]"],
                                           :name-encode "get-env",
                                           :history [["+" "1.9.542"]],
                                           :type "function",
                                           :full-name-encode "cljs.spec.test.alpha/get-env",
                                           :source {:code "(defn get-env []\n  {:ua-product (get-ua-product)})",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/cljs/cljs/spec/test/alpha.cljs",
                                                    :lines [58 59]},
                                           :full-name "cljs.spec.test.alpha/get-env"},
           "cljs.spec.gen.alpha/int" {:ns "cljs.spec.gen.alpha",
                                      :name "int",
                                      :signature ["[& args]"],
                                      :name-encode "int",
                                      :history [["+" "1.9.542"]],
                                      :type "function",
                                      :full-name-encode "cljs.spec.gen.alpha/int",
                                      :source {:code "(lazy-prims any any-printable boolean char char-alpha char-alphanumeric char-ascii double\n  int keyword keyword-ns large-integer ratio simple-type simple-type-printable\n  string string-ascii string-alphanumeric symbol symbol-ns uuid)",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/spec/gen/alpha.cljs",
                                               :lines [74 76]},
                                      :full-name "cljs.spec.gen.alpha/int",
                                      :docstring "Fn returning clojure.test.check.generators/int"},
           "cljs.repl/error->str" {:ns "cljs.repl",
                                   :name "error->str",
                                   :signature ["[error]"],
                                   :name-encode "error-GTstr",
                                   :history [["+" "1.10.514"]],
                                   :type "function",
                                   :full-name-encode "cljs.repl/error-GTstr",
                                   :source {:code "(defn error->str [error]\n  (ex-str (ex-triage (Error->map error))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/repl.cljs",
                                            :lines [205 206]},
                                   :full-name "cljs.repl/error->str"},
           "cljs.math/hypot" {:return-type number,
                              :ns "cljs.math",
                              :name "hypot",
                              :signature ["[x y]"],
                              :name-encode "hypot",
                              :history [["+" "1.11.50"]],
                              :type "function",
                              :full-name-encode "cljs.math/hypot",
                              :source {:code "(defn ^number hypot\n  {:added \"1.11.10\"}\n  [x y] (Math/hypot x y))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/math.cljs",
                                       :lines [699 705]},
                              :full-name "cljs.math/hypot",
                              :docstring "Returns sqrt(x^2 + y^2) without intermediate underflow or overflow.\nIf x or y is ##Inf or ##-Inf => ##Inf\nIf x or y is ##NaN and neither is ##Inf or ##-Inf => ##NaN\nSee: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/hypot"},
           "cljs.core/long" {:ns "cljs.core",
                             :name "long",
                             :signature ["[x]"],
                             :name-encode "long",
                             :history [["+" "0.0-1211"]],
                             :type "function",
                             :full-name-encode "cljs.core/long",
                             :source {:code "(defn long\n  [x]\n  (fix x))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [2896 2899]},
                             :full-name "cljs.core/long",
                             :docstring "Coerce to long by stripping decimal places. Identical to `int'."},
           "cljs.core/es6-iterator" {:ns "cljs.core",
                                     :name "es6-iterator",
                                     :signature ["[coll]"],
                                     :name-encode "es6-iterator",
                                     :history [["+" "0.0-2371"]],
                                     :type "function",
                                     :full-name-encode "cljs.core/es6-iterator",
                                     :source {:code "(defn es6-iterator\n  [coll]\n  (ES6Iterator. (seq coll)))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/cljs/cljs/core.cljs",
                                              :lines [1339 1342]},
                                     :full-name "cljs.core/es6-iterator",
                                     :docstring "Return a ES2015+ compatible iterator for coll."},
           "cljs.core/not-empty" {:ns "cljs.core",
                                  :name "not-empty",
                                  :signature ["[coll]"],
                                  :name-encode "not-empty",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/not-empty",
                                  :source {:code "(defn not-empty\n  [coll] (when (seq coll) coll))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [4100 4102]},
                                  :full-name "cljs.core/not-empty",
                                  :docstring "If coll is empty, returns nil, else coll"},
           "cljs.core/println" {:ns "cljs.core",
                                :name "println",
                                :signature ["[& objs]"],
                                :name-encode "println",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/println",
                                :source {:code "(defn println\n  [& objs]\n  (pr-with-opts objs (assoc (pr-opts) :readably false))\n  (when *print-newline*\n    (newline (pr-opts))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [10674 10679]},
                                :full-name "cljs.core/println",
                                :docstring "Same as print followed by (newline)"},
           "cljs.core/NS_CACHE" {:ns "cljs.core",
                                 :name "NS_CACHE",
                                 :name-encode "NS_CACHE",
                                 :history [["+" "1.7.10"]],
                                 :type "var",
                                 :full-name-encode "cljs.core/NS_CACHE",
                                 :source {:code "(def\n  ^{:jsdoc [\"@type {*}\"]}\n  NS_CACHE nil)",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [12129 12131]},
                                 :full-name "cljs.core/NS_CACHE",
                                 :docstring "Bootstrap only."},
           "clojure.browser.repl/connect" {:ns "clojure.browser.repl",
                                           :name "connect",
                                           :signature ["[repl-server-url]"],
                                           :name-encode "connect",
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "clojure.browser.repl/connect",
                                           :source {:code "(defn connect\n  [repl-server-url]\n  (let [connected? (atom false)\n        repl-connection (net/xpc-connection {:peer_uri repl-server-url})]\n    (swap! xpc-connection (constantly repl-connection))\n    (net/register-service repl-connection\n      :start-handshake\n      (fn [_]\n        ;; Child will keep retrying, but we only want\n        ;; to ack once.\n        (when-not @connected?\n          (reset! connected? true)\n          (reset! parent-connected? true)\n          (net/transmit repl-connection :ack-handshake nil)\n          (flush-print-queue! repl-connection))))\n    (net/register-service repl-connection\n      :reconnect\n      (fn [_]\n        (reset! connected? false)\n        (reset! parent-connected? false)))\n    (net/register-service repl-connection\n      :evaluate-javascript\n      (fn [json]\n        (let [obj  (json/parse json)\n              repl (gobj/get obj \"repl\")\n              form (gobj/get obj \"form\")]\n          (net/transmit\n            repl-connection\n            :send-result\n            (json/serialize\n              #js {\"repl\" repl\n                   \"result\"\n                   (binding [*repl* repl]\n                     (evaluate-javascript repl-connection form))})))))\n    (net/connect repl-connection\n      (constantly nil)\n      (fn [iframe]\n        (set! (.-display (.-style iframe))\n          \"none\")))\n    (bootstrap)\n    repl-connection))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/cljs/clojure/browser/repl.cljs",
                                                    :lines [235 278]},
                                           :full-name "clojure.browser.repl/connect",
                                           :docstring "Connects to a REPL server from an HTML document. After the\nconnection is made, the REPL will evaluate forms in the context of\nthe document that called this function."},
           "cljs.spec.alpha/with-gen" {:ns "cljs.spec.alpha",
                                       :name "with-gen",
                                       :signature ["[spec gen-fn]"],
                                       :name-encode "with-gen",
                                       :history [["+" "1.9.542"]],
                                       :type "function",
                                       :full-name-encode "cljs.spec.alpha/with-gen",
                                       :source {:code "(defn with-gen\n  [spec gen-fn]\n  (let [spec (reg-resolve spec)]\n    (if (regex? spec)\n      (assoc spec ::gfn gen-fn)\n      (with-gen* (specize spec) gen-fn))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/spec/alpha.cljs",
                                                :lines [211 217]},
                                       :full-name "cljs.spec.alpha/with-gen",
                                       :docstring "Takes a spec and a no-arg, generator-returning fn and returns a version of that spec that uses that generator"},
           "cljs.core/bytes" {:ns "cljs.core",
                              :name "bytes",
                              :signature ["[x]"],
                              :name-encode "bytes",
                              :history [["+" "0.0-1798"]],
                              :type "function",
                              :full-name-encode "cljs.core/bytes",
                              :source {:code "(defn bytes [x] x)",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [2907]},
                              :full-name "cljs.core/bytes"},
           "cljs.core/unchecked-byte" {:return-type number,
                                       :ns "cljs.core",
                                       :name "unchecked-byte",
                                       :signature ["[x]"],
                                       :name-encode "unchecked-byte",
                                       :history [["+" "0.0-1798"]],
                                       :type "function/macro",
                                       :full-name-encode "cljs.core/unchecked-byte",
                                       :source {:code "(defn ^number unchecked-byte [x] x)",
                                                :title "Function code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/core.cljs",
                                                :lines [2799]},
                                       :extra-sources [{:code "(core/defmacro unchecked-byte [x] x)",
                                                        :title "Macro code",
                                                        :repo "clojurescript",
                                                        :tag "r1.12.38",
                                                        :filename "src/main/clojure/cljs/core.cljc",
                                                        :lines [1071]}],
                                       :full-name "cljs.core/unchecked-byte"},
           "clojure.browser.dom/insert-at" {:ns "clojure.browser.dom",
                                            :name "insert-at",
                                            :signature ["[parent child index]"],
                                            :name-encode "insert-at",
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "clojure.browser.dom/insert-at",
                                            :source {:code "(defn insert-at [parent child index]\n  (gdom/insertChildAt parent child index))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/cljs/clojure/browser/dom.cljs",
                                                     :lines [104 105]},
                                            :full-name "clojure.browser.dom/insert-at"},
           "cljs.core/quot" {:ns "cljs.core",
                             :name "quot",
                             :signature ["[n d]"],
                             :name-encode "quot",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/quot",
                             :source {:code "(defn quot\n  [n d]\n  (let [rem (js-mod n d)]\n    (fix (/ (- n rem) d))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [2925 2929]},
                             :full-name "cljs.core/quot",
                             :docstring "quot[ient] of dividing numerator by denominator."},
           "cljs.repl.reflect/handle-reflect-query" {:ns "cljs.repl.reflect",
                                                     :name "handle-reflect-query",
                                                     :signature ["[[param _] & _]"],
                                                     :name-encode "handle-reflect-query",
                                                     :history [["+"
                                                                "0.0-1503"]],
                                                     :type "multimethod",
                                                     :full-name-encode "cljs.repl.reflect/handle-reflect-query",
                                                     :source {:code "(defmulti handle-reflect-query (fn [[param _] & _] param))",
                                                              :title "Source code",
                                                              :repo "clojurescript",
                                                              :tag "r1.12.38",
                                                              :filename "src/main/clojure/cljs/repl/reflect.clj",
                                                              :lines [69]},
                                                     :extra-sources ({:code "(defmethod handle-reflect-query [[_ sym] req conn opts]\n  (let [sym (read-url-string sym)]\n    (compile-and-return conn (get-meta sym))))",
                                                                      :title "Dispatch method",
                                                                      :repo "clojurescript",
                                                                      :tag "r1.12.38",
                                                                      :filename "src/main/clojure/cljs/repl/reflect.clj",
                                                                      :lines [71
                                                                              74]}
                                                                     {:code "(defmethod handle-reflect-query [[_ mform] req conn opts]\n  (let [mform (-> mform read-url-string macroexpand)]\n    (server/send-and-close conn 200 (with-out-str (pprint/pprint mform)))))",
                                                                      :title "Dispatch method",
                                                                      :repo "clojurescript",
                                                                      :tag "r1.12.38",
                                                                      :filename "src/main/clojure/cljs/repl/reflect.clj",
                                                                      :lines [76
                                                                              79]}),
                                                     :full-name "cljs.repl.reflect/handle-reflect-query"},
           "clojure.browser.event/get-listener" {:ns "clojure.browser.event",
                                                 :name "get-listener",
                                                 :signature ["[src type listener opt_capt opt_handler]"],
                                                 :name-encode "get-listener",
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.browser.event/get-listener",
                                                 :source {:code "(defn get-listener [src type listener opt_capt opt_handler])",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r1.12.38",
                                                          :filename "src/main/cljs/clojure/browser/event.cljs",
                                                          :lines [91]},
                                                 :full-name "clojure.browser.event/get-listener"},
           "cljs.core/filter" {:ns "cljs.core",
                               :name "filter",
                               :signature ["[pred]" "[pred coll]"],
                               :name-encode "filter",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/filter",
                               :source {:code "(defn filter\n  ([pred]\n    (fn [rf]\n      (fn\n        ([] (rf))\n        ([result] (rf result))\n        ([result input]\n           (if (pred input)\n             (rf result input)\n             result)))))\n  ([pred coll]\n   (lazy-seq\n    (when-let [s (seq coll)]\n      (if (chunked-seq? s)\n        (let [c (chunk-first s)\n              size (count c)\n              b (chunk-buffer size)]\n          (dotimes [i size]\n              (when (pred (-nth c i))\n                (chunk-append b (-nth c i))))\n          (chunk-cons (chunk b) (filter pred (chunk-rest s))))\n        (let [f (first s) r (rest s)]\n          (if (pred f)\n            (cons f (filter pred r))\n            (filter pred r))))))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [5276 5303]},
                               :full-name "cljs.core/filter",
                               :docstring "Returns a lazy sequence of the items in coll for which\n(pred item) returns logical true. pred must be free of side-effects.\nReturns a transducer when no collection is provided."},
           "warnings/fn-var" {:ns "warnings",
                              :name "fn-var",
                              :name-encode "fn-var",
                              :type "warning",
                              :full-name-encode "warnings/fn-var",
                              :full-name "warnings/fn-var",
                              :history [["+" "0.0-1835"]]},
           "cljs.repl/setup" {:ns "cljs.repl",
                              :name "setup",
                              :signature ["[repl-env opts]"],
                              :name-encode "setup",
                              :history [["+" "1.10.63"]],
                              :type "function",
                              :full-name-encode "cljs.repl/setup",
                              :source {:code "(defn setup [repl-env opts]\n  (-setup repl-env opts))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/clojure/cljs/repl.cljc",
                                       :lines [127 128]},
                              :full-name "cljs.repl/setup"},
           "cljs.math/atan" {:return-type number,
                             :ns "cljs.math",
                             :name "atan",
                             :signature ["[a]"],
                             :name-encode "atan",
                             :history [["+" "1.11.50"]],
                             :type "function",
                             :full-name-encode "cljs.math/atan",
                             :source {:code "(defn ^number atan\n  {:added \"1.11.10\"}\n  [a] (Math/atan a))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/math.cljs",
                                      :lines [118 124]},
                             :full-name "cljs.math/atan",
                             :docstring "Returns the arc tangent of a, in the range of -pi/2 to pi/2.\nIf a is ##NaN => ##NaN\nIf a is zero => zero with the same sign as a\nSee: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/atan"},
           "cljs.spec.gen.alpha/not-empty" {:ns "cljs.spec.gen.alpha",
                                            :name "not-empty",
                                            :signature ["[& args]"],
                                            :name-encode "not-empty",
                                            :history [["+" "1.9.542"]],
                                            :type "function",
                                            :full-name-encode "cljs.spec.gen.alpha/not-empty",
                                            :source {:code "(lazy-combinators hash-map list map not-empty set vector vector-distinct fmap elements\n  bind choose one-of such-that tuple sample return\n  large-integer* double* frequency shuffle)",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/cljs/cljs/spec/gen/alpha.cljs",
                                                     :lines [70 72]},
                                            :full-name "cljs.spec.gen.alpha/not-empty",
                                            :docstring "Lazy loaded version of clojure.test.check.generators/not-empty"},
           "cljs.core/RSeq" {:protocols #{"ISeqable"
                                          "IMeta"
                                          "IWithMeta"
                                          "IEmptyableCollection"
                                          "ICounted"
                                          "IReduce"
                                          "ISequential"
                                          "ISeq"
                                          "ICollection"
                                          "IHash"
                                          "IPrintWithWriter"
                                          "INext"
                                          "IEquiv"
                                          "ICloneable"},
                             :ns "cljs.core",
                             :name "RSeq",
                             :signature ["[ci i meta]"],
                             :name-encode "RSeq",
                             :history [["+" "0.0-1424"]],
                             :type "type",
                             :full-name-encode "cljs.core/RSeq",
                             :source {:code "(deftype RSeq [ci i meta]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  ICloneable\n  (-clone [_] (RSeq. ci i meta))\n\n  IMeta\n  (-meta [coll] meta)\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (RSeq. ci i new-meta)))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ISeq\n  (-first [coll]\n    (-nth ci i))\n  (-rest [coll]\n    (if (pos? i)\n      (RSeq. ci (dec i) nil)\n      ()))\n\n  INext\n  (-next [coll]\n    (when (pos? i)\n      (RSeq. ci (dec i) nil)))\n\n  ICounted\n  (-count [coll] (inc i))\n\n  ICollection\n  (-conj [coll o]\n    (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (.-EMPTY List))\n\n  IHash\n  (-hash [coll] (hash-ordered-coll coll))\n\n  IReduce\n  (-reduce [col f] (seq-reduce f col))\n  (-reduce [col f start] (seq-reduce f start col)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [1730 1791]},
                             :full-name "cljs.core/RSeq"},
           "cljs.spec.alpha/regex?" {:ns "cljs.spec.alpha",
                                     :name "regex?",
                                     :signature ["[x]"],
                                     :name-encode "regexQMARK",
                                     :history [["+" "1.9.542"]],
                                     :type "function",
                                     :full-name-encode "cljs.spec.alpha/regexQMARK",
                                     :source {:code "(defn regex?\n  [x]\n  (c/and (::op x) x))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/cljs/cljs/spec/alpha.cljs",
                                              :lines [80 83]},
                                     :full-name "cljs.spec.alpha/regex?",
                                     :docstring "returns x if x is a (cljs.spec.alpha) regex op, else logical false"},
           "clojure.zip/branch?" {:ns "clojure.zip",
                                  :name "branch?",
                                  :signature ["[loc]"],
                                  :name-encode "branchQMARK",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.zip/branchQMARK",
                                  :source {:code "(defn branch?\n  [loc]\n    ((:zip/branch? (meta loc)) (node loc)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/clojure/zip.cljs",
                                           :lines [64 67]},
                                  :full-name "clojure.zip/branch?",
                                  :docstring "Returns true if the node at loc is a branch"},
           "warnings/unsupported-js-module-type" {:ns "warnings",
                                                  :name "unsupported-js-module-type",
                                                  :name-encode "unsupported-js-module-type",
                                                  :type "warning",
                                                  :full-name-encode "warnings/unsupported-js-module-type",
                                                  :full-name "warnings/unsupported-js-module-type",
                                                  :history [["+"
                                                             "1.7.10"]]},
           "cljs.pprint/*print-radix*" {:ns "cljs.pprint",
                                        :name "*print-radix*",
                                        :name-encode "STARprint-radixSTAR",
                                        :history [["+" "0.0-3255"]],
                                        :type "dynamic var",
                                        :full-name-encode "cljs.pprint/STARprint-radixSTAR",
                                        :source {:code "(def ^{:added \"1.2\", :dynamic true} *print-radix* nil)",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/cljs/cljs/pprint.cljs",
                                                 :lines [666 671]},
                                        :full-name "cljs.pprint/*print-radix*",
                                        :docstring "Print a radix specifier in front of integers and rationals. If *print-base* is 2, 8,\nor 16, then the radix specifier used is #b, #o, or #x, respectively. Otherwise the\nradix specifier is in the form #XXr where XX is the decimal value of *print-base* "},
           "cljs.core/ObjMap" {:protocols #{"IFn"
                                            "ISeqable"
                                            "IMap"
                                            "IMeta"
                                            "IWithMeta"
                                            "IKVReduce"
                                            "IEditableCollection"
                                            "IEmptyableCollection"
                                            "ICounted"
                                            "ILookup"
                                            "ICollection"
                                            "IHash"
                                            "IPrintWithWriter"
                                            "IAssociative"
                                            "IFind"
                                            "IEquiv"},
                               :ns "cljs.core",
                               :name "ObjMap",
                               :signature ["[meta keys strobj update-count __hash]"],
                               :name-encode "ObjMap",
                               :history [["+" "0.0-927"]],
                               :type "type",
                               :full-name-encode "cljs.core/ObjMap",
                               :source {:code "(deftype ObjMap [meta keys strobj update-count ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (ObjMap. new-meta keys strobj update-count __hash)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (reduce -conj\n              coll\n              entry)))\n\n  IEmptyableCollection\n  (-empty [coll] (-with-meta (.-EMPTY ObjMap) meta))\n\n  IEquiv\n  (-equiv [coll other] (equiv-map coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-unordered-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (when (pos? (alength keys))\n      (map #(vector % (unchecked-get strobj %))\n           (.sort keys obj-map-compare-keys))))\n\n  ICounted\n  (-count [coll] (alength keys))\n\n  ILookup\n  (-lookup [coll k] (-lookup coll k nil))\n  (-lookup [coll k not-found]\n    (if (and (string? k)\n             (not (nil? (scan-array 1 k keys))))\n      (unchecked-get strobj k)\n      not-found))\n\n  IAssociative\n  (-assoc [coll k v]\n    (if (string? k)\n        (if (or (> update-count (.-HASHMAP_THRESHOLD ObjMap))\n                (>= (alength keys) (.-HASHMAP_THRESHOLD ObjMap)))\n          (obj-map->hash-map coll k v)\n          (if-not (nil? (scan-array 1 k keys))\n            (let [new-strobj (obj-clone strobj keys)]\n              (gobject/set new-strobj k v)\n              (ObjMap. meta keys new-strobj (inc update-count) nil)) ; overwrite\n            (let [new-strobj (obj-clone strobj keys) ; append\n                  new-keys (aclone keys)]\n              (gobject/set new-strobj k v)\n              (.push new-keys k)\n              (ObjMap. meta new-keys new-strobj (inc update-count) nil))))\n        ;; non-string key. game over.\n        (obj-map->hash-map coll k v)))\n  (-contains-key? [coll k]\n    (if (and (string? k)\n             (not (nil? (scan-array 1 k keys))))\n      true\n      false))\n\n  IFind\n  (-find [coll k]\n    (when (and (string? k)\n            (not (nil? (scan-array 1 k keys))))\n      (MapEntry. k (unchecked-get strobj k) nil)))\n\n  IKVReduce\n  (-kv-reduce [coll f init]\n    (let [len (alength keys)]\n      (loop [keys (.sort keys obj-map-compare-keys)\n             init init]\n        (if (seq keys)\n          (let [k (first keys)\n                init (f init k (unchecked-get strobj k))]\n            (if (reduced? init)\n              @init\n              (recur (rest keys) init)))\n          init))))\n\n  IMap\n  (-dissoc [coll k]\n    (if (and (string? k)\n             (not (nil? (scan-array 1 k keys))))\n      (let [new-keys (aclone keys)\n            new-strobj (obj-clone strobj keys)]\n        (.splice new-keys (scan-array 1 k new-keys) 1)\n        (js-delete new-strobj k)\n        (ObjMap. meta new-keys new-strobj (inc update-count) nil))\n      coll)) ; key not found, return coll unchanged\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found))\n\n  IEditableCollection\n  (-as-transient [coll]\n    (transient (into (hash-map) coll))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [6555 6666]},
                               :full-name "cljs.core/ObjMap"},
           "cljs.spec/instrument" {:ns "cljs.spec",
                                   :name "instrument",
                                   :signature ["[v]"],
                                   :name-encode "instrument",
                                   :history [["+" "1.9.14"]
                                             ["-" "1.9.183"]],
                                   :type "macro",
                                   :full-name-encode "cljs.spec/instrument",
                                   :source {:code "(defmacro instrument\n  [v]\n  (let [v   (if-not (seq? v) (list 'var v) v)\n        sym (second v)]\n    `(do\n       (when-let [checked# (cljs.spec/instrument* ~v)]\n         (set! ~sym checked#))\n       ~v)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.9.93",
                                            :filename "src/main/cljs/cljs/spec.cljc",
                                            :lines [437 448]},
                                   :full-name "cljs.spec/instrument",
                                   :docstring "Instruments the var at v, a var or symbol, to check specs\nregistered with fdef. Wraps the fn at v to check :args\nspec, if it exist, throwing an ex-info with explain-data if a\ncheck fails. Idempotent.",
                                   :removed {:in "1.9.183",
                                             :last-seen "1.9.93"}},
           "repl-options/quit-prompt" {:ns "repl-options",
                                       :name "quit-prompt",
                                       :name-encode "quit-prompt",
                                       :type "option",
                                       :full-name-encode "repl-options/quit-prompt",
                                       :full-name "repl-options/quit-prompt",
                                       :history [["+" "0.0-3148"]]},
           "cljs.core/sequence" {:ns "cljs.core",
                                 :name "sequence",
                                 :signature ["[coll]"
                                             "[xform coll]"
                                             "[xform coll & colls]"],
                                 :name-encode "sequence",
                                 :history [["+" "0.0-2120"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/sequence",
                                 :source {:code "(defn sequence\n  ([coll]\n     (if (seq? coll)\n       coll\n       (or (seq coll) ())))\n  ([xform coll]\n   (or (chunkIteratorSeq\n         (.create TransformerIterator xform (iter coll)))\n       ()))\n  ([xform coll & colls]\n   (or (chunkIteratorSeq\n         (.createMulti TransformerIterator xform (map iter (cons coll colls))))\n       ())))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [4300 4320]},
                                 :full-name "cljs.core/sequence",
                                 :docstring "Coerces coll to a (possibly empty) sequence, if it is not already\none. Will not force a lazy seq. (sequence nil) yields (), When a\ntransducer is supplied, returns a lazy sequence of applications of\nthe transform to the items in coll(s), i.e. to the set of first\nitems of each coll, followed by the set of second\nitems in each coll, until any one of the colls is exhausted.  Any\nremaining items in other colls are ignored. The transform should accept\nnumber-of-colls arguments"},
           "compiler-options/opts-cache" {:ns "compiler-options",
                                          :name "opts-cache",
                                          :name-encode "opts-cache",
                                          :type "option",
                                          :full-name-encode "compiler-options/opts-cache",
                                          :full-name "compiler-options/opts-cache",
                                          :history [["+" "1.10.126"]]},
           "warnings/declared-arglists-mismatch" {:ns "warnings",
                                                  :name "declared-arglists-mismatch",
                                                  :name-encode "declared-arglists-mismatch",
                                                  :type "warning",
                                                  :full-name-encode "warnings/declared-arglists-mismatch",
                                                  :full-name "warnings/declared-arglists-mismatch",
                                                  :history [["+"
                                                             "1.10.312"]]},
           "cljs.core/zipmap" {:ns "cljs.core",
                               :name "zipmap",
                               :signature ["[keys vals]"],
                               :name-encode "zipmap",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/zipmap",
                               :source {:code "(defn zipmap\n  [keys vals]\n    (loop [map (transient {})\n           ks (seq keys)\n           vs (seq vals)]\n      (if (and ks vs)\n        (recur (assoc! map (first ks) (first vs))\n               (next ks)\n               (next vs))\n        (persistent! map))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [9748 9758]},
                               :full-name "cljs.core/zipmap",
                               :docstring "Returns a map with the keys mapped to the corresponding vals."},
           "cljs.core/char?" {:ns "cljs.core",
                              :name "char?",
                              :signature ["[x]"],
                              :name-encode "charQMARK",
                              :history [["+" "1.7.10"]],
                              :type "function",
                              :full-name-encode "cljs.core/charQMARK",
                              :source {:code "(defn char?\n  [x]\n  (and (string? x) (== 1 (.-length x))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [282 285]},
                              :full-name "cljs.core/char?",
                              :docstring "Returns true if x is a JavaScript string of length one."},
           "cljs.core/hash-combine" {:ns "cljs.core",
                                     :name "hash-combine",
                                     :signature ["[seed hash]"],
                                     :name-encode "hash-combine",
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "cljs.core/hash-combine",
                                     :source {:code "(defn hash-combine [seed hash]\n  ; a la boost\n  (bit-xor seed\n    (+ hash 0x9e3779b9\n      (bit-shift-left seed 6)\n      (bit-shift-right seed 2))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/cljs/cljs/core.cljs",
                                              :lines [1062 1067]},
                                     :full-name "cljs.core/hash-combine"},
           "cljs.core/reversible?" {:ns "cljs.core",
                                    :name "reversible?",
                                    :signature ["[coll]"],
                                    :name-encode "reversibleQMARK",
                                    :history [["+" "0.0-1211"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/reversibleQMARK",
                                    :source {:code "(defn reversible?\n  [coll]\n  (satisfies? IReversible coll))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [3278 3281]},
                                    :full-name "cljs.core/reversible?",
                                    :docstring "Returns true if coll satisfies? IReversible."},
           "cljs.build.api/node-inputs" {:ns "cljs.build.api",
                                         :name "node-inputs",
                                         :signature ["[entries]"
                                                     "[entries opts]"],
                                         :name-encode "node-inputs",
                                         :history [["+" "1.9.456"]],
                                         :type "function",
                                         :full-name-encode "cljs.build.api/node-inputs",
                                         :source {:code "(defn node-inputs\n  ([entries]\n   (node-inputs entries\n     (:options (or (ana-api/current-state) (ana-api/empty-state)))))\n  ([entries opts]\n   (closure/node-inputs entries opts)))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/clojure/cljs/build/api.clj",
                                                  :lines [292 301]},
                                         :full-name "cljs.build.api/node-inputs",
                                         :docstring "EXPERIMENTAL: return the foreign libs entries as computed by running\nthe module-deps package on the supplied JavaScript entry points. Assumes\nthat the `@cljs-oss/module-deps` NPM package is either locally or globally\ninstalled."},
           "syntax/arg" {:syntax-equiv {:edn-url nil, :clj-url nil},
                         :ns "syntax",
                         :name "arg",
                         :name-encode "arg",
                         :history [["+" "0.0-1853"]],
                         :type "syntax",
                         :full-name-encode "syntax/arg",
                         :extra-sources ({:code "(defn- read-arg\n  [rdr pct opts pending-forms]\n  (if-not (thread-bound? #'arg-env)\n    (read-symbol rdr pct)\n    (let [ch (peek-char rdr)]\n      (cond\n       (or (whitespace? ch)\n           (macro-terminating? ch)\n           (nil? ch))\n       (register-arg 1)\n\n       (identical? ch \\&)\n       (do (read-char rdr)\n           (register-arg -1))\n\n       :else\n       (let [n (read* rdr true nil opts pending-forms)]\n         (if-not (integer? n)\n           (throw (IllegalStateException. \"Arg literal must be %, %& or %integer\"))\n           (register-arg n)))))))",
                                          :title "Reader code",
                                          :repo "tools.reader",
                                          :tag "v1.3.6",
                                          :filename "src/main/clojure/clojure/tools/reader.clj",
                                          :lines [568 587]}
                                         {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                          :title "Reader table",
                                          :repo "tools.reader",
                                          :tag "v1.3.6",
                                          :filename "src/main/clojure/clojure/tools/reader.clj",
                                          :lines [788 807]}),
                         :full-name "syntax/arg"},
           "compiler-options/anon-fn-naming-policy" {:ns "compiler-options",
                                                     :name "anon-fn-naming-policy",
                                                     :name-encode "anon-fn-naming-policy",
                                                     :type "option",
                                                     :full-name-encode "compiler-options/anon-fn-naming-policy",
                                                     :full-name "compiler-options/anon-fn-naming-policy",
                                                     :history [["+"
                                                                "0.0-2411"]]},
           "cljs.core/PersistentArrayMap.createAsIfByAssocComplexPath" {:ns "cljs.core",
                                                                        :name "PersistentArrayMap.createAsIfByAssocComplexPath",
                                                                        :signature ["[init has-trailing?]"],
                                                                        :name-encode "PersistentArrayMapDOTcreateAsIfByAssocComplexPath",
                                                                        :history [["+"
                                                                                   "1.11.50"]],
                                                                        :parent-type "PersistentArrayMap",
                                                                        :type "function",
                                                                        :full-name-encode "cljs.core/PersistentArrayMapDOTcreateAsIfByAssocComplexPath",
                                                                        :source {:code "(set! (.-createAsIfByAssocComplexPath PersistentArrayMap)\n  (fn [init ^boolean has-trailing?]\n    (let [init (if has-trailing?\n                 (pam-grow-seed-array init\n                   ;; into {} in case the final element is not a map but something conj-able\n                   ;; for parity with Clojure implementation of CLJ-2603\n                   (into {} (aget init (dec (alength init)))))\n                 init)\n          n    (pam-new-size init)\n          len  (alength init)]\n      (if (< n len)\n        (let [nodups (make-array n)]\n          (loop [i 0 m 0]\n            (if (< i len)\n              (let [dupe? (loop [j 0]\n                            (if (< j m)\n                              (or\n                                (key-test (aget init i) (aget init j))\n                                (recur (+ 2 j)))\n                              false))]\n                (if-not dupe?\n                  (let [j (loop [j (- len 2)]\n                            (if (>= j i)\n                              (if (key-test (aget init i) (aget init j))\n                                j\n                                (recur (- j 2)))\n                              j))]\n                    (aset nodups m (aget init i))\n                    (aset nodups (inc m) (aget init (inc j)))\n                    (recur (+ 2 i) (+ 2 m)))\n                  (recur (+ 2 i) m)))))\n          (PersistentArrayMap. nil (/ (alength nodups) 2) nodups nil))\n        (PersistentArrayMap. nil (/ (alength init) 2) init nil)))))",
                                                                                 :title "Source code",
                                                                                 :repo "clojurescript",
                                                                                 :tag "r1.12.38",
                                                                                 :filename "src/main/cljs/cljs/core.cljs",
                                                                                 :lines [7235
                                                                                         7267]},
                                                                        :full-name "cljs.core/PersistentArrayMap.createAsIfByAssocComplexPath"},
           "warnings/dynamic" {:ns "warnings",
                               :name "dynamic",
                               :name-encode "dynamic",
                               :type "warning",
                               :full-name-encode "warnings/dynamic",
                               :full-name "warnings/dynamic",
                               :history [["+" "0.0-1835"]]},
           "warnings/single-segment-namespace" {:ns "warnings",
                                                :name "single-segment-namespace",
                                                :name-encode "single-segment-namespace",
                                                :type "warning",
                                                :full-name-encode "warnings/single-segment-namespace",
                                                :full-name "warnings/single-segment-namespace",
                                                :history [["+"
                                                           "0.0-2814"]]},
           "warnings/undeclared-ns-form" {:ns "warnings",
                                          :name "undeclared-ns-form",
                                          :name-encode "undeclared-ns-form",
                                          :type "warning",
                                          :full-name-encode "warnings/undeclared-ns-form",
                                          :full-name "warnings/undeclared-ns-form",
                                          :history [["+" "0.0-2014"]]},
           "cljs.core/PersistentHashMap.createWithCheck" {:ns "cljs.core",
                                                          :name "PersistentHashMap.createWithCheck",
                                                          :signature ["[arr]"],
                                                          :name-encode "PersistentHashMapDOTcreateWithCheck",
                                                          :history [["+"
                                                                     "1.9.456"]],
                                                          :parent-type "PersistentHashMap",
                                                          :type "function",
                                                          :full-name-encode "cljs.core/PersistentHashMapDOTcreateWithCheck",
                                                          :source {:code "(set! (.-createWithCheck PersistentHashMap)\n  (fn [arr]\n    (let [len (alength arr)\n          ret (transient (.-EMPTY PersistentHashMap))]\n      (loop [i 0]\n        (when (< i len)\n          (-assoc! ret (aget arr i) (aget arr (inc i)))\n          (if (not= (-count ret) (inc (/ i 2)))\n            (throw (js/Error. (str \"Duplicate key: \" (aget arr i))))\n            (recur (+ i 2)))))\n      (-persistent! ret))))",
                                                                   :title "Source code",
                                                                   :repo "clojurescript",
                                                                   :tag "r1.12.38",
                                                                   :filename "src/main/cljs/cljs/core.cljs",
                                                                   :lines [8251
                                                                           8261]},
                                                          :full-name "cljs.core/PersistentHashMap.createWithCheck"},
           "clojure.core.reducers/flatten" {:ns "clojure.core.reducers",
                                            :name "flatten",
                                            :signature ["[]" "[coll]"],
                                            :name-encode "flatten",
                                            :history [["+" "0.0-1236"]],
                                            :type "function",
                                            :full-name-encode "clojure.core.reducers/flatten",
                                            :source {:code "(defcurried flatten\n  {}\n  [coll]\n  (folder coll\n   (fn [f1]\n     (fn\n       ([] (f1))\n       ([ret v]\n          (if (sequential? v)\n            (-reduce (flatten v) f1 ret)\n            (f1 ret v)))))))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/cljs/clojure/core/reducers.cljs",
                                                     :lines [130 143]},
                                            :full-name "clojure.core.reducers/flatten",
                                            :docstring "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat foldable\n  collection."},
           "cljs.spec.impl.gen/set" {:ns "cljs.spec.impl.gen",
                                     :name "set",
                                     :signature ["[& args]"],
                                     :name-encode "set",
                                     :history [["+" "1.9.14"]
                                               ["-" "1.9.542"]],
                                     :type "function",
                                     :full-name-encode "cljs.spec.impl.gen/set",
                                     :source {:code "(lazy-combinators hash-map list map not-empty set vector vector-distinct fmap elements\n  bind choose one-of such-that tuple sample return\n  large-integer* double* frequency)",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.9.521",
                                              :filename "src/main/cljs/cljs/spec/impl/gen.cljs",
                                              :lines [69 71]},
                                     :full-name "cljs.spec.impl.gen/set",
                                     :docstring "Lazy loaded version of clojure.test.check.generators/set",
                                     :removed {:in "1.9.542",
                                               :last-seen "1.9.521"}},
           "cljs.core/max-key" {:ns "cljs.core",
                                :name "max-key",
                                :signature ["[k x]"
                                            "[k x y]"
                                            "[k x y & more]"],
                                :name-encode "max-key",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/max-key",
                                :source {:code "(defn max-key\n  ([k x] x)\n  ([k x y] (if (> (k x) (k y)) x y))\n  ([k x y & more]\n   (reduce #(max-key k %1 %2) (max-key k x y) more)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [9760 9767]},
                                :full-name "cljs.core/max-key",
                                :docstring "Returns the x for which (k x), a number, is greatest.\n\nIf there are multiple such xs, the last one is returned."},
           "clojure.zip/insert-child" {:ns "clojure.zip",
                                       :name "insert-child",
                                       :signature ["[loc item]"],
                                       :name-encode "insert-child",
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "clojure.zip/insert-child",
                                       :source {:code "(defn insert-child\n  [loc item]\n    (replace loc (make-node loc (node loc) (cons item (children loc)))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/clojure/zip.cljs",
                                                :lines [194 198]},
                                       :full-name "clojure.zip/insert-child",
                                       :docstring "Inserts the item as the leftmost child of the node at this loc,\nwithout moving"},
           "cljs.repl.browser/send-404" {:ns "cljs.repl.browser",
                                         :name "send-404",
                                         :signature ["[conn path]"],
                                         :name-encode "send-404",
                                         :history [["+" "0.0-927"]
                                                   ["-" "0.0-1503"]],
                                         :type "function",
                                         :full-name-encode "cljs.repl.browser/send-404",
                                         :source {:code "(defn send-404 [conn path]\n  (send-and-close conn 404\n                  (str \"<html><body>\"\n                       \"<h2>Page not found</h2>\"\n                       \"No page \" path \" found on this server.\"\n                       \"</body></html>\")\n                  \"text/html\"))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1450",
                                                  :filename "src/clj/cljs/repl/browser.clj",
                                                  :lines [92 98]},
                                         :full-name "cljs.repl.browser/send-404",
                                         :removed {:in "0.0-1503",
                                                   :last-seen "0.0-1450"}},
           "cljs.core/defrecord" {:ns "cljs.core",
                                  :name "defrecord",
                                  :signature ["[rsym fields & impls]"],
                                  :name-encode "defrecord",
                                  :history [["+" "0.0-927"]],
                                  :type "macro",
                                  :full-name-encode "cljs.core/defrecord",
                                  :source {:code "(core/defmacro defrecord\n  [rsym fields & impls]\n  (validate-fields \"defrecord\" rsym fields)\n  (core/let [rsym (vary-meta rsym assoc :internal-ctor true)\n             r    (vary-meta\n                    (:name (cljs.analyzer/resolve-var (dissoc &env :locals) rsym))\n                    assoc :internal-ctor true)]\n    `(let []\n       ~(emit-defrecord &env rsym r fields impls)\n       (set! (.-getBasis ~r) (fn [] '[~@fields]))\n       (set! (.-cljs$lang$type ~r) true)\n       (set! (.-cljs$lang$ctorPrSeq ~r) (fn [this#] (cljs.core/list ~(core/str r))))\n       (set! (.-cljs$lang$ctorPrWriter ~r) (fn [this# writer#] (-write writer# ~(core/str r))))\n       ~(build-positional-factory rsym r fields)\n       ~(build-map-factory rsym r fields)\n       ~r)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/clojure/cljs/core.cljc",
                                           :lines [1929 1996]},
                                  :full-name "cljs.core/defrecord",
                                  :docstring "(defrecord name [fields*]  options* specs*)\n\nCurrently there are no options.\n\nEach spec consists of a protocol or interface name followed by zero\nor more method bodies:\n\nprotocol-or-Object\n(methodName [args*] body)*\n\nThe record will have the (immutable) fields named by\nfields, which can have type hints. Protocols and methods\nare optional. The only methods that can be supplied are those\ndeclared in the protocols.  Note that method bodies are\nnot closures, the local environment includes only the named fields,\nand those fields can be accessed directly.\n\nMethod definitions take the form:\n\n(methodname [args*] body)\n\nThe argument and return types can be hinted on the arg and\nmethodname symbols. If not supplied, they will be inferred, so type\nhints should be reserved for disambiguation.\n\nMethods should be supplied for all methods of the desired\nprotocol(s). You can also define overrides for\nmethods of Object. Note that a parameter must be supplied to\ncorrespond to the target object ('this' in JavaScript parlance). Note also\nthat recur calls to the method head should *not* pass the target object, it\nwill be supplied automatically and can not be substituted.\n\nIn the method bodies, the (unqualified) name can be used to name the\nclass (for calls to new, instance? etc).\n\nThe type will have implementations of several ClojureScript\nprotocol generated automatically: IMeta/IWithMeta (metadata support) and\nIMap, etc.\n\nIn addition, defrecord will define type-and-value-based =,\nand will define ClojureScript IHash and IEquiv.\n\nTwo constructors will be defined, one taking the designated fields\nfollowed by a metadata map (nil for none) and an extension field\nmap (nil for none), and one taking only the fields (using nil for\nmeta and extension fields). Note that the field names __meta\nand __extmap are currently reserved and should not be used when\ndefining your own records.\n\nGiven (defrecord TypeName ...), two factory functions will be\ndefined: ->TypeName, taking positional parameters for the fields,\nand map->TypeName, taking a map of keywords to field values."},
           "cljs.core/eduction" {:ns "cljs.core",
                                 :name "eduction",
                                 :signature ["[xform* coll]"],
                                 :name-encode "eduction",
                                 :history [["+" "0.0-2371"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/eduction",
                                 :source {:code "(defn eduction\n  {:arglists '([xform* coll])}\n  [& xforms]\n  (Eduction. (apply comp (butlast xforms)) (last xforms)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [11097 11104]},
                                 :full-name "cljs.core/eduction",
                                 :docstring "Returns a reducible/iterable application of the transducers\nto the items in coll. Transducers are applied in order as if\ncombined with comp. Note that these applications will be\nperformed every time reduce/iterator is called."},
           "cljs.spec.impl.gen/return" {:ns "cljs.spec.impl.gen",
                                        :name "return",
                                        :signature ["[& args]"],
                                        :name-encode "return",
                                        :history [["+" "1.9.14"]
                                                  ["-" "1.9.542"]],
                                        :type "function",
                                        :full-name-encode "cljs.spec.impl.gen/return",
                                        :source {:code "(lazy-combinators hash-map list map not-empty set vector vector-distinct fmap elements\n  bind choose one-of such-that tuple sample return\n  large-integer* double* frequency)",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.9.521",
                                                 :filename "src/main/cljs/cljs/spec/impl/gen.cljs",
                                                 :lines [69 71]},
                                        :full-name "cljs.spec.impl.gen/return",
                                        :docstring "Lazy loaded version of clojure.test.check.generators/return",
                                        :removed {:in "1.9.542",
                                                  :last-seen "1.9.521"}},
           "cljs.spec.alpha/def" {:ns "cljs.spec.alpha",
                                  :name "def",
                                  :signature ["[k spec-form]"],
                                  :name-encode "def",
                                  :history [["+" "1.9.542"]],
                                  :type "macro",
                                  :full-name-encode "cljs.spec.alpha/def",
                                  :source {:code "(defmacro def\n  [k spec-form]\n  (let [k    (if (symbol? k)\n               (let [sym (ns-qualify &env k)]\n                 (swap! _speced_vars conj\n                   (vary-meta sym assoc :fdef-ns (-> &env :ns :name)))\n                 sym)\n               k)\n        form (res &env spec-form)]\n    (swap! registry-ref (fn [r]\n                          (if (nil? form)\n                            (dissoc r k)\n                            (assoc r k form))))\n    `(def-impl '~k '~form ~spec-form)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/spec/alpha.cljc",
                                           :lines [68 85]},
                                  :full-name "cljs.spec.alpha/def",
                                  :docstring "Given a namespace-qualified keyword or resolveable symbol k, and a\nspec, spec-name, predicate or regex-op makes an entry in the\nregistry mapping k to the spec. Use nil to remove an entry in\nthe registry for k."},
           "cljs.core/ex-info" {:ns "cljs.core",
                                :name "ex-info",
                                :signature ["[msg data]"
                                            "[msg data cause]"],
                                :name-encode "ex-info",
                                :history [["+" "0.0-1576"]],
                                :type "function",
                                :full-name-encode "cljs.core/ex-info",
                                :source {:code "(defn ex-info\n  ([msg data] (ex-info msg data nil))\n  ([msg data cause]\n    (ExceptionInfo. msg data cause)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [11808 11813]},
                                :full-name "cljs.core/ex-info",
                                :docstring "Create an instance of ExceptionInfo, an Error type that carries a\nmap of additional data."},
           "cljs.js/empty-state" {:ns "cljs.js",
                                  :name "empty-state",
                                  :signature ["[]" "[init]"],
                                  :name-encode "empty-state",
                                  :history [["+" "1.7.10"]],
                                  :type "function",
                                  :full-name-encode "cljs.js/empty-state",
                                  :source {:code "(defn empty-state\n  ([]\n   (doto (env/default-compiler-env)\n     (swap!\n       (fn [state]\n         (-> state\n           (assoc-in [::ana/namespaces 'cljs.core] (dump-core)))))))\n  ([init]\n   (doto (empty-state) (swap! init))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/js.cljs",
                                           :lines [129 139]},
                                  :full-name "cljs.js/empty-state",
                                  :docstring "Construct an empty compiler state. Required to invoke analyze, compile,\neval and eval-str."},
           "cljs.core/update-keys" {:ns "cljs.core",
                                    :name "update-keys",
                                    :signature ["[m f]"],
                                    :name-encode "update-keys",
                                    :history [["+" "1.11.50"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/update-keys",
                                    :source {:code "(defn update-keys\n  {:added \"1.11\"}\n  [m f]\n  (let [ret (persistent!\n              (reduce-kv (fn [acc k v] (assoc! acc (f k) v))\n                         (transient {})\n                         m))]\n    (with-meta ret (meta m))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [12086 12098]},
                                    :full-name "cljs.core/update-keys",
                                    :docstring "m f => {(f k) v ...}\nGiven a map m and a function f of 1-argument, returns a new map whose\nkeys are the result of applying f to the keys of m, mapped to the\ncorresponding values of m.\nf must return a unique key for each key of m, else the behavior is undefined."},
           "closure-warnings/check-variables" {:ns "closure-warnings",
                                               :name "check-variables",
                                               :name-encode "check-variables",
                                               :type "warning",
                                               :full-name-encode "closure-warnings/check-variables",
                                               :full-name "closure-warnings/check-variables",
                                               :history [["+"
                                                          "0.0-2120"]]},
           "cljs.repl.browser/repl-env" {:ns "cljs.repl.browser",
                                         :name "repl-env",
                                         :signature ["[& {:as opts}]"],
                                         :name-encode "repl-env",
                                         :history [["+" "0.0-927"]],
                                         :type "function",
                                         :full-name-encode "cljs.repl.browser/repl-env",
                                         :source {:code "(defn repl-env\n  [& {:as opts}]\n  (repl-env* opts))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/clojure/cljs/repl/browser.clj",
                                                  :lines [476 493]},
                                         :full-name "cljs.repl.browser/repl-env",
                                         :docstring "Create a browser-connected REPL environment.\n\nOptions:\n\nport:           The port on which the REPL server will run. Defaults to 9000.\nlaunch-browser: A Boolean indicating whether a browser should be automatically\n                launched connecting back to the terminal REPL. Defaults to true.\nworking-dir:    The directory where the compiled REPL client JavaScript will\n                be stored. Defaults to \".repl\" with a ClojureScript version\n                suffix, eg. \".repl-0.0-2138\".\nstatic-dir:     List of directories to search for static content. Defaults to\n                [\".\" \"out/\"].\nsrc:            The source directory containing user-defined cljs files. Used to\n                support reflection. Defaults to \"src/\".\n"},
           "cljs.repl.nashorn/bootstrap-repl" {:ns "cljs.repl.nashorn",
                                               :name "bootstrap-repl",
                                               :signature ["[engine output-dir opts]"],
                                               :name-encode "bootstrap-repl",
                                               :history [["+"
                                                          "0.0-2814"]
                                                         ["-"
                                                          "1.10.738"]],
                                               :type "function",
                                               :full-name-encode "cljs.repl.nashorn/bootstrap-repl",
                                               :source {:code "(defn bootstrap-repl [engine output-dir opts]\n      (env/ensure\n        (let [deps-file \".nashorn_repl_deps.js\"\n              core (io/resource \"cljs/core.cljs\")\n              core-js (closure/compile core\n                        (assoc opts :output-file\n                          (closure/src-file->target-file\n                            core (dissoc opts :output-dir))))\n              deps (closure/add-dependencies opts core-js)]\n          ;; output unoptimized code and the deps file\n          ;; for all compiled namespaces\n          (apply closure/output-unoptimized\n            (assoc opts :output-to (.getPath (io/file output-dir deps-file)))\n            deps)\n          ;; load the deps file so we can goog.require cljs.core etc.\n          (load-js-file engine deps-file))))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.10.597",
                                                        :filename "src/main/clojure/cljs/repl/nashorn.clj",
                                                        :lines [74 89]},
                                               :full-name "cljs.repl.nashorn/bootstrap-repl",
                                               :removed {:in "1.10.738",
                                                         :last-seen "1.10.597"}},
           "compiler-options/optimize-constants" {:ns "compiler-options",
                                                  :name "optimize-constants",
                                                  :name-encode "optimize-constants",
                                                  :type "option",
                                                  :full-name-encode "compiler-options/optimize-constants",
                                                  :full-name "compiler-options/optimize-constants",
                                                  :history [["+"
                                                             "0.0-1877"]]},
           "cljs.core/butlast" {:ns "cljs.core",
                                :name "butlast",
                                :signature ["[s]"],
                                :name-encode "butlast",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/butlast",
                                :source {:code "(defn butlast\n  [s]\n  (loop [ret [] s s]\n    (if (next s)\n      (recur (conj ret (first s)) (next s))\n      (seq ret))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [9731 9737]},
                                :full-name "cljs.core/butlast",
                                :docstring "Return a seq of all but the last item in coll, in linear time"},
           "cljs.core/array-iter" {:ns "cljs.core",
                                   :name "array-iter",
                                   :signature ["[x]"],
                                   :name-encode "array-iter",
                                   :history [["+" "0.0-2301"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/array-iter",
                                   :source {:code "(defn array-iter [x]\n  (ArrayIter. x 0))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [4132 4133]},
                                   :full-name "cljs.core/array-iter"},
           "compiler-options/aot-cache" {:ns "compiler-options",
                                         :name "aot-cache",
                                         :name-encode "aot-cache",
                                         :type "option",
                                         :full-name-encode "compiler-options/aot-cache",
                                         :full-name "compiler-options/aot-cache",
                                         :history [["+" "1.10.126"]]},
           "cljs.spec.alpha/nilable" {:ns "cljs.spec.alpha",
                                      :name "nilable",
                                      :signature ["[pred]"],
                                      :name-encode "nilable",
                                      :history [["+" "1.9.542"]],
                                      :type "macro",
                                      :full-name-encode "cljs.spec.alpha/nilable",
                                      :source {:code "(defmacro nilable\n  [pred]\n  (let [pf (res &env pred)]\n    `(nilable-impl '~pf ~pred nil)))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/spec/alpha.cljc",
                                               :lines [470 474]},
                                      :full-name "cljs.spec.alpha/nilable",
                                      :docstring "returns a spec that accepts nil and values satisfiying pred"},
           "cljs.core/print-str" {:ns "cljs.core",
                                  :name "print-str",
                                  :signature ["[& objs]"],
                                  :name-encode "print-str",
                                  :history [["+" "0.0-1011"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/print-str",
                                  :source {:code "(defn print-str\n  [& objs]\n  (pr-str-with-opts objs (assoc (pr-opts) :readably false)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [10669 10672]},
                                  :full-name "cljs.core/print-str",
                                  :docstring "print to a string, returning it"},
           "closure-warnings/check-eventful-object-disposal" {:ns "closure-warnings",
                                                              :name "check-eventful-object-disposal",
                                                              :name-encode "check-eventful-object-disposal",
                                                              :type "warning",
                                                              :full-name-encode "closure-warnings/check-eventful-object-disposal",
                                                              :full-name "closure-warnings/check-eventful-object-disposal",
                                                              :history [["+"
                                                                         "1.9.473"]
                                                                        ["-"
                                                                         "1.10.738"]],
                                                              :removed {:in "1.10.738",
                                                                        :last-seen "1.10.597"}},
           "cljs.repl.rhino/load-file" {:ns "cljs.repl.rhino",
                                        :name "load-file",
                                        :signature ["[repl-env opts src]"],
                                        :name-encode "load-file",
                                        :history [["+" "0.0-2985"]
                                                  ["-" "1.10.738"]],
                                        :type "function",
                                        :full-name-encode "cljs.repl.rhino/load-file",
                                        :source {:code "(defn load-file\n  [repl-env opts src]\n  (let [goog-path (io/file (util/output-directory opts) \"goog\" src)]\n    (rhino-eval repl-env (.getPath goog-path) 1 (io/reader goog-path))))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.10.597",
                                                 :filename "src/main/clojure/cljs/repl/rhino.clj",
                                                 :lines [91 97]},
                                        :full-name "cljs.repl.rhino/load-file",
                                        :docstring "Load a JavaScript. This is needed to load JavaScript files before the Rhino\nenvironment is bootstrapped. After bootstrapping load-javascript will be\nused.",
                                        :removed {:in "1.10.738",
                                                  :last-seen "1.10.597"}},
           "cljs.core/hash" {:ns "cljs.core",
                             :name "hash",
                             :signature ["[o]"],
                             :name-encode "hash",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/hash",
                             :source {:code "(defn hash\n  [o]\n  (cond\n    (implements? IHash o)\n    (bit-xor (-hash o) 0)\n\n    (number? o)\n    (if ^boolean (js/isFinite o)\n      (if-not ^boolean (.isSafeInteger js/Number o)\n        (hash-double o)\n        (js-mod (Math/floor o) 2147483647))\n      (case o\n        ##Inf\n        2146435072\n        ##-Inf\n        -1048576\n        2146959360))\n\n    ;; note: mirrors Clojure's behavior on the JVM, where the hashCode is\n    ;; 1231 for true and 1237 for false\n    ;; http://docs.oracle.com/javase/7/docs/api/java/lang/Boolean.html#hashCode%28%29\n    (true? o) 1231\n\n    (false? o) 1237\n\n    (string? o)\n    (m3-hash-int (hash-string o))\n\n    (instance? js/Date o)\n    (bit-xor (.valueOf o) 0)\n\n    (nil? o) 0\n\n    :else\n    (bit-xor (-hash o) 0)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [1024 1060]},
                             :full-name "cljs.core/hash",
                             :docstring "Returns the hash code of its argument. Note this is the hash code\nconsistent with =."},
           "cljs.core/bit-set" {:ns "cljs.core",
                                :name "bit-set",
                                :signature ["[x n]"],
                                :name-encode "bit-set",
                                :history [["+" "0.0-927"]],
                                :type "function/macro",
                                :full-name-encode "cljs.core/bit-set",
                                :source {:code "(defn bit-set\n  [x n]\n  (cljs.core/bit-set x n))",
                                         :title "Function code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [2975 2978]},
                                :extra-sources [{:code "(core/defmacro ^::ana/numeric bit-set [x n]\n  (core/list 'js* \"(~{} | (1 << ~{}))\" x n))",
                                                 :title "Macro code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/clojure/cljs/core.cljc",
                                                 :lines [1243 1244]}],
                                :full-name "cljs.core/bit-set",
                                :docstring "Set bit at index n"},
           "syntax/false" {:syntax-equiv {:edn-url nil, :clj-url nil},
                           :ns "syntax",
                           :name "false",
                           :name-encode "false",
                           :history [["+" "0.0-1853"]],
                           :type "special symbol",
                           :full-name-encode "syntax/false",
                           :extra-sources ({:code "(defn- read-symbol\n  [rdr initch]\n  (let [[line column] (starting-line-col-info rdr)]\n    (when-let [token (read-token rdr :symbol initch)]\n      (case token\n\n        ;; special symbols\n        \"nil\" nil\n        \"true\" true\n        \"false\" false\n        \"/\" '/\n\n        (or (when-let [p (parse-symbol token)]\n              (with-meta (symbol (p 0) (p 1))\n                (when line\n                  (merge\n                   (when-let [file (get-file-name rdr)]\n                     {:file file})\n                   (let [[end-line end-column] (ending-line-col-info rdr)]\n                     {:line line\n                      :column column\n                      :end-line end-line\n                      :end-column end-column})))))\n            (err/throw-invalid rdr :symbol token))))))",
                                            :title "Reader code",
                                            :repo "tools.reader",
                                            :tag "v1.3.6",
                                            :filename "src/main/clojure/clojure/tools/reader.clj",
                                            :lines [304 327]}),
                           :full-name "syntax/false"},
           "cljs.core/clj->js" {:ns "cljs.core",
                                :name "clj->js",
                                :signature ["[x & {:keys [keyword-fn], :or {keyword-fn name}, :as options}]"],
                                :name-encode "clj-GTjs",
                                :history [["+" "0.0-1552"]],
                                :type "function",
                                :full-name-encode "cljs.core/clj-GTjs",
                                :source {:code "(defn clj->js\n  [x & {:keys [keyword-fn]\n        :or   {keyword-fn name}\n        :as options}]\n  (letfn [(keyfn [k] (key->js k thisfn))\n          (thisfn [x] (cond\n                        (nil? x) nil\n                        (satisfies? IEncodeJS x) (-clj->js x)\n                        (keyword? x) (keyword-fn x)\n                        (symbol? x) (str x)\n                        (map? x) (let [m (js-obj)]\n                                   (doseq [[k v] x]\n                                     (gobject/set m (keyfn k) (thisfn v)))\n                                   m)\n                        (coll? x) (let [arr (array)]\n                                    (doseq [x (map thisfn x)]\n                                      (.push arr x))\n                                    arr)\n                        :else x))]\n    (thisfn x)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [11174 11199]},
                                :full-name "cljs.core/clj->js",
                                :docstring "Recursively transforms ClojureScript values to JavaScript.\nsets/vectors/lists become Arrays, Keywords and Symbol become Strings,\nMaps become Objects. Arbitrary keys are encoded to by `key->js`.\nOptions is a key-value pair, where the only valid key is\n:keyword-fn, which should point to a single-argument function to be\ncalled on keyword keys. Default to `name`."},
           "repl-options/analyze-path" {:ns "repl-options",
                                        :name "analyze-path",
                                        :name-encode "analyze-path",
                                        :type "option",
                                        :full-name-encode "repl-options/analyze-path",
                                        :full-name "repl-options/analyze-path",
                                        :history [["+" "0.0-1552"]]},
           "cljs.js/load-analysis-cache!" {:ns "cljs.js",
                                           :name "load-analysis-cache!",
                                           :signature ["[state ns cache]"],
                                           :name-encode "load-analysis-cacheBANG",
                                           :history [["+" "1.7.10"]],
                                           :type "function",
                                           :full-name-encode "cljs.js/load-analysis-cacheBANG",
                                           :source {:code "(defn load-analysis-cache! [state ns cache]\n  (swap! state assoc-in [::ana/namespaces ns] cache))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/cljs/cljs/js.cljs",
                                                    :lines [141 142]},
                                           :full-name "cljs.js/load-analysis-cache!"},
           "cljs.core/concat" {:ns "cljs.core",
                               :name "concat",
                               :signature ["[]"
                                           "[x]"
                                           "[x y]"
                                           "[x y & zs]"],
                               :name-encode "concat",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/concat",
                               :source {:code "(defn concat\n  ([] (lazy-seq nil))\n  ([x] (lazy-seq x))\n  ([x y]\n    (lazy-seq\n      (let [s (seq x)]\n        (if s\n          (if (chunked-seq? s)\n            (chunk-cons (chunk-first s) (concat (chunk-rest s) y))\n            (cons (first s) (concat (rest s) y)))\n          y))))\n  ([x y & zs]\n     (let [cat (fn cat [xys zs]\n                 (lazy-seq\n                   (let [xys (seq xys)]\n                     (if xys\n                       (if (chunked-seq? xys)\n                         (chunk-cons (chunk-first xys)\n                                     (cat (chunk-rest xys) zs))\n                         (cons (first xys) (cat (rest xys) zs)))\n                       (when zs\n                         (cat (first zs) (next zs)))))))]\n       (cat (concat x y) zs))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [3865 3888]},
                               :full-name "cljs.core/concat",
                               :docstring "Returns a lazy seq representing the concatenation of the elements in the supplied colls."},
           "cljs.test/IAsyncTest" {:ns "cljs.test",
                                   :name "IAsyncTest",
                                   :name-encode "IAsyncTest",
                                   :history [["+" "0.0-2814"]],
                                   :type "protocol",
                                   :full-name-encode "cljs.test/IAsyncTest",
                                   :source {:code "(defprotocol IAsyncTest)",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/test.cljs",
                                            :lines [430 432]},
                                   :full-name "cljs.test/IAsyncTest",
                                   :docstring "Marker protocol denoting CPS function to begin asynchronous\n  testing."},
           "cljs.spec.test/get-ua-product" {:ns "cljs.spec.test",
                                            :name "get-ua-product",
                                            :signature ["[]"],
                                            :name-encode "get-ua-product",
                                            :history [["+" "1.9.183"]
                                                      ["-" "1.9.542"]],
                                            :type "function",
                                            :full-name-encode "cljs.spec.test/get-ua-product",
                                            :source {:code "(defn get-ua-product []\n  (if (not= \"browser\" *target*)\n    (keyword *target*)\n    (cond\n      product/SAFARI :safari\n      product/CHROME :chrome\n      product/FIREFOX :firefox\n      product/IE :ie)))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.9.521",
                                                     :filename "src/main/cljs/cljs/spec/test.cljs",
                                                     :lines [51 58]},
                                            :full-name "cljs.spec.test/get-ua-product",
                                            :removed {:in "1.9.542",
                                                      :last-seen "1.9.521"}},
           "cljs.core/map-entry?" {:ns "cljs.core",
                                   :name "map-entry?",
                                   :signature ["[x]"],
                                   :name-encode "map-entryQMARK",
                                   :history [["+" "1.10.63"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/map-entryQMARK",
                                   :source {:code "(defn map-entry?\n  [x]\n  (implements? IMapEntry x))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [6885 6888]},
                                   :full-name "cljs.core/map-entry?",
                                   :docstring "Returns true if x satisfies IMapEntry"},
           "cljs.core/conj" {:ns "cljs.core",
                             :name "conj",
                             :signature ["[]"
                                         "[coll]"
                                         "[coll x]"
                                         "[coll x & xs]"],
                             :name-encode "conj",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/conj",
                             :source {:code "(defn conj\n  ([] [])\n  ([coll] coll)\n  ([coll x]\n    (if-not (nil? coll)\n      (-conj coll x)\n      (list x)))\n  ([coll x & xs]\n    (if xs\n      (recur (conj coll x) (first xs) (next xs))\n      (conj coll x))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [1832 1847]},
                             :full-name "cljs.core/conj",
                             :docstring "conj[oin]. Returns a new collection with the xs\n'added'. (conj nil item) returns (item).\n(conj coll) returns coll. (conj) returns [].\nThe 'addition' may happen at different 'places' depending\non the concrete type."},
           "cljs.core/unchecked-short" {:return-type number,
                                        :ns "cljs.core",
                                        :name "unchecked-short",
                                        :signature ["[x]"],
                                        :name-encode "unchecked-short",
                                        :history [["+" "0.0-1798"]],
                                        :type "function/macro",
                                        :full-name-encode "cljs.core/unchecked-short",
                                        :source {:code "(defn ^number unchecked-short [x] x)",
                                                 :title "Function code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/cljs/cljs/core.cljs",
                                                 :lines [2801]},
                                        :extra-sources [{:code "(core/defmacro unchecked-short [x] x)",
                                                         :title "Macro code",
                                                         :repo "clojurescript",
                                                         :tag "r1.12.38",
                                                         :filename "src/main/clojure/cljs/core.cljc",
                                                         :lines [1073]}],
                                        :full-name "cljs.core/unchecked-short"},
           "clojure.set/difference" {:ns "clojure.set",
                                     :name "difference",
                                     :signature ["[s1]"
                                                 "[s1 s2]"
                                                 "[s1 s2 & sets]"],
                                     :name-encode "difference",
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "clojure.set/difference",
                                     :source {:code "(defn difference\n  ([s1] s1)\n  ([s1 s2] \n     (if (< (count s1) (count s2))\n       (reduce (fn [result item] \n                   (if (contains? s2 item) \n                     (disj result item) \n                     result))\n               s1 s1)\n       (reduce disj s1 s2)))\n  ([s1 s2 & sets] \n     (reduce difference s1 (conj sets s2))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/cljs/clojure/set.cljs",
                                              :lines [46 58]},
                                     :full-name "clojure.set/difference",
                                     :docstring "Return a set that is the first set without elements of the remaining sets"},
           "cljs.spec.gen.alpha/set" {:ns "cljs.spec.gen.alpha",
                                      :name "set",
                                      :signature ["[& args]"],
                                      :name-encode "set",
                                      :history [["+" "1.9.542"]],
                                      :type "function",
                                      :full-name-encode "cljs.spec.gen.alpha/set",
                                      :source {:code "(lazy-combinators hash-map list map not-empty set vector vector-distinct fmap elements\n  bind choose one-of such-that tuple sample return\n  large-integer* double* frequency shuffle)",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/spec/gen/alpha.cljs",
                                               :lines [70 72]},
                                      :full-name "cljs.spec.gen.alpha/set",
                                      :docstring "Lazy loaded version of clojure.test.check.generators/set"},
           "cljs.spec/instrument*" {:ns "cljs.spec",
                                    :name "instrument*",
                                    :signature ["[v]"],
                                    :name-encode "instrumentSTAR",
                                    :history [["+" "1.9.14"]
                                              ["-" "1.9.183"]],
                                    :type "function",
                                    :full-name-encode "cljs.spec/instrumentSTAR",
                                    :source {:code "(defn instrument*\n  [v]\n  (let [spec (get-spec v)]\n    (if (fn-spec? spec)\n      (locking instrumented-vars\n               (let [{:keys [raw wrapped]} (get @instrumented-vars v)\n                     current @v]\n                 (when-not (= wrapped current)\n                   (let [checked (spec-checking-fn v current)]\n                     (swap! instrumented-vars assoc v {:raw current :wrapped checked})\n                     checked))))\n      (throw (no-fn-spec v spec)))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.9.93",
                                             :filename "src/main/cljs/cljs/spec.cljs",
                                             :lines [332 343]},
                                    :full-name "cljs.spec/instrument*",
                                    :removed {:in "1.9.183",
                                              :last-seen "1.9.93"}},
           "cljs.core/byte" {:return-type number,
                             :ns "cljs.core",
                             :name "byte",
                             :signature ["[x]"],
                             :name-encode "byte",
                             :history [["+" "0.0-1798"]],
                             :type "function/macro",
                             :full-name-encode "cljs.core/byte",
                             :source {:code "(defn ^number byte [x] x)",
                                      :title "Function code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [2785]},
                             :extra-sources [{:code "(core/defmacro byte [x] x)",
                                              :title "Macro code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/clojure/cljs/core.cljc",
                                              :lines [1066]}],
                             :full-name "cljs.core/byte"},
           "cljs.core/when-first" {:ns "cljs.core",
                                   :name "when-first",
                                   :signature ["[bindings & body]"],
                                   :name-encode "when-first",
                                   :history [["+" "0.0-927"]],
                                   :type "macro",
                                   :full-name-encode "cljs.core/when-first",
                                   :source {:code "(defmacro when-first\n  {:added \"1.0\"}\n  [bindings & body]\n  (assert-args\n     (vector? bindings) \"a vector for its binding\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n  (let [[x xs] bindings]\n    `(when-let [xs# (seq ~xs)]\n       (let [~x (first xs#)]\n           ~@body))))",
                                            :title "Source code",
                                            :repo "clojure",
                                            :tag "clojure-1.10.0",
                                            :filename "src/clj/clojure/core.clj",
                                            :lines [4600 4612]},
                                   :full-name "cljs.core/when-first",
                                   :docstring "bindings => x xs\n\nRoughly the same as (when (seq xs) (let [x (first xs)] body)) but xs is evaluated only once"},
           "cljs.core/add-tap" {:ns "cljs.core",
                                :name "add-tap",
                                :signature ["[f]"],
                                :name-encode "add-tap",
                                :history [["+" "1.10.63"]],
                                :type "function",
                                :full-name-encode "cljs.core/add-tap",
                                :source {:code "(defn add-tap\n  [f]\n  (maybe-init-tapset)\n  (swap! tapset conj f)\n  nil)",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [12045 12051]},
                                :full-name "cljs.core/add-tap",
                                :docstring "Adds f, a fn of one argument, to the tap set. This function will be called with\nanything sent via tap>. Remember f in order to remove-tap"},
           "cljs.reader/*tag-table*" {:ns "cljs.reader",
                                      :name "*tag-table*",
                                      :name-encode "STARtag-tableSTAR",
                                      :type "dynamic var",
                                      :full-name-encode "cljs.reader/STARtag-tableSTAR",
                                      :source {:code "(def ^:dynamic *tag-table*\n  (atom\n    (add-data-readers\n      {'inst  read-date\n       'uuid  read-uuid\n       'queue read-queue\n       'js    read-js})))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/reader.cljs",
                                               :lines [134 140]},
                                      :full-name "cljs.reader/*tag-table*",
                                      :history [["+" "0.0-1236"]]},
           "cljs.core/distinct?" {:return-type boolean,
                                  :ns "cljs.core",
                                  :name "distinct?",
                                  :signature ["[x]"
                                              "[x y]"
                                              "[x y & more]"],
                                  :name-encode "distinctQMARK",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/distinctQMARK",
                                  :source {:code "(defn ^boolean distinct?\n  ([x] true)\n  ([x y] (not (= x y)))\n  ([x y & more]\n     (if (not (= x y))\n     (loop [s #{x y} xs more]\n       (let [x (first xs)\n             etc (next xs)]\n         (if xs\n           (if (contains? s x)\n             false\n             (recur (conj s x) etc))\n           true)))\n     false)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [2440 2454]},
                                  :full-name "cljs.core/distinct?",
                                  :docstring "Returns true if no two of the arguments are ="},
           "cljs.pprint/pprint" {:ns "cljs.pprint",
                                 :name "pprint",
                                 :signature ["[object]"
                                             "[object writer]"],
                                 :name-encode "pprint",
                                 :history [["+" "0.0-3255"]],
                                 :type "function",
                                 :full-name-encode "cljs.pprint/pprint",
                                 :source {:code "(defn pprint\n  ([object]\n   (let [sb (StringBuffer.)]\n     (binding [*out* (StringBufferWriter. sb)]\n       (pprint object *out*)\n       (string-print (str sb)))))\n  ([object writer]\n   (with-pretty-writer writer\n                       (binding [*print-pretty* true]\n                         (write-out object))\n                       (if (not (= 0 (get-column *out*)))\n                         (-write *out* \\newline)))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/pprint.cljs",
                                          :lines [814 825]},
                                 :full-name "cljs.pprint/pprint"},
           "clojure.core.reducers/filter" {:ns "clojure.core.reducers",
                                           :name "filter",
                                           :signature ["[pred]"
                                                       "[pred coll]"],
                                           :name-encode "filter",
                                           :history [["+" "0.0-1236"]],
                                           :type "function",
                                           :full-name-encode "clojure.core.reducers/filter",
                                           :source {:code "(defcurried filter\n  {}\n  [pred coll]\n  (folder coll\n   (fn [f1]\n     (rfn [f1 k]\n          ([ret k v]\n             (if (pred k v)\n               (f1 ret k v)\n               ret))))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/cljs/clojure/core/reducers.cljs",
                                                    :lines [117 128]},
                                           :full-name "clojure.core.reducers/filter",
                                           :docstring "Retains values in the reduction of coll for which (pred val)\n  returns logical true. Foldable."},
           "cljs.core/INamed" {:ns "cljs.core",
                               :name "INamed",
                               :name-encode "INamed",
                               :implementations #{"Symbol"
                                                  "Keyword"
                                                  "MultiFn"},
                               :history [["+" "0.0-1798"]],
                               :type "protocol",
                               :full-name-encode "cljs.core/INamed",
                               :source {:code "(defprotocol INamed\n  (^string -name [x]\n    \"Returns the name String of x.\")\n  ( ^{:tag #{string clj-nil}}-namespace [x]\n    \"Returns the namespace String of x.\"))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [858 863]},
                               :methods [{:name "-name",
                                          :signature ["[x]"],
                                          :docstring "Returns the name String of x."}
                                         {:name "-namespace",
                                          :signature ["[x]"],
                                          :docstring "Returns the namespace String of x."}],
                               :full-name "cljs.core/INamed",
                               :docstring "Protocol for adding a name."},
           "cljs.math/increment-exact" {:return-type number,
                                        :ns "cljs.math",
                                        :name "increment-exact",
                                        :signature ["[a]"],
                                        :name-encode "increment-exact",
                                        :history [["+" "1.11.50"]],
                                        :type "function",
                                        :full-name-encode "cljs.math/increment-exact",
                                        :source {:code "(defn ^number increment-exact\n  {:added \"1.11.10\"}\n  [a]\n  (if (or (>= a js/Number.MAX_SAFE_INTEGER) (< a js/Number.MIN_SAFE_INTEGER))\n    (throw (ex-info \"Integer overflow\" {:fn \"increment-exact\"}))\n    (inc a)))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/cljs/cljs/math.cljs",
                                                 :lines [543 549]},
                                        :full-name "cljs.math/increment-exact",
                                        :docstring "Returns a incremented by 1, throws ArithmeticException on overflow."},
           "cljs.repl/merge-spec" {:ns "cljs.repl",
                                   :name "merge-spec",
                                   :signature ["[[lib & {:as aindex}] [_ & {:as bindex}]]"],
                                   :name-encode "merge-spec",
                                   :history [["+" "0.0-2629"]
                                             ["-" "0.0-2655"]],
                                   :type "function",
                                   :full-name-encode "cljs.repl/merge-spec",
                                   :source {:code "(defn merge-spec [[lib & {:as aindex}] [_ & {:as bindex}]]\n  (let [merged-map\n        (merge-with\n          (fn [x y]\n            (if (vector? x)\n              (vec (distinct (into x y)))\n              y))\n          aindex bindex)]\n    (apply vector lib\n      (apply concat\n        (sort\n          (fn [[sa] [sb]]\n            (compare (spec-sort sa) (spec-sort sb)))\n          merged-map)))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2644",
                                            :filename "src/clj/cljs/repl.clj",
                                            :lines [196 209]},
                                   :full-name "cljs.repl/merge-spec",
                                   :removed {:in "0.0-2655",
                                             :last-seen "0.0-2644"}},
           "syntax/set" {:syntax-equiv {:edn-url nil, :clj-url nil},
                         :ns "syntax",
                         :name "set",
                         :name-encode "set",
                         :history [["+" "0.0-1853"]],
                         :type "syntax",
                         :full-name-encode "syntax/set",
                         :extra-sources ({:code "(defn- read-set\n  [rdr _ opts pending-forms]\n  (let [[start-line start-column] (starting-line-col-info rdr)\n        ;; subtract 1 from start-column so it includes the # in the leading #{\n        start-column (if start-column (int (dec (int start-column))))\n        the-set (PersistentHashSet/createWithCheck\n          (read-delimited :set \\} rdr opts pending-forms))\n        [end-line end-column] (ending-line-col-info rdr)]\n    (with-meta the-set\n      (when start-line\n        (merge\n         (when-let [file (get-file-name rdr)]\n           {:file file})\n         {:line start-line\n          :column start-column\n          :end-line end-line\n          :end-column end-column})))))",
                                          :title "Reader code",
                                          :repo "tools.reader",
                                          :tag "v1.3.6",
                                          :filename "src/main/clojure/clojure/tools/reader.clj",
                                          :lines [388 404]}
                                         {:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    \\? read-cond\n    \\: read-namespaced-map\n    \\# read-symbolic-value\n    nil))",
                                          :title "Reader table",
                                          :repo "tools.reader",
                                          :tag "v1.3.6",
                                          :filename "src/main/clojure/clojure/tools/reader.clj",
                                          :lines [809 823]}),
                         :full-name "syntax/set"},
           "cljs.core/add-to-string-hash-cache" {:ns "cljs.core",
                                                 :name "add-to-string-hash-cache",
                                                 :signature ["[k]"],
                                                 :name-encode "add-to-string-hash-cache",
                                                 :history [["+"
                                                            "0.0-1424"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core/add-to-string-hash-cache",
                                                 :source {:code "(defn add-to-string-hash-cache [k]\n  (let [h (hash-string* k)]\n    (gobject/set string-hash-cache k h)\n    (set! string-hash-cache-count (inc string-hash-cache-count))\n    h))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r1.12.38",
                                                          :filename "src/main/cljs/cljs/core.cljs",
                                                          :lines [1007
                                                                  1011]},
                                                 :full-name "cljs.core/add-to-string-hash-cache"},
           "cljs.repl.rhino/repl-env" {:ns "cljs.repl.rhino",
                                       :name "repl-env",
                                       :signature ["[& {:as opts}]"],
                                       :name-encode "repl-env",
                                       :history [["+" "0.0-927"]
                                                 ["-" "1.10.738"]],
                                       :type "function",
                                       :full-name-encode "cljs.repl.rhino/repl-env",
                                       :source {:code "(defn repl-env\n  [& {:as opts}]\n  (repl-env* opts))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.10.597",
                                                :filename "src/main/clojure/cljs/repl/rhino.clj",
                                                :lines [226 230]},
                                       :full-name "cljs.repl.rhino/repl-env",
                                       :docstring "Returns a fresh JS environment, suitable for passing to repl.\nHang on to return for use across repl calls.",
                                       :removed {:in "1.10.738",
                                                 :last-seen "1.10.597"}},
           "cljs.math/cbrt" {:return-type number,
                             :ns "cljs.math",
                             :name "cbrt",
                             :signature ["[a]"],
                             :name-encode "cbrt",
                             :history [["+" "1.11.50"]],
                             :type "function",
                             :full-name-encode "cljs.math/cbrt",
                             :source {:code "(defn ^number cbrt\n  {:added \"1.11.10\"}\n  [a] (Math/cbrt a))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/math.cljs",
                                      :lines [176 183]},
                             :full-name "cljs.math/cbrt",
                             :docstring "Returns the cube root of a.\nIf a is ##NaN => ##NaN\nIf a is ##Inf or ##-Inf => a\nIf a is zero => zero with sign matching a\nSee: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/cbrt"},
           "cljs.core/HashCollisionNode" {:protocols #{"IIterable"},
                                          :ns "cljs.core",
                                          :name "HashCollisionNode",
                                          :signature ["[edit collision-hash cnt arr]"],
                                          :name-encode "HashCollisionNode",
                                          :history [["+" "0.0-1211"]],
                                          :type "type",
                                          :full-name-encode "cljs.core/HashCollisionNode",
                                          :source {:code "(deftype HashCollisionNode [edit\n                            ^:mutable collision-hash\n                            ^:mutable cnt\n                            ^:mutable arr]\n  Object\n  (inode-assoc [inode shift hash key val added-leaf?]\n    (if (== hash collision-hash)\n      (let [idx (hash-collision-node-find-index arr cnt key)]\n        (if (== idx -1)\n          (let [len     (* 2 cnt)\n                new-arr (make-array (+ len 2))]\n            (array-copy arr 0 new-arr 0 len)\n            (aset new-arr len key)\n            (aset new-arr (inc len) val)\n            (set! (.-val added-leaf?) true)\n            (HashCollisionNode. nil collision-hash (inc cnt) new-arr))\n          (if (= (aget arr (inc idx)) val)\n            inode\n            (HashCollisionNode. nil collision-hash cnt (clone-and-set arr (inc idx) val)))))\n      (.inode-assoc (BitmapIndexedNode. nil (bitpos collision-hash shift) (array nil inode))\n                    shift hash key val added-leaf?)))\n\n  (inode-without [inode shift hash key]\n    (let [idx (hash-collision-node-find-index arr cnt key)]\n      (cond (== idx -1) inode\n            (== cnt 1)  nil\n            :else (HashCollisionNode. nil collision-hash (dec cnt) (remove-pair arr (quot idx 2))))))\n\n  (inode-lookup [inode shift hash key not-found]\n    (let [idx (hash-collision-node-find-index arr cnt key)]\n      (cond (< idx 0) not-found\n            :else     (aget arr (inc idx)))))\n\n  (inode-find [inode shift hash key not-found]\n    (let [idx (hash-collision-node-find-index arr cnt key)]\n      (cond (< idx 0) not-found\n            :else     (MapEntry. (aget arr idx) (aget arr (inc idx)) nil))))\n\n  (inode-seq [inode]\n    (create-inode-seq arr))\n\n  (ensure-editable [inode e]\n    (if (identical? e edit)\n      inode\n      (let [new-arr (make-array (* 2 (inc cnt)))]\n        (array-copy arr 0 new-arr 0 (* 2 cnt))\n        (HashCollisionNode. e collision-hash cnt new-arr))))\n\n  (ensure-editable-array [inode e count array]\n    (if (identical? e edit)\n      (do (set! arr array)\n          (set! cnt count)\n          inode)\n      (HashCollisionNode. edit collision-hash count array)))\n\n  (inode-assoc! [inode edit shift hash key val added-leaf?]\n    (if (== hash collision-hash)\n      (let [idx (hash-collision-node-find-index arr cnt key)]\n        (if (== idx -1)\n          (if (> (alength arr) (* 2 cnt))\n            (let [editable (edit-and-set inode edit (* 2 cnt) key (inc (* 2 cnt)) val)]\n              (set! (.-val added-leaf?) true)\n              (set! (.-cnt editable) (inc (.-cnt editable)))\n              editable)\n            (let [len     (alength arr)\n                  new-arr (make-array (+ len 2))]\n              (array-copy arr 0 new-arr 0 len)\n              (aset new-arr len key)\n              (aset new-arr (inc len) val)\n              (set! (.-val added-leaf?) true)\n              (.ensure-editable-array inode edit (inc cnt) new-arr)))\n          (if (identical? (aget arr (inc idx)) val)\n            inode\n            (edit-and-set inode edit (inc idx) val))))\n      (.inode-assoc! (BitmapIndexedNode. edit (bitpos collision-hash shift) (array nil inode nil nil))\n                     edit shift hash key val added-leaf?)))\n\n  (inode-without! [inode edit shift hash key removed-leaf?]\n    (let [idx (hash-collision-node-find-index arr cnt key)]\n      (if (== idx -1)\n        inode\n        (do (set! (.-val removed-leaf?) true)\n            (if (== cnt 1)\n              nil\n              (let [editable (.ensure-editable inode edit)\n                    earr     (.-arr editable)]\n                (aset earr idx (aget earr (- (* 2 cnt) 2)))\n                (aset earr (inc idx) (aget earr (dec (* 2 cnt))))\n                (aset earr (dec (* 2 cnt)) nil)\n                (aset earr (- (* 2 cnt) 2) nil)\n                (set! (.-cnt editable) (dec (.-cnt editable)))\n                editable))))))\n\n  (kv-reduce [inode f init]\n    (inode-kv-reduce arr f init))\n\n  IIterable\n  (-iterator [coll]\n    (NodeIterator. arr 0 nil nil)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/cljs/cljs/core.cljs",
                                                   :lines [7806 7904]},
                                          :full-name "cljs.core/HashCollisionNode"},
           "cljs.core/m3-mix-K1" {:return-type number,
                                  :ns "cljs.core",
                                  :name "m3-mix-K1",
                                  :signature ["[k1]"],
                                  :name-encode "m3-mix-K1",
                                  :history [["+" "0.0-2261"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/m3-mix-K1",
                                  :source {:code "(defn ^number m3-mix-K1 [k1]\n  (-> (int k1) (imul m3-C1) (int-rotate-left 15) (imul m3-C2)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [941 942]},
                                  :full-name "cljs.core/m3-mix-K1"},
           "cljs.core/object?" {:ns "cljs.core",
                                :name "object?",
                                :signature ["[x]"],
                                :name-encode "objectQMARK",
                                :history [["+" "0.0-2120"]],
                                :type "function",
                                :full-name-encode "cljs.core/objectQMARK",
                                :source {:code "(defn object?\n  [x]\n  (if-not (nil? x)\n    (identical? (.-constructor x) js/Object)\n    false))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [270 275]},
                                :full-name "cljs.core/object?",
                                :docstring "Returns true if x's constructor is Object"},
           "cljs.core/pos?" {:return-type boolean,
                             :ns "cljs.core",
                             :name "pos?",
                             :signature ["[x]"],
                             :name-encode "posQMARK",
                             :history [["+" "0.0-927"]],
                             :type "function/macro",
                             :full-name-encode "cljs.core/posQMARK",
                             :source {:code "(defn ^boolean pos?\n  [x] (cljs.core/pos? x))",
                                      :title "Function code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [3021 3023]},
                             :extra-sources [{:code "(core/defmacro ^::ana/numeric pos? [x]\n  `(> ~x 0))",
                                              :title "Macro code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/clojure/cljs/core.cljc",
                                              :lines [1174 1175]}],
                             :full-name "cljs.core/pos?",
                             :docstring "Returns true if num is greater than zero, else false"},
           "cljs.spec.gen.alpha/return" {:ns "cljs.spec.gen.alpha",
                                         :name "return",
                                         :signature ["[& args]"],
                                         :name-encode "return",
                                         :history [["+" "1.9.542"]],
                                         :type "function",
                                         :full-name-encode "cljs.spec.gen.alpha/return",
                                         :source {:code "(lazy-combinators hash-map list map not-empty set vector vector-distinct fmap elements\n  bind choose one-of such-that tuple sample return\n  large-integer* double* frequency shuffle)",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/cljs/cljs/spec/gen/alpha.cljs",
                                                  :lines [70 72]},
                                         :full-name "cljs.spec.gen.alpha/return",
                                         :docstring "Lazy loaded version of clojure.test.check.generators/return"},
           "cljs.spec.alpha/unform" {:ns "cljs.spec.alpha",
                                     :name "unform",
                                     :signature ["[spec x]"],
                                     :name-encode "unform",
                                     :history [["+" "1.9.542"]],
                                     :type "function",
                                     :full-name-encode "cljs.spec.alpha/unform",
                                     :source {:code "(defn unform\n  [spec x]\n  (unform* (specize spec) x))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/cljs/cljs/spec/alpha.cljs",
                                              :lines [174 179]},
                                     :full-name "cljs.spec.alpha/unform",
                                     :docstring "Given a spec and a value created by or compliant with a call to\n'conform' with the same spec, returns a value with all conform\n destructuring undone."},
           "cljs.math/round" {:return-type number,
                              :ns "cljs.math",
                              :name "round",
                              :signature ["[a]"],
                              :name-encode "round",
                              :history [["+" "1.11.50"]],
                              :type "function",
                              :full-name-encode "cljs.math/round",
                              :source {:code "(defn ^number round\n  {:added \"1.11.10\"}\n  [a]\n  (cond\n    ^boolean (js/isNaN a) 0\n    ^boolean (js/isFinite a) (Math/round a)\n    (== ##Inf a) js/Number.MAX_SAFE_INTEGER\n    :default js/Number.MIN_SAFE_INTEGER))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/math.cljs",
                                       :lines [493 506]},
                              :full-name "cljs.math/round",
                              :docstring "Returns the closest long to a. If equally close to two values, return the one\ncloser to ##Inf.\nIf a is ##NaN => 0\nIf a is ##-Inf => js/Number.MIN_SAFE_INTEGER\nIf a is ##Inf => js/Number.MAX_SAFE_INTEGER\nSee: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round"},
           "cljs.core/APersistentVector" {:ns "cljs.core",
                                          :name "APersistentVector",
                                          :name-encode "APersistentVector",
                                          :implementations #{"PersistentVector"},
                                          :history [["+" "1.9.655"]],
                                          :type "protocol",
                                          :full-name-encode "cljs.core/APersistentVector",
                                          :source {:code "(defprotocol APersistentVector)",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/cljs/cljs/core.cljs",
                                                   :lines [5616 5617]},
                                          :full-name "cljs.core/APersistentVector",
                                          :docstring "Marker protocol"},
           "compiler-options/source-map-path" {:ns "compiler-options",
                                               :name "source-map-path",
                                               :name-encode "source-map-path",
                                               :type "option",
                                               :full-name-encode "compiler-options/source-map-path",
                                               :full-name "compiler-options/source-map-path",
                                               :history [["+"
                                                          "0.0-2060"]]},
           "cljs.core/refer-clojure" {:ns "cljs.core",
                                      :name "refer-clojure",
                                      :signature ["[& args]"],
                                      :name-encode "refer-clojure",
                                      :history [["+" "1.9.198"]],
                                      :type "macro",
                                      :full-name-encode "cljs.core/refer-clojure",
                                      :source {:code "(core/defmacro refer-clojure\n  [& args]\n  `(~'ns* ~(cons :refer-clojure args)))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/clojure/cljs/core.cljc",
                                               :lines [3079 3090]},
                                      :full-name "cljs.core/refer-clojure",
                                      :docstring "Refers to all the public vars of `cljs.core`, subject to\nfilters.\nFilters can include at most one each of:\n\n:exclude list-of-symbols\n:rename map-of-fromsymbol-tosymbol\n\nFilters can be used to select a subset, via exclusion, or to provide a mapping\nto a symbol different from the var's name, in order to prevent clashes."},
           "cljs.test/block" {:ns "cljs.test",
                              :name "block",
                              :signature ["[fns]"],
                              :name-encode "block",
                              :history [["+" "0.0-2814"]],
                              :type "function",
                              :full-name-encode "cljs.test/block",
                              :source {:code "(defn block\n  [fns]\n  (some-> fns\n          (vary-meta assoc ::block? true)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/test.cljs",
                                       :lines [458 463]},
                              :full-name "cljs.test/block",
                              :docstring "Tag a seq of fns to be picked up by run-block as injected\ncontinuation.  See run-block."},
           "cljs.core/into-array" {:return-type array,
                                   :ns "cljs.core",
                                   :name "into-array",
                                   :signature ["[aseq]" "[type aseq]"],
                                   :name-encode "into-array",
                                   :history [["+" "0.0-1211"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/into-array",
                                   :source {:code "(defn ^array into-array\n  ([aseq]\n     (into-array nil aseq))\n  ([type aseq]\n     (reduce (fn [a x] (.push a x) a) (array) aseq)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [530 536]},
                                   :full-name "cljs.core/into-array",
                                   :docstring "Returns an array with components set to the values in aseq. Optional type\nargument accepted for compatibility with Clojure."},
           "syntax/tagged-literal" {:syntax-equiv {:edn-url nil,
                                                   :clj-url nil},
                                    :ns "syntax",
                                    :name "tagged-literal",
                                    :name-encode "tagged-literal",
                                    :history [["+" "0.0-1853"]],
                                    :type "syntax",
                                    :full-name-encode "syntax/tagged-literal",
                                    :extra-sources ({:code "(defn- read-tagged [rdr initch opts pending-forms]\n  (let [tag (read* rdr true nil opts pending-forms)]\n    (if-not (symbol? tag)\n      (err/throw-bad-reader-tag rdr tag))\n    (if *suppress-read*\n      (tagged-literal tag (read* rdr true nil opts pending-forms))\n      (if-let [f (or (*data-readers* tag)\n                     (default-data-readers tag))]\n        (f (read* rdr true nil opts pending-forms))\n        (if (.contains (name tag) \".\")\n          (read-ctor rdr tag opts pending-forms)\n          (if-let [f *default-data-reader-fn*]\n            (f tag (read* rdr true nil opts pending-forms))\n            (err/throw-unknown-reader-tag rdr tag)))))))",
                                                     :title "Reader code",
                                                     :repo "tools.reader",
                                                     :tag "v1.3.6",
                                                     :filename "src/main/clojure/clojure/tools/reader.clj",
                                                     :lines [858 871]}),
                                    :full-name "syntax/tagged-literal"},
           "cljs.core/PersistentVector" {:protocols #{"IFn"
                                                      "ISeqable"
                                                      "IMeta"
                                                      "IWithMeta"
                                                      "IKVReduce"
                                                      "IReversible"
                                                      "IEditableCollection"
                                                      "IStack"
                                                      "IEmptyableCollection"
                                                      "ICounted"
                                                      "IReduce"
                                                      "ILookup"
                                                      "ISequential"
                                                      "ICollection"
                                                      "APersistentVector"
                                                      "IHash"
                                                      "IDrop"
                                                      "IComparable"
                                                      "IPrintWithWriter"
                                                      "IIndexed"
                                                      "IIterable"
                                                      "IAssociative"
                                                      "IVector"
                                                      "IFind"
                                                      "IEquiv"
                                                      "ICloneable"},
                                         :ns "cljs.core",
                                         :name "PersistentVector",
                                         :signature ["[meta cnt shift root tail __hash]"],
                                         :name-encode "PersistentVector",
                                         :history [["+" "0.0-1006"]],
                                         :type "type",
                                         :full-name-encode "cljs.core/PersistentVector",
                                         :source {:code "(deftype PersistentVector [meta cnt shift root tail ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  ICloneable\n  (-clone [_] (PersistentVector. meta cnt shift root tail __hash))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (PersistentVector. new-meta cnt shift root tail __hash)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IStack\n  (-peek [coll]\n    (when (> cnt 0)\n      (-nth coll (dec cnt))))\n  (-pop [coll]\n    (cond\n     (zero? cnt) (throw (js/Error. \"Can't pop empty vector\"))\n     (== 1 cnt) (-with-meta (.-EMPTY PersistentVector) meta)\n     (< 1 (- cnt (tail-off coll)))\n      (PersistentVector. meta (dec cnt) shift root (.slice tail 0 -1) nil)\n      :else (let [new-tail (unchecked-array-for coll (- cnt 2))\n                  nr (pop-tail coll shift root)\n                  new-root (if (nil? nr) (.-EMPTY-NODE PersistentVector) nr)\n                  cnt-1 (dec cnt)]\n              (if (and (< 5 shift) (nil? (pv-aget new-root 1)))\n                (PersistentVector. meta cnt-1 (- shift 5) (pv-aget new-root 0) new-tail nil)\n                (PersistentVector. meta cnt-1 shift new-root new-tail nil)))))\n\n  ICollection\n  (-conj [coll o]\n    (if (< (- cnt (tail-off coll)) 32)\n      (let [len (alength tail)\n            new-tail (make-array (inc len))]\n        (dotimes [i len]\n          (aset new-tail i (aget tail i)))\n        (aset new-tail len o)\n        (PersistentVector. meta (inc cnt) shift root new-tail nil))\n      (let [root-overflow? (> (bit-shift-right-zero-fill cnt 5) (bit-shift-left 1 shift))\n            new-shift (if root-overflow? (+ shift 5) shift)\n            new-root (if root-overflow?\n                       (let [n-r (pv-fresh-node nil)]\n                           (pv-aset n-r 0 root)\n                           (pv-aset n-r 1 (new-path nil shift (VectorNode. nil tail)))\n                           n-r)\n                       (push-tail coll shift root (VectorNode. nil tail)))]\n        (PersistentVector. meta (inc cnt) new-shift new-root (array o) nil))))\n\n  IEmptyableCollection\n  (-empty [coll] (-with-meta (.-EMPTY PersistentVector) meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other]\n    (if (instance? PersistentVector other)\n      (if (== cnt (count other))\n        (let [me-iter  (-iterator coll)\n              you-iter (-iterator other)]\n          (loop []\n            (if ^boolean (.hasNext me-iter)\n              (let [x (.next me-iter)\n                    y (.next you-iter)]\n                (if (= x y)\n                  (recur)\n                  false))\n              true)))\n        false)\n      (equiv-sequential coll other)))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (cond\n      (zero? cnt) nil\n      (<= cnt 32) (IndexedSeq. tail 0 nil)\n      :else (chunked-seq coll (first-array-for-longvec coll) 0 0)))\n\n  IDrop\n  (-drop [coll n]\n    (if (< n cnt)\n      (let [offset (js-mod n 32)]\n        (chunked-seq coll (unchecked-array-for coll n) (- n offset) offset))\n      nil))\n\n  ICounted\n  (-count [coll] cnt)\n\n  IIndexed\n  (-nth [coll n]\n    (aget (array-for coll n) (bit-and n 0x01f)))\n  (-nth [coll n not-found]\n    (if (and (<= 0 n) (< n cnt))\n      (aget (unchecked-array-for coll n) (bit-and n 0x01f))\n      not-found))\n\n  ILookup\n  (-lookup [coll k] (-lookup coll k nil))\n  (-lookup [coll k not-found] (if (number? k)\n                                (-nth coll k not-found)\n                                not-found))\n\n  IAssociative\n  (-assoc [coll k v]\n    (if (number? k)\n      (-assoc-n coll k v)\n      (throw (js/Error. \"Vector's key for assoc must be a number.\"))))\n  (-contains-key? [coll k]\n    (if (integer? k)\n      (and (<= 0 k) (< k cnt))\n      false))\n\n  IFind\n  (-find [coll n]\n    (when (and (<= 0 n) (< n cnt))\n      (MapEntry. n (aget (unchecked-array-for coll n) (bit-and n 0x01f)) nil)))\n\n  APersistentVector\n  IVector\n  (-assoc-n [coll n val]\n    (cond\n       (and (<= 0 n) (< n cnt))\n       (if (<= (tail-off coll) n)\n         (let [new-tail (aclone tail)]\n           (aset new-tail (bit-and n 0x01f) val)\n           (PersistentVector. meta cnt shift root new-tail nil))\n         (PersistentVector. meta cnt shift (do-assoc coll shift root n val) tail nil))\n       (== n cnt) (-conj coll val)\n       :else (throw (js/Error. (str \"Index \" n \" out of bounds  [0,\" cnt \"]\")))))\n\n  IReduce\n  (-reduce [v f]\n    (pv-reduce v f 0 cnt))\n  (-reduce [v f init]\n    (loop [i 0 init init]\n      (if (< i cnt)\n        (let [arr  (unchecked-array-for v i)\n              len  (alength arr)\n              init (loop [j 0 init init]\n                     (if (< j len)\n                       (let [init (f init (aget arr j))]\n                         (if (reduced? init)\n                           init\n                           (recur (inc j) init)))\n                       init))]\n          (if (reduced? init)\n            @init\n            (recur (+ i len) init)))\n        init)))\n\n  IKVReduce\n  (-kv-reduce [v f init]\n    (loop [i 0 init init]\n      (if (< i cnt)\n        (let [arr  (unchecked-array-for v i)\n              len  (alength arr)\n              init (loop [j 0 init init]\n                     (if (< j len)\n                       (let [init (f init (+ j i) (aget arr j))]\n                         (if (reduced? init)\n                           init\n                           (recur (inc j) init)))\n                       init))]\n          (if (reduced? init)\n            @init\n            (recur (+ i len) init)))\n        init)))\n\n  IFn\n  (-invoke [coll k]\n    (if (number? k)\n      (-nth coll k)\n      (throw (js/Error. \"Key must be integer\"))))\n\n  IEditableCollection\n  (-as-transient [coll]\n    (TransientVector. cnt shift (tv-editable-root root) (tv-editable-tail tail)))\n\n  IReversible\n  (-rseq [coll]\n    (when (pos? cnt)\n      (RSeq. coll (dec cnt) nil)))\n\n  IIterable\n  (-iterator [this]\n    (ranged-iterator this 0 cnt)))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/cljs/cljs/core.cljs",
                                                  :lines [5619 5821]},
                                         :full-name "cljs.core/PersistentVector"},
           "cljs.core/IHash" {:ns "cljs.core",
                              :name "IHash",
                              :name-encode "IHash",
                              :implementations #{"Subvec"
                                                 "TaggedLiteral"
                                                 "Symbol"
                                                 "PersistentQueue"
                                                 "PersistentHashMap"
                                                 "PersistentTreeSet"
                                                 "PersistentArrayMapSeq"
                                                 "RedNode"
                                                 "EmptyList"
                                                 "ObjMap"
                                                 "BlackNode"
                                                 "PersistentVector"
                                                 "ValSeq"
                                                 "IntegerRange"
                                                 "ChunkedCons"
                                                 "Range"
                                                 "PersistentQueueSeq"
                                                 "ChunkedSeq"
                                                 "ArrayNodeSeq"
                                                 "KeySeq"
                                                 "IndexedSeq"
                                                 "Namespace"
                                                 "PersistentTreeMap"
                                                 "PersistentTreeMapSeq"
                                                 "symbol"
                                                 "RSeq"
                                                 "PersistentArrayMap"
                                                 "Keyword"
                                                 "PersistentHashSet"
                                                 "NodeSeq"
                                                 "List"
                                                 "Atom"
                                                 "MultiFn"
                                                 "Repeat"
                                                 "Cons"
                                                 "Var"
                                                 "default"
                                                 "LazySeq"
                                                 "MapEntry"
                                                 "UUID"},
                              :history [["+" "0.0-927"]],
                              :type "protocol",
                              :full-name-encode "cljs.core/IHash",
                              :source {:code "(defprotocol IHash\n  (-hash [o]\n    \"Returns the hash code of o.\"))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [728 731]},
                              :methods [{:name "-hash",
                                         :signature ["[o]"],
                                         :docstring "Returns the hash code of o."}],
                              :full-name "cljs.core/IHash",
                              :docstring "Protocol for adding hashing functionality to a type."},
           "cljs.repl.node/seq->js-array" {:ns "cljs.repl.node",
                                           :name "seq->js-array",
                                           :signature ["[v]"],
                                           :name-encode "seq-GTjs-array",
                                           :history [["+" "0.0-2814"]],
                                           :type "function",
                                           :full-name-encode "cljs.repl.node/seq-GTjs-array",
                                           :source {:code "(defn seq->js-array [v]\n  (str \"[\" (apply str (interpose \", \" (map pr-str v))) \"]\"))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/clojure/cljs/repl/node.clj",
                                                    :lines [83 84]},
                                           :full-name "cljs.repl.node/seq->js-array"},
           "clojure.reflect/doc" {:ns "clojure.reflect",
                                  :name "doc",
                                  :signature ["[sym]"],
                                  :name-encode "doc",
                                  :history [["+" "0.0-1503"]],
                                  :type "function",
                                  :full-name-encode "clojure.reflect/doc",
                                  :source {:code "(defn doc\n  [sym]\n  (meta sym print-doc))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/clojure/reflect.cljs",
                                           :lines [53 57]},
                                  :full-name "clojure.reflect/doc",
                                  :docstring "Queries the reflection api with a fully qualified symbol, then prints\ndocumentation information at the repl."},
           "cljs.core/is_proto_" {:ns "cljs.core",
                                  :name "is_proto_",
                                  :signature ["[x]"],
                                  :name-encode "is_proto_",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/is_proto_",
                                  :source {:code "(defn is_proto_\n  [x]\n  (identical? (.-prototype (.-constructor x)) x))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [302 304]},
                                  :full-name "cljs.core/is_proto_"},
           "warnings/protocol-impl-recur-with-target" {:ns "warnings",
                                                       :name "protocol-impl-recur-with-target",
                                                       :name-encode "protocol-impl-recur-with-target",
                                                       :type "warning",
                                                       :full-name-encode "warnings/protocol-impl-recur-with-target",
                                                       :full-name "warnings/protocol-impl-recur-with-target",
                                                       :history [["+"
                                                                  "1.9.655"]]},
           "cljs.core/shorts" {:ns "cljs.core",
                               :name "shorts",
                               :signature ["[x]"],
                               :name-encode "shorts",
                               :history [["+" "0.0-1798"]],
                               :type "function",
                               :full-name-encode "cljs.core/shorts",
                               :source {:code "(defn shorts [x] x)",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [2909]},
                               :full-name "cljs.core/shorts"},
           "cljs.core/TransientVector" {:protocols #{"IFn"
                                                     "ITransientCollection"
                                                     "ICounted"
                                                     "ILookup"
                                                     "IIndexed"
                                                     "ITransientAssociative"
                                                     "ITransientVector"},
                                        :ns "cljs.core",
                                        :name "TransientVector",
                                        :signature ["[cnt shift root tail]"],
                                        :name-encode "TransientVector",
                                        :history [["+" "0.0-1211"]],
                                        :type "type",
                                        :full-name-encode "cljs.core/TransientVector",
                                        :source {:code "(deftype TransientVector [^:mutable cnt\n                          ^:mutable shift\n                          ^:mutable root\n                          ^:mutable tail]\n  ITransientCollection\n  (-conj! [tcoll o]\n    (if ^boolean (.-edit root)\n      (if (< (- cnt (tail-off tcoll)) 32)\n        (do (aset tail (bit-and cnt 0x01f) o)\n            (set! cnt (inc cnt))\n            tcoll)\n        (let [tail-node (VectorNode. (.-edit root) tail)\n              new-tail  (make-array 32)]\n          (aset new-tail 0 o)\n          (set! tail new-tail)\n          (if (> (bit-shift-right-zero-fill cnt 5)\n                 (bit-shift-left 1 shift))\n            (let [new-root-array (make-array 32)\n                  new-shift      (+ shift 5)]\n              (aset new-root-array 0 root)\n              (aset new-root-array 1 (new-path (.-edit root) shift tail-node))\n              (set! root  (VectorNode. (.-edit root) new-root-array))\n              (set! shift new-shift)\n              (set! cnt   (inc cnt))\n              tcoll)\n            (let [new-root (tv-push-tail tcoll shift root tail-node)]\n              (set! root new-root)\n              (set! cnt  (inc cnt))\n              tcoll))))\n      (throw (js/Error. \"conj! after persistent!\"))))\n\n  (-persistent! [tcoll]\n    (if ^boolean (.-edit root)\n      (do (set! (.-edit root) nil)\n          (let [len (- cnt (tail-off tcoll))\n                trimmed-tail (make-array len)]\n            (array-copy tail 0 trimmed-tail 0 len)\n            (PersistentVector. nil cnt shift root trimmed-tail nil)))\n      (throw (js/Error. \"persistent! called twice\"))))\n\n  ITransientAssociative\n  (-assoc! [tcoll key val]\n    (if (number? key)\n      (-assoc-n! tcoll key val)\n      (throw (js/Error. \"TransientVector's key for assoc! must be a number.\"))))\n\n  ITransientVector\n  (-assoc-n! [tcoll n val]\n    (if ^boolean (.-edit root)\n      (cond\n        (and (<= 0 n) (< n cnt))\n        (if (<= (tail-off tcoll) n)\n          (do (aset tail (bit-and n 0x01f) val)\n              tcoll)\n          (let [new-root\n                ((fn go [level node]\n                   (let [node (tv-ensure-editable (.-edit root) node)]\n                     (if (zero? level)\n                       (do (pv-aset node (bit-and n 0x01f) val)\n                           node)\n                       (let [subidx (bit-and (bit-shift-right-zero-fill n level)\n                                             0x01f)]\n                         (pv-aset node subidx\n                                  (go (- level 5) (pv-aget node subidx)))\n                         node))))\n                 shift root)]\n            (set! root new-root)\n            tcoll))\n        (== n cnt) (-conj! tcoll val)\n        :else\n        (throw\n         (js/Error.\n          (str \"Index \" n \" out of bounds for TransientVector of length\" cnt))))\n      (throw (js/Error. \"assoc! after persistent!\"))))\n\n  (-pop! [tcoll]\n    (if ^boolean (.-edit root)\n      (cond\n        (zero? cnt) (throw (js/Error. \"Can't pop empty vector\"))\n        (== 1 cnt)                       (do (set! cnt 0) tcoll)\n        (pos? (bit-and (dec cnt) 0x01f)) (do (set! cnt (dec cnt)) tcoll)\n        :else\n        (let [new-tail (unchecked-editable-array-for tcoll (- cnt 2))\n              new-root (let [nr (tv-pop-tail tcoll shift root)]\n                         (if-not (nil? nr)\n                           nr\n                           (VectorNode. (.-edit root) (make-array 32))))]\n          (if (and (< 5 shift) (nil? (pv-aget new-root 1)))\n            (let [new-root (tv-ensure-editable (.-edit root) (pv-aget new-root 0))]\n              (set! root  new-root)\n              (set! shift (- shift 5))\n              (set! cnt   (dec cnt))\n              (set! tail  new-tail)\n              tcoll)\n            (do (set! root new-root)\n                (set! cnt  (dec cnt))\n                (set! tail new-tail)\n                tcoll))))\n      (throw (js/Error. \"pop! after persistent!\"))))\n\n  ICounted\n  (-count [coll]\n    (if ^boolean (.-edit root)\n      cnt\n      (throw (js/Error. \"count after persistent!\"))))\n\n  IIndexed\n  (-nth [coll n]\n    (if ^boolean (.-edit root)\n      (aget (array-for coll n) (bit-and n 0x01f))\n      (throw (js/Error. \"nth after persistent!\"))))\n\n  (-nth [coll n not-found]\n    (if (and (<= 0 n) (< n cnt))\n      (-nth coll n)\n      not-found))\n\n  ILookup\n  (-lookup [coll k] (-lookup coll k nil))\n\n  (-lookup [coll k not-found]\n    (cond\n      (not ^boolean (.-edit root)) (throw (js/Error. \"lookup after persistent!\"))\n      (number? k) (-nth coll k not-found)\n      :else not-found))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/cljs/cljs/core.cljs",
                                                 :lines [6199 6330]},
                                        :full-name "cljs.core/TransientVector"},
           "cljs.core/keep-indexed" {:ns "cljs.core",
                                     :name "keep-indexed",
                                     :signature ["[f]" "[f coll]"],
                                     :name-encode "keep-indexed",
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "cljs.core/keep-indexed",
                                     :source {:code "(defn keep-indexed\n  ([f]\n   (fn [rf]\n     (let [ia (volatile! -1)]\n       (fn\n         ([] (rf))\n         ([result] (rf result))\n         ([result input]\n            (let [i (vswap! ia inc)\n                  v (f i input)]\n              (if (nil? v)\n                result\n                (rf result v))))))))\n  ([f coll]\n     (letfn [(keepi [idx coll]\n               (lazy-seq\n                (when-let [s (seq coll)]\n                  (if (chunked-seq? s)\n                    (let [c (chunk-first s)\n                          size (count c)\n                          b (chunk-buffer size)]\n                      (dotimes [i size]\n                        (let [x (f (+ idx i) (-nth c i))]\n                          (when-not (nil? x)\n                            (chunk-append b x))))\n                      (chunk-cons (chunk b) (keepi (+ idx size) (chunk-rest s))))\n                    (let [x (f idx (first s))]\n                      (if (nil? x)\n                        (keepi (inc idx) (rest s))\n                        (cons x (keepi (inc idx) (rest s)))))))))]\n       (keepi 0 coll))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/cljs/cljs/core.cljs",
                                              :lines [4694 4728]},
                                     :full-name "cljs.core/keep-indexed",
                                     :docstring "Returns a lazy sequence of the non-nil results of (f index item). Note,\nthis means false return values will be included.  f must be free of\nside-effects.  Returns a stateful transducer when no collection is\nprovided."},
           "cljs.core/bit-shift-right" {:ns "cljs.core",
                                        :name "bit-shift-right",
                                        :signature ["[x n]"],
                                        :name-encode "bit-shift-right",
                                        :history [["+" "0.0-927"]],
                                        :type "function/macro",
                                        :full-name-encode "cljs.core/bit-shift-right",
                                        :source {:code "(defn bit-shift-right\n  [x n] (cljs.core/bit-shift-right x n))",
                                                 :title "Function code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/cljs/cljs/core.cljs",
                                                 :lines [2989 2991]},
                                        :extra-sources [{:code "(core/defmacro ^::ana/numeric bit-shift-right [x n]\n  (core/list 'js* \"(~{} >> ~{})\" x n))",
                                                         :title "Macro code",
                                                         :repo "clojurescript",
                                                         :tag "r1.12.38",
                                                         :filename "src/main/clojure/cljs/core.cljc",
                                                         :lines [1234
                                                                 1235]}],
                                        :full-name "cljs.core/bit-shift-right",
                                        :docstring "Bitwise shift right"},
           "cljs.repl.server/stop" {:ns "cljs.repl.server",
                                    :name "stop",
                                    :signature ["[]"],
                                    :name-encode "stop",
                                    :history [["+" "0.0-1503"]],
                                    :type "function",
                                    :full-name-encode "cljs.repl.server/stop",
                                    :source {:code "(defn stop []\n  (when-let [sock (:socket @state)]\n    (when-not (.isClosed sock)\n      (.close sock))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/clojure/cljs/repl/server.clj",
                                             :lines [232 235]},
                                    :full-name "cljs.repl.server/stop"},
           "cljs.core/comparator" {:ns "cljs.core",
                                   :name "comparator",
                                   :signature ["[pred]"],
                                   :name-encode "comparator",
                                   :history [["+" "0.0-1586"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/comparator",
                                   :source {:code "(defn comparator\n  [pred]\n  (fn [x y]\n    (cond (pred x y) -1 (pred y x) 1 :else 0)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [11874 11878]},
                                   :full-name "cljs.core/comparator",
                                   :docstring "Returns an JavaScript compatible comparator based upon pred."},
           "cljs.core/TransformerIterator.createMulti" {:ns "cljs.core",
                                                        :name "TransformerIterator.createMulti",
                                                        :signature ["[xform sources]"],
                                                        :name-encode "TransformerIteratorDOTcreateMulti",
                                                        :history [["+"
                                                                   "1.9.562"]],
                                                        :parent-type "TransformerIterator",
                                                        :type "function",
                                                        :full-name-encode "cljs.core/TransformerIteratorDOTcreateMulti",
                                                        :source {:code "(set! (.-createMulti TransformerIterator)\n  (fn [xform sources]\n    (transformer-iterator xform (MultiIterator. (to-array sources)) true)))",
                                                                 :title "Source code",
                                                                 :repo "clojurescript",
                                                                 :tag "r1.12.38",
                                                                 :filename "src/main/cljs/cljs/core.cljs",
                                                                 :lines [4296
                                                                         4298]},
                                                        :full-name "cljs.core/TransformerIterator.createMulti"},
           "cljs.core/ES6Iterator" {:ns "cljs.core",
                                    :name "ES6Iterator",
                                    :signature ["[s]"],
                                    :name-encode "ES6Iterator",
                                    :history [["+" "0.0-2371"]],
                                    :type "type",
                                    :full-name-encode "cljs.core/ES6Iterator",
                                    :source {:code "(deftype ES6Iterator [^:mutable s]\n  Object\n  (next [_]\n    (if-not (nil? s)\n      (let [x (first s)]\n        (set! s (next s))\n        #js {:value x :done false})\n      #js {:value nil :done true})))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [1330 1337]},
                                    :full-name "cljs.core/ES6Iterator"},
           "cljs.pprint/getf" {:ns "cljs.pprint",
                               :name "getf",
                               :signature ["[sym]"],
                               :name-encode "getf",
                               :history [["+" "0.0-3255"]],
                               :type "macro",
                               :full-name-encode "cljs.pprint/getf",
                               :source {:code "(defmacro getf\n  [sym]\n  `(~sym @@~'this))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/pprint.cljc",
                                        :lines [28 31]},
                               :full-name "cljs.pprint/getf",
                               :docstring "Get the value of the field a named by the argument (which should be a keyword)."},
           "compiler-options/checked-arrays" {:ns "compiler-options",
                                              :name "checked-arrays",
                                              :name-encode "checked-arrays",
                                              :type "option",
                                              :full-name-encode "compiler-options/checked-arrays",
                                              :full-name "compiler-options/checked-arrays",
                                              :history [["+"
                                                         "1.9.854"]]},
           "cljs.core/coercive-=" {:ns "cljs.core",
                                   :name "coercive-=",
                                   :signature ["[x y]"],
                                   :name-encode "coercive-EQ",
                                   :history [["+" "0.0-1211"]
                                             ["-" "1.9.493"]
                                             ["+" "1.9.494"]],
                                   :type "macro",
                                   :full-name-encode "cljs.core/coercive-EQ",
                                   :source {:code "(core/defmacro coercive-= [x y]\n  (bool-expr (core/list 'js* \"(~{} == ~{})\" x y)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/clojure/cljs/core.cljc",
                                            :lines [911 912]},
                                   :full-name "cljs.core/coercive-="},
           "compiler-options/print-input-delimiter" {:ns "compiler-options",
                                                     :name "print-input-delimiter",
                                                     :name-encode "print-input-delimiter",
                                                     :type "option",
                                                     :full-name-encode "compiler-options/print-input-delimiter",
                                                     :full-name "compiler-options/print-input-delimiter",
                                                     :history [["+"
                                                                "0.0-971"]]},
           "cljs.repl/dir" {:ns "cljs.repl",
                            :name "dir",
                            :signature ["[ns]"],
                            :name-encode "dir",
                            :history [["+" "0.0-2985"]],
                            :type "macro",
                            :full-name-encode "cljs.repl/dir",
                            :source {:code "(defmacro dir\n  [ns]\n  `(doseq [sym# (quote ~(sort (named-publics-vars (resolve-ns ns))))]\n     (println sym#)))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/clojure/cljs/repl.cljc",
                                     :lines [1572 1576]},
                            :full-name "cljs.repl/dir",
                            :docstring "Prints a sorted directory of public vars in a namespace"},
           "cljs.core/PersistentTreeSet" {:protocols #{"IFn"
                                                       "ISeqable"
                                                       "IMeta"
                                                       "IWithMeta"
                                                       "IReversible"
                                                       "IEmptyableCollection"
                                                       "ISet"
                                                       "ICounted"
                                                       "ILookup"
                                                       "ISorted"
                                                       "ICollection"
                                                       "IHash"
                                                       "IPrintWithWriter"
                                                       "IEquiv"
                                                       "ICloneable"},
                                          :ns "cljs.core",
                                          :name "PersistentTreeSet",
                                          :signature ["[meta tree-map __hash]"],
                                          :name-encode "PersistentTreeSet",
                                          :history [["+" "0.0-1211"]],
                                          :type "type",
                                          :full-name-encode "cljs.core/PersistentTreeSet",
                                          :source {:code "(deftype PersistentTreeSet [meta tree-map ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (keys [coll]\n    (es6-iterator (seq coll)))\n  (entries [coll]\n    (es6-set-entries-iterator (seq coll)))\n  (values [coll]\n    (es6-iterator (seq coll)))\n  (has [coll k]\n    (contains? coll k))\n  (forEach [coll f]\n    (doseq [[k v] coll]\n      (f v k)))\n\n  ICloneable\n  (-clone [_] (PersistentTreeSet. meta tree-map __hash))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (PersistentTreeSet. new-meta tree-map __hash)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll o]\n    (PersistentTreeSet. meta (assoc tree-map o nil) nil))\n\n  IEmptyableCollection\n  (-empty [coll] (PersistentTreeSet. meta (-empty tree-map) 0))\n\n  IEquiv\n  (-equiv [coll other]\n    (and\n     (set? other)\n     (== (count coll) (count other))\n     ^boolean\n     (try\n       (reduce-kv\n         #(or (contains? other %2) (reduced false))\n         true tree-map)\n       (catch js/Error ex\n         false))))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-unordered-coll __hash))\n\n  ISeqable\n  (-seq [coll] (keys tree-map))\n\n  ISorted\n  (-sorted-seq [coll ascending?]\n    (map key (-sorted-seq tree-map ascending?)))\n\n  (-sorted-seq-from [coll k ascending?]\n    (map key (-sorted-seq-from tree-map k ascending?)))\n\n  (-entry-key [coll entry] entry)\n\n  (-comparator [coll] (-comparator tree-map))\n\n  IReversible\n  (-rseq [coll]\n    (if (pos? (count tree-map))\n      (map key (rseq tree-map))))\n\n  ICounted\n  (-count [coll] (count tree-map))\n\n  ILookup\n  (-lookup [coll v]\n    (-lookup coll v nil))\n  (-lookup [coll v not-found]\n    (let [n (.entry-at tree-map v)]\n      (if-not (nil? n)\n        (.-key n)\n        not-found)))\n\n  ISet\n  (-disjoin [coll v]\n    (PersistentTreeSet. meta (dissoc tree-map v) nil))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/cljs/cljs/core.cljs",
                                                   :lines [9546 9638]},
                                          :full-name "cljs.core/PersistentTreeSet"},
           "clojure.zip/insert-right" {:ns "clojure.zip",
                                       :name "insert-right",
                                       :signature ["[loc item]"],
                                       :name-encode "insert-right",
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "clojure.zip/insert-right",
                                       :source {:code "(defn insert-right\n  [loc item]\n    (let [[node {r :r :as path}] loc]\n      (if (nil? path)\n        (throw \"Insert at top\")\n        (with-meta [node (assoc path :r (cons item r) :changed? true)] (meta loc)))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/clojure/zip.cljs",
                                                :lines [174 181]},
                                       :full-name "clojure.zip/insert-right",
                                       :docstring "Inserts the item as the right sibling of the node at this loc,\nwithout moving"},
           "cljs.core/make-hierarchy" {:ns "cljs.core",
                                       :name "make-hierarchy",
                                       :signature ["[]"],
                                       :name-encode "make-hierarchy",
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "cljs.core/make-hierarchy",
                                       :source {:code "(defn make-hierarchy\n  [] {:parents {} :descendants {} :ancestors {}})",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/core.cljs",
                                                :lines [11300 11302]},
                                       :full-name "cljs.core/make-hierarchy",
                                       :docstring "Creates a hierarchy object for use with derive, isa? etc."},
           "cljs.core/repeat" {:ns "cljs.core",
                               :name "repeat",
                               :signature ["[x]" "[n x]"],
                               :name-encode "repeat",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/repeat",
                               :source {:code "(defn repeat\n  ([x] (Repeat. nil -1 x nil nil))\n  ([n x] (if (pos? n)\n           (Repeat. nil n x nil nil)\n           (.-EMPTY List))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [5129 5134]},
                               :full-name "cljs.core/repeat",
                               :docstring "Returns a lazy (infinite!, or length n if supplied) sequence of xs."},
           "syntax/destructure-map" {:syntax-equiv {:edn-url nil,
                                                    :clj-url nil},
                                     :ns "syntax",
                                     :name "destructure-map",
                                     :name-encode "destructure-map",
                                     :history [["+" "0.0-927"]],
                                     :type "binding",
                                     :full-name-encode "syntax/destructure-map",
                                     :source {:code "(core/defn destructure [bindings]\n  (core/let [bents (partition 2 bindings)\n             pb (core/fn pb [bvec b v]\n                  (core/let [pvec\n                             (core/fn [bvec b val]\n                               (core/let [gvec (gensym \"vec__\")\n                                          gseq (gensym \"seq__\")\n                                          gfirst (gensym \"first__\")\n                                          has-rest (some #{'&} b)]\n                                 (core/loop [ret (core/let [ret (conj bvec gvec val)]\n                                                   (if has-rest\n                                                     (conj ret gseq (core/list `seq gvec))\n                                                     ret))\n                                             n 0\n                                             bs b\n                                             seen-rest? false]\n                                   (if (seq bs)\n                                     (core/let [firstb (first bs)]\n                                       (core/cond\n                                         (= firstb '&) (recur (pb ret (second bs) gseq)\n                                                              n\n                                                              (nnext bs)\n                                                              true)\n                                         (= firstb :as) (pb ret (second bs) gvec)\n                                         :else (if seen-rest?\n                                                 (throw #?(:clj (new Exception \"Unsupported binding form, only :as can follow & parameter\")\n                                                           :cljs (new js/Error \"Unsupported binding form, only :as can follow & parameter\")))\n                                                 (recur (pb (if has-rest\n                                                              (conj ret\n                                                                    gfirst `(first ~gseq)\n                                                                    gseq `(next ~gseq))\n                                                              ret)\n                                                            firstb\n                                                            (if has-rest\n                                                              gfirst\n                                                              (core/list `nth gvec n nil)))\n                                                        (core/inc n)\n                                                        (next bs)\n                                                        seen-rest?))))\n                                     ret))))\n                             pmap\n                             (core/fn [bvec b v]\n                               (core/let [gmap (gensym \"map__\")\n                                          defaults (:or b)]\n                                 (core/loop [ret (core/-> bvec (conj gmap) (conj v)\n                                                          (conj gmap) (conj `(--destructure-map ~gmap))\n                                                     ((core/fn [ret]\n                                                        (if (:as b)\n                                                          (conj ret (:as b) gmap)\n                                                          ret))))\n                                             bes (core/let [transforms\n                                                            (reduce\n                                                              (core/fn [transforms mk]\n                                                                (if (core/keyword? mk)\n                                                                  (core/let [mkns (namespace mk)\n                                                                        mkn (name mk)]\n                                                                    (core/cond (= mkn \"keys\") (assoc transforms mk #(keyword (core/or mkns (namespace %)) (name %)))\n                                                                               (= mkn \"syms\") (assoc transforms mk #(core/list `quote (symbol (core/or mkns (namespace %)) (name %))))\n                                                                               (= mkn \"strs\") (assoc transforms mk core/str)\n                                                                               :else transforms))\n                                                                  transforms))\n                                                              {}\n                                                              (keys b))]\n                                                   (reduce\n                                                     (core/fn [bes entry]\n                                                       (reduce #(assoc %1 %2 ((val entry) %2))\n                                                         (dissoc bes (key entry))\n                                                         ((key entry) bes)))\n                                                     (dissoc b :as :or)\n                                                     transforms))]\n                                   (if (seq bes)\n                                     (core/let [bb (key (first bes))\n                                                bk (val (first bes))\n                                                local (if #?(:clj  (core/instance? clojure.lang.Named bb)\n                                                             :cljs (cljs.core/implements? INamed bb))\n                                                          (with-meta (symbol nil (name bb)) (meta bb))\n                                                        bb)\n                                                bv (if (contains? defaults local)\n                                                     (core/list 'cljs.core/get gmap bk (defaults local))\n                                                     (core/list 'cljs.core/get gmap bk))]\n                                       (recur\n                                         (if (core/or (core/keyword? bb) (core/symbol? bb)) ;(ident? bb)\n                                           (core/-> ret (conj local bv))\n                                           (pb ret bb bv))\n                                              (next bes)))\n                                     ret))))]\n                    (core/cond\n                      (core/symbol? b) (core/-> bvec (conj (if (namespace b) (symbol (name b)) b)) (conj v))\n                      (core/keyword? b) (core/-> bvec (conj (symbol (name b))) (conj v))\n                      (vector? b) (pvec bvec b v)\n                      (map? b) (pmap bvec b v)\n                      :else (throw\n                             #?(:clj (new Exception (core/str \"Unsupported binding form: \" b))\n                                :cljs (new js/Error (core/str \"Unsupported binding form: \" b)))))))\n             process-entry (core/fn [bvec b] (pb bvec (first b) (second b)))]\n    (if (every? core/symbol? (map first bents))\n      bindings\n      (core/if-let [kwbs (seq (filter #(core/keyword? (first %)) bents))]\n        (throw\n          #?(:clj (new Exception (core/str \"Unsupported binding key: \" (ffirst kwbs)))\n             :cljs (new js/Error (core/str \"Unsupported binding key: \" (ffirst kwbs)))))\n        (reduce process-entry [] bents)))))",
                                              :title "Parser code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/clojure/cljs/core.cljc",
                                              :lines [629 730]},
                                     :full-name "syntax/destructure-map"},
           "cljs.spec.test/unstrument" {:ns "cljs.spec.test",
                                        :name "unstrument",
                                        :signature ["[]"
                                                    "[sym-or-syms]"],
                                        :name-encode "unstrument",
                                        :history [["+" "1.9.183"]
                                                  ["-" "1.9.542"]],
                                        :type "macro",
                                        :full-name-encode "cljs.spec.test/unstrument",
                                        :source {:code "(defmacro unstrument\n  ([]\n   `(unstrument '[~@(deref instrumented-vars)]))\n  ([sym-or-syms]\n   (let [syms (sym-or-syms->syms (eval sym-or-syms))]\n     `(reduce\n        (fn [ret# f#]\n          (let [sym# (f#)]\n            (cond-> ret# sym# (conj sym#))))\n        []\n        [~@(->> syms\n             (map\n               (fn [sym]\n                 (when (symbol? sym)\n                   `(fn []\n                      (unstrument-1 '~sym)))))\n             (remove nil?))]))))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.9.521",
                                                 :filename "src/main/cljs/cljs/spec/test.cljc",
                                                 :lines [127 146]},
                                        :full-name "cljs.spec.test/unstrument",
                                        :docstring "Undoes instrument on the vars named by sym-or-syms, specified\nas in instrument. With no args, unstruments all instrumented vars.\nReturns a collection of syms naming the vars unstrumented.",
                                        :removed {:in "1.9.542",
                                                  :last-seen "1.9.521"}},
           "syntax/syntax-quote" {:syntax-equiv {:edn-url nil,
                                                 :clj-url nil},
                                  :ns "syntax",
                                  :name "syntax-quote",
                                  :name-encode "syntax-quote",
                                  :history [["+" "0.0-1853"]],
                                  :type "syntax",
                                  :full-name-encode "syntax/syntax-quote",
                                  :extra-sources ({:code "(defn- read-syntax-quote\n  [rdr backquote opts pending-forms]\n  (binding [gensym-env {}]\n    (-> (read* rdr true nil opts pending-forms)\n      syntax-quote*)))",
                                                   :title "Reader code",
                                                   :repo "tools.reader",
                                                   :tag "v1.3.6",
                                                   :filename "src/main/clojure/clojure/tools/reader.clj",
                                                   :lines [747 751]}
                                                  {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                                   :title "Reader table",
                                                   :repo "tools.reader",
                                                   :tag "v1.3.6",
                                                   :filename "src/main/clojure/clojure/tools/reader.clj",
                                                   :lines [788 807]}),
                                  :full-name "syntax/syntax-quote"},
           "cljs.spec.impl.gen/vector-distinct" {:ns "cljs.spec.impl.gen",
                                                 :name "vector-distinct",
                                                 :signature ["[& args]"],
                                                 :name-encode "vector-distinct",
                                                 :history [["+"
                                                            "1.9.85"]
                                                           ["-"
                                                            "1.9.542"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.spec.impl.gen/vector-distinct",
                                                 :source {:code "(lazy-combinators hash-map list map not-empty set vector vector-distinct fmap elements\n  bind choose one-of such-that tuple sample return\n  large-integer* double* frequency)",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r1.9.521",
                                                          :filename "src/main/cljs/cljs/spec/impl/gen.cljs",
                                                          :lines [69
                                                                  71]},
                                                 :full-name "cljs.spec.impl.gen/vector-distinct",
                                                 :docstring "Lazy loaded version of clojure.test.check.generators/vector-distinct",
                                                 :removed {:in "1.9.542",
                                                           :last-seen "1.9.521"}},
           "cljs.core/array-list" {:ns "cljs.core",
                                   :name "array-list",
                                   :signature ["[]"],
                                   :name-encode "array-list",
                                   :history [["+" "0.0-2301"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/array-list",
                                   :source {:code "(defn array-list []\n  (ArrayList. (array)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [9786 9787]},
                                   :full-name "cljs.core/array-list"},
           "cljs.repl.rhino/goog-require" {:ns "cljs.repl.rhino",
                                           :name "goog-require",
                                           :signature ["[repl-env opts rule]"],
                                           :name-encode "goog-require",
                                           :history [["+" "0.0-927"]
                                                     ["-" "0.0-2985"]],
                                           :type "function",
                                           :full-name-encode "cljs.repl.rhino/goog-require",
                                           :source {:code "(defn goog-require [repl-env opts rule]\n  (let [path        (string/replace (comp/munge rule) \\. File/separatorChar)\n        output-dir  (util/output-directory opts)\n        cljsc-path  (str output-dir File/separator (str path \".js\"))\n        cljs-path   (str path \".cljs\")\n        gpath       (-eval (str \"goog.dependencies_.nameToPath['\" rule \"']\")\n                      repl-env \"<cljs repl>\" 1)\n        js-path     (str \"goog/\" gpath)\n        js-out-path (io/file output-dir \"goog\"\n                      (string/replace gpath \\/ File/separatorChar))]\n    (let [compiled (io/file cljsc-path)]\n      (if (.exists compiled)\n        ;; TODO: only take this path if analysis cache is available\n        ;; - David\n        (do\n          (with-open [reader (io/reader compiled)]\n            (-eval reader repl-env cljsc-path 1)))\n        (if-let [res (io/resource cljs-path)]\n          (binding [ana/*cljs-ns* 'cljs.user]\n            (repl/load-stream repl-env cljs-path res))\n          (if-let [res (io/resource js-path)]\n            (with-open [reader (io/reader res)]\n              (-eval reader repl-env js-path 1))\n            (if (.exists js-out-path)\n              (with-open [reader (io/reader js-out-path)]\n                (-eval reader repl-env js-path 1))\n              (throw\n               (Exception.\n                 (str \"Cannot find \"\n                   cljs-path \" or \"\n                   js-path \" or \"\n                   (.getName js-out-path) \" in classpath\"))))))))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2913",
                                                    :filename "src/clj/cljs/repl/rhino.clj",
                                                    :lines [78 109]},
                                           :full-name "cljs.repl.rhino/goog-require",
                                           :removed {:in "0.0-2985",
                                                     :last-seen "0.0-2913"}},
           "cljs.core/prn-str-with-opts" {:ns "cljs.core",
                                          :name "prn-str-with-opts",
                                          :signature ["[objs opts]"],
                                          :name-encode "prn-str-with-opts",
                                          :history [["+" "0.0-1011"]],
                                          :type "function",
                                          :full-name-encode "cljs.core/prn-str-with-opts",
                                          :source {:code "(defn prn-str-with-opts\n  [objs opts]\n  (if (empty? objs)\n    \"\\n\"\n    (let [sb (pr-sb-with-opts objs opts)]\n      (.append sb \\newline)\n      (str sb))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/cljs/cljs/core.cljs",
                                                   :lines [10621
                                                           10628]},
                                          :full-name "cljs.core/prn-str-with-opts",
                                          :docstring "Same as pr-str-with-opts followed by (newline)"},
           "cljs.core/MultiFn" {:protocols #{"IFn"
                                             "IMultiFn"
                                             "IHash"
                                             "INamed"},
                                :ns "cljs.core",
                                :name "MultiFn",
                                :signature ["[name dispatch-fn default-dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy]"],
                                :name-encode "MultiFn",
                                :history [["+" "0.0-927"]],
                                :type "type",
                                :full-name-encode "cljs.core/MultiFn",
                                :source {:code "(deftype MultiFn [name dispatch-fn default-dispatch-val hierarchy\n                  method-table prefer-table method-cache cached-hierarchy]\n  IFn\n  (-invoke [mf]\n    (let [dispatch-val (dispatch-fn)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn)))\n  (-invoke [mf a]\n    (let [dispatch-val (dispatch-fn a)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a)))\n  (-invoke [mf a b]\n    (let [dispatch-val (dispatch-fn a b)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b)))\n  (-invoke [mf a b c]\n    (let [dispatch-val (dispatch-fn a b c)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c)))\n  (-invoke [mf a b c d]\n    (let [dispatch-val (dispatch-fn a b c d)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d)))\n  (-invoke [mf a b c d e]\n    (let [dispatch-val (dispatch-fn a b c d e)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e)))\n  (-invoke [mf a b c d e f]\n    (let [dispatch-val (dispatch-fn a b c d e f)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f)))\n  (-invoke [mf a b c d e f g]\n    (let [dispatch-val (dispatch-fn a b c d e f g)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g)))\n  (-invoke [mf a b c d e f g h]\n    (let [dispatch-val (dispatch-fn a b c d e f g h)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h)))\n  (-invoke [mf a b c d e f g h i]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i)))\n  (-invoke [mf a b c d e f g h i j]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j)))\n  (-invoke [mf a b c d e f g h i j k]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k)))\n  (-invoke [mf a b c d e f g h i j k l]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l)))\n  (-invoke [mf a b c d e f g h i j k l m]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m)))\n  (-invoke [mf a b c d e f g h i j k l m n]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m n)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m n)))\n  (-invoke [mf a b c d e f g h i j k l m n o]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m n o)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m n o)))\n  (-invoke [mf a b c d e f g h i j k l m n o p]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m n o p)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m n o p)))\n  (-invoke [mf a b c d e f g h i j k l m n o p q]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m n o p q)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m n o p q)))\n  (-invoke [mf a b c d e f g h i j k l m n o p q r]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m n o p q r)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m n o p q r)))\n  (-invoke [mf a b c d e f g h i j k l m n o p q r s]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m n o p q r s)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m n o p q r s)))\n  (-invoke [mf a b c d e f g h i j k l m n o p q r s t]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m n o p q r s t)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m n o p q r s t)))\n  (-invoke [mf a b c d e f g h i j k l m n o p q r s t rest]\n    (let [dispatch-val (apply dispatch-fn a b c d e f g h i j k l m n o p q r s t rest)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (apply target-fn a b c d e f g h i j k l m n o p q r s t rest)))\n\n  IMultiFn\n  (-reset [mf]\n    (swap! method-table (fn [mf] {}))\n    (swap! method-cache (fn [mf] {}))\n    (swap! prefer-table (fn [mf] {}))\n    (swap! cached-hierarchy (fn [mf] nil))\n    mf)\n\n  (-add-method [mf dispatch-val method]\n    (swap! method-table assoc dispatch-val method)\n    (reset-cache method-cache method-table cached-hierarchy hierarchy)\n    mf)\n\n  (-remove-method [mf dispatch-val]\n    (swap! method-table dissoc dispatch-val)\n    (reset-cache method-cache method-table cached-hierarchy hierarchy)\n    mf)\n\n  (-get-method [mf dispatch-val]\n    (when-not (= @cached-hierarchy @hierarchy)\n      (reset-cache method-cache method-table cached-hierarchy hierarchy))\n    (if-let [target-fn (@method-cache dispatch-val)]\n      target-fn\n      (find-and-cache-best-method name dispatch-val hierarchy method-table\n        prefer-table method-cache cached-hierarchy default-dispatch-val)))\n\n  (-prefer-method [mf dispatch-val-x dispatch-val-y]\n    (when (prefers* dispatch-val-y dispatch-val-x  prefer-table)\n      (throw (js/Error. (str \"Preference conflict in multimethod '\" name \"': \" dispatch-val-y\n                   \" is already preferred to \" dispatch-val-x))))\n    (swap! prefer-table\n           (fn [old]\n             (assoc old dispatch-val-x\n                    (conj (get old dispatch-val-x #{})\n                          dispatch-val-y))))\n    (reset-cache method-cache method-table cached-hierarchy hierarchy))\n\n  (-methods [mf] @method-table)\n  (-prefers [mf] @prefer-table)\n  (-default-dispatch-val [mf] default-dispatch-val)\n  (-dispatch-fn [mf] dispatch-fn)\n\n  INamed\n  (-name [this] (-name name))\n  (-namespace [this] (-namespace name))\n\n  IHash\n  (-hash [this] (goog/getUid this)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [11486 11669]},
                                :full-name "cljs.core/MultiFn"},
           "cljs.spec.test.alpha/checkable-syms*" {:ns "cljs.spec.test.alpha",
                                                   :name "checkable-syms*",
                                                   :signature ["[]"
                                                               "[opts]"],
                                                   :name-encode "checkable-symsSTAR",
                                                   :history [["+"
                                                              "1.9.542"]],
                                                   :type "function",
                                                   :full-name-encode "cljs.spec.test.alpha/checkable-symsSTAR",
                                                   :source {:code "(defn checkable-syms*\n  ([]\n    (checkable-syms* nil))\n  ([opts]\n   (reduce into #{}\n     [(filter fn-spec-name? (keys @(registry-ref)))\n      (keys (:spec opts))])))",
                                                            :title "Source code",
                                                            :repo "clojurescript",
                                                            :tag "r1.12.38",
                                                            :filename "src/main/cljs/cljs/spec/test/alpha.cljc",
                                                            :lines [238
                                                                    244]},
                                                   :full-name "cljs.spec.test.alpha/checkable-syms*"},
           "cljs.spec.alpha/exercise-fn" {:ns "cljs.spec.alpha",
                                          :name "exercise-fn",
                                          :signature ["[sym]"
                                                      "[sym n]"
                                                      "[sym n fspec]"],
                                          :name-encode "exercise-fn",
                                          :history [["+" "1.9.542"]],
                                          :type "macro",
                                          :full-name-encode "cljs.spec.alpha/exercise-fn",
                                          :source {:code "(defmacro exercise-fn\n  ([sym]\n   `(exercise-fn ~sym 10))\n  ([sym n]\n   `(exercise-fn ~sym ~n nil))\n  ([sym n fspec]\n   (let [sym (cond-> sym\n               (clojure.core/and (sequential? sym)\n                                 (= (first sym) 'quote))\n               second)]\n     `(let [fspec# ~(if-not fspec\n                      `(get-spec '~(:name (resolve &env sym)))\n                      fspec)\n            f#     ~sym]\n        (if-let [arg-spec# (c/and fspec# (:args fspec#))]\n          (for [args# (gen/sample (gen arg-spec#) ~n)]\n            [args# (apply f# args#)])\n          (throw (js/Error. \"No :args spec found, can't generate\")))))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/cljs/cljs/spec/alpha.cljc",
                                                   :lines [521 542]},
                                          :full-name "cljs.spec.alpha/exercise-fn",
                                          :docstring "exercises the fn named by sym (a symbol) by applying it to\nn (default 10) generated samples of its args spec. When fspec is\nsupplied its arg spec is used, and sym-or-f can be a fn.  Returns a\nsequence of tuples of [args ret]. "},
           "cljs.test/successful?" {:ns "cljs.test",
                                    :name "successful?",
                                    :signature ["[summary]"],
                                    :name-encode "successfulQMARK",
                                    :history [["+" "0.0-2496"]],
                                    :type "function",
                                    :full-name-encode "cljs.test/successfulQMARK",
                                    :source {:code "(defn successful?\n  [summary]\n  (and (zero? (:fail summary 0))\n       (zero? (:error summary 0))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/test.cljs",
                                             :lines [601 606]},
                                    :full-name "cljs.test/successful?",
                                    :docstring "Returns true if the given test summary indicates all tests\nwere successful, false otherwise."},
           "cljs.core/hash-keyword" {:ns "cljs.core",
                                     :name "hash-keyword",
                                     :signature ["[k]"],
                                     :name-encode "hash-keyword",
                                     :history [["+" "0.0-2261"]],
                                     :type "function",
                                     :full-name-encode "cljs.core/hash-keyword",
                                     :source {:code "(defn hash-keyword [k]\n  (int (+ (hash-symbol k) 0x9e3779b9)))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/cljs/cljs/core.cljs",
                                              :lines [3381 3382]},
                                     :full-name "cljs.core/hash-keyword"},
           "cljs.test/run-tests-block" {:ns "cljs.test",
                                        :name "run-tests-block",
                                        :signature ["[env-or-ns & namespaces]"],
                                        :name-encode "run-tests-block",
                                        :history [["+" "0.0-2814"]],
                                        :type "macro",
                                        :full-name-encode "cljs.test/run-tests-block",
                                        :source {:code "(defmacro run-tests-block\n  [env-or-ns & namespaces]\n  (assert (every?\n           (fn [[quote ns]] (and (= quote 'quote) (symbol? ns)))\n           namespaces)\n          \"All arguments to run-tests must be quoted symbols\")\n  (let [is-ns (ns? env-or-ns)\n        env (gensym \"env\")\n        summary (gensym \"summary\")]\n    `(let [~env ~(if is-ns\n                   `(empty-env)\n                   env-or-ns)\n           ~summary (cljs.core/volatile!\n                     {:test 0 :pass 0 :fail 0 :error 0\n                      :type :summary})]\n       (concat ~@(map\n                  (fn [ns]\n                    `(concat (test-ns-block ~env ~ns)\n                             [(fn []\n                                (cljs.core/vswap!\n                                 ~summary\n                                 (partial merge-with +)\n                                 (:report-counters\n                                  (get-and-clear-env!))))]))\n                  (if is-ns\n                    (concat [env-or-ns] namespaces)\n                    namespaces))\n               [(fn []\n                   (set-env! ~env)\n                   (do-report (deref ~summary))\n                   (report (assoc (deref ~summary) :type :end-run-tests))\n                   (clear-env!))]))))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/cljs/cljs/test.cljc",
                                                 :lines [273 306]},
                                        :full-name "cljs.test/run-tests-block",
                                        :docstring "Like test-vars, but returns a block for further composition and\nlater execution."},
           "cljs.spec.gen.alpha/any" {:ns "cljs.spec.gen.alpha",
                                      :name "any",
                                      :signature ["[& args]"],
                                      :name-encode "any",
                                      :history [["+" "1.9.542"]],
                                      :type "function",
                                      :full-name-encode "cljs.spec.gen.alpha/any",
                                      :source {:code "(lazy-prims any any-printable boolean char char-alpha char-alphanumeric char-ascii double\n  int keyword keyword-ns large-integer ratio simple-type simple-type-printable\n  string string-ascii string-alphanumeric symbol symbol-ns uuid)",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/spec/gen/alpha.cljs",
                                               :lines [74 76]},
                                      :full-name "cljs.spec.gen.alpha/any",
                                      :docstring "Fn returning clojure.test.check.generators/any"},
           "cljs.core/inst?" {:ns "cljs.core",
                              :name "inst?",
                              :signature ["[x]"],
                              :name-encode "instQMARK",
                              :history [["+" "1.9.75"]],
                              :type "function",
                              :full-name-encode "cljs.core/instQMARK",
                              :source {:code "(defn inst?\n  [x]\n  (satisfies? Inst x))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [1440 1443]},
                              :full-name "cljs.core/inst?",
                              :docstring "Return true if x satisfies Inst"},
           "cljs.core/Reduced" {:protocols #{"IDeref"},
                                :ns "cljs.core",
                                :name "Reduced",
                                :signature ["[val]"],
                                :name-encode "Reduced",
                                :history [["+" "0.0-1211"]],
                                :type "type",
                                :full-name-encode "cljs.core/Reduced",
                                :source {:code "(deftype Reduced [val]\n  IDeref\n  (-deref [o] val))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [1473 1475]},
                                :full-name "cljs.core/Reduced"},
           "cljs.test/run-test" {:ns "cljs.test",
                                 :name "run-test",
                                 :signature ["[test-symbol]"],
                                 :name-encode "run-test",
                                 :history [["+" "1.11.121"]],
                                 :type "macro",
                                 :full-name-encode "cljs.test/run-test",
                                 :source {:code "(defmacro run-test\n  [test-symbol]\n  (let [test-var (ana-api/resolve &env test-symbol)]\n    (cond (nil? test-var)\n          `(cljs.core/*print-err-fn* \"Unable to resolve\" ~(str test-symbol) \"to a test function.\")\n          (not (:test test-var))\n          `(cljs.core/*print-err-fn* ~(str test-symbol) \"is not a test\")\n          :else\n          (let [ns (:ns test-var)]\n            `(let [env# (get-current-env)]\n               (run-block\n                (concat\n                 [(fn []\n                    (when (nil? env#)\n                      (set-env! (empty-env)))\n                    ~(when (ana-api/resolve &env 'cljs-test-once-fixtures)\n                       `(update-current-env! [:once-fixtures] assoc '~ns\n                                             ~(symbol (str ns) \"cljs-test-once-fixtures\")))\n                    ~(when (ana-api/resolve &env 'cljs-test-each-fixtures)\n                       `(update-current-env! [:each-fixtures] assoc '~ns\n                                             ~(symbol (str ns) \"cljs-test-each-fixtures\"))))]\n                 (test-vars-block\n                  [(var ~test-symbol)])\n                 [(fn []\n                    (when (nil? env#)\n                      (clear-env!)))])))))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/test.cljc",
                                          :lines [399 427]},
                                 :full-name "cljs.test/run-test",
                                 :docstring "Runs a single test.\n\nBecause the intent is to run a single test, there is no check for the namespace test-ns-hook."},
           "cljs.core/not-any?" {:ns "cljs.core",
                                 :name "not-any?",
                                 :signature ["[pred coll]"],
                                 :name-encode "not-anyQMARK",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/not-anyQMARK",
                                 :source {:code "(defn not-any?\n  [pred coll] (not (some pred coll)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [4345 4348]},
                                 :full-name "cljs.core/not-any?",
                                 :docstring "Returns false if (pred x) is logical true for any x in coll,\nelse true."},
           "cljs.reader/read-regex" {:ns "cljs.reader",
                                     :name "read-regex",
                                     :signature ["[rdr ch]"],
                                     :name-encode "read-regex",
                                     :history [["+" "0.0-927"]
                                               ["-" "1.9.854"]],
                                     :type "function",
                                     :full-name-encode "cljs.reader/read-regex",
                                     :source {:code "(defn read-regex\n  [rdr ch]\n  (-> (read-raw-string* rdr ch) re-pattern))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.9.671",
                                              :filename "src/main/cljs/cljs/reader.cljs",
                                              :lines [413 415]},
                                     :full-name "cljs.reader/read-regex",
                                     :removed {:in "1.9.854",
                                               :last-seen "1.9.671"}},
           "cljs.repl/spec-sort" {:ns "cljs.repl",
                                  :name "spec-sort",
                                  :name-encode "spec-sort",
                                  :history [["+" "0.0-2629"]
                                            ["-" "0.0-2655"]],
                                  :type "var",
                                  :full-name-encode "cljs.repl/spec-sort",
                                  :source {:code "(def spec-sort\n  {:as 0\n   :refer 1\n   :refer-macros 2\n   :include-macros 3})",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2644",
                                           :filename "src/clj/cljs/repl.clj",
                                           :lines [190 194]},
                                  :full-name "cljs.repl/spec-sort",
                                  :removed {:in "0.0-2655",
                                            :last-seen "0.0-2644"}},
           "clojure.zip/next" {:ns "clojure.zip",
                               :name "next",
                               :signature ["[loc]"],
                               :name-encode "next",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip/next",
                               :source {:code "(defn next\n  [loc]\n    (if (= :end (loc 1))\n      loc\n      (or \n       (and (branch? loc) (down loc))\n       (right loc)\n       (loop [p loc]\n         (if (up p)\n           (or (right (up p)) (recur (up p)))\n           [(node p) :end])))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/clojure/zip.cljs",
                                        :lines [206 219]},
                               :full-name "clojure.zip/next",
                               :docstring "Moves to the next loc in the hierarchy, depth-first. When reaching\nthe end, returns a distinguished loc detectable via end?. If already\nat the end, stays there."},
           "cljs.math/subtract-exact" {:return-type number,
                                       :ns "cljs.math",
                                       :name "subtract-exact",
                                       :signature ["[x y]"],
                                       :name-encode "subtract-exact",
                                       :history [["+" "1.11.50"]],
                                       :type "function",
                                       :full-name-encode "cljs.math/subtract-exact",
                                       :source {:code "(defn ^number subtract-exact\n  {:added \"1.11.10\"}\n  [x y]\n  (let [r (- x y)]\n    (if (or (> r js/Number.MAX_SAFE_INTEGER) (< r js/Number.MIN_SAFE_INTEGER))\n      (throw (ex-info \"Integer overflow\" {:fn \"subtract-exact\"}))\n      r)))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/math.cljs",
                                                :lines [525 532]},
                                       :full-name "cljs.math/subtract-exact",
                                       :docstring "Returns the difference of x and y, throws ArithmeticException on overflow. "},
           "cljs.analyzer.api/no-warn" {:ns "cljs.analyzer.api",
                                        :name "no-warn",
                                        :signature ["[& body]"],
                                        :name-encode "no-warn",
                                        :history [["+" "0.0-3291"]],
                                        :type "macro",
                                        :full-name-encode "cljs.analyzer.api/no-warn",
                                        :source {:code "(defmacro no-warn\n  [& body]\n  (let [no-warnings (zipmap (keys ana/*cljs-warnings*) (repeat false))]\n    `(binding [ana/*cljs-warnings* ~no-warnings]\n       ~@body)))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/clojure/cljs/analyzer/api.cljc",
                                                 :lines [62 67]},
                                        :full-name "cljs.analyzer.api/no-warn",
                                        :docstring "Disable analyzer warnings for any analysis executed in body."},
           "syntax/dispatch" {:syntax-equiv {:edn-url nil,
                                             :clj-url nil},
                              :ns "syntax",
                              :name "dispatch",
                              :name-encode "dispatch",
                              :history [["+" "0.0-1853"]],
                              :type "syntax",
                              :full-name-encode "syntax/dispatch",
                              :extra-sources ({:code "(defn- read-dispatch\n  [rdr _ opts pending-forms]\n  (if-let [ch (read-char rdr)]\n    (if-let [dm (dispatch-macros ch)]\n      (dm rdr ch opts pending-forms)\n      (read-tagged (doto rdr (unread ch)) ch opts pending-forms)) ;; ctor reader is implemented as a tagged literal\n    (err/throw-eof-at-dispatch rdr)))",
                                               :title "Reader code",
                                               :repo "tools.reader",
                                               :tag "v1.3.6",
                                               :filename "src/main/clojure/clojure/tools/reader.clj",
                                               :lines [68 74]}
                                              {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                               :title "Reader table",
                                               :repo "tools.reader",
                                               :tag "v1.3.6",
                                               :filename "src/main/clojure/clojure/tools/reader.clj",
                                               :lines [788 807]}),
                              :full-name "syntax/dispatch"},
           "cljs.test/async" {:ns "cljs.test",
                              :name "async",
                              :signature ["[done & body]"],
                              :name-encode "async",
                              :history [["+" "0.0-2814"]],
                              :type "macro",
                              :full-name-encode "cljs.test/async",
                              :source {:code "(defmacro async\n  [done & body]\n  `(reify\n     cljs.test/IAsyncTest\n     cljs.core/IFn\n     (~'-invoke [_# ~done]\n       ~@body)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/test.cljc",
                                       :lines [248 265]},
                              :full-name "cljs.test/async",
                              :docstring "Wraps body as a CPS function that can be returned from a test to\ncontinue asynchronously.  Binds done to a function that must be\ninvoked once and from an async context after any assertions.\n\n(deftest example-with-timeout\n  (async done\n    (js/setTimeout (fn []\n                     ;; make assertions in async context...\n                     (done) ;; ...then call done\n                     )\n                   0)))"},
           "cljs.core/find-ns" {:ns "cljs.core",
                                :name "find-ns",
                                :signature ["[ns]"],
                                :name-encode "find-ns",
                                :history [["+" "1.7.10"]],
                                :type "function",
                                :full-name-encode "cljs.core/find-ns",
                                :source {:code "(defn find-ns\n  [ns]\n  (when (nil? NS_CACHE)\n    (set! NS_CACHE (atom {})))\n  (let [the-ns (get @NS_CACHE ns)]\n    (if-not (nil? the-ns)\n      the-ns\n      (let [ns-obj (find-ns-obj ns)]\n        (when-not (nil? ns-obj)\n          (let [new-ns (create-ns ns ns-obj)]\n            (swap! NS_CACHE assoc ns new-ns)\n            new-ns))))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [12184 12197]},
                                :full-name "cljs.core/find-ns",
                                :docstring "Returns the namespace named by the symbol or nil if it doesn't exist.\nBootstrap only."},
           "cljs.core/IFn" {:ns "cljs.core",
                            :name "IFn",
                            :name-encode "IFn",
                            :implementations #{"Subvec"
                                               "Symbol"
                                               "PersistentHashMap"
                                               "PersistentTreeSet"
                                               "RedNode"
                                               "TransientArrayMap"
                                               "ObjMap"
                                               "MetaFn"
                                               "BlackNode"
                                               "PersistentVector"
                                               "TransientVector"
                                               "PersistentTreeMap"
                                               "PersistentArrayMap"
                                               "Keyword"
                                               "PersistentHashSet"
                                               "TransientHashMap"
                                               "MultiFn"
                                               "Var"
                                               "MapEntry"
                                               "TransientHashSet"},
                            :history [["+" "0.0-971"]],
                            :type "protocol",
                            :full-name-encode "cljs.core/IFn",
                            :source {:code "(defprotocol IFn\n  (-invoke\n    [this]\n    [this a]\n    [this a b]\n    [this a b c]\n    [this a b c d]\n    [this a b c d e]\n    [this a b c d e f]\n    [this a b c d e f g]\n    [this a b c d e f g h]\n    [this a b c d e f g h i]\n    [this a b c d e f g h i j]\n    [this a b c d e f g h i j k]\n    [this a b c d e f g h i j k l]\n    [this a b c d e f g h i j k l m]\n    [this a b c d e f g h i j k l m n]\n    [this a b c d e f g h i j k l m n o]\n    [this a b c d e f g h i j k l m n o p]\n    [this a b c d e f g h i j k l m n o p q]\n    [this a b c d e f g h i j k l m n o p q r]\n    [this a b c d e f g h i j k l m n o p q r s]\n    [this a b c d e f g h i j k l m n o p q r s t]\n    [this a b c d e f g h i j k l m n o p q r s t rest]))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [556 582]},
                            :methods [{:name "-invoke",
                                       :signature ["[this]"
                                                   "[this a]"
                                                   "[this a b]"
                                                   "[this a b c]"
                                                   "[this a b c d]"
                                                   "[this a b c d e]"
                                                   "[this a b c d e f]"
                                                   "[this a b c d e f g]"
                                                   "[this a b c d e f g h]"
                                                   "[this a b c d e f g h i]"
                                                   "[this a b c d e f g h i j]"
                                                   "[this a b c d e f g h i j k]"
                                                   "[this a b c d e f g h i j k l]"
                                                   "[this a b c d e f g h i j k l m]"
                                                   "[this a b c d e f g h i j k l m n]"
                                                   "[this a b c d e f g h i j k l m n o]"
                                                   "[this a b c d e f g h i j k l m n o p]"
                                                   "[this a b c d e f g h i j k l m n o p q]"
                                                   "[this a b c d e f g h i j k l m n o p q r]"
                                                   "[this a b c d e f g h i j k l m n o p q r s]"
                                                   "[this a b c d e f g h i j k l m n o p q r s t]"
                                                   "[this a b c d e f g h i j k l m n o p q r s t rest]"],
                                       :docstring nil}],
                            :full-name "cljs.core/IFn",
                            :docstring "Protocol for adding the ability to invoke an object as a function.\n  For example, a vector can also be used to look up a value:\n  ([1 2 3 4] 1) => 2"},
           "cljs.core/aget" {:ns "cljs.core",
                             :name "aget",
                             :signature ["[array idx]"
                                         "[array idx & idxs]"],
                             :name-encode "aget",
                             :history [["+" "0.0-927"]],
                             :type "function/macro",
                             :full-name-encode "cljs.core/aget",
                             :source {:code "(defn aget\n  ([array idx]\n     (cljs.core/aget array idx))\n  ([array idx & idxs]\n     (apply aget (aget array idx) idxs)))",
                                      :title "Function code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [508 513]},
                             :extra-sources [{:code "(core/defmacro aget\n  ([array idx]\n   (core/case (ana/checked-arrays)\n     :warn `(checked-aget ~array ~idx)\n     :error `(checked-aget' ~array ~idx)\n     (core/list 'js* \"(~{}[~{}])\" array idx)))\n  ([array idx & idxs]\n   (core/case (ana/checked-arrays)\n     :warn `(checked-aget ~array ~idx ~@idxs)\n     :error `(checked-aget' ~array ~idx ~@idxs)\n     (core/let [astr (apply core/str (repeat (count idxs) \"[~{}]\"))]\n       `(~'js* ~(core/str \"(~{}[~{}]\" astr \")\") ~array ~idx ~@idxs)))))",
                                              :title "Macro code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/clojure/cljs/core.cljc",
                                              :lines [1019 1030]}],
                             :full-name "cljs.core/aget",
                             :docstring "Returns the value at the index/indices. Works on JavaScript arrays."},
           "cljs.spec.test.alpha/instrument-1" {:ns "cljs.spec.test.alpha",
                                                :name "instrument-1",
                                                :signature ["[[quote s] opts]"],
                                                :name-encode "instrument-1",
                                                :history [["+"
                                                           "1.9.542"]],
                                                :type "macro",
                                                :full-name-encode "cljs.spec.test.alpha/instrument-1",
                                                :source {:code "(defmacro instrument-1\n  [[quote s] opts]\n  (when-let [v (ana-api/resolve &env s)]\n    (let [var-name (:name v)]\n      (when (and (nil? (:const v))\n                 #?(:cljs (nil? (:macro v)))\n                 (contains? #?(:clj (s/speced-vars)\n                               :cljs (cljs.spec.alpha$macros/speced-vars))\n                            var-name))\n        (swap! instrumented-vars conj var-name)\n        `(let [checked# (#'instrument-1* '~s (var ~s) ~opts)]\n           (when checked# (set! ~s checked#))\n           '~var-name)))))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1.12.38",
                                                         :filename "src/main/cljs/cljs/spec/test/alpha.cljc",
                                                         :lines [60
                                                                 72]},
                                                :full-name "cljs.spec.test.alpha/instrument-1"},
           "cljs.core/if-let" {:ns "cljs.core",
                               :name "if-let",
                               :signature ["[bindings then]"
                                           "[bindings then else & oldform]"],
                               :name-encode "if-let",
                               :history [["+" "0.0-927"]],
                               :type "macro",
                               :full-name-encode "cljs.core/if-let",
                               :source {:code "(defmacro if-let\n  {:added \"1.0\"}\n  ([bindings then]\n   `(if-let ~bindings ~then nil))\n  ([bindings then else & oldform]\n   (assert-args\n     (vector? bindings) \"a vector for its binding\"\n     (nil? oldform) \"1 or 2 forms after binding vector\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n   (let [form (bindings 0) tst (bindings 1)]\n     `(let [temp# ~tst]\n        (if temp#\n          (let [~form temp#]\n            ~then)\n          ~else)))))",
                                        :title "Source code",
                                        :repo "clojure",
                                        :tag "clojure-1.10.0",
                                        :filename "src/clj/clojure/core.clj",
                                        :lines [1841 1859]},
                               :full-name "cljs.core/if-let",
                               :docstring "bindings => binding-form test\n\nIf test is true, evaluates then with binding-form bound to the value of \ntest, if not, yields else"},
           "repl-options/def-emits-var" {:ns "repl-options",
                                         :name "def-emits-var",
                                         :name-encode "def-emits-var",
                                         :type "option",
                                         :full-name-encode "repl-options/def-emits-var",
                                         :full-name "repl-options/def-emits-var",
                                         :history [["+" "1.7.10"]]},
           "cljs.spec.test/get-env" {:ns "cljs.spec.test",
                                     :name "get-env",
                                     :signature ["[]"],
                                     :name-encode "get-env",
                                     :history [["+" "1.9.183"]
                                               ["-" "1.9.542"]],
                                     :type "function",
                                     :full-name-encode "cljs.spec.test/get-env",
                                     :source {:code "(defn get-env []\n  {:ua-product (get-ua-product)})",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.9.521",
                                              :filename "src/main/cljs/cljs/spec/test.cljs",
                                              :lines [60 61]},
                                     :full-name "cljs.spec.test/get-env",
                                     :removed {:in "1.9.542",
                                               :last-seen "1.9.521"}},
           "cljs.core//" {:return-type number,
                          :ns "cljs.core",
                          :name "/",
                          :signature ["[x]" "[x y]" "[x y & more]"],
                          :name-encode "SLASH",
                          :history [["+" "0.0-927"]],
                          :type "function/macro",
                          :full-name-encode "cljs.core/SLASH",
                          :source {:code "(defn ^number /\n  ([x] (/ 1 x))\n  ([x y] (cljs.core/divide x y)) ;; FIXME: waiting on cljs.core//\n  ([x y & more] (reduce / (/ x y) more)))",
                                   :title "Function code",
                                   :repo "clojurescript",
                                   :tag "r1.12.38",
                                   :filename "src/main/cljs/cljs/core.cljs",
                                   :lines [2707 2712]},
                          :extra-sources [{:code "(core/defmacro ^::ana/numeric /\n  ([x] `(/ 1 ~x))\n  ([x y] (core/list 'js* \"(~{} / ~{})\" x y))\n  ([x y & more] `(/ (/ ~x ~y) ~@more)))",
                                           :title "Macro code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/clojure/cljs/core.cljc",
                                           :lines [1130 1133]}],
                          :full-name "cljs.core//",
                          :docstring "If no denominators are supplied, returns 1/numerator,\nelse returns numerator divided by all of the denominators."},
           "cljs.core/unchecked-int" {:ns "cljs.core",
                                      :name "unchecked-int",
                                      :signature ["[x]"],
                                      :name-encode "unchecked-int",
                                      :history [["+" "0.0-1798"]],
                                      :type "function",
                                      :full-name-encode "cljs.core/unchecked-int",
                                      :source {:code "(defn unchecked-int\n  [x]\n  (fix x))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [2891 2894]},
                                      :full-name "cljs.core/unchecked-int",
                                      :docstring "Coerce to int by stripping decimal places."},
           "cljs.repl.server/read-get" {:ns "cljs.repl.server",
                                        :name "read-get",
                                        :signature ["[line rdr]"],
                                        :name-encode "read-get",
                                        :history [["+" "0.0-1503"]],
                                        :type "function",
                                        :full-name-encode "cljs.repl.server/read-get",
                                        :source {:code "(defn read-get [line rdr]\n  (let [[_ file _] (str/split line #\" \")\n        {:keys [path ref query-str]} (parse-file-parts file)\n        headers (parse-headers (read-headers rdr))]\n    {:method :get\n     :path path\n     :ref ref\n     :query-str query-str\n     :headers headers}))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/clojure/cljs/repl/server.clj",
                                                 :lines [108 116]},
                                        :full-name "cljs.repl.server/read-get"},
           "cljs.core/min-key" {:ns "cljs.core",
                                :name "min-key",
                                :signature ["[k x]"
                                            "[k x y]"
                                            "[k x y & more]"],
                                :name-encode "min-key",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/min-key",
                                :source {:code "(defn min-key\n  ([k x] x)\n  ([k x y] (if (< (k x) (k y)) x y))\n  ([k x y & more]\n     (reduce #(min-key k %1 %2) (min-key k x y) more)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [9769 9776]},
                                :full-name "cljs.core/min-key",
                                :docstring "Returns the x for which (k x), a number, is least.\n\nIf there are multiple such xs, the last one is returned."},
           "compiler-options/closure-defines" {:ns "compiler-options",
                                               :name "closure-defines",
                                               :name-encode "closure-defines",
                                               :type "option",
                                               :full-name-encode "compiler-options/closure-defines",
                                               :full-name "compiler-options/closure-defines",
                                               :history [["+"
                                                          "0.0-2120"]]},
           "clojure.zip/root" {:ns "clojure.zip",
                               :name "root",
                               :signature ["[loc]"],
                               :name-encode "root",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip/root",
                               :source {:code "(defn root\n  [loc]\n    (if (= :end (loc 1))\n      (node loc)\n      (let [p (up loc)]\n        (if p\n          (recur p)\n          (node loc)))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/clojure/zip.cljs",
                                        :lines [124 133]},
                               :full-name "clojure.zip/root",
                               :docstring "zips all the way up and returns the root node, reflecting any\nchanges."},
           "cljs.core/drop-while" {:ns "cljs.core",
                                   :name "drop-while",
                                   :signature ["[pred]" "[pred coll]"],
                                   :name-encode "drop-while",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/drop-while",
                                   :source {:code "(defn drop-while\n  ([pred]\n     (fn [rf]\n       (let [da (volatile! true)]\n         (fn\n           ([] (rf))\n           ([result] (rf result))\n           ([result input]\n              (let [drop? @da]\n                (if (and drop? (pred input))\n                  result\n                  (do\n                    (vreset! da nil)\n                    (rf result input)))))))))\n  ([pred coll]\n     (let [step (fn [pred coll]\n                  (let [s (seq coll)]\n                    (if (and s (pred (first s)))\n                      (recur pred (rest s))\n                      s)))]\n       (lazy-seq (step pred coll)))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [4927 4950]},
                                   :full-name "cljs.core/drop-while",
                                   :docstring "Returns a lazy sequence of the items in coll starting from the\nfirst item for which (pred item) returns logical false.  Returns a\nstateful transducer when no collection is provided."},
           "closure-warnings/function-params" {:ns "closure-warnings",
                                               :name "function-params",
                                               :name-encode "function-params",
                                               :type "warning",
                                               :full-name-encode "closure-warnings/function-params",
                                               :full-name "closure-warnings/function-params",
                                               :history [["+"
                                                          "1.9.473"]]},
           "cljs.repl.browser/send-repl-client-page" {:ns "cljs.repl.browser",
                                                      :name "send-repl-client-page",
                                                      :signature ["[{:keys [path], :as request} conn opts]"],
                                                      :name-encode "send-repl-client-page",
                                                      :history [["+"
                                                                 "0.0-927"]],
                                                      :type "function",
                                                      :full-name-encode "cljs.repl.browser/send-repl-client-page",
                                                      :source {:code "(defn send-repl-client-page\n  [{:keys [path] :as request} conn opts]\n  (if-not browser-state\n    (server/send-404 conn path)\n    (server/send-and-close conn 200\n      (str\n        \"<html><head><meta charset=\\\"UTF-8\\\"></head><body>\"\n        \"<script type=\\\"text/javascript\\\">\"\n        (repl-client-js)\n        \"</script>\"\n        \"<script type=\\\"text/javascript\\\">\n        clojure.browser.repl.client.start(\\\"http://\" (-> request :headers :host) \"\\\");\n          </script>\"\n        \"</body></html>\")\n     \"text/html\")))",
                                                               :title "Source code",
                                                               :repo "clojurescript",
                                                               :tag "r1.12.38",
                                                               :filename "src/main/clojure/cljs/repl/browser.clj",
                                                               :lines [120
                                                                       134]},
                                                      :full-name "cljs.repl.browser/send-repl-client-page"},
           "clojure.browser.repl/evaluate-javascript" {:ns "clojure.browser.repl",
                                                       :name "evaluate-javascript",
                                                       :signature ["[conn block]"],
                                                       :name-encode "evaluate-javascript",
                                                       :history [["+"
                                                                  "0.0-927"]],
                                                       :type "function",
                                                       :full-name-encode "clojure.browser.repl/evaluate-javascript",
                                                       :source {:code "(defn evaluate-javascript\n  [conn block]\n  (let [result\n        (try\n          {:status :success\n           :value (str (js* \"eval(~{block})\"))}\n          (catch :default e\n            {:status :exception\n             :value (cljs.repl/error->str e)}))]\n    (pr-str result)))",
                                                                :title "Source code",
                                                                :repo "clojurescript",
                                                                :tag "r1.12.38",
                                                                :filename "src/main/cljs/clojure/browser/repl.cljs",
                                                                :lines [67
                                                                        77]},
                                                       :full-name "clojure.browser.repl/evaluate-javascript",
                                                       :docstring "Process a single block of JavaScript received from the server"},
           "closure-warnings/visiblity" {:ns "closure-warnings",
                                         :name "visiblity",
                                         :name-encode "visiblity",
                                         :type "warning",
                                         :full-name-encode "closure-warnings/visiblity",
                                         :full-name "closure-warnings/visiblity",
                                         :history [["+" "0.0-2120"]
                                                   ["-" "1.10.866"]],
                                         :removed {:in "1.10.866",
                                                   :last-seen "1.10.844"}},
           "cljs.core/set-validator!" {:ns "cljs.core",
                                       :name "set-validator!",
                                       :signature ["[iref val]"],
                                       :name-encode "set-validatorBANG",
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "cljs.core/set-validatorBANG",
                                       :source {:code "(defn set-validator!\n  [iref val]\n  (when (and (some? val)\n             (not (val (-deref iref))))\n    (throw (js/Error. \"Validator rejected reference state\")))\n  (set! (.-validator iref) val))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/core.cljs",
                                                :lines [4654 4665]},
                                       :full-name "cljs.core/set-validator!",
                                       :docstring "Sets the validator-fn for an atom. validator-fn must be nil or a\nside-effect-free fn of one argument, which will be passed the intended\nnew state on any state change. If the new state is unacceptable, the\nvalidator-fn should return false or throw an Error. If the current state\nis not acceptable to the new validator, an Error will be thrown and the\nvalidator will not be changed."},
           "syntax/queue-literal" {:syntax-equiv {:edn-url nil,
                                                  :clj-url nil},
                                   :ns "syntax",
                                   :name "queue-literal",
                                   :name-encode "queue-literal",
                                   :history [["+" "0.0-1424"]],
                                   :type "tagged literal",
                                   :full-name-encode "syntax/queue-literal",
                                   :extra-sources ({:code "(defn read-queue\n  [form]\n  (when-not (vector? form)\n    (throw\n      #?(:clj  (RuntimeException.\n                 \"Queue literal expects a vector for its elements.\")\n         :cljs (js/Error.\n                 \"Queue literal expects a vector for its elements.\"))))\n  (list 'cljs.core/into 'cljs.core.PersistentQueue.EMPTY form))",
                                                    :title "Reader code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/clojure/cljs/tagged_literals.cljc",
                                                    :lines [13 21]}
                                                   {:code "(def ^:dynamic *cljs-data-readers*\n  (merge ;; assumes we can read all data_readers\n    #?(:clj *data-readers*)\n    {'queue read-queue\n     'uuid  read-uuid\n     'inst  read-inst\n     'js    read-js}))",
                                                    :title "Reader table",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/clojure/cljs/tagged_literals.cljc",
                                                    :lines [87 93]}),
                                   :full-name "syntax/queue-literal"},
           "cljs.spec.alpha/*compile-asserts*" {:ns "cljs.spec.alpha",
                                                :name "*compile-asserts*",
                                                :name-encode "STARcompile-assertsSTAR",
                                                :history [["+"
                                                           "1.9.542"]],
                                                :type "dynamic var",
                                                :full-name-encode "cljs.spec.alpha/STARcompile-assertsSTAR",
                                                :source {:code "(defonce\n  ^{:dynamic true}\n  *compile-asserts*\n  (s/init-compile-asserts))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1.12.38",
                                                         :filename "src/main/cljs/cljs/spec/alpha.cljs",
                                                         :lines [1470
                                                                 1478]},
                                                :full-name "cljs.spec.alpha/*compile-asserts*",
                                                :docstring "If true, compiler will enable spec asserts, which are then\nsubject to runtime control via check-asserts? If false, compiler\nwill eliminate all spec assert overhead. See 'assert'.\nInitially set to the negation of the ':elide-asserts' compiler option.\nDefaults to true."},
           "cljs.core/<" {:return-type boolean,
                          :ns "cljs.core",
                          :name "<",
                          :signature ["[x]" "[x y]" "[x y & more]"],
                          :name-encode "LT",
                          :history [["+" "0.0-927"]],
                          :type "function/macro",
                          :full-name-encode "cljs.core/LT",
                          :source {:code "(defn ^boolean <\n  ([x] true)\n  ([x y] (cljs.core/< x y))\n  ([x y & more]\n     (if (cljs.core/< x y)\n       (if (next more)\n         (recur y (first more) (next more))\n         (cljs.core/< y (first more)))\n       false)))",
                                   :title "Function code",
                                   :repo "clojurescript",
                                   :tag "r1.12.38",
                                   :filename "src/main/cljs/cljs/core.cljs",
                                   :lines [2714 2724]},
                          :extra-sources [{:code "(core/defmacro ^::ana/numeric <\n  ([x] true)\n  ([x y] (bool-expr (core/list 'js* \"(~{} < ~{})\" x y)))\n  ([x y & more] `(and (< ~x ~y) (< ~y ~@more))))",
                                           :title "Macro code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/clojure/cljs/core.cljc",
                                           :lines [1140 1143]}],
                          :full-name "cljs.core/<",
                          :docstring "Returns non-nil if nums are in monotonically increasing order,\notherwise false."},
           "cljs.core/catch" {:ns "cljs.core",
                              :name "catch",
                              :signature ["[classname name expr*]"],
                              :name-encode "catch",
                              :history [["+" "0.0-927"]],
                              :type "special form",
                              :full-name-encode "cljs.core/catch",
                              :source {:code "(defmethod parse 'try\n  [op env [_ & body :as form] name _]\n  (let [catchenv (update-in env [:context] #(if (= :expr %) :return %))\n        catch? (every-pred seq? #(= (first %) 'catch))\n        default? (every-pred catch? #(= (second %) :default))\n        finally? (every-pred seq? #(= (first %) 'finally))\n\n        {:keys [body cblocks dblock fblock]}\n        (loop [parser {:state :start :forms body\n                       :body [] :cblocks [] :dblock nil :fblock nil}]\n          (if (seq? (:forms parser))\n            (let [[form & forms*] (:forms parser)\n                  parser* (assoc parser :forms forms*)]\n              (case (:state parser)\n                :start (cond\n                         (catch? form) (recur (assoc parser :state :catches))\n                         (finally? form) (recur (assoc parser :state :finally))\n                         :else (recur (update-in parser* [:body] conj form)))\n                :catches (cond\n                           (default? form) (recur (assoc parser* :dblock form :state :finally))\n                           (catch? form) (recur (update-in parser* [:cblocks] conj form))\n                           (finally? form) (recur (assoc parser :state :finally))\n                           :else (throw (error env \"Invalid try form\")))\n                :finally (recur (assoc parser* :fblock form :state :done))\n                :done (throw (error env \"Unexpected form after finally\"))))\n            parser))\n\n        finally (when (seq fblock)\n                  (-> (disallowing-recur (analyze (assoc env :context :statement) `(do ~@(rest fblock))))\n                      (assoc :body? true)))\n        e (when (or (seq cblocks) dblock) (gensym \"e\"))\n        default (if-let [[_ _ name & cb] dblock]\n                  `(cljs.core/let [~name ~e] ~@cb)\n                  `(throw ~e))\n        cblock (if (seq cblocks)\n                 `(cljs.core/cond\n                   ~@(mapcat\n                      (fn [[_ type name & cb]]\n                        (when name (assert (not (namespace name)) \"Can't qualify symbol in catch\"))\n                        `[(cljs.core/instance? ~type ~e)\n                          (cljs.core/let [~name ~e] ~@cb)])\n                      cblocks)\n                   :else ~default)\n                 default)\n        locals (:locals catchenv)\n        locals (if e\n                 (assoc locals e\n                        {:name e\n                         :line (get-line e env)\n                         :column (get-col e env)\n                         ;; :local is required for {:op :local ...} nodes\n                         ;; but previously we had no way to figure this out\n                         ;; for `catch` locals, by adding it here we can recover\n                         ;; it later\n                         :local :catch})\n                 locals)\n        catch (when cblock\n                (disallowing-recur (analyze (assoc catchenv :locals locals) cblock)))\n        try (disallowing-recur (analyze (if (or e finally) catchenv env) `(do ~@body)))]\n\n    {:env env :op :try :form form\n     :body (assoc try :body? true)\n     :finally finally\n     :name e\n     :catch catch\n     :children (vec\n                 (concat [:body]\n                         (when catch\n                           [:catch])\n                         (when finally\n                           [:finally])))}))",
                                       :title "Parser code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/clojure/cljs/analyzer.cljc",
                                       :lines [1834 1904]},
                              :extra-sources ({:code "(defmethod emit* :try\n  [{try :body :keys [env catch name finally]}]\n  (let [context (:context env)]\n    (if (or name finally)\n      (do\n        (when (= :expr context)\n          (emits \"(function (){\"))\n        (emits \"try{\" try \"}\")\n        (when name\n          (emits \"catch (\" (munge name) \"){\" catch \"}\"))\n        (when finally\n          (assert (not= :const (:op (ana/unwrap-quote finally))) \"finally block cannot contain constant\")\n          (emits \"finally {\" finally \"}\"))\n        (when (= :expr context)\n          (emits \"})()\")))\n      (emits try))))",
                                               :title "Emitting code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/clojure/cljs/compiler.cljc",
                                               :lines [1068 1083]}),
                              :full-name "cljs.core/catch",
                              :docstring "catch-clause => (catch classname name expr*)\nfinally-clause => (finally expr*)\nCatches and handles JavaScript exceptions."},
           "syntax/shebang" {:syntax-equiv {:edn-url nil,
                                            :clj-url nil},
                             :ns "syntax",
                             :name "shebang",
                             :name-encode "shebang",
                             :history [["+" "0.0-1853"]],
                             :type "syntax",
                             :full-name-encode "syntax/shebang",
                             :extra-sources ({:code "(defn read-comment\n  [rdr & _]\n  (skip-line rdr))",
                                              :title "Reader code",
                                              :repo "tools.reader",
                                              :tag "v1.3.6",
                                              :filename "src/main/clojure/clojure/tools/reader/impl/commons.clj",
                                              :lines [124 126]}
                                             {:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    \\? read-cond\n    \\: read-namespaced-map\n    \\# read-symbolic-value\n    nil))",
                                              :title "Reader table",
                                              :repo "tools.reader",
                                              :tag "v1.3.6",
                                              :filename "src/main/clojure/clojure/tools/reader.clj",
                                              :lines [809 823]}),
                             :full-name "syntax/shebang"},
           "cljs.spec.alpha/assert" {:ns "cljs.spec.alpha",
                                     :name "assert",
                                     :signature ["[spec x]"],
                                     :name-encode "assert",
                                     :history [["+" "1.9.542"]],
                                     :type "macro",
                                     :full-name-encode "cljs.spec.alpha/assert",
                                     :source {:code "(defmacro assert\n  [spec x]\n  `(if *compile-asserts*\n     (if @#'*runtime-asserts*\n       (assert* ~spec ~x)\n       ~x)\n    ~x))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/cljs/cljs/spec/alpha.cljc",
                                              :lines [548 564]},
                                     :full-name "cljs.spec.alpha/assert",
                                     :docstring "spec-checking assert expression. Returns x if x is valid? according\nto spec, else throws an error with explain-data plus ::failure of\n:assertion-failed.\nCan be disabled at either compile time or runtime:\nIf *compile-asserts* is false at compile time, compiles to x. Defaults\nto the negation value of the ':elide-asserts' compiler option, or true if\nnot set.\nIf (check-asserts?) is false at runtime, always returns x. Defaults to\nvalue of 'cljs.spec.alpha/*runtime-asserts*', or false if not set. You can\ntoggle check-asserts? with (check-asserts bool)."},
           "cljs.repl.reflect/read-url-string" {:ns "cljs.repl.reflect",
                                                :name "read-url-string",
                                                :name-encode "read-url-string",
                                                :type "var",
                                                :full-name-encode "cljs.repl.reflect/read-url-string",
                                                :source {:code "(def read-url-string (comp read-string url-decode))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1.12.38",
                                                         :filename "src/main/clojure/cljs/repl/reflect.clj",
                                                         :lines [51]},
                                                :full-name "cljs.repl.reflect/read-url-string",
                                                :history [["+"
                                                           "0.0-1503"]]},
           "cljs.math/add-exact" {:return-type number,
                                  :ns "cljs.math",
                                  :name "add-exact",
                                  :signature ["[x y]"],
                                  :name-encode "add-exact",
                                  :history [["+" "1.11.50"]],
                                  :type "function",
                                  :full-name-encode "cljs.math/add-exact",
                                  :source {:code "(defn ^number add-exact\n  {:added \"1.11.10\"}\n  [x y]\n  (let [r (clojure.core/+ x y)]\n    (if (or (> r js/Number.MAX_SAFE_INTEGER) (< r js/Number.MIN_SAFE_INTEGER))\n      (throw (ex-info \"Integer overflow\" {:fn \"add-exact\"}))\n      r)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/math.cljs",
                                           :lines [516 523]},
                                  :full-name "cljs.math/add-exact",
                                  :docstring "Returns the sum of x and y, throws an exception on overflow. "},
           "cljs.core/deftype*" {:ns "cljs.core",
                                 :name "deftype*",
                                 :name-encode "deftypeSTAR",
                                 :history [["+" "0.0-927"]],
                                 :type "special form",
                                 :full-name-encode "cljs.core/deftypeSTAR",
                                 :source {:code "(defmethod parse 'deftype*\n  [_ env form _ _]\n  (parse-type :deftype env form))",
                                          :title "Parser code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/clojure/cljs/analyzer.cljc",
                                          :lines [3470 3472]},
                                 :extra-sources ({:code "(defmethod emit* :deftype\n  [{:keys [t fields pmasks body protocols]}]\n  (let [fields (map munge fields)]\n    (emitln \"\")\n    (emitln \"/**\")\n    (emitln \"* @constructor\")\n    (doseq [protocol protocols]\n      (emitln \" * @implements {\" (munge (str protocol)) \"}\"))\n    (emitln \"*/\")\n    (emitln (munge t) \" = (function (\" (comma-sep fields) \"){\")\n    (doseq [fld fields]\n      (emitln \"this.\" fld \" = \" fld \";\"))\n    (doseq [[pno pmask] pmasks]\n      (emitln \"this.cljs$lang$protocol_mask$partition\" pno \"$ = \" pmask \";\"))\n    (emitln \"});\")\n    (emit body)))",
                                                  :title "Emitting code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/clojure/cljs/compiler.cljc",
                                                  :lines [1389 1404]}),
                                 :full-name "cljs.core/deftype*"},
           "cljs.spec.alpha/*fspec-iterations*" {:ns "cljs.spec.alpha",
                                                 :name "*fspec-iterations*",
                                                 :name-encode "STARfspec-iterationsSTAR",
                                                 :type "dynamic var",
                                                 :full-name-encode "cljs.spec.alpha/STARfspec-iterationsSTAR",
                                                 :source {:code "(def ^:dynamic *fspec-iterations*\n  21)",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r1.12.38",
                                                          :filename "src/main/cljs/cljs/spec/alpha.cljs",
                                                          :lines [27
                                                                  29]},
                                                 :full-name "cljs.spec.alpha/*fspec-iterations*",
                                                 :history [["+"
                                                            "1.9.542"]]},
           "cljs.math/log10" {:return-type number,
                              :ns "cljs.math",
                              :name "log10",
                              :signature ["[a]"],
                              :name-encode "log10",
                              :history [["+" "1.11.50"]],
                              :type "function",
                              :full-name-encode "cljs.math/log10",
                              :source {:code "(defn ^number log10\n  {:added \"1.11.10\"}\n  [a] (Math/log10 a))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/math.cljs",
                                       :lines [158 165]},
                              :full-name "cljs.math/log10",
                              :docstring "Returns the logarithm (base 10) of a.\nIf a is ##NaN or negative => ##NaN\nIf a is ##Inf => ##Inf\nIf a is zero => ##-Inf\nSee: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/log10"},
           "cljs.repl/repl-special-doc-map" {:ns "cljs.repl",
                                             :name "repl-special-doc-map",
                                             :name-encode "repl-special-doc-map",
                                             :type "var",
                                             :full-name-encode "cljs.repl/repl-special-doc-map",
                                             :source {:code "(def repl-special-doc-map\n  '{in-ns {:arglists ([name])\n           :doc \"Sets *cljs-ns* to the namespace named by the symbol, creating it if needed.\"}\n    load-file {:arglists ([name])\n               :doc \"Sequentially read and evaluate the set of forms contained in the file.\"}\n    load {:arglists ([& paths])\n               :doc \"Loads Clojure code from resources in classpath. A path is interpreted as\n  classpath-relative if it begins with a slash or relative to the root\n  directory for the current namespace otherwise.\"}})",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.12.38",
                                                      :filename "src/main/clojure/cljs/repl.cljc",
                                                      :lines [1416
                                                              1424]},
                                             :full-name "cljs.repl/repl-special-doc-map",
                                             :history [["+"
                                                        "0.0-3058"]]},
           "cljs.spec.gen.alpha/for-all*" {:ns "cljs.spec.gen.alpha",
                                           :name "for-all*",
                                           :signature ["[& args]"],
                                           :name-encode "for-allSTAR",
                                           :history [["+" "1.9.542"]],
                                           :type "function",
                                           :full-name-encode "cljs.spec.gen.alpha/for-allSTAR",
                                           :source {:code "(defn for-all*\n  [& args]\n  (apply @for-all*-ref args))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/cljs/cljs/spec/gen/alpha.cljs",
                                                    :lines [37 40]},
                                           :full-name "cljs.spec.gen.alpha/for-all*",
                                           :docstring "Dynamically loaded clojure.test.check.properties/for-all*."},
           "cljs.repl/run-inits" {:ns "cljs.repl",
                                  :name "run-inits",
                                  :signature ["[renv inits]"],
                                  :name-encode "run-inits",
                                  :history [["+" "1.10.63"]],
                                  :type "function",
                                  :full-name-encode "cljs.repl/run-inits",
                                  :source {:code "(defn run-inits [renv inits]\n  (doseq [{:keys [type] :as init} inits]\n    (case type\n      :init-forms\n      (doseq [form (:forms init)]\n        (eval-cljs renv (ana/empty-env) form))\n      :eval-forms\n      (binding [*repl-opts* (merge *repl-opts* {:def-emits-var true :wrap init-wrap-fn})]\n        (doseq [form (:forms init)]\n          (let [value (eval-cljs renv (ana/empty-env) form *repl-opts*)]\n            (when-not (repl-nil? value)\n              (println value)))))\n      :init-script\n      (let [script (:script init)]\n        (load-stream renv (util/get-name script) script)))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/clojure/cljs/repl.cljc",
                                           :lines [1003 1017]},
                                  :full-name "cljs.repl/run-inits"},
           "cljs.core/fn" {:ns "cljs.core",
                           :name "fn",
                           :signature ["[& sigs]"],
                           :name-encode "fn",
                           :history [["+" "0.0-927"]],
                           :type "macro",
                           :full-name-encode "cljs.core/fn",
                           :source {:code "(defmacro fn\n  {:added \"1.0\", :special-form true,\n   :forms '[(fn name? [params* ] exprs*) (fn name? ([params* ] exprs*)+)]}\n  [& sigs]\n    (let [name (if (symbol? (first sigs)) (first sigs) nil)\n          sigs (if name (next sigs) sigs)\n          sigs (if (vector? (first sigs)) \n                 (list sigs) \n                 (if (seq? (first sigs))\n                   sigs\n                   ;; Assume single arity syntax\n                   (throw (IllegalArgumentException. \n                            (if (seq sigs)\n                              (str \"Parameter declaration \" \n                                   (first sigs)\n                                   \" should be a vector\")\n                              (str \"Parameter declaration missing\"))))))\n          psig (fn* [sig]\n                 ;; Ensure correct type before destructuring sig\n                 (when (not (seq? sig))\n                   (throw (IllegalArgumentException.\n                            (str \"Invalid signature \" sig\n                                 \" should be a list\"))))\n                 (let [[params & body] sig\n                       _ (when (not (vector? params))\n                           (throw (IllegalArgumentException. \n                                    (if (seq? (first sigs))\n                                      (str \"Parameter declaration \" params\n                                           \" should be a vector\")\n                                      (str \"Invalid signature \" sig\n                                           \" should be a list\")))))\n                       conds (when (and (next body) (map? (first body))) \n                                           (first body))\n                       body (if conds (next body) body)\n                       conds (or conds (meta params))\n                       pre (:pre conds)\n                       post (:post conds)                       \n                       body (if post\n                              `((let [~'% ~(if (< 1 (count body)) \n                                            `(do ~@body) \n                                            (first body))]\n                                 ~@(map (fn* [c] `(assert ~c)) post)\n                                 ~'%))\n                              body)\n                       body (if pre\n                              (concat (map (fn* [c] `(assert ~c)) pre) \n                                      body)\n                              body)]\n                   (maybe-destructured params body)))\n          new-sigs (map psig sigs)]\n      (with-meta\n        (if name\n          (list* 'fn* name new-sigs)\n          (cons 'fn* new-sigs))\n        (meta &form))))",
                                    :title "Source code",
                                    :repo "clojure",
                                    :tag "clojure-1.10.0",
                                    :filename "src/clj/clojure/core.clj",
                                    :lines [4513 4573]},
                           :full-name "cljs.core/fn",
                           :docstring "params => positional-params* , or positional-params* & next-param\npositional-param => binding-form\nnext-param => binding-form\nname => symbol\n\nDefines a function"},
           "cljs.core/split-with" {:ns "cljs.core",
                                   :name "split-with",
                                   :signature ["[pred coll]"],
                                   :name-encode "split-with",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/split-with",
                                   :source {:code "(defn split-with\n  [pred coll]\n  [(take-while pred coll) (drop-while pred coll)])",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [10238 10241]},
                                   :full-name "cljs.core/split-with",
                                   :docstring "Returns a vector of [(take-while pred coll) (drop-while pred coll)]"},
           "cljs.pprint/formatter-out" {:ns "cljs.pprint",
                                        :name "formatter-out",
                                        :signature ["[format-in]"],
                                        :name-encode "formatter-out",
                                        :history [["+" "0.0-3255"]],
                                        :type "macro",
                                        :full-name-encode "cljs.pprint/formatter-out",
                                        :source {:code "(defmacro formatter-out\n  [format-in]\n  `(let [format-in# ~format-in\n         cf# (if (string? format-in#) (cljs.pprint/cached-compile format-in#) format-in#)]\n     (fn [& args#]\n       (let [navigator# (cljs.pprint/init-navigator args#)]\n         (cljs.pprint/execute-format cf# navigator#)))))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/cljs/cljs/pprint.cljc",
                                                 :lines [143 155]},
                                        :full-name "cljs.pprint/formatter-out",
                                        :docstring "Makes a function which can directly run format-in. The function is\nfn [& args] ... and returns nil. This version of the formatter macro is\ndesigned to be used with *out* set to an appropriate Writer. In particular,\nthis is meant to be used as part of a pretty printer dispatch method.\n\nformat-in can be either a control string or a previously compiled format."},
           "cljs.math/sinh" {:return-type number,
                             :ns "cljs.math",
                             :name "sinh",
                             :signature ["[x]"],
                             :name-encode "sinh",
                             :history [["+" "1.11.50"]],
                             :type "function",
                             :full-name-encode "cljs.math/sinh",
                             :source {:code "(defn ^number sinh\n  {:added \"1.11.10\"}\n  [x] (Math/sinh x))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/math.cljs",
                                      :lines [672 678]},
                             :full-name "cljs.math/sinh",
                             :docstring "Returns the hyperbolic sine of x, (e^x - e^-x)/2.\nIf x is ##NaN => ##NaN\nIf x is ##Inf or ##-Inf or zero => x\nSee: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sinh"},
           "closure-warnings/internet-explorer-checks" {:ns "closure-warnings",
                                                        :name "internet-explorer-checks",
                                                        :name-encode "internet-explorer-checks",
                                                        :type "warning",
                                                        :full-name-encode "closure-warnings/internet-explorer-checks",
                                                        :full-name "closure-warnings/internet-explorer-checks",
                                                        :history [["+"
                                                                   "0.0-2120"]
                                                                  ["-"
                                                                   "1.10.738"]],
                                                        :removed {:in "1.10.738",
                                                                  :last-seen "1.10.597"}},
           "cljs.js/eval-str" {:ns "cljs.js",
                               :name "eval-str",
                               :signature ["[state source cb]"
                                           "[state source name cb]"
                                           "[state source name opts cb]"],
                               :name-encode "eval-str",
                               :history [["+" "1.7.10"]],
                               :type "function",
                               :full-name-encode "cljs.js/eval-str",
                               :source {:code "(defn eval-str\n  ([state source cb]\n   (eval-str state source nil cb))\n  ([state source name cb]\n   (eval-str state source name nil cb))\n  ([state source name opts cb]\n   {:pre [(atom? state) (string? source)\n          (valid-name? name) (valid-opts? opts) (fn? cb)]}\n   (eval-str*\n     {:*compiler*     state\n      :*data-readers* tags/*cljs-data-readers*\n      :*analyze-deps* (:analyze-deps opts true)\n      :*cljs-dep-set* ana/*cljs-dep-set*\n      :*load-macros*  (:load-macros opts true)\n      :*load-fn*      (or (:load opts) *load-fn*)\n      :*eval-fn*      (or (:eval opts) *eval-fn*)}\n     source name opts cb)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/js.cljs",
                                        :lines [1140 1205]},
                               :full-name "cljs.js/eval-str",
                               :docstring "Evalute ClojureScript source given as a string. The parameters:\n\nstate (atom)\n  the compiler state\n\nsource (string)\n  the ClojureScript source\n\nname (symbol or string)\n  optional, the name of the source - used as key in :source-maps\n\nopts (map)\n  compilation options.\n\n  :eval             - eval function to invoke, see *eval-fn*\n  :load             - library resolution function, see *load-fn*\n  :source-map       - set to true to generate inline source map information\n  :cache-source     - optional, a function to run side-effects with the\n                      compilation result prior to actual evalution. This function\n                      takes two arguments, the first is the eval map, the source\n                      will be under :source. The second argument is a callback of\n                      one argument. If an error occurs an :error key should be\n                      supplied.\n  :def-emits-var    - sets whether def (and derived) forms return either a Var\n                      (if set to true) or the def init value (if false). Default\n                      is false.\n  :checked-arrays   - if :warn or :error, checks inferred types and values passed\n                      to aget/aset. Logs for incorrect values if :warn, throws if\n                      :error. Defaults to false.\n  :static-fns       - employ static dispatch to specific function arities in\n                      emitted JavaScript, as opposed to making use of the\n                      `call` construct. Defaults to false.\n  :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\n                      unknown functions, but instead direct invokes via\n                      `f(a0,a1...)`. Defaults to `false`.\n  :target           - use `:nodejs` if targeting Node.js. Takes no other options\n                      at the moment.\n  :ns               - optional, the namespace in which to evaluate the source.\n  :verbose          - optional, emit details from compiler activity. Defaults to\n                      false.\n  :context          - optional, sets the context for the source. Possible values\n                   are `:expr`, `:statement` and `:return`. Defaults to\n                    `:statement`.\n\ncb (function)\n  callback, will be invoked with a map. If succesful the map will contain\n  a :value key with the result of evaluation and :ns the current namespace.\n  If unsuccessful will contain a :error key with an ex-info instance describing\n  the cause of failure."},
           "cljs.pprint/pp" {:ns "cljs.pprint",
                             :name "pp",
                             :signature ["[]"],
                             :name-encode "pp",
                             :history [["+" "0.0-3255"]],
                             :type "macro",
                             :full-name-encode "cljs.pprint/pp",
                             :source {:code "(defmacro pp\n  {:added \"1.2\"}\n  [] `(cljs.pprint/pprint *1))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/pprint.cljc",
                                      :lines [163 167]},
                             :full-name "cljs.pprint/pp",
                             :docstring "A convenience macro that pretty prints the last thing output. This is\nexactly equivalent to (pprint *1)."},
           "cljs.core/IWriter" {:ns "cljs.core",
                                :name "IWriter",
                                :name-encode "IWriter",
                                :implementations #{"StringBufferWriter"},
                                :history [["+" "0.0-1503"]],
                                :type "protocol",
                                :full-name-encode "cljs.core/IWriter",
                                :source {:code "(defprotocol IWriter\n  (-write [writer s]\n    \"Writes s with writer and returns the result.\")\n  (-flush [writer]\n    \"Flush writer.\"))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [769 774]},
                                :methods [{:name "-write",
                                           :signature ["[writer s]"],
                                           :docstring "Writes s with writer and returns the result."}
                                          {:name "-flush",
                                           :signature ["[writer]"],
                                           :docstring "Flush writer."}],
                                :full-name "cljs.core/IWriter",
                                :docstring "Protocol for writing. Currently only implemented by StringBufferWriter."},
           "cljs.repl.browser/preloaded-libs" {:ns "cljs.repl.browser",
                                               :name "preloaded-libs",
                                               :name-encode "preloaded-libs",
                                               :history [["+"
                                                          "0.0-1424"]
                                                         ["-"
                                                          "0.0-3115"]],
                                               :type "var",
                                               :full-name-encode "cljs.repl.browser/preloaded-libs",
                                               :source {:code "(def preloaded-libs (atom #{}))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r3058",
                                                        :filename "src/clj/cljs/repl/browser.clj",
                                                        :lines [28]},
                                               :full-name "cljs.repl.browser/preloaded-libs",
                                               :removed {:in "0.0-3115",
                                                         :last-seen "0.0-3058"}},
           "cljs.core/IReduce" {:ns "cljs.core",
                                :name "IReduce",
                                :name-encode "IReduce",
                                :implementations #{"Subvec"
                                                   "Cycle"
                                                   "PersistentArrayMapSeq"
                                                   "RedNode"
                                                   "EmptyList"
                                                   "Iterate"
                                                   "ArrayChunk"
                                                   "BlackNode"
                                                   "PersistentVector"
                                                   "ValSeq"
                                                   "IntegerRange"
                                                   "Range"
                                                   "ChunkedSeq"
                                                   "ArrayNodeSeq"
                                                   "KeySeq"
                                                   "IndexedSeq"
                                                   "PersistentTreeMapSeq"
                                                   "RSeq"
                                                   "PersistentArrayMap"
                                                   "NodeSeq"
                                                   "List"
                                                   "Repeat"
                                                   "Cons"
                                                   "LazySeq"
                                                   "Eduction"
                                                   "MapEntry"},
                                :history [["+" "0.0-927"]],
                                :type "protocol",
                                :full-name-encode "cljs.core/IReduce",
                                :source {:code "(defprotocol IReduce\n  (-reduce [coll f] [coll f start]\n    \"f should be a function of 2 arguments. If start is not supplied,\n     returns the result of applying f to the first 2 items in coll, then\n     applying f to that result and the 3rd item, etc.\"))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [708 714]},
                                :methods [{:name "-reduce",
                                           :signature ["[coll f]"
                                                       "[coll f start]"],
                                           :docstring "f should be a function of 2 arguments. If start is not supplied,\n     returns the result of applying f to the first 2 items in coll, then\n     applying f to that result and the 3rd item, etc."}],
                                :full-name "cljs.core/IReduce",
                                :docstring "Protocol for seq types that can reduce themselves.\n  Called by cljs.core/reduce."},
           "cljs.reader/symbol-pattern" {:ns "cljs.reader",
                                         :name "symbol-pattern",
                                         :name-encode "symbol-pattern",
                                         :history [["+" "0.0-927"]
                                                   ["-" "1.9.854"]],
                                         :type "var",
                                         :full-name-encode "cljs.reader/symbol-pattern",
                                         :source {:code "(def symbol-pattern (re-pattern \"^[:]?([^0-9/].*/)?([^0-9/][^/]*)$\"))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.9.671",
                                                  :filename "src/main/cljs/cljs/reader.cljs",
                                                  :lines [102]},
                                         :full-name "cljs.reader/symbol-pattern",
                                         :removed {:in "1.9.854",
                                                   :last-seen "1.9.671"}},
           "cljs.core/PersistentHashSet.fromArray" {:ns "cljs.core",
                                                    :name "PersistentHashSet.fromArray",
                                                    :signature ["[items no-clone]"],
                                                    :name-encode "PersistentHashSetDOTfromArray",
                                                    :history [["+"
                                                               "0.0-1443"]],
                                                    :parent-type "PersistentHashSet",
                                                    :type "function",
                                                    :full-name-encode "cljs.core/PersistentHashSetDOTfromArray",
                                                    :source {:code "(set! (.-fromArray PersistentHashSet)\n  (fn [items ^boolean no-clone]\n    (let [len (alength items)]\n      (if (<= len (.-HASHMAP-THRESHOLD PersistentArrayMap))\n        (let [arr (if no-clone items (aclone items))]\n          (loop [i 0\n                 out (transient (.-EMPTY PersistentArrayMap))]\n            (if (< i len)\n              (recur (inc i) (-assoc! out (aget items i) nil))\n              (PersistentHashSet. nil (-persistent! out) nil))))\n       (loop [i 0\n              out (transient (.-EMPTY PersistentHashSet))]\n         (if (< i len)\n           (recur (inc i) (-conj! out (aget items i)))\n           (-persistent! out)))))))",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r1.12.38",
                                                             :filename "src/main/cljs/cljs/core.cljs",
                                                             :lines [9474
                                                                     9488]},
                                                    :full-name "cljs.core/PersistentHashSet.fromArray"},
           "cljs.spec.alpha/*recursion-limit*" {:ns "cljs.spec.alpha",
                                                :name "*recursion-limit*",
                                                :name-encode "STARrecursion-limitSTAR",
                                                :type "dynamic var",
                                                :full-name-encode "cljs.spec.alpha/STARrecursion-limitSTAR",
                                                :source {:code "(def ^:dynamic *recursion-limit*\n  4)",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1.12.38",
                                                         :filename "src/main/cljs/cljs/spec/alpha.cljs",
                                                         :lines [21
                                                                 25]},
                                                :full-name "cljs.spec.alpha/*recursion-limit*",
                                                :history [["+"
                                                           "1.9.542"]]},
           "cljs.core/repeatedly" {:ns "cljs.core",
                                   :name "repeatedly",
                                   :signature ["[f]" "[n f]"],
                                   :name-encode "repeatedly",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/repeatedly",
                                   :source {:code "(defn repeatedly\n  ([f] (lazy-seq (cons (f) (repeatedly f))))\n  ([n f] (take n (repeatedly f))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [5141 5146]},
                                   :full-name "cljs.core/repeatedly",
                                   :docstring "Takes a function of no args, presumably with side effects, and\nreturns an infinite (or length n if supplied) lazy sequence of calls\nto it"},
           "closure-warnings/missing-override" {:ns "closure-warnings",
                                                :name "missing-override",
                                                :name-encode "missing-override",
                                                :type "warning",
                                                :full-name-encode "closure-warnings/missing-override",
                                                :full-name "closure-warnings/missing-override",
                                                :history [["+"
                                                           "1.9.473"]]},
           "cljs.core/uri?" {:ns "cljs.core",
                             :name "uri?",
                             :signature ["[x]"],
                             :name-encode "uriQMARK",
                             :history [["+" "1.9.946"]],
                             :type "function",
                             :full-name-encode "cljs.core/uriQMARK",
                             :source {:code "(defn uri?\n  {:added \"1.9\"}\n  [x]\n  (instance? goog.Uri x))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [12224 12228]},
                             :full-name "cljs.core/uri?",
                             :docstring "Returns true x is a goog.Uri instance."},
           "cljs.build.api/mark-cljs-ns-for-recompile!" {:ns "cljs.build.api",
                                                         :name "mark-cljs-ns-for-recompile!",
                                                         :signature ["[ns-sym]"
                                                                     "[ns-sym output-dir]"],
                                                         :name-encode "mark-cljs-ns-for-recompileBANG",
                                                         :history [["+"
                                                                    "0.0-2496"]],
                                                         :type "function",
                                                         :full-name-encode "cljs.build.api/mark-cljs-ns-for-recompileBANG",
                                                         :source {:code "(defn mark-cljs-ns-for-recompile!\n  ([ns-sym] (closure/mark-cljs-ns-for-recompile! ns-sym nil))\n  ([ns-sym output-dir] (closure/mark-cljs-ns-for-recompile! ns-sym output-dir)))",
                                                                  :title "Source code",
                                                                  :repo "clojurescript",
                                                                  :tag "r1.12.38",
                                                                  :filename "src/main/clojure/cljs/build/api.clj",
                                                                  :lines [37
                                                                          40]},
                                                         :full-name "cljs.build.api/mark-cljs-ns-for-recompile!",
                                                         :docstring "Backdates a cljs target file so that it the cljs compiler will recompile it."},
           "cljs.analyzer.api/current-ns" {:ns "cljs.analyzer.api",
                                           :name "current-ns",
                                           :signature ["[]"],
                                           :name-encode "current-ns",
                                           :history [["+" "1.10.753"]],
                                           :type "function",
                                           :full-name-encode "cljs.analyzer.api/current-ns",
                                           :source {:code "(defn current-ns\n  []\n  ana/*cljs-ns*)",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/clojure/cljs/analyzer/api.cljc",
                                                    :lines [46 49]},
                                           :full-name "cljs.analyzer.api/current-ns",
                                           :docstring "Return the current ns under analysis or compilation."},
           "cljs.repl.browser/parse-stacktrace" {:ns "cljs.repl.browser",
                                                 :name "parse-stacktrace",
                                                 :signature ["[repl-env st err opts]"],
                                                 :name-encode "parse-stacktrace",
                                                 :history [["+"
                                                            "0.0-3053"]
                                                           ["-"
                                                            "1.7.10"]],
                                                 :type "multimethod",
                                                 :full-name-encode "cljs.repl.browser/parse-stacktrace",
                                                 :source {:code "(defmulti parse-stacktrace (fn [repl-env st err opts] (:ua-product err)))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r3308",
                                                          :filename "src/main/clojure/cljs/repl/browser.clj",
                                                          :lines [206]},
                                                 :extra-sources ({:code "(defmethod parse-stacktrace :default\n  [repl-env st err opts] st)",
                                                                  :title "Dispatch method",
                                                                  :repo "clojurescript",
                                                                  :tag "r3308",
                                                                  :filename "src/main/clojure/cljs/repl/browser.clj",
                                                                  :lines [208
                                                                          209]}
                                                                 {:code "(defmethod parse-stacktrace :chrome\n  [repl-env st err opts]\n  (->> st\n    string/split-lines\n    (drop-while #(.startsWith % \"Error\"))\n    (take-while #(not (.startsWith % \"    at eval\")))\n    (map #(chrome-st-el->frame repl-env % opts))\n    (remove nil?)\n    vec))",
                                                                  :title "Dispatch method",
                                                                  :repo "clojurescript",
                                                                  :tag "r3308",
                                                                  :filename "src/main/clojure/cljs/repl/browser.clj",
                                                                  :lines [273
                                                                          281]}
                                                                 {:code "(defmethod parse-stacktrace :safari\n  [repl-env st err opts]\n  (->> st\n    string/split-lines\n    (drop-while #(.startsWith % \"Error\"))\n    (take-while #(not (.startsWith % \"eval code\")))\n    (remove string/blank?)\n    (map #(safari-st-el->frame repl-env % opts))\n    (remove nil?)\n    vec))",
                                                                  :title "Dispatch method",
                                                                  :repo "clojurescript",
                                                                  :tag "r3308",
                                                                  :filename "src/main/clojure/cljs/repl/browser.clj",
                                                                  :lines [343
                                                                          352]}
                                                                 {:code "(defmethod parse-stacktrace :firefox\n  [repl-env st err opts]\n  (->> st\n    string/split-lines\n    (drop-while #(.startsWith % \"Error\"))\n    (take-while #(= (.indexOf % \"> eval\") -1))\n    (remove string/blank?)\n    (map #(firefox-st-el->frame repl-env % opts))\n    (remove nil?)\n    vec))",
                                                                  :title "Dispatch method",
                                                                  :repo "clojurescript",
                                                                  :tag "r3308",
                                                                  :filename "src/main/clojure/cljs/repl/browser.clj",
                                                                  :lines [438
                                                                          447]}),
                                                 :full-name "cljs.repl.browser/parse-stacktrace",
                                                 :removed {:in "1.7.10",
                                                           :last-seen "0.0-3308"}},
           "cljs.js/ns-side-effects" {:ns "cljs.js",
                                      :name "ns-side-effects",
                                      :signature ["[bound-vars ana-env ast opts cb]"
                                                  "[load bound-vars ana-env {:keys [op], :as ast} opts cb]"],
                                      :name-encode "ns-side-effects",
                                      :history [["+" "1.7.10"]
                                                ["-" "1.7.28"]],
                                      :type "function",
                                      :full-name-encode "cljs.js/ns-side-effects",
                                      :source {:code "(defn ns-side-effects\n  ([bound-vars ana-env ast opts cb]\n    (ns-side-effects false bound-vars ana-env ast opts cb))\n  ([load bound-vars ana-env {:keys [op] :as ast} opts cb]\n   (when (:verbose opts)\n     (debug-prn \"Namespace side effects for\" (:name ast)))\n   (if (= :ns op)\n     (let [{:keys [deps uses requires require-macros use-macros reload reloads]} ast\n           env (:*compiler* bound-vars)]\n       (letfn [(check-uses-and-load-macros [res]\n                 (if (:error res)\n                   (cb res)\n                   (let [res (try\n                               (when (and (:*analyze-deps* bound-vars) (seq uses))\n                                 (when (:verbose opts) (debug-prn \"Checking uses\"))\n                                 (ana/check-uses uses env)\n                                 {:value nil})\n                               (catch :default cause\n                                 (wrap-error\n                                   (ana/error ana-env\n                                     (str \"Could not parse ns form \" (:name ast)) cause))))]\n                     (if (:error res)\n                       (cb res)\n                       (if (:*load-macros* bound-vars)\n                         (do\n                           (when (:verbose opts) (debug-prn \"Processing :use-macros for\" (:name ast)))\n                           (load-macros bound-vars :use-macros use-macros reload reloads opts\n                             (fn [res]\n                               (if (:error res)\n                                 (cb res)\n                                 (do\n                                   (when (:verbose opts) (debug-prn \"Processing :require-macros for\" (:name ast)))\n                                   (load-macros bound-vars :require-macros require-macros reloads reloads opts\n                                     (fn [res]\n                                       (if (:error res)\n                                         (cb res)\n                                         (let [res (try\n                                                     (when (seq use-macros)\n                                                       (when (:verbose opts) (debug-prn \"Checking :use-macros for\" (:name ast)))\n                                                       (ana/check-use-macros use-macros env))\n                                                     {:value nil}\n                                                     (catch :default cause\n                                                       (wrap-error\n                                                         (ana/error ana-env\n                                                           (str \"Could not parse ns form \" (:name ast)) cause))))]\n                                           (if (:error res)\n                                             (cb res)\n                                             (cb {:value ast})))))))))))\n                        (cb {:value ast}))))))]\n         (cond\n           (and load (seq deps))\n           (load-deps bound-vars ana-env (:name ast) deps (dissoc opts :macros-ns)\n             check-uses-and-load-macros)\n\n           (and (not load) (:*analyze-deps* bound-vars) (seq deps))\n           (analyze-deps bound-vars ana-env (:name ast) deps (dissoc opts :macros-ns)\n             check-uses-and-load-macros)\n\n           :else\n           (check-uses-and-load-macros {:value nil}))))\n     (cb {:value ast}))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.7.10",
                                               :filename "src/main/cljs/cljs/js.cljs",
                                               :lines [317 377]},
                                      :full-name "cljs.js/ns-side-effects",
                                      :removed {:in "1.7.28",
                                                :last-seen "1.7.10"}},
           "cljs.reader/read-delimited-list" {:ns "cljs.reader",
                                              :name "read-delimited-list",
                                              :signature ["[delim rdr recursive?]"],
                                              :name-encode "read-delimited-list",
                                              :history [["+"
                                                         "0.0-927"]
                                                        ["-"
                                                         "1.9.854"]],
                                              :type "function",
                                              :full-name-encode "cljs.reader/read-delimited-list",
                                              :source {:code "(defn read-delimited-list\n  [delim rdr recursive?]\n  (loop [a (array)]\n    (let [ch (read-past whitespace? rdr)]\n      (when-not ch (reader-error rdr \"EOF while reading\"))\n      (if (identical? delim ch)\n        a\n        (if-let [macrofn (macros ch)]\n          (let [mret (macrofn rdr ch)]\n            (recur (if (identical? mret rdr) a (do\n                                                 (.push a mret)\n                                                 a))))\n          (do\n            (unread rdr ch)\n            (let [o (read rdr true nil recursive?)]\n              (recur (if (identical? o rdr) a (do\n                                                (.push a o)\n                                                a))))))))))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.9.671",
                                                       :filename "src/main/cljs/cljs/reader.cljs",
                                                       :lines [226
                                                               243]},
                                              :full-name "cljs.reader/read-delimited-list",
                                              :removed {:in "1.9.854",
                                                        :last-seen "1.9.671"}},
           "cljs.test/inc-report-counter!" {:ns "cljs.test",
                                            :name "inc-report-counter!",
                                            :signature ["[name]"],
                                            :name-encode "inc-report-counterBANG",
                                            :history [["+" "0.0-2496"]],
                                            :type "function",
                                            :full-name-encode "cljs.test/inc-report-counterBANG",
                                            :source {:code "(defn inc-report-counter!\n  [name]\n  (if (:report-counters (get-current-env))\n    (update-current-env! [:report-counters name] (fnil inc 0))))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/cljs/cljs/test.cljs",
                                                     :lines [305 310]},
                                            :full-name "cljs.test/inc-report-counter!",
                                            :docstring "Increments the named counter in *report-counters*, a ref to a map.\nDoes nothing if *report-counters* is nil."},
           "cljs.core/undefined?" {:return-type boolean,
                                   :ns "cljs.core",
                                   :name "undefined?",
                                   :signature ["[x]"],
                                   :name-encode "undefinedQMARK",
                                   :history [["+" "0.0-927"]],
                                   :type "function/macro",
                                   :full-name-encode "cljs.core/undefinedQMARK",
                                   :source {:code "(defn ^boolean undefined?\n  [x]\n  (cljs.core/undefined? x))",
                                            :title "Function code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [2294 2297]},
                                   :extra-sources [{:code "(core/defmacro undefined?\n  [x]\n  (bool-expr (core/list 'js* \"(void 0 === ~{})\" x)))",
                                                    :title "Macro code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/clojure/cljs/core.cljc",
                                                    :lines [993 996]}],
                                   :full-name "cljs.core/undefined?",
                                   :docstring "Returns true if x identical to the JavaScript undefined value."},
           "clojure.zip/prev" {:ns "clojure.zip",
                               :name "prev",
                               :signature ["[loc]"],
                               :name-encode "prev",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip/prev",
                               :source {:code "(defn prev\n  [loc]\n    (if-let [lloc (left loc)]\n      (loop [loc lloc]\n        (if-let [child (and (branch? loc) (down loc))]\n          (recur (rightmost child))\n          loc))\n      (up loc)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/clojure/zip.cljs",
                                        :lines [221 230]},
                               :full-name "clojure.zip/prev",
                               :docstring "Moves to the previous loc in the hierarchy, depth-first. If already\nat the root, returns nil."},
           "cljs.core/seq?" {:ns "cljs.core",
                             :name "seq?",
                             :signature ["[s]"],
                             :name-encode "seqQMARK",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/seqQMARK",
                             :source {:code "(defn seq?\n  [s]\n  (if (nil? s)\n    false\n    (satisfies? ISeq s)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [2299 2304]},
                             :full-name "cljs.core/seq?",
                             :docstring "Return true if s satisfies ISeq"},
           "cljs.repl.browser/browser-state" {:ns "cljs.repl.browser",
                                              :name "browser-state",
                                              :name-encode "browser-state",
                                              :type "dynamic var",
                                              :full-name-encode "cljs.repl.browser/browser-state",
                                              :source {:code "(def ^:dynamic browser-state nil)",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.12.38",
                                                       :filename "src/main/clojure/cljs/repl/browser.clj",
                                                       :lines [27]},
                                              :full-name "cljs.repl.browser/browser-state",
                                              :history [["+"
                                                         "0.0-1503"]]},
           "repl-options/print" {:ns "repl-options",
                                 :name "print",
                                 :name-encode "print",
                                 :type "option",
                                 :full-name-encode "repl-options/print",
                                 :full-name "repl-options/print",
                                 :history [["+" "0.0-2911"]]},
           "warnings/extend-type-invalid-method-shape" {:ns "warnings",
                                                        :name "extend-type-invalid-method-shape",
                                                        :name-encode "extend-type-invalid-method-shape",
                                                        :type "warning",
                                                        :full-name-encode "warnings/extend-type-invalid-method-shape",
                                                        :full-name "warnings/extend-type-invalid-method-shape",
                                                        :history [["+"
                                                                   "0.0-3115"]]},
           "cljs.pprint/formatter" {:ns "cljs.pprint",
                                    :name "formatter",
                                    :signature ["[format-in]"],
                                    :name-encode "formatter",
                                    :history [["+" "0.0-3255"]],
                                    :type "macro",
                                    :full-name-encode "cljs.pprint/formatter",
                                    :source {:code "(defmacro formatter\n  [format-in]\n  `(let [format-in# ~format-in\n         my-c-c# cljs.pprint/cached-compile\n         my-e-f# cljs.pprint/execute-format\n         my-i-n# cljs.pprint/init-navigator\n         cf# (if (string? format-in#) (my-c-c# format-in#) format-in#)]\n     (fn [stream# & args#]\n       (let [navigator# (my-i-n# args#)]\n         (my-e-f# stream# cf# navigator#)))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/pprint.cljc",
                                             :lines [127 141]},
                                    :full-name "cljs.pprint/formatter",
                                    :docstring "Makes a function which can directly run format-in. The function is\nfn [stream & args] ... and returns nil unless the stream is nil (meaning\noutput to a string) in which case it returns the resulting string.\n\nformat-in can be either a control string or a previously compiled format."},
           "cljs.core/prn-str" {:ns "cljs.core",
                                :name "prn-str",
                                :signature ["[& objs]"],
                                :name-encode "prn-str",
                                :history [["+" "0.0-1011"]],
                                :type "function",
                                :full-name-encode "cljs.core/prn-str",
                                :source {:code "(defn prn-str\n  [& objs]\n  (prn-str-with-opts objs (pr-opts)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [10649 10652]},
                                :full-name "cljs.core/prn-str",
                                :docstring "Same as pr-str followed by (newline)"},
           "cljs.core/chunk-buffer" {:ns "cljs.core",
                                     :name "chunk-buffer",
                                     :signature ["[capacity]"],
                                     :name-encode "chunk-buffer",
                                     :history [["+" "0.0-1424"]],
                                     :type "function",
                                     :full-name-encode "cljs.core/chunk-buffer",
                                     :source {:code "(defn chunk-buffer [capacity]\n  (ChunkBuffer. (make-array capacity) 0))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/cljs/cljs/core.cljs",
                                              :lines [3603 3604]},
                                     :full-name "cljs.core/chunk-buffer"},
           "cljs.core/odd?" {:ns "cljs.core",
                             :name "odd?",
                             :signature ["[n]"],
                             :name-encode "oddQMARK",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/oddQMARK",
                             :source {:code "(defn odd?\n  [n] (not (even? n)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [4356 4358]},
                             :full-name "cljs.core/odd?",
                             :docstring "Returns true if n is odd, throws an exception if n is not an integer"},
           "cljs.spec.impl.gen/double" {:ns "cljs.spec.impl.gen",
                                        :name "double",
                                        :signature ["[& args]"],
                                        :name-encode "double",
                                        :history [["+" "1.9.14"]
                                                  ["-" "1.9.542"]],
                                        :type "function",
                                        :full-name-encode "cljs.spec.impl.gen/double",
                                        :source {:code "(lazy-prims any any-printable boolean char char-alpha char-alphanumeric char-ascii double\n  int keyword keyword-ns large-integer ratio simple-type simple-type-printable\n  string string-ascii string-alphanumeric symbol symbol-ns uuid)",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.9.521",
                                                 :filename "src/main/cljs/cljs/spec/impl/gen.cljs",
                                                 :lines [73 75]},
                                        :full-name "cljs.spec.impl.gen/double",
                                        :docstring "Fn returning clojure.test.check.generators/double",
                                        :removed {:in "1.9.542",
                                                  :last-seen "1.9.521"}},
           "cljs.core/cons" {:ns "cljs.core",
                             :name "cons",
                             :signature ["[x coll]"],
                             :name-encode "cons",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/cons",
                             :source {:code "(defn cons\n  [x coll]\n  (cond\n    (nil? coll)             (List. nil x nil 1 nil)\n    (implements? ISeq coll) (Cons. nil x coll nil)\n    :default                (Cons. nil x (seq coll) nil)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [3373 3379]},
                             :full-name "cljs.core/cons",
                             :docstring "Returns a new seq where x is the first element and coll is the rest."},
           "cljs.spec/unstrument-ns" {:ns "cljs.spec",
                                      :name "unstrument-ns",
                                      :signature ["[& ns-syms]"],
                                      :name-encode "unstrument-ns",
                                      :history [["+" "1.9.14"]
                                                ["-" "1.9.183"]],
                                      :type "macro",
                                      :full-name-encode "cljs.spec/unstrument-ns",
                                      :source {:code "(defmacro unstrument-ns\n  [& ns-syms]\n  `(do\n     ~@(map #(list 'cljs.spec/unstrument %) (speced-vars* ns-syms))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.9.93",
                                               :filename "src/main/cljs/cljs/spec.cljc",
                                               :lines [467 472]},
                                      :full-name "cljs.spec/unstrument-ns",
                                      :docstring "Call unstrument for all speced-vars in namespaces named\nby ns-syms. Idempotent.",
                                      :removed {:in "1.9.183",
                                                :last-seen "1.9.93"}},
           "syntax/function" {:syntax-equiv {:edn-url nil,
                                             :clj-url nil},
                              :ns "syntax",
                              :name "function",
                              :name-encode "function",
                              :history [["+" "0.0-1853"]],
                              :type "syntax",
                              :full-name-encode "syntax/function",
                              :extra-sources ({:code "(defn- read-fn\n  [rdr _ opts pending-forms]\n  (if (thread-bound? #'arg-env)\n    (throw (IllegalStateException. \"Nested #()s are not allowed\")))\n  (binding [arg-env (sorted-map)]\n    (let [form (read* (doto rdr (unread \\()) true nil opts pending-forms) ;; this sets bindings\n          rargs (rseq arg-env)\n          args (if rargs\n                 (let [higharg (long (key ( first rargs)))]\n                   (let [args (loop [i 1 args (transient [])]\n                                (if (> i higharg)\n                                  (persistent! args)\n                                  (recur (inc i) (conj! args (or (get arg-env i)\n                                                                 (garg i))))))\n                         args (if (arg-env -1)\n                                (conj args '& (arg-env -1))\n                                args)]\n                     args))\n                 [])]\n      (list 'fn* args form))))",
                                               :title "Reader code",
                                               :repo "tools.reader",
                                               :tag "v1.3.6",
                                               :filename "src/main/clojure/clojure/tools/reader.clj",
                                               :lines [534 553]}
                                              {:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    \\? read-cond\n    \\: read-namespaced-map\n    \\# read-symbolic-value\n    nil))",
                                               :title "Reader table",
                                               :repo "tools.reader",
                                               :tag "v1.3.6",
                                               :filename "src/main/clojure/clojure/tools/reader.clj",
                                               :lines [809 823]}),
                              :full-name "syntax/function"},
           "cljs.reader/read-set" {:ns "cljs.reader",
                                   :name "read-set",
                                   :signature ["[rdr _]"],
                                   :name-encode "read-set",
                                   :history [["+" "0.0-927"]
                                             ["-" "1.9.854"]],
                                   :type "function",
                                   :full-name-encode "cljs.reader/read-set",
                                   :source {:code "(defn read-set\n  [rdr _]\n  (.createWithCheck PersistentHashSet (read-delimited-list \"}\" rdr true)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.9.671",
                                            :filename "src/main/cljs/cljs/reader.cljs",
                                            :lines [409 411]},
                                   :full-name "cljs.reader/read-set",
                                   :removed {:in "1.9.854",
                                             :last-seen "1.9.671"}},
           "cljs.core/PersistentArrayMap.createAsIfByAssoc" {:ns "cljs.core",
                                                             :name "PersistentArrayMap.createAsIfByAssoc",
                                                             :signature ["[init]"],
                                                             :name-encode "PersistentArrayMapDOTcreateAsIfByAssoc",
                                                             :history [["+"
                                                                        "1.9.456"]],
                                                             :parent-type "PersistentArrayMap",
                                                             :type "function",
                                                             :full-name-encode "cljs.core/PersistentArrayMapDOTcreateAsIfByAssoc",
                                                             :source {:code "(set! (.-createAsIfByAssoc PersistentArrayMap)\n  (fn [init]\n    ;; check trailing element\n    (let [len           (alength init)\n          has-trailing? (== 1 (bit-and len  1))]\n      (if-not (or has-trailing? (pam-dupes? init))\n        (PersistentArrayMap. nil (/ len 2) init nil)\n        (.createAsIfByAssocComplexPath PersistentArrayMap init has-trailing?)))))",
                                                                      :title "Source code",
                                                                      :repo "clojurescript",
                                                                      :tag "r1.12.38",
                                                                      :filename "src/main/cljs/cljs/core.cljs",
                                                                      :lines [7226
                                                                              7233]},
                                                             :full-name "cljs.core/PersistentArrayMap.createAsIfByAssoc"},
           "cljs.core/descendants" {:ns "cljs.core",
                                    :name "descendants",
                                    :signature ["[tag]" "[h tag]"],
                                    :name-encode "descendants",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/descendants",
                                    :source {:code "(defn descendants\n  ([tag] (descendants @(get-global-hierarchy) tag))\n  ([h tag] (not-empty (get (:descendants h) tag))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [11353 11360]},
                                    :full-name "cljs.core/descendants",
                                    :docstring "Returns the immediate and indirect children of tag, through a\nrelationship established via derive. h must be a hierarchy obtained\nfrom make-hierarchy, if not supplied defaults to the global\nhierarchy. Note: does not work on JavaScript type inheritance\nrelationships."},
           "syntax/nil" {:syntax-equiv {:edn-url nil, :clj-url nil},
                         :ns "syntax",
                         :name "nil",
                         :name-encode "nil",
                         :history [["+" "0.0-1853"]],
                         :type "special symbol",
                         :full-name-encode "syntax/nil",
                         :extra-sources ({:code "(defn- read-symbol\n  [rdr initch]\n  (let [[line column] (starting-line-col-info rdr)]\n    (when-let [token (read-token rdr :symbol initch)]\n      (case token\n\n        ;; special symbols\n        \"nil\" nil\n        \"true\" true\n        \"false\" false\n        \"/\" '/\n\n        (or (when-let [p (parse-symbol token)]\n              (with-meta (symbol (p 0) (p 1))\n                (when line\n                  (merge\n                   (when-let [file (get-file-name rdr)]\n                     {:file file})\n                   (let [[end-line end-column] (ending-line-col-info rdr)]\n                     {:line line\n                      :column column\n                      :end-line end-line\n                      :end-column end-column})))))\n            (err/throw-invalid rdr :symbol token))))))",
                                          :title "Reader code",
                                          :repo "tools.reader",
                                          :tag "v1.3.6",
                                          :filename "src/main/clojure/clojure/tools/reader.clj",
                                          :lines [304 327]}),
                         :full-name "syntax/nil"},
           "syntax/map" {:syntax-equiv {:edn-url nil, :clj-url nil},
                         :ns "syntax",
                         :name "map",
                         :name-encode "map",
                         :history [["+" "0.0-1853"]],
                         :type "syntax",
                         :full-name-encode "syntax/map",
                         :extra-sources ({:code "(defn- read-map\n  [rdr _ opts pending-forms]\n  (let [[start-line start-column] (starting-line-col-info rdr)\n        the-map (read-delimited :map \\} rdr opts pending-forms)\n        map-count (count the-map)\n        [end-line end-column] (ending-line-col-info rdr)]\n    (when (odd? map-count)\n      (err/throw-odd-map rdr start-line start-column the-map))\n    (with-meta\n      (if (zero? map-count)\n        {}\n        (RT/map (to-array the-map)))\n      (when start-line\n        (merge\n         (when-let [file (get-file-name rdr)]\n           {:file file})\n         {:line start-line\n          :column start-column\n          :end-line end-line\n          :end-column end-column})))))",
                                          :title "Reader code",
                                          :repo "tools.reader",
                                          :tag "v1.3.6",
                                          :filename "src/main/clojure/clojure/tools/reader.clj",
                                          :lines [239 259]}
                                         {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                          :title "Reader table",
                                          :repo "tools.reader",
                                          :tag "v1.3.6",
                                          :filename "src/main/clojure/clojure/tools/reader.clj",
                                          :lines [788 807]}),
                         :full-name "syntax/map"},
           "warnings/protocol-impl-with-variadic-method" {:ns "warnings",
                                                          :name "protocol-impl-with-variadic-method",
                                                          :name-encode "protocol-impl-with-variadic-method",
                                                          :type "warning",
                                                          :full-name-encode "warnings/protocol-impl-with-variadic-method",
                                                          :full-name "warnings/protocol-impl-with-variadic-method",
                                                          :history [["+"
                                                                     "1.9.660"]]},
           "cljs.core/take-nth" {:ns "cljs.core",
                                 :name "take-nth",
                                 :signature ["[n]" "[n coll]"],
                                 :name-encode "take-nth",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/take-nth",
                                 :source {:code "(defn take-nth\n  ([n]\n   {:pre [(number? n)]}\n     (fn [rf]\n       (let [ia (volatile! -1)]\n         (fn\n           ([] (rf))\n           ([result] (rf result))\n           ([result input]\n              (let [i (vswap! ia inc)]\n                (if (zero? (rem i n))\n                  (rf result input)\n                  result)))))))\n  ([n coll]\n   {:pre [(number? n)]}\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (cons (first s) (take-nth n (drop n s)))))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [10217 10236]},
                                 :full-name "cljs.core/take-nth",
                                 :docstring "Returns a lazy seq of every nth item in coll.  Returns a stateful\ntransducer when no collection is provided."},
           "cljs.reader/throwing-reader" {:ns "cljs.reader",
                                          :name "throwing-reader",
                                          :signature ["[msg]"],
                                          :name-encode "throwing-reader",
                                          :history [["+" "0.0-927"]
                                                    ["-" "1.9.854"]],
                                          :type "function",
                                          :full-name-encode "cljs.reader/throwing-reader",
                                          :source {:code "(defn throwing-reader\n  [msg]\n  (fn [rdr _]\n    (reader-error rdr msg)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.9.671",
                                                   :filename "src/main/cljs/cljs/reader.cljs",
                                                   :lines [394 397]},
                                          :full-name "cljs.reader/throwing-reader",
                                          :removed {:in "1.9.854",
                                                    :last-seen "1.9.671"}},
           "cljs.math/floor-div" {:return-type number,
                                  :ns "cljs.math",
                                  :name "floor-div",
                                  :signature ["[x y]"],
                                  :name-encode "floor-div",
                                  :history [["+" "1.11.50"]],
                                  :type "function",
                                  :full-name-encode "cljs.math/floor-div",
                                  :source {:code "(defn ^number floor-div\n  {:added \"1.11.10\"}\n  [x y]\n  (if-not (and ^boolean (js/Number.isSafeInteger x) ^boolean (js/Number.isSafeInteger y))\n    (throw (ex-info \"floor-div called with non-safe-integer arguments\"\n                    {:x-int? (js/Number.isSafeInteger x) :y-int? (js/Number.isSafeInteger y)}))\n    (let [r (long (/ x y))]\n      (if (and (xor (< x 0) (< y 0)) (not (== (* r y) x)))\n        (dec r)\n        r))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/math.cljs",
                                           :lines [571 582]},
                                  :full-name "cljs.math/floor-div",
                                  :docstring "Integer division that rounds to negative infinity (as opposed to zero).\nSee: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#floorDiv-long-long-"},
           "cljs.repl.browser/send-static" {:ns "cljs.repl.browser",
                                            :name "send-static",
                                            :signature ["[{path :path, :as request} conn {:keys [static-dir output-dir host port gzip?], :or {output-dir \"out\"}, :as opts}]"],
                                            :name-encode "send-static",
                                            :history [["+" "0.0-1211"]],
                                            :type "function",
                                            :full-name-encode "cljs.repl.browser/send-static",
                                            :source {:code "(defn send-static\n  [{path :path :as request} conn\n   {:keys [static-dir output-dir host port gzip?] :or {output-dir \"out\"} :as opts}]\n  (let [output-dir (when-not (.isAbsolute (io/file output-dir)) output-dir)]\n    (if (and static-dir (not= \"/favicon.ico\" path))\n      (let [path (if (= \"/\" path) \"/index.html\" path)\n            local-path\n            (cond->\n              (seq (for [x (if (string? static-dir) [static-dir] static-dir)\n                         :when (.exists (io/file (str x path)))]\n                     (str x path)))\n              (complement nil?) first)\n            local-path\n            (if (nil? local-path)\n              (cond\n                (re-find #\".jar\" path)\n                (io/resource (second (string/split path #\".jar!/\")))\n                (string/includes? path (System/getProperty \"user.dir\"))\n                (io/file (string/replace path (str (System/getProperty \"user.dir\") \"/\") \"\"))\n                (#{\"/cljs-logo-icon-32.png\" \"/cljs-logo.svg\"} path)\n                (io/resource (subs path 1))\n                :else nil)\n              local-path)]\n        (cond\n          local-path\n          (let [mime-type (path->mime-type ext->mime-type path \"text/plain\")\n                encoding (mime-type->encoding mime-type \"UTF-8\")]\n            (server/send-and-close conn 200 (slurp local-path :encoding encoding)\n                                   mime-type encoding (and gzip? (or (= \"text/javascript\" mime-type)\n                                                                     (= \"application/wasm\" mime-type)))))\n\n          ;; \"/index.html\" doesn't exist, provide our own\n          (= path \"/index.html\")\n          (server/send-and-close conn 200\n            (default-index (str output-dir \"/main.js\"))\n            \"text/html\" \"UTF-8\")\n\n          ;; \"/main.js\" doesn't exist, provide our own\n          (= path (cond->> \"/main.js\" output-dir (str \"/\" output-dir )))\n          (let [closure-defines (-> `{\"goog.json.USE_NATIVE_JSON\" true\n                                      clojure.browser.repl/HOST ~host\n                                      clojure.browser.repl/PORT ~port}\n                                  (merge (:closure-defines @browser-state))\n                                  cljsc/normalize-closure-defines\n                                  json/write-str)]\n            (server/send-and-close conn 200\n              (str \"var CLOSURE_UNCOMPILED_DEFINES = \" closure-defines \";\\n\"\n                   \"var CLOSURE_NO_DEPS = true;\\n\"\n                   \"document.write('<script src=\\\"\" output-dir \"/goog/base.js\\\"></script>');\\n\"\n                   \"document.write('<script src=\\\"\" output-dir \"/goog/deps.js\\\"></script>');\\n\"\n                   (when (.exists (io/file output-dir \"cljs_deps.js\"))\n                     (str \"document.write('<script src=\\\"\" output-dir \"/cljs_deps.js\\\"></script>');\\n\"))\n                   \"document.write('<script src=\\\"\" output-dir \"/brepl_deps.js\\\"></script>');\\n\"\n                   \"document.write('<script>goog.require(\\\"clojure.browser.repl.preload\\\");</script>');\\n\")\n              \"text/javascript\" \"UTF-8\"))\n\n          :else (server/send-404 conn path)))\n      (server/send-404 conn path))))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/clojure/cljs/repl/browser.clj",
                                                     :lines [183 240]},
                                            :full-name "cljs.repl.browser/send-static"},
           "cljs.spec/fspec" {:ns "cljs.spec",
                              :name "fspec",
                              :signature ["[& {:keys [args ret fn gen]}]"],
                              :name-encode "fspec",
                              :history [["+" "1.9.14"]
                                        ["-" "1.9.542"]],
                              :type "macro",
                              :full-name-encode "cljs.spec/fspec",
                              :source {:code "(defmacro fspec\n  [& {:keys [args ret fn gen]}]\n  (let [env &env]\n    `(fspec-impl (spec ~args) '~(res env args)\n                           (spec ~ret) '~(res env ret)\n                           (spec ~fn) '~(res env fn) ~gen)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.9.521",
                                       :filename "src/main/cljs/cljs/spec.cljc",
                                       :lines [368 386]},
                              :full-name "cljs.spec/fspec",
                              :docstring "takes :args :ret and (optional) :fn kwargs whose values are preds\nand returns a spec whose conform/explain take a fn and validates it\nusing generative testing. The conformed value is always the fn itself.\n\nSee 'fdef' for a single operation that creates an fspec and\nregisters it, as well as a full description of :args, :ret and :fn\n\nfspecs can generate functions that validate the arguments and\nfabricate a return value compliant with the :ret spec, ignoring\nthe :fn spec if present.\n\nOptionally takes :gen generator-fn, which must be a fn of no args\nthat returns a test.check generator.",
                              :removed {:in "1.9.542",
                                        :last-seen "1.9.521"}},
           "compiler-options/closure-property-map-in" {:ns "compiler-options",
                                                       :name "closure-property-map-in",
                                                       :name-encode "closure-property-map-in",
                                                       :type "option",
                                                       :full-name-encode "compiler-options/closure-property-map-in",
                                                       :full-name "compiler-options/closure-property-map-in",
                                                       :history [["+"
                                                                  "1.10.63"]]},
           "cljs.analyzer.api/forms-seq" {:ns "cljs.analyzer.api",
                                          :name "forms-seq",
                                          :signature ["[rdr]"
                                                      "[rdr filename]"],
                                          :name-encode "forms-seq",
                                          :history [["+" "0.0-3208"]],
                                          :type "function",
                                          :full-name-encode "cljs.analyzer.api/forms-seq",
                                          :source {:code "   (defn forms-seq\n     ([rdr] (ana/forms-seq* rdr nil))\n     ([rdr filename] (ana/forms-seq* rdr filename)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/clojure/cljs/analyzer/api.cljc",
                                                   :lines [144 148]},
                                          :full-name "cljs.analyzer.api/forms-seq",
                                          :docstring "Seq of Clojure/ClojureScript forms from rdr, a java.io.Reader. Optionally\n  accepts a filename argument which will be used in any emitted errors."},
           "cljs.core/double" {:return-type number,
                               :ns "cljs.core",
                               :name "double",
                               :signature ["[x]"],
                               :name-encode "double",
                               :history [["+" "0.0-1798"]],
                               :type "function/macro",
                               :full-name-encode "cljs.core/double",
                               :source {:code "(defn ^number double [x] x)",
                                        :title "Function code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [2797]},
                               :extra-sources [{:code "(core/defmacro double [x] x)",
                                                :title "Macro code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/clojure/cljs/core.cljc",
                                                :lines [1069]}],
                               :full-name "cljs.core/double"},
           "cljs.analyzer.api/get-js-index" {:ns "cljs.analyzer.api",
                                             :name "get-js-index",
                                             :signature ["[]"
                                                         "[state]"],
                                             :name-encode "get-js-index",
                                             :history [["+" "1.7.122"]],
                                             :type "function",
                                             :full-name-encode "cljs.analyzer.api/get-js-index",
                                             :source {:code "(defn get-js-index\n  ([] (get-js-index (current-state)))\n  ([state]\n   (get @state :js-dependency-index)))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.12.38",
                                                      :filename "src/main/clojure/cljs/analyzer/api.cljc",
                                                      :lines [108 113]},
                                             :full-name "cljs.analyzer.api/get-js-index",
                                             :docstring "Return the currently computed Google Closure js dependency index from the\ncompiler state."},
           "cljs.core/even?" {:ns "cljs.core",
                              :name "even?",
                              :signature ["[n]"],
                              :name-encode "evenQMARK",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/evenQMARK",
                              :source {:code "(defn even?\n  [n] (if (integer? n)\n        (zero? (bit-and n 1))\n        (throw (js/Error. (str \"Argument must be an integer: \" n)))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [4350 4354]},
                              :full-name "cljs.core/even?",
                              :docstring "Returns true if n is even, throws an exception if n is not an integer"},
           "compiler-options/foreign-libs" {:ns "compiler-options",
                                            :name "foreign-libs",
                                            :name-encode "foreign-libs",
                                            :type "option",
                                            :full-name-encode "compiler-options/foreign-libs",
                                            :full-name "compiler-options/foreign-libs",
                                            :history [["+" "0.0-971"]]},
           "cljs.core/simple-benchmark" {:ns "cljs.core",
                                         :name "simple-benchmark",
                                         :signature ["[bindings expr iterations & {:keys [print-fn], :or {print-fn (quote println)}}]"],
                                         :name-encode "simple-benchmark",
                                         :history [["+" "0.0-1236"]],
                                         :type "macro",
                                         :full-name-encode "cljs.core/simple-benchmark",
                                         :source {:code "(core/defmacro simple-benchmark\n  [bindings expr iterations & {:keys [print-fn] :or {print-fn 'println}}]\n  (core/let [bs-str   (pr-str bindings)\n             expr-str (pr-str expr)]\n    `(let ~bindings\n       (let [start#   (.getTime (js/Date.))\n             ret#     (dotimes [_# ~iterations] ~expr)\n             end#     (.getTime (js/Date.))\n             elapsed# (- end# start#)]\n         (~print-fn (str ~bs-str \", \" ~expr-str \", \"\n                      ~iterations \" runs, \" elapsed# \" msecs\"))))))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/clojure/cljs/core.cljc",
                                                  :lines [2824 2840]},
                                         :full-name "cljs.core/simple-benchmark",
                                         :docstring "Runs expr iterations times in the context of a let expression with\nthe given bindings, then prints out the bindings and the expr\nfollowed by number of iterations and total time. The optional\nargument print-fn, defaulting to println, sets function used to\nprint the result. expr's string representation will be produced\nusing pr-str in any case."},
           "cljs.build.api/cljs-ns-dependents" {:ns "cljs.build.api",
                                                :name "cljs-ns-dependents",
                                                :signature ["[ns]"
                                                            "[state ns]"],
                                                :name-encode "cljs-ns-dependents",
                                                :history [["+"
                                                           "0.0-2629"]
                                                          ["-"
                                                           "1.7.166"]],
                                                :type "function",
                                                :full-name-encode "cljs.build.api/cljs-ns-dependents",
                                                :source {:code "(defn cljs-ns-dependents\n  ([ns]\n   (cljs-ns-dependents\n     (if-not (nil? env/*compiler*)\n       env/*compiler*\n       (env/default-compiler-env))\n     ns))\n  ([state ns]\n   (env/with-compiler-env state\n     (ana/ns-dependents ns))))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1.7.145",
                                                         :filename "src/main/clojure/cljs/build/api.clj",
                                                         :lines [73
                                                                 85]},
                                                :full-name "cljs.build.api/cljs-ns-dependents",
                                                :docstring "Given a namespace symbol return a seq of all dependent\nnamespaces sorted in dependency order. Will include\ntransient dependents.",
                                                :removed {:in "1.7.166",
                                                          :last-seen "1.7.145"}},
           "syntax/number" {:syntax-equiv {:edn-url nil, :clj-url nil},
                            :ns "syntax",
                            :name "number",
                            :name-encode "number",
                            :history [["+" "0.0-1853"]],
                            :type "syntax",
                            :full-name-encode "syntax/number",
                            :extra-sources ({:code "(defn- read-number\n  [rdr initch]\n  (loop [sb (doto (StringBuilder.) (.append initch))\n         ch (read-char rdr)]\n    (if (or (whitespace? ch) (macros ch) (nil? ch))\n      (let [s (str sb)]\n        (unread rdr ch)\n        (or (match-number s)\n            (err/throw-invalid-number rdr s)))\n      (recur (doto sb (.append ch)) (read-char rdr)))))",
                                             :title "Reader code",
                                             :repo "tools.reader",
                                             :tag "v1.3.6",
                                             :filename "src/main/clojure/clojure/tools/reader.clj",
                                             :lines [261 270]}),
                            :full-name "syntax/number"},
           "cljs.repl.browser/outs" {:ns "cljs.repl.browser",
                                     :name "outs",
                                     :name-encode "outs",
                                     :type "var",
                                     :full-name-encode "cljs.repl.browser/outs",
                                     :source {:code "(def outs (ConcurrentHashMap.))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/clojure/cljs/repl/browser.clj",
                                              :lines [30]},
                                     :full-name "cljs.repl.browser/outs",
                                     :history [["+" "1.10.217"]]},
           "cljs.core/persistent-array-map-seq" {:ns "cljs.core",
                                                 :name "persistent-array-map-seq",
                                                 :signature ["[arr i _meta]"],
                                                 :name-encode "persistent-array-map-seq",
                                                 :history [["+"
                                                            "0.0-1820"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core/persistent-array-map-seq",
                                                 :source {:code "(defn persistent-array-map-seq [arr i _meta]\n  (when (<= i (- (alength arr) 2))\n    (PersistentArrayMapSeq. arr i _meta)))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r1.12.38",
                                                          :filename "src/main/cljs/cljs/core.cljs",
                                                          :lines [6960
                                                                  6962]},
                                                 :full-name "cljs.core/persistent-array-map-seq"},
           "cljs.analyzer.api/ns-specs" {:ns "cljs.analyzer.api",
                                         :name "ns-specs",
                                         :signature ["[ns]"],
                                         :name-encode "ns-specs",
                                         :history [["+" "0.0-2629"]
                                                   ["-" "0.0-2655"]],
                                         :type "function",
                                         :full-name-encode "cljs.analyzer.api/ns-specs",
                                         :source {:code "(defn ns-specs\n  [ns]\n  {:pre [(symbol? ns)]}\n  (get-in @env/*compiler* [::ana/namespaces ns :specs]))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2644",
                                                  :filename "src/clj/cljs/analyzer/api.clj",
                                                  :lines [48 53]},
                                         :full-name "cljs.analyzer.api/ns-specs",
                                         :docstring "Given a namespace return all the original specs for a namspace as originally\nprovided in the source.",
                                         :removed {:in "0.0-2655",
                                                   :last-seen "0.0-2644"}},
           "cljs.repl.nashorn/repl-env" {:ns "cljs.repl.nashorn",
                                         :name "repl-env",
                                         :signature ["[& {:as opts}]"],
                                         :name-encode "repl-env",
                                         :history [["+" "0.0-2814"]
                                                   ["-" "1.10.738"]],
                                         :type "function",
                                         :full-name-encode "cljs.repl.nashorn/repl-env",
                                         :source {:code "(defn repl-env\n      [& {:as opts}]\n      (repl-env* opts))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.10.597",
                                                  :filename "src/main/clojure/cljs/repl/nashorn.clj",
                                                  :lines [166 169]},
                                         :full-name "cljs.repl.nashorn/repl-env",
                                         :docstring "Create a Nashorn repl-env for use with the repl/repl* method in Clojurescript.",
                                         :removed {:in "1.10.738",
                                                   :last-seen "1.10.597"}},
           "compiler-options/source-map-asset-path" {:ns "compiler-options",
                                                     :name "source-map-asset-path",
                                                     :name-encode "source-map-asset-path",
                                                     :type "option",
                                                     :full-name-encode "compiler-options/source-map-asset-path",
                                                     :full-name "compiler-options/source-map-asset-path",
                                                     :history [["+"
                                                                "1.9.90"]]},
           "repl-options/compiler-env" {:ns "repl-options",
                                        :name "compiler-env",
                                        :name-encode "compiler-env",
                                        :type "option",
                                        :full-name-encode "repl-options/compiler-env",
                                        :full-name "repl-options/compiler-env",
                                        :history [["+" "0.0-3148"]]},
           "clojure.set/subset?" {:ns "clojure.set",
                                  :name "subset?",
                                  :signature ["[set1 set2]"],
                                  :name-encode "subsetQMARK",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.set/subsetQMARK",
                                  :source {:code "(defn subset? \n  [set1 set2]\n  (and (<= (count set1) (count set2))\n       (every? #(contains? set2 %) set1)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/clojure/set.cljs",
                                           :lines [135 139]},
                                  :full-name "clojure.set/subset?",
                                  :docstring "Is set1 a subset of set2?"},
           "cljs.core/flush" {:ns "cljs.core",
                              :name "flush",
                              :signature ["[]"],
                              :name-encode "flush",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/flush",
                              :source {:code "(defn flush [] ;stub\n  nil)",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [10472 10473]},
                              :full-name "cljs.core/flush"},
           "cljs.core/long-array" {:ns "cljs.core",
                                   :name "long-array",
                                   :signature ["[size-or-seq]"
                                               "[size init-val-or-seq]"],
                                   :name-encode "long-array",
                                   :history [["+" "0.0-1211"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/long-array",
                                   :source {:code "(defn long-array\n  ([size-or-seq]\n     (if (number? size-or-seq)\n       (long-array size-or-seq nil)\n       (into-array size-or-seq)))\n  ([size init-val-or-seq]\n     (let [a (make-array size)]\n       (if (seq? init-val-or-seq)\n         (let [s (seq init-val-or-seq)]\n           (loop [i 0 s s]\n             (if (and s (< i size))\n               (do\n                 (aset a i (first s))\n                 (recur (inc i) (next s)))\n               a)))\n         (do\n           (dotimes [i size]\n             (aset a i init-val-or-seq))\n           a)))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [3778 3798]},
                                   :full-name "cljs.core/long-array",
                                   :docstring "Creates an array of longs. Does not coerce array, provided for compatibility\nwith Clojure."},
           "cljs.reader/reader-error" {:ns "cljs.reader",
                                       :name "reader-error",
                                       :signature ["[rdr & msg]"],
                                       :name-encode "reader-error",
                                       :history [["+" "0.0-927"]
                                                 ["-" "1.9.854"]],
                                       :type "function",
                                       :full-name-encode "cljs.reader/reader-error",
                                       :source {:code "(defn reader-error\n  [rdr & msg]\n  (throw (js/Error. (apply str msg))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.9.671",
                                                :filename "src/main/cljs/cljs/reader.cljs",
                                                :lines [70 72]},
                                       :full-name "cljs.reader/reader-error",
                                       :removed {:in "1.9.854",
                                                 :last-seen "1.9.671"}},
           "compiler-options/externs" {:ns "compiler-options",
                                       :name "externs",
                                       :name-encode "externs",
                                       :type "option",
                                       :full-name-encode "compiler-options/externs",
                                       :full-name "compiler-options/externs",
                                       :history [["+" "0.0-971"]]},
           "clojure.walk/prewalk-replace" {:ns "clojure.walk",
                                           :name "prewalk-replace",
                                           :signature ["[smap form]"],
                                           :name-encode "prewalk-replace",
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "clojure.walk/prewalk-replace",
                                           :source {:code "(defn prewalk-replace\n  {:added \"1.1\"}\n  [smap form]\n  (prewalk (fn [x] (if (contains? smap x) (smap x) x)) form))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/cljs/clojure/walk.cljs",
                                                    :lines [84 90]},
                                           :full-name "clojure.walk/prewalk-replace",
                                           :docstring "Recursively transforms form by replacing keys in smap with their\nvalues.  Like clojure/replace but works on any data structure.  Does\nreplacement at the root of the tree first."},
           "cljs.compiler.api/emit" {:ns "cljs.compiler.api",
                                     :name "emit",
                                     :signature ["[ast]"
                                                 "[state ast]"],
                                     :name-encode "emit",
                                     :history [["+" "0.0-3255"]],
                                     :type "function",
                                     :full-name-encode "cljs.compiler.api/emit",
                                     :source {:code "(defn emit\n  ([ast]\n   (emit (or (ana-api/current-state) (ana-api/empty-state)) ast))\n  ([state ast]\n   (ana-api/with-state state\n     (with-out-str\n       (comp/emit ast)))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/clojure/cljs/compiler/api.clj",
                                              :lines [26 33]},
                                     :full-name "cljs.compiler.api/emit",
                                     :docstring "Given an AST node generated by the analyzer emit JavaScript as a string."},
           "syntax/ns-map-alias" {:syntax-equiv {:edn-url nil,
                                                 :clj-url nil},
                                  :ns "syntax",
                                  :name "ns-map-alias",
                                  :name-encode "ns-map-alias",
                                  :history [["+" "1.9.183"]],
                                  :type "syntax",
                                  :full-name-encode "syntax/ns-map-alias",
                                  :extra-sources ({:code "(defn- read-namespaced-map\n  [rdr _ opts pending-forms]\n  (let [[start-line start-column] (starting-line-col-info rdr)\n        token (read-token rdr :namespaced-map (read-char rdr))]\n    (if-let [ns (cond\n                  (= token \":\")\n                  (ns-name *ns*)\n\n                  (= \\: (first token))\n                  (some-> token (subs 1) parse-symbol second' symbol resolve-ns ns-name)\n\n                  :else\n                  (some-> token parse-symbol second'))]\n\n      (let [ch (read-past whitespace? rdr)]\n        (if (identical? ch \\{)\n          (let [items (read-delimited :namespaced-map \\} rdr opts pending-forms)\n                [end-line end-column] (ending-line-col-info rdr)]\n            (when (odd? (count items))\n              (err/throw-odd-map rdr nil nil items))\n            (let [keys (take-nth 2 items)\n                  vals (take-nth 2 (rest items))]\n              (with-meta\n                (RT/map (to-array (mapcat list (namespace-keys (str ns) keys) vals)))\n                (when start-line\n                  (merge\n                   (when-let [file (get-file-name rdr)]\n                     {:file file})\n                   {:line start-line\n                    :column start-column\n                    :end-line end-line\n                    :end-column end-column})))))\n          (err/throw-ns-map-no-map rdr token)))\n      (err/throw-bad-ns rdr token))))",
                                                   :title "Reader code",
                                                   :repo "tools.reader",
                                                   :tag "v1.3.6",
                                                   :filename "src/main/clojure/clojure/tools/reader.clj",
                                                   :lines [753 786]}
                                                  {:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    \\? read-cond\n    \\: read-namespaced-map\n    \\# read-symbolic-value\n    nil))",
                                                   :title "Reader table",
                                                   :repo "tools.reader",
                                                   :tag "v1.3.6",
                                                   :filename "src/main/clojure/clojure/tools/reader.clj",
                                                   :lines [809 823]}),
                                  :full-name "syntax/ns-map-alias"},
           "cljs.core/*1" {:ns "cljs.core",
                           :name "*1",
                           :name-encode "STAR1",
                           :history [["+" "0.0-927"]],
                           :type "dynamic var",
                           :full-name-encode "cljs.core/STAR1",
                           :source {:code "(def\n  ^{:dynamic true}\n  *1)",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r1.12.38",
                                    :filename "src/main/cljs/cljs/core.cljs",
                                    :lines [207 210]},
                           :full-name "cljs.core/*1",
                           :docstring "bound in a repl thread to the most recent value printed"},
           "cljs.core/subseq" {:ns "cljs.core",
                               :name "subseq",
                               :signature ["[sc test key]"
                                           "[sc start-test start-key end-test end-key]"],
                               :name-encode "subseq",
                               :history [["+" "0.0-1211"]],
                               :type "function",
                               :full-name-encode "cljs.core/subseq",
                               :source {:code "(defn subseq\n  ([sc test key]\n     (let [include (mk-bound-fn sc test key)]\n       (if (#{> >=} test)\n         (when-let [[e :as s] (-sorted-seq-from sc key true)]\n           (if (include e) s (next s)))\n         (take-while include (-sorted-seq sc true)))))\n  ([sc start-test start-key end-test end-key]\n     (when-let [[e :as s] (-sorted-seq-from sc start-key true)]\n       (take-while (mk-bound-fn sc end-test end-key)\n                   (if ((mk-bound-fn sc start-test start-key) e) s (next s))))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [9886 9899]},
                               :full-name "cljs.core/subseq",
                               :docstring "sc must be a sorted collection, test(s) one of <, <=, > or\n>=. Returns a seq of those entries with keys ek for\nwhich (test (.. sc comparator (compare ek key)) 0) is true"},
           "cljs.core/Eduction" {:protocols #{"ISeqable"
                                              "IReduce"
                                              "ISequential"
                                              "IPrintWithWriter"
                                              "IIterable"},
                                 :ns "cljs.core",
                                 :name "Eduction",
                                 :signature ["[xform coll]"],
                                 :name-encode "Eduction",
                                 :history [["+" "0.0-2371"]],
                                 :type "type",
                                 :full-name-encode "cljs.core/Eduction",
                                 :source {:code "(deftype Eduction [xform coll]\n  Object\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  ISequential\n\n  IIterable\n  (-iterator [_]\n    (.create TransformerIterator xform (iter coll)))\n\n  ISeqable\n  (-seq [_] (seq (sequence xform coll)))\n\n  IReduce\n  (-reduce [_ f] (transduce xform (completing f) coll))\n  (-reduce [_ f init] (transduce xform (completing f) init coll))\n\n  IPrintWithWriter\n  (-pr-writer [coll writer opts]\n    (pr-sequential-writer writer pr-writer \"(\" \" \" \")\" opts coll)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [11067 11093]},
                                 :full-name "cljs.core/Eduction"},
           "cljs.core/Set.EMPTY" {:ns "cljs.core",
                                  :name "Set.EMPTY",
                                  :name-encode "SetDOTEMPTY",
                                  :history [["+" "0.0-927"]
                                            ["-" "0.0-1211"]],
                                  :parent-type "Set",
                                  :type "var",
                                  :full-name-encode "cljs.core/SetDOTEMPTY",
                                  :source {:code "(set! cljs.core.Set/EMPTY (Set. nil (hash-map)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [2708]},
                                  :full-name "cljs.core/Set.EMPTY",
                                  :removed {:in "0.0-1211",
                                            :last-seen "0.0-1011"}},
           "cljs.analyzer.api/analyze-file" {:ns "cljs.analyzer.api",
                                             :name "analyze-file",
                                             :signature ["[f]"
                                                         "[f opts]"
                                                         "[state f opts]"],
                                             :name-encode "analyze-file",
                                             :history [["+"
                                                        "0.0-3208"]],
                                             :type "function",
                                             :full-name-encode "cljs.analyzer.api/analyze-file",
                                             :source {:code "   (defn analyze-file\n     ([f] (analyze-file f nil))\n     ([f opts]\n      (analyze-file (or (current-state) (empty-state opts)) f opts))\n     ([state f opts]\n      (env/with-compiler-env state\n        (binding [ana/*cljs-warning-handlers* (:warning-handlers opts ana/*cljs-warning-handlers*)]\n          (ana/analyze-file f opts)))))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.12.38",
                                                      :filename "src/main/clojure/cljs/analyzer/api.cljc",
                                                      :lines [171 186]},
                                             :full-name "cljs.analyzer.api/analyze-file",
                                             :docstring "Given a java.io.File, java.net.URL or a string identifying a resource on the\n   classpath attempt to analyze it.\n\n   This function side-effects the ambient compilation environment\n   `cljs.env/*compiler*` to aggregate analysis information. opts argument is\n   compiler options, if :cache-analysis true will cache analysis to\n   \":output-dir/some/ns/foo.cljs.cache.edn\". This function does not return a\n   meaningful value."},
           "cljs.spec/coll-gen" {:ns "cljs.spec",
                                 :name "coll-gen",
                                 :signature ["[pred init-coll]"],
                                 :name-encode "coll-gen",
                                 :history [["+" "1.9.14"]
                                           ["-" "1.9.183"]],
                                 :type "function",
                                 :full-name-encode "cljs.spec/coll-gen",
                                 :source {:code "(defn coll-gen\n  [pred init-coll]\n  (let [init (empty init-coll)]\n    (fn []\n      (gen/fmap\n        #(if (vector? init) % (into init %))\n        (gen/vector (gen pred))))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.9.93",
                                          :filename "src/main/cljs/cljs/spec.cljs",
                                          :lines [1188 1197]},
                                 :full-name "cljs.spec/coll-gen",
                                 :docstring "returns a function of no args that returns a generator of\ncollections of items conforming to pred, with the same shape as\ninit-coll",
                                 :removed {:in "1.9.183",
                                           :last-seen "1.9.93"}},
           "cljs.reader/read-unicode-char" {:ns "cljs.reader",
                                            :name "read-unicode-char",
                                            :signature ["[reader initch]"],
                                            :name-encode "read-unicode-char",
                                            :history [["+" "0.0-927"]
                                                      ["-" "0.0-1424"]],
                                            :type "function",
                                            :full-name-encode "cljs.reader/read-unicode-char",
                                            :source {:code "(defn read-unicode-char\n  [reader initch]\n  (reader-error reader \"Unicode characters not supported by reader (yet)\"))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1236",
                                                     :filename "src/cljs/cljs/reader.cljs",
                                                     :lines [171 173]},
                                            :full-name "cljs.reader/read-unicode-char",
                                            :removed {:in "0.0-1424",
                                                      :last-seen "0.0-1236"}},
           "cljs.core/dissoc" {:ns "cljs.core",
                               :name "dissoc",
                               :signature ["[coll]"
                                           "[coll k]"
                                           "[coll k & ks]"],
                               :name-encode "dissoc",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/dissoc",
                               :source {:code "(defn dissoc\n  ([coll] coll)\n  ([coll k]\n    (when-not (nil? coll)\n      (-dissoc coll k)))\n  ([coll k & ks]\n    (when-not (nil? coll)\n      (let [ret (dissoc coll k)]\n        (if ks\n          (recur ret (first ks) (next ks))\n          ret)))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [2055 2067]},
                               :full-name "cljs.core/dissoc",
                               :docstring "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\nthat does not contain a mapping for key(s)."},
           "cljs.spec.alpha/int-in-range?" {:ns "cljs.spec.alpha",
                                            :name "int-in-range?",
                                            :signature ["[start end val]"],
                                            :name-encode "int-in-rangeQMARK",
                                            :history [["+" "1.9.542"]],
                                            :type "function",
                                            :full-name-encode "cljs.spec.alpha/int-in-rangeQMARK",
                                            :source {:code "(defn int-in-range?\n  [start end val]\n  (cond\n    (integer? val) (c/and (<= start val) (< val end))\n\n    (instance? goog.math.Long val)\n    (c/and (.lessThanOrEqual start val)\n           (.lessThan val end))\n\n    (instance? goog.math.Integer val)\n    (c/and (.lessThanOrEqual start val)\n           (.lessThan val end))\n\n    :else false))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/cljs/cljs/spec/alpha.cljs",
                                                     :lines [1452
                                                             1467]},
                                            :full-name "cljs.spec.alpha/int-in-range?",
                                            :docstring "Return true if start <= val, val < end and val is a fixed\nprecision integer."},
           "cljs.pprint/*print-pretty*" {:ns "cljs.pprint",
                                         :name "*print-pretty*",
                                         :name-encode "STARprint-prettySTAR",
                                         :history [["+" "0.0-3255"]],
                                         :type "dynamic var",
                                         :full-name-encode "cljs.pprint/STARprint-prettySTAR",
                                         :source {:code "(def ^{:dynamic true} *print-pretty* true)",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/cljs/cljs/pprint.cljs",
                                                  :lines [616 618]},
                                         :full-name "cljs.pprint/*print-pretty*",
                                         :docstring "Bind to true if you want write to use pretty printing"},
           "cljs.core/qualified-symbol?" {:ns "cljs.core",
                                          :name "qualified-symbol?",
                                          :signature ["[x]"],
                                          :name-encode "qualified-symbolQMARK",
                                          :history [["+" "1.9.75"]],
                                          :type "function",
                                          :full-name-encode "cljs.core/qualified-symbolQMARK",
                                          :source {:code "(defn qualified-symbol?\n  [x] (boolean (and (symbol? x) (namespace x) true)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/cljs/cljs/core.cljs",
                                                   :lines [3470 3472]},
                                          :full-name "cljs.core/qualified-symbol?",
                                          :docstring "Return true if x is a symbol with a namespace"},
           "cljs.core/exists?" {:ns "cljs.core",
                                :name "exists?",
                                :signature ["[x]"],
                                :name-encode "existsQMARK",
                                :history [["+" "0.0-1798"]],
                                :type "macro",
                                :full-name-encode "cljs.core/existsQMARK",
                                :source {:code "(core/defmacro exists?\n  [x]\n  (if (core/symbol? x)\n    (core/let [x     (core/cond-> (:name (cljs.analyzer/resolve-var &env x))\n                       (= \"js\" (namespace x)) name)\n               segs  (string/split (core/str (string/replace-first (core/str x) \"/\" \".\")) #\"\\.\")\n               n     (count segs)\n               syms  (map\n                       #(vary-meta (symbol \"js\" (string/join \".\" %))\n                          assoc :cljs.analyzer/no-resolve true)\n                       (reverse (take n (iterate butlast segs))))\n               js    (string/join \" && \" (repeat n \"(typeof ~{} !== 'undefined')\"))]\n      (bool-expr (concat (core/list 'js* js) syms)))\n    `(some? ~x)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/clojure/cljs/core.cljc",
                                         :lines [976 991]},
                                :full-name "cljs.core/exists?",
                                :docstring "Return true if argument exists, analogous to usage of typeof operator\nin JavaScript."},
           "cljs.core/ffirst" {:ns "cljs.core",
                               :name "ffirst",
                               :signature ["[coll]"],
                               :name-encode "ffirst",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/ffirst",
                               :source {:code "(defn ffirst\n  [coll]\n  (first (first coll)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [1800 1803]},
                               :full-name "cljs.core/ffirst",
                               :docstring "Same as (first (first x))"},
           "cljs.compiler.api/munge" {:ns "cljs.compiler.api",
                                      :name "munge",
                                      :signature ["[s]"],
                                      :name-encode "munge",
                                      :history [["+" "1.10.738"]],
                                      :type "function",
                                      :full-name-encode "cljs.compiler.api/munge",
                                      :source {:code "(defn munge\n  [s]\n  (comp/munge s))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/clojure/cljs/compiler/api.clj",
                                               :lines [21 24]},
                                      :full-name "cljs.compiler.api/munge",
                                      :docstring "Munge a symbol or string. Preserves the original type."},
           "cljs.spec/and" {:ns "cljs.spec",
                            :name "and",
                            :signature ["[& pred-forms]"],
                            :name-encode "and",
                            :history [["+" "1.9.14"] ["-" "1.9.542"]],
                            :type "macro",
                            :full-name-encode "cljs.spec/and",
                            :source {:code "(defmacro and\n  [& pred-forms]\n  `(and-spec-impl '~(mapv #(res &env %) pred-forms) ~(vec pred-forms) nil))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.9.521",
                                     :filename "src/main/cljs/cljs/spec.cljc",
                                     :lines [194 202]},
                            :full-name "cljs.spec/and",
                            :docstring "Takes predicate/spec-forms, e.g.\n\n(s/and even? #(< % 42))\n\nReturns a spec that returns the conformed value. Successive\nconformed values propagate through rest of predicates.",
                            :removed {:in "1.9.542",
                                      :last-seen "1.9.521"}},
           "cljs.repl/ex-triage" {:ns "cljs.repl",
                                  :name "ex-triage",
                                  :signature ["[datafied-throwable]"],
                                  :name-encode "ex-triage",
                                  :history [["+" "1.10.514"]],
                                  :type "function",
                                  :full-name-encode "cljs.repl/ex-triage",
                                  :source {:code "(defn ex-triage\n  [datafied-throwable]\n  (let [{:keys [via trace phase] :or {phase :execution}} datafied-throwable\n        {:keys [type message data]} (last via)\n        {:keys [:clojure.spec.alpha/problems :clojure.spec.alpha/fn :clojure.spec.test.alpha/caller]} data\n        {:keys [:clojure.error/source] :as top-data} (:data (first via))]\n    (assoc\n     (case phase\n       :read-source\n       (let [{:keys [:clojure.error/line :clojure.error/column]} data]\n         (cond-> (merge (-> via second :data) top-data)\n           source (assoc :clojure.error/source (file-name source))\n           (#{\"NO_SOURCE_FILE\" \"NO_SOURCE_PATH\"} source) (dissoc :clojure.error/source)\n           message (assoc :clojure.error/cause message)))\n\n       (:compile-syntax-check :compilation :macro-syntax-check :macroexpansion)\n       (cond-> top-data\n         source (assoc :clojure.error/source (file-name source))\n         (#{\"NO_SOURCE_FILE\" \"NO_SOURCE_PATH\"} source) (dissoc :clojure.error/source)\n         type (assoc :clojure.error/class type)\n         message (assoc :clojure.error/cause message)\n         problems (assoc :clojure.error/spec data))\n\n       (:read-eval-result :print-eval-result)\n       (let [[source method file line] (-> trace first)]\n         (cond-> top-data\n           line (assoc :clojure.error/line line)\n           file (assoc :clojure.error/source file)\n           (and source method) (assoc :clojure.error/symbol (java-loc->source source method))\n           type (assoc :clojure.error/class type)\n           message (assoc :clojure.error/cause message)))\n\n       :execution\n       (let [[source method file line] (->> trace (drop-while #(core-class? (name (first %)))) first)\n             file (first (remove #(or (nil? %) (#{\"NO_SOURCE_FILE\" \"NO_SOURCE_PATH\"} %)) [(:file caller) file]))\n             err-line (or (:line caller) line)]\n         (cond-> {:clojure.error/class type}\n           err-line (assoc :clojure.error/line err-line)\n           message (assoc :clojure.error/cause message)\n           (or fn (and source method)) (assoc :clojure.error/symbol (or fn (java-loc->source source method)))\n           file (assoc :clojure.error/source file)\n           problems (assoc :clojure.error/spec data))))\n      :clojure.error/phase phase)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/clojure/cljs/repl.cljc",
                                           :lines [850 905]},
                                  :full-name "cljs.repl/ex-triage",
                                  :docstring "Returns an analysis of the phase, error, cause, and location of an error that occurred\nbased on Throwable data, as returned by Throwable->map. All attributes other than phase\nare optional:\n  :clojure.error/phase - keyword phase indicator, one of:\n    :read-source :compile-syntax-check :compilation :macro-syntax-check :macroexpansion\n    :execution :read-eval-result :print-eval-result\n  :clojure.error/source - file name (no path)\n  :clojure.error/line - integer line number\n  :clojure.error/column - integer column number\n  :clojure.error/symbol - symbol being expanded/compiled/invoked\n  :clojure.error/class - cause exception class symbol\n  :clojure.error/cause - cause exception message\n  :clojure.error/spec - explain-data for spec error"},
           "clojure.zip/replace" {:ns "clojure.zip",
                                  :name "replace",
                                  :signature ["[loc node]"],
                                  :name-encode "replace",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.zip/replace",
                                  :source {:code "(defn replace\n  [loc node]\n    (let [[_ path] loc]\n      (with-meta [node (assoc path :changed? true)] (meta loc))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/clojure/zip.cljs",
                                           :lines [183 187]},
                                  :full-name "clojure.zip/replace",
                                  :docstring "Replaces the node at this loc, without moving"},
           "cljs.core/vec" {:ns "cljs.core",
                            :name "vec",
                            :signature ["[coll]"],
                            :name-encode "vec",
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core/vec",
                            :source {:code "(defn vec\n  [coll]\n  (cond\n    (map-entry? coll)\n    [(key coll) (val coll)]\n\n    (vector? coll)\n    (with-meta coll nil)\n\n    (array? coll)\n    (.fromArray PersistentVector coll true)\n\n    :else\n    (-persistent!\n      (reduce -conj!\n        (-as-transient (.-EMPTY PersistentVector))\n        coll))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [5845 5863]},
                            :full-name "cljs.core/vec",
                            :docstring "Creates a new vector containing the contents of coll. JavaScript arrays\nwill be aliased and should not be modified."},
           "cljs.spec/merge" {:ns "cljs.spec",
                              :name "merge",
                              :signature ["[& pred-forms]"],
                              :name-encode "merge",
                              :history [["+" "1.9.183"]
                                        ["-" "1.9.542"]],
                              :type "macro",
                              :full-name-encode "cljs.spec/merge",
                              :source {:code "(defmacro merge\n  [& pred-forms]\n  `(merge-spec-impl '~(mapv #(res &env %) pred-forms) ~(vec pred-forms) nil))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.9.521",
                                       :filename "src/main/cljs/cljs/spec.cljc",
                                       :lines [498 505]},
                              :full-name "cljs.spec/merge",
                              :docstring "Takes map-validating specs (e.g. 'keys' specs) and\nreturns a spec that returns a conformed map satisfying all of the\nspecs.  Successive conformed values propagate through rest of\npredicates. Unlike 'and', merge can generate maps satisfying the\nunion of the predicates.",
                              :removed {:in "1.9.542",
                                        :last-seen "1.9.521"}},
           "cljs.core/or" {:ns "cljs.core",
                           :name "or",
                           :signature ["[]" "[x]" "[x & next]"],
                           :name-encode "or",
                           :history [["+" "0.0-927"]],
                           :type "macro",
                           :full-name-encode "cljs.core/or",
                           :source {:code "(core/defmacro or\n  ([] nil)\n  ([x] x)\n  ([x & next]\n   `(let [or# ~x]\n      (if or# or# (or ~@next)))))",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r1.12.38",
                                    :filename "src/main/clojure/cljs/core.cljc",
                                    :lines [888 897]},
                           :full-name "cljs.core/or",
                           :docstring "Evaluates exprs one at a time, from left to right. If a form\nreturns a logical true value, or returns that value and doesn't\nevaluate any of the other expressions, otherwise it returns the\nvalue of the last expression. (or) returns nil."},
           "cljs.core/doubles" {:ns "cljs.core",
                                :name "doubles",
                                :signature ["[x]"],
                                :name-encode "doubles",
                                :history [["+" "0.0-1798"]],
                                :type "function",
                                :full-name-encode "cljs.core/doubles",
                                :source {:code "(defn doubles [x] x)",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [2912]},
                                :full-name "cljs.core/doubles"},
           "cljs.core/mod" {:ns "cljs.core",
                            :name "mod",
                            :signature ["[n d]"],
                            :name-encode "mod",
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core/mod",
                            :source {:code "(defn mod\n  [n d]\n  (js-mod (+ (js-mod n d) d) d))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [2920 2923]},
                            :full-name "cljs.core/mod",
                            :docstring "Modulus of num and div. Truncates toward negative infinity."},
           "cljs.core/aset" {:ns "cljs.core",
                             :name "aset",
                             :signature ["[array idx val]"
                                         "[array idx idx2 & idxv]"],
                             :name-encode "aset",
                             :history [["+" "0.0-927"]],
                             :type "function/macro",
                             :full-name-encode "cljs.core/aset",
                             :source {:code "(defn aset\n  ([array idx val]\n    (cljs.core/aset array idx val))\n  ([array idx idx2 & idxv]\n    (apply aset (aget array idx) idx2 idxv)))",
                                      :title "Function code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [515 521]},
                             :extra-sources [{:code "(core/defmacro aset\n  ([array idx val]\n   (core/case (ana/checked-arrays)\n     :warn `(checked-aset ~array ~idx ~val)\n     :error `(checked-aset' ~array ~idx ~val)\n     (core/list 'js* \"(~{}[~{}] = ~{})\" array idx val)))\n  ([array idx idx2 & idxv]\n   (core/case (ana/checked-arrays)\n     :warn `(checked-aset ~array ~idx ~idx2 ~@idxv)\n     :error `(checked-aset' ~array ~idx ~idx2 ~@idxv)\n     (core/let [n    (core/dec (count idxv))\n                astr (apply core/str (repeat n \"[~{}]\"))]\n       `(~'js* ~(core/str \"(~{}[~{}][~{}]\" astr \" = ~{})\") ~array ~idx ~idx2 ~@idxv)))))",
                                              :title "Macro code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/clojure/cljs/core.cljc",
                                              :lines [1032 1044]}],
                             :full-name "cljs.core/aset",
                             :docstring "Sets the value at the index/indices. Works on JavaScript arrays.\nReturns val."},
           "cljs.js/eval" {:ns "cljs.js",
                           :name "eval",
                           :signature ["[state form cb]"
                                       "[state form opts cb]"],
                           :name-encode "eval",
                           :history [["+" "1.7.10"]],
                           :type "function",
                           :full-name-encode "cljs.js/eval",
                           :source {:code "(defn eval\n  ([state form cb]\n   (eval state form nil cb))\n  ([state form opts cb]\n   (eval*\n     {:*compiler*     state\n      :*data-readers* tags/*cljs-data-readers*\n      :*analyze-deps* (:analyze-deps opts true)\n      :*cljs-dep-set* ana/*cljs-dep-set*\n      :*load-macros*  (:load-macros opts true)\n      :*load-fn*      (or (:load opts) *load-fn*)\n      :*eval-fn*      (or (:eval opts) *eval-fn*)}\n     form opts cb)))",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r1.12.38",
                                    :filename "src/main/cljs/cljs/js.cljs",
                                    :lines [850 902]},
                           :full-name "cljs.js/eval",
                           :docstring "Evaluate a single ClojureScript form. The parameters:\n\nstate (atom)\n  the compiler state\n\nform (s-expr)\n  the ClojureScript source\n\nopts (map)\n  compilation options.\n\n   :eval             - eval function to invoke, see *eval-fn*\n   :load             - library resolution function, see *load-fn*\n   :source-map       - set to true to generate inline source map information\n   :def-emits-var    - sets whether def (and derived) forms return either a Var\n                       (if set to true) or the def init value (if false). Default\n                       is false.\n   :checked-arrays   - if :warn or :error, checks inferred types and values passed\n                       to aget/aset. Logs for incorrect values if :warn, throws if\n                       :error. Defaults to false.\n   :static-fns       - employ static dispatch to specific function arities in\n                       emitted JavaScript, as opposed to making use of the\n                       `call` construct. Defaults to false.\n   :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\n                       unknown functions, but instead direct invokes via\n                       `f(a0,a1...)`. Defaults to `false`.\n   :target           - use `:nodejs` if targeting Node.js. Takes no other options\n                       at the moment.\n   :ns               - optional, the namespace in which to evaluate the source.\n   :verbose          - optional, emit details from compiler activity. Defaults to\n                       false.\n   :context          - optional, sets the context for the source. Possible values\n                       are `:expr`, `:statement` and `:return`. Defaults to\n                       `:statement`.\n\ncb (function)\n  callback, will be invoked with a map. If successful the map will contain\n  a key :value with the result of evalution. If unsuccessful the map will\n  contain a key :error with an ex-info instance describing the cause of\n  failure."},
           "cljs.core/second" {:ns "cljs.core",
                               :name "second",
                               :signature ["[coll]"],
                               :name-encode "second",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/second",
                               :source {:code "(defn second\n  [coll]\n  (first (next coll)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [1795 1798]},
                               :full-name "cljs.core/second",
                               :docstring "Same as (first (next x))"},
           "cljs.core/IChunkedNext" {:ns "cljs.core",
                                     :name "IChunkedNext",
                                     :name-encode "IChunkedNext",
                                     :implementations #{"IntegerRange"
                                                        "ChunkedCons"
                                                        "Range"
                                                        "ChunkedSeq"},
                                     :history [["+" "0.0-1424"]],
                                     :type "protocol",
                                     :full-name-encode "cljs.core/IChunkedNext",
                                     :source {:code "(defprotocol IChunkedNext\n  (-chunked-next [coll]\n    \"Returns a new collection of coll without the first chunk.\"))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/cljs/cljs/core.cljs",
                                              :lines [853 856]},
                                     :methods [{:name "-chunked-next",
                                                :signature ["[coll]"],
                                                :docstring "Returns a new collection of coll without the first chunk."}],
                                     :full-name "cljs.core/IChunkedNext",
                                     :docstring "Protocol for accessing the chunks of a collection."},
           "cljs.spec.test/check" {:ns "cljs.spec.test",
                                   :name "check",
                                   :signature ["[]"
                                               "[sym-or-syms]"
                                               "[sym-or-syms opts]"],
                                   :name-encode "check",
                                   :history [["+" "1.9.183"]
                                             ["-" "1.9.542"]],
                                   :type "macro",
                                   :full-name-encode "cljs.spec.test/check",
                                   :source {:code "(defmacro check\n  ([]\n   `(check '~(checkable-syms*)))\n  ([sym-or-syms]\n   `(check ~sym-or-syms nil))\n  ([sym-or-syms opts]\n   (let [syms (sym-or-syms->syms (eval sym-or-syms))\n         opts-sym (gensym \"opts\")]\n     `(let [~opts-sym ~opts]\n        [~@(->> syms\n             (filter (checkable-syms* opts))\n             (map\n               (fn [sym]\n                 (do `(check-1 '~sym nil nil ~opts-sym)))))]))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.9.521",
                                            :filename "src/main/cljs/cljs/spec/test.cljc",
                                            :lines [205 251]},
                                   :full-name "cljs.spec.test/check",
                                   :docstring "Run generative tests for spec conformance on vars named by\nsym-or-syms, a symbol or collection of symbols. If sym-or-syms\nis not specified, check all checkable vars. If a symbol identifies a\nnamespace then all symbols in that namespace will be enumerated.\n\nThe opts map includes the following optional keys, where stc\naliases clojure.test.check:\n\n::stc/opts  opts to flow through test.check/quick-check\n:gen        map from spec names to generator overrides\n\nThe ::stc/opts include :num-tests in addition to the keys\ndocumented by test.check. Generator overrides are passed to\nspec/gen when generating function args.\n\nReturns a lazy sequence of check result maps with the following\nkeys\n\n:spec       the spec tested\n:sym        optional symbol naming the var tested\n:failure    optional test failure\n::stc/ret   optional value returned by test.check/quick-check\n\nThe value for :failure can be any exception. Exceptions thrown by\nspec itself will have an ::s/failure value in ex-data:\n\n:check-failed   at least one checked return did not conform\n:no-args-spec   no :args spec provided\n:no-fn          no fn provided\n:no-fspec       no fspec provided\n:no-gen         unable to generate :args\n:instrument     invalid args detected by instrument\n",
                                   :removed {:in "1.9.542",
                                             :last-seen "1.9.521"}},
           "closure-warnings/global-this" {:ns "closure-warnings",
                                           :name "global-this",
                                           :name-encode "global-this",
                                           :type "warning",
                                           :full-name-encode "closure-warnings/global-this",
                                           :full-name "closure-warnings/global-this",
                                           :history [["+" "0.0-2120"]]},
           "cljs.core/set!" {:ns "cljs.core",
                             :name "set!",
                             :signature ["[var-symbol expr]"
                                         "[(.- instance-expr instanceFieldName-symbol) expr]"],
                             :name-encode "setBANG",
                             :history [["+" "0.0-927"]],
                             :type "special form",
                             :full-name-encode "cljs.core/setBANG",
                             :source {:code "(defmethod parse 'set!\n  [_ env [_ target val alt :as form] _ _]\n  (let [[target val] (if (= 4 (count form))\n                       ;; (set! o -prop val)\n                       [`(. ~target ~val) alt]\n                       [target val])]\n    (disallowing-recur\n      (binding [*private-var-access-nowarn* true]\n        (let [enve  (assoc env :context :expr)\n              texpr (cond\n                      (symbol? target)\n                      (do\n                        (cond\n                          (and (= target '*unchecked-if*)   ;; TODO: proper resolve\n                               (or (true? val) (false? val)))\n                          (set! *unchecked-if* val)\n\n                          (and (= target '*unchecked-arrays*) ;; TODO: proper resolve\n                               (or (true? val) (false? val)))\n                          (set! *unchecked-arrays* val)\n\n                          (and (= target '*warn-on-infer*)\n                               (or (true? val) (false? val)))\n                          (set! *cljs-warnings* (assoc *cljs-warnings* :infer-warning val)))\n                        (when (some? (:const (resolve-var (dissoc env :locals) target)))\n                          (throw (error env \"Can't set! a constant\")))\n                        (let [local (handle-symbol-local target (-> env :locals target))]\n                          (when-not (or (nil? local)\n                                        (and (:field local)\n                                             (or (:mutable local)\n                                                 (:unsynchronized-mutable local)\n                                                 (:volatile-mutable local))))\n                            (throw (error env \"Can't set! local var or non-mutable field\"))))\n                        (analyze-symbol enve target))\n\n                      :else\n                      (when (seq? target)\n                        (let [texpr (if (-> target meta :extend-type)\n                                      ;; we're setting a prototype via extend-type macro\n                                      ;; nothing to warn\n                                      (binding [*cljs-warnings*\n                                                (assoc *cljs-warnings* :infer-warning false)]\n                                        (analyze-seq enve target nil))\n                                      (analyze-seq enve target nil))]\n                          (when (:field texpr)\n                            texpr))))\n              vexpr (analyze enve val)]\n          ;; as top level fns are decomposed for Closure cross-module code motion, we need to\n          ;; restore their :methods information\n          (when (seq? target)\n            (let [sym  (some-> target second)\n                  meta (meta sym)]\n              (when-let [info (and (= :fn (:op vexpr)) (:top-fn meta))]\n                (swap! env/*compiler* update-in\n                  [::namespaces (-> env :ns :name) :defs sym :methods]\n                  (fnil conj [])\n                  ;; just use original fn meta, as the fn method is already desugared\n                  ;; only get tag from analysis\n                  (merge\n                    (select-keys info [:fixed-arity :variadic?])\n                    (select-keys (-> vexpr :methods first) [:tag]))))))\n          (when-not texpr\n            (throw (error env \"set! target must be a field or a symbol naming a var\")))\n          (cond\n            (and (not (:def-emits-var env))                 ;; non-REPL context\n                 (some? ('#{*unchecked-if* *unchecked-arrays* *warn-on-infer*} target)))\n            {:env env :op :no-op}\n\n            :else\n            {:env env :op :set! :form form :target texpr :val vexpr\n             :children [:target :val]}))))))",
                                      :title "Parser code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/clojure/cljs/analyzer.cljc",
                                      :lines [2627 2697]},
                             :extra-sources ({:code "(defmethod emit* :set!\n  [{:keys [target val env]}]\n  (emit-wrap env (emits \"(\" target \" = \" val \")\")))",
                                              :title "Emitting code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/clojure/cljs/compiler.cljc",
                                              :lines [1263 1265]}),
                             :full-name "cljs.core/set!",
                             :docstring "Used to set vars and JavaScript object fields"},
           "cljs.core/bit-count" {:ns "cljs.core",
                                  :name "bit-count",
                                  :signature ["[v]"],
                                  :name-encode "bit-count",
                                  :history [["+" "0.0-1211"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/bit-count",
                                  :source {:code "(defn bit-count\n  [v]\n  (let [v (- v (bit-and (bit-shift-right v 1) 0x55555555))\n        v (+ (bit-and v 0x33333333) (bit-and (bit-shift-right v 2) 0x33333333))]\n    (bit-shift-right (* (bit-and (+ v (bit-shift-right v 4)) 0xF0F0F0F) 0x1010101) 24)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [3001 3006]},
                                  :full-name "cljs.core/bit-count",
                                  :docstring "Counts the number of bits set in n"},
           "clojure.set/rename" {:ns "clojure.set",
                                 :name "rename",
                                 :signature ["[xrel kmap]"],
                                 :name-encode "rename",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "clojure.set/rename",
                                 :source {:code "(defn rename\n  [xrel kmap]\n    (set (map #(rename-keys % kmap) xrel)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/clojure/set.cljs",
                                          :lines [82 85]},
                                 :full-name "clojure.set/rename",
                                 :docstring "Returns a rel of the maps in xrel with the keys in kmap renamed to the vals in kmap"},
           "cljs.core/m3-hash-int" {:return-type number,
                                    :ns "cljs.core",
                                    :name "m3-hash-int",
                                    :signature ["[in]"],
                                    :name-encode "m3-hash-int",
                                    :history [["+" "0.0-2261"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/m3-hash-int",
                                    :source {:code "(defn ^number m3-hash-int [in]\n  (if (zero? in)\n    in\n    (let [k1 (m3-mix-K1 in)\n          h1 (m3-mix-H1 m3-seed k1)]\n      (m3-fmix h1 4))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [956 961]},
                                    :full-name "cljs.core/m3-hash-int"},
           "cljs.compiler.api/compile-file" {:ns "cljs.compiler.api",
                                             :name "compile-file",
                                             :signature ["[src]"
                                                         "[src dest]"
                                                         "[src dest opts]"
                                                         "[state src dest opts]"],
                                             :name-encode "compile-file",
                                             :history [["+"
                                                        "0.0-3255"]],
                                             :type "function",
                                             :full-name-encode "cljs.compiler.api/compile-file",
                                             :source {:code "(defn compile-file\n  ([src]\n   (compile-file src (closure/src-file->target-file src)))\n  ([src dest]\n   (compile-file src dest nil))\n  ([src dest opts]\n   (compile-file (or (ana-api/current-state) (ana-api/empty-state opts)) src dest opts))\n  ([state src dest opts]\n   (ana-api/with-state state\n     (binding [ana/*cljs-warning-handlers* (:warning-handlers opts ana/*cljs-warning-handlers*)]\n       (comp/compile-file src dest opts)))))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.12.38",
                                                      :filename "src/main/clojure/cljs/compiler/api.clj",
                                                      :lines [59 81]},
                                             :full-name "cljs.compiler.api/compile-file",
                                             :docstring "Compiles src to a file of the same name, but with a .js extension,\nin the src file's directory.\n\nWith dest argument, write file to provided location. If the dest\nargument is a file outside the source tree, missing parent\ndirectories will be created. The src file will only be compiled if\nthe dest file has an older modification time.\n\nBoth src and dest may be either a String or a File.\n\nReturns a map containing {:ns .. :provides .. :requires .. :file ..}.\nIf the file was not compiled returns only {:file ...}"},
           "closure-warnings/unused-local-variable" {:ns "closure-warnings",
                                                     :name "unused-local-variable",
                                                     :name-encode "unused-local-variable",
                                                     :type "warning",
                                                     :full-name-encode "closure-warnings/unused-local-variable",
                                                     :full-name "closure-warnings/unused-local-variable",
                                                     :history [["+"
                                                                "1.9.473"]]},
           "cljs.core/assoc!" {:ns "cljs.core",
                               :name "assoc!",
                               :signature ["[tcoll key val]"
                                           "[tcoll key val & kvs]"],
                               :name-encode "assocBANG",
                               :history [["+" "0.0-1211"]],
                               :type "function",
                               :full-name-encode "cljs.core/assocBANG",
                               :source {:code "(defn assoc!\n  ([tcoll key val]\n    (-assoc! tcoll key val))\n  ([tcoll key val & kvs]\n    (let [ntcoll (-assoc! tcoll key val)]\n      (if kvs\n        (recur ntcoll (first kvs) (second kvs) (nnext kvs))\n        ntcoll))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [3928 3938]},
                               :full-name "cljs.core/assoc!",
                               :docstring "When applied to a transient map, adds mapping of key(s) to\nval(s). When applied to a transient vector, sets the val at index.\nNote - index must be <= (count vector). Returns coll."},
           "cljs.spec.test/enumerate-namespace" {:ns "cljs.spec.test",
                                                 :name "enumerate-namespace",
                                                 :signature ["[[quote ns-sym-or-syms]]"],
                                                 :name-encode "enumerate-namespace",
                                                 :history [["+"
                                                            "1.9.183"]
                                                           ["-"
                                                            "1.9.456"]],
                                                 :type "macro",
                                                 :full-name-encode "cljs.spec.test/enumerate-namespace",
                                                 :source {:code "(defmacro enumerate-namespace\n  [[quote ns-sym-or-syms]]\n  (let [xs (into #{}\n             (mapcat (fn [ns-sym]\n                       (->> (vals (ana-api/ns-interns ns-sym))\n                         (filter #(not (:macro %)))\n                         (map :name)\n                         (map\n                           (fn [name-sym]\n                             (symbol (name ns-sym) (name name-sym)))))))\n             (collectionize ns-sym-or-syms))]\n    `(quote ~xs)))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r1.9.293",
                                                          :filename "src/main/cljs/cljs/spec/test.cljc",
                                                          :lines [28
                                                                  41]},
                                                 :full-name "cljs.spec.test/enumerate-namespace",
                                                 :docstring "Given a symbol naming an ns, or a collection of such symbols,\nreturns the set of all symbols naming vars in those nses.",
                                                 :removed {:in "1.9.456",
                                                           :last-seen "1.9.293"}},
           "cljs.repl/mapped-line-and-column" {:ns "cljs.repl",
                                               :name "mapped-line-and-column",
                                               :signature ["[source-map line column]"],
                                               :name-encode "mapped-line-and-column",
                                               :history [["+"
                                                          "0.0-2814"]
                                                         ["-"
                                                          "0.0-3148"]],
                                               :type "function",
                                               :full-name-encode "cljs.repl/mapped-line-and-column",
                                               :source {:code "(defn mapped-line-and-column\n  [source-map line column]\n  (let [default [line column]]\n    ;; source maps are 0 indexed for lines\n    (if-let [columns (get source-map (dec line))]\n      (vec\n        (map inc\n          (map\n            ;; source maps are 0 indexed for columns\n            ;; multiple segments may exist at column\n            ;; the last segment seems most accurate\n            (last\n              (if-let [mapping (get columns (dec column))]\n                mapping\n                (second (first columns))))\n            [:line :col])))\n      default)))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r3126",
                                                        :filename "src/clj/cljs/repl.clj",
                                                        :lines [223
                                                                241]},
                                               :full-name "cljs.repl/mapped-line-and-column",
                                               :docstring "Given a cljs.source-map source map data structure map a generated line\nand column back to the original line and column.",
                                               :removed {:in "0.0-3148",
                                                         :last-seen "0.0-3126"}},
           "cljs.build.api/add-dependency-sources" {:ns "cljs.build.api",
                                                    :name "add-dependency-sources",
                                                    :signature ["[xs]"
                                                                "[xs opts]"
                                                                "[state xs opts]"],
                                                    :name-encode "add-dependency-sources",
                                                    :history [["+"
                                                               "1.10.738"]],
                                                    :type "function",
                                                    :full-name-encode "cljs.build.api/add-dependency-sources",
                                                    :source {:code "(defn add-dependency-sources\n  ([xs]\n   (add-dependency-sources xs {}))\n  ([xs opts]\n   (add-dependency-sources (or (ana-api/current-state) (ana-api/empty-state opts)) xs opts))\n  ([state xs opts]\n   (ana-api/with-state state\n     (closure/add-dependency-sources xs opts))))",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r1.12.38",
                                                             :filename "src/main/clojure/cljs/build/api.clj",
                                                             :lines [138
                                                                     147]},
                                                    :full-name "cljs.build.api/add-dependency-sources",
                                                    :docstring "Given a sequence of cljs.closure/IJavaScript values, return a set that includes\nall dependencies."},
           "cljs.test/get-and-clear-env!" {:ns "cljs.test",
                                           :name "get-and-clear-env!",
                                           :signature ["[]"],
                                           :name-encode "get-and-clear-envBANG",
                                           :history [["+" "0.0-2814"]],
                                           :type "function",
                                           :full-name-encode "cljs.test/get-and-clear-envBANG",
                                           :source {:code "(defn get-and-clear-env! []\n  \"Like get-current-env, but cleans env before returning.\"\n  (let [env (cljs.test/get-current-env)]\n    (clear-env!)\n    env))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/cljs/cljs/test.cljs",
                                                    :lines [283 287]},
                                           :full-name "cljs.test/get-and-clear-env!"},
           "cljs.core/delay?" {:ns "cljs.core",
                               :name "delay?",
                               :signature ["[x]"],
                               :name-encode "delayQMARK",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/delayQMARK",
                               :source {:code "(defn delay?\n  [x] (instance? Delay x))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [10981 10983]},
                               :full-name "cljs.core/delay?",
                               :docstring "returns true if x is a Delay created with delay"},
           "clojure.zip/left" {:ns "clojure.zip",
                               :name "left",
                               :signature ["[loc]"],
                               :name-encode "left",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip/left",
                               :source {:code "(defn left\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (when (and path (seq l))\n        (with-meta [(peek l) (assoc path :l (pop l) :r (cons node r))] (meta loc)))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/clojure/zip.cljs",
                                        :lines [150 155]},
                               :full-name "clojure.zip/left",
                               :docstring "Returns the loc of the left sibling of the node at this loc, or nil"},
           "cljs.reader/not-implemented" {:ns "cljs.reader",
                                          :name "not-implemented",
                                          :signature ["[rdr ch]"],
                                          :name-encode "not-implemented",
                                          :history [["+" "0.0-927"]
                                                    ["-" "1.9.854"]],
                                          :type "function",
                                          :full-name-encode "cljs.reader/not-implemented",
                                          :source {:code "(defn not-implemented\n  [rdr ch]\n  (reader-error rdr \"Reader for \" ch \" not implemented yet\"))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.9.671",
                                                   :filename "src/main/cljs/cljs/reader.cljs",
                                                   :lines [249 251]},
                                          :full-name "cljs.reader/not-implemented",
                                          :removed {:in "1.9.854",
                                                    :last-seen "1.9.671"}},
           "cljs.core/IAssociative" {:ns "cljs.core",
                                     :name "IAssociative",
                                     :name-encode "IAssociative",
                                     :implementations #{"Subvec"
                                                        "PersistentHashMap"
                                                        "RedNode"
                                                        "ObjMap"
                                                        "BlackNode"
                                                        "PersistentVector"
                                                        "PersistentTreeMap"
                                                        "PersistentArrayMap"
                                                        "MapEntry"},
                                     :history [["+" "0.0-927"]],
                                     :type "protocol",
                                     :full-name-encode "cljs.core/IAssociative",
                                     :source {:code "(defprotocol IAssociative\n  (^boolean -contains-key? [coll k]\n    \"Returns true if k is a key in coll.\")\n  #_(-entry-at [coll k])\n  (^clj -assoc [coll k v]\n    \"Returns a new collection of coll with a mapping from key k to\n     value v added to it.\"))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/cljs/cljs/core.cljs",
                                              :lines [644 651]},
                                     :methods [{:name "-contains-key?",
                                                :signature ["[coll k]"],
                                                :docstring "Returns true if k is a key in coll."}
                                               {:name "-assoc",
                                                :signature ["[coll k v]"],
                                                :docstring "Returns a new collection of coll with a mapping from key k to\n     value v added to it."}],
                                     :full-name "cljs.core/IAssociative",
                                     :docstring "Protocol for adding associativity to collections."},
           "cljs.pprint/pprint-tab" {:ns "cljs.pprint",
                                     :name "pprint-tab",
                                     :signature ["[kind colnum colinc]"],
                                     :name-encode "pprint-tab",
                                     :history [["+" "0.0-3255"]],
                                     :type "function",
                                     :full-name-encode "cljs.pprint/pprint-tab",
                                     :source {:code "(defn pprint-tab\n  {:added \"1.2\"}\n  [kind colnum colinc]\n  (check-enumerated-arg kind #{:line :section :line-relative :section-relative})\n  (throw (js/Error. \"pprint-tab is not yet implemented\")))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/cljs/cljs/pprint.cljs",
                                              :lines [869 884]},
                                     :full-name "cljs.pprint/pprint-tab",
                                     :docstring "Tab at this point in the pretty printing stream. kind specifies whether the tab\nis :line, :section, :line-relative, or :section-relative.\n\nColnum and colinc specify the target column and the increment to move the target\nforward if the output is already past the original target.\n\nThis function is intended for use when writing custom dispatch functions.\n\nOutput is sent to *out* which must be a pretty printing writer.\n\nTHIS FUNCTION IS NOT YET IMPLEMENTED."},
           "compiler-options/rename-prefix-namespace" {:ns "compiler-options",
                                                       :name "rename-prefix-namespace",
                                                       :name-encode "rename-prefix-namespace",
                                                       :type "option",
                                                       :full-name-encode "compiler-options/rename-prefix-namespace",
                                                       :full-name "compiler-options/rename-prefix-namespace",
                                                       :history [["+"
                                                                  "1.9.946"]]},
           "cljs.core/ObjMap.EMPTY" {:ns "cljs.core",
                                     :name "ObjMap.EMPTY",
                                     :name-encode "ObjMapDOTEMPTY",
                                     :history [["+" "0.0-927"]],
                                     :parent-type "ObjMap",
                                     :type "var",
                                     :full-name-encode "cljs.core/ObjMapDOTEMPTY",
                                     :source {:code "(set! (.-EMPTY ObjMap) (ObjMap. nil (array) (js-obj) 0 empty-unordered-hash))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/cljs/cljs/core.cljs",
                                              :lines [6668]},
                                     :full-name "cljs.core/ObjMap.EMPTY"},
           "closure-warnings/deprecated" {:ns "closure-warnings",
                                          :name "deprecated",
                                          :name-encode "deprecated",
                                          :type "warning",
                                          :full-name-encode "closure-warnings/deprecated",
                                          :full-name "closure-warnings/deprecated",
                                          :history [["+" "0.0-2120"]]},
           "cljs.core/group-by" {:ns "cljs.core",
                                 :name "group-by",
                                 :signature ["[f coll]"],
                                 :name-encode "group-by",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/group-by",
                                 :source {:code "(defn group-by\n  [f coll]\n  (persistent!\n    (reduce\n      (fn [ret x]\n        (let [k (f x)]\n          (assoc! ret k (conj (get ret k []) x))))\n      (transient {}) coll)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [11288 11298]},
                                 :full-name "cljs.core/group-by",
                                 :docstring "Returns a map of the elements of coll keyed by the result of\nf on each element. The value at each key will be a vector of the\ncorresponding elements, in the order they appeared in coll."},
           "cljs.spec/MAX_INT" {:ns "cljs.spec",
                                :name "MAX_INT",
                                :name-encode "MAX_INT",
                                :history [["+" "1.9.85"]
                                          ["-" "1.9.542"]],
                                :type "var",
                                :full-name-encode "cljs.spec/MAX_INT",
                                :source {:code "(def ^:const MAX_INT 9007199254740991)",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.9.521",
                                         :filename "src/main/cljs/cljs/spec.cljs",
                                         :lines [19]},
                                :full-name "cljs.spec/MAX_INT",
                                :removed {:in "1.9.542",
                                          :last-seen "1.9.521"}},
           "compiler-options/language-out" {:ns "compiler-options",
                                            :name "language-out",
                                            :name-encode "language-out",
                                            :type "option",
                                            :full-name-encode "compiler-options/language-out",
                                            :full-name "compiler-options/language-out",
                                            :history [["+" "0.0-2197"]]},
           "cljs.build.api/watch" {:ns "cljs.build.api",
                                   :name "watch",
                                   :signature ["[source opts]"
                                               "[source opts compiler-env]"
                                               "[source opts compiler-env stop]"],
                                   :name-encode "watch",
                                   :history [["+" "0.0-3208"]],
                                   :type "function",
                                   :full-name-encode "cljs.build.api/watch",
                                   :source {:code "(defn watch\n  ([source opts]\n   (watch source opts\n     (or (ana-api/current-state)\n         (ana-api/empty-state\n           (closure/add-externs-sources opts)))))\n  ([source opts compiler-env]\n   (watch source opts compiler-env nil))\n  ([source opts compiler-env stop]\n   (binding [ana/*cljs-warning-handlers* (:warning-handlers opts ana/*cljs-warning-handlers*)]\n     (closure/watch source opts compiler-env stop))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/clojure/cljs/build/api.clj",
                                            :lines [233 244]},
                                   :full-name "cljs.build.api/watch",
                                   :docstring "Given a source which can be compiled, watch it for changes to produce."},
           "cljs.repl/special-doc-map" {:ns "cljs.repl",
                                        :name "special-doc-map",
                                        :name-encode "special-doc-map",
                                        :type "var",
                                        :full-name-encode "cljs.repl/special-doc-map",
                                        :source {:code "(def special-doc-map\n  '{. {:forms [(.instanceMethod instance args*)\n               (.-instanceField instance)]\n       :doc \"The instance member form works for methods and fields.\n  They all expand into calls to the dot operator at macroexpansion time.\"}\n    ns {:forms [(name docstring? attr-map? references*)]\n        :doc \"You must currently use the ns form only with the following caveats\n\n    * You must use the :only form of :use\n    * :require supports :as, :refer, and :rename\n      - all options can be skipped\n      - in this case a symbol can be used as a libspec directly\n        - that is, (:require lib.foo) and (:require [lib.foo]) are both\n          supported and mean the same thing\n      - :rename specifies a map from referred var names to different\n        symbols (and can be used to prevent clashes)\n      - prefix lists are not supported\n    * The only options for :refer-clojure are :exclude and :rename\n    * :import is available for importing Google Closure classes\n      - ClojureScript types and records should be brought in with :use\n        or :require :refer, not :import ed\n    * Macros must be defined in a different compilation stage than the one\n      from where they are consumed. One way to achieve this is to define\n      them in one namespace and use them from another. They are referenced\n      via the :require-macros / :use-macros options to ns\n      - :require-macros and :use-macros support the same forms that\n        :require and :use do\n\n  Implicit macro loading: If a namespace is required or used, and that\n  namespace itself requires or uses macros from its own namespace, then\n  the macros will be implicitly required or used using the same\n  specifications. Furthermore, in this case, macro vars may be included\n  in a :refer or :only spec. This oftentimes leads to simplified library\n  usage, such that the consuming namespace need not be concerned about\n  explicitly distinguishing between whether certain vars are functions\n  or macros. For example:\n\n  (ns testme.core (:require [cljs.test :as test :refer [test-var deftest]]))\n\n  will result in test/is resolving properly, along with the test-var\n  function and the deftest macro being available unqualified.\n\n  Inline macro specification: As a convenience, :require can be given\n  either :include-macros true or :refer-macros [syms...]. Both desugar\n  into forms which explicitly load the matching Clojure file containing\n  macros. (This works independently of whether the namespace being\n  required internally requires or uses its own macros.) For example:\n\n  (ns testme.core\n  (:require [foo.core :as foo :refer [foo-fn] :include-macros true]\n            [woz.core :as woz :refer [woz-fn] :refer-macros [app jx]]))\n\n  is sugar for\n\n  (ns testme.core\n  (:require [foo.core :as foo :refer [foo-fn]]\n            [woz.core :as woz :refer [woz-fn]])\n  (:require-macros [foo.core :as foo]\n                   [woz.core :as woz :refer [app jx]]))\n\n  Auto-aliasing clojure namespaces: If a non-existing clojure.* namespace\n  is required or used and a matching cljs.* namespace exists, the cljs.*\n  namespace will be loaded and an alias will be automatically established\n  from the clojure.* namespace to the cljs.* namespace. For example:\n\n  (ns testme.core (:require [clojure.test]))\n\n  will be automatically converted to\n\n  (ns testme.core (:require [cljs.test :as clojure.test]))\"}\n    def {:forms [(def symbol doc-string? init?)]\n         :doc \"Creates and interns a global var with the name\n  of symbol in the current namespace (*ns*) or locates such a var if\n  it already exists.  If init is supplied, it is evaluated, and the\n  root binding of the var is set to the resulting value.  If init is\n  not supplied, the root binding of the var is unaffected.\"}\n    do {:forms [(do exprs*)]\n        :doc \"Evaluates the expressions in order and returns the value of\n  the last. If no expressions are supplied, returns nil.\"}\n    if {:forms [(if test then else?)]\n        :doc \"Evaluates test. If not the singular values nil or false,\n  evaluates and yields then, otherwise, evaluates and yields else. If\n  else is not supplied it defaults to nil.\"}\n    new {:forms [(Constructor. args*) (new Constructor args*)]\n         :url \"java_interop#new\"\n         :doc \"The args, if any, are evaluated from left to right, and\n  passed to the JavaScript constructor. The constructed object is\n  returned.\"}\n    quote {:forms [(quote form)]\n           :doc \"Yields the unevaluated form.\"}\n    recur {:forms [(recur exprs*)]\n           :doc \"Evaluates the exprs in order, then, in parallel, rebinds\n  the bindings of the recursion point to the values of the exprs.\n  Execution then jumps back to the recursion point, a loop or fn method.\"}\n    set! {:forms[(set! var-symbol expr)\n                 (set! (.- instance-expr instanceFieldName-symbol) expr)]\n          :url \"vars#set\"\n          :doc \"Used to set vars and JavaScript object fields\"}\n    throw {:forms [(throw expr)]\n           :doc \"The expr is evaluated and thrown.\"}\n    try {:forms [(try expr* catch-clause* finally-clause?)]\n         :doc \"catch-clause => (catch classname name expr*)\n  finally-clause => (finally expr*)\n  Catches and handles JavaScript exceptions.\"}\n    var {:forms [(var symbol)]\n         :doc \"The symbol must resolve to a var, and the Var object\nitself (not its value) is returned. The reader macro #'x expands to (var x).\"}})",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/clojure/cljs/repl.cljc",
                                                 :lines [1303 1409]},
                                        :full-name "cljs.repl/special-doc-map",
                                        :history [["+" "0.0-2985"]]},
           "cljs.reader/*default-data-reader-fn*" {:ns "cljs.reader",
                                                   :name "*default-data-reader-fn*",
                                                   :name-encode "STARdefault-data-reader-fnSTAR",
                                                   :type "dynamic var",
                                                   :full-name-encode "cljs.reader/STARdefault-data-reader-fnSTAR",
                                                   :source {:code "(def ^:dynamic *default-data-reader-fn*\n  (atom nil))",
                                                            :title "Source code",
                                                            :repo "clojurescript",
                                                            :tag "r1.12.38",
                                                            :filename "src/main/cljs/cljs/reader.cljs",
                                                            :lines [131
                                                                    132]},
                                                   :full-name "cljs.reader/*default-data-reader-fn*",
                                                   :history [["+"
                                                              "0.0-1576"]]},
           "cljs.core/array-index-of" {:ns "cljs.core",
                                       :name "array-index-of",
                                       :signature ["[arr k]"],
                                       :name-encode "array-index-of",
                                       :history [["+" "0.0-3178"]],
                                       :type "function",
                                       :full-name-encode "cljs.core/array-index-of",
                                       :source {:code "(defn array-index-of [arr k]\n  (cond\n    (keyword? k) (array-index-of-keyword? arr k)\n\n    (or (string? k) (number? k))\n    (array-index-of-identical? arr k)\n\n    (symbol? k) (array-index-of-symbol? arr k)\n\n    (nil? k)\n    (array-index-of-nil? arr)\n\n    :else (array-index-of-equiv? arr k)))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/core.cljs",
                                                :lines [6757 6769]},
                                       :full-name "cljs.core/array-index-of"},
           "cljs.core/*e" {:ns "cljs.core",
                           :name "*e",
                           :name-encode "STARe",
                           :history [["+" "0.0-2814"]],
                           :type "dynamic var",
                           :full-name-encode "cljs.core/STARe",
                           :source {:code "(def\n  ^{:dynamic true}\n  *e)",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r1.12.38",
                                    :filename "src/main/cljs/cljs/core.cljs",
                                    :lines [222 225]},
                           :full-name "cljs.core/*e",
                           :docstring "bound in a repl thread to the most recent exception caught by the repl"},
           "cljs.build.api/compiler-opts?" {:ns "cljs.build.api",
                                            :name "compiler-opts?",
                                            :signature ["[m]"],
                                            :name-encode "compiler-optsQMARK",
                                            :history [["+" "1.9.854"]],
                                            :type "function",
                                            :full-name-encode "cljs.build.api/compiler-optsQMARK",
                                            :source {:code "(defn compiler-opts? [m]\n  (and (map? m)\n       (or (contains? m :output-to)\n           (contains? m :modules)\n           (contains? m :npm-deps)\n           (contains? m :main)\n           (contains? m :optimizations)\n           (contains? m :foreign-libs))))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/clojure/cljs/build/api.clj",
                                                     :lines [249 256]},
                                            :full-name "cljs.build.api/compiler-opts?"},
           "cljs.core/sorted-map-by" {:ns "cljs.core",
                                      :name "sorted-map-by",
                                      :signature ["[comparator & keyvals]"],
                                      :name-encode "sorted-map-by",
                                      :history [["+" "0.0-1211"]],
                                      :type "function",
                                      :full-name-encode "cljs.core/sorted-map-by",
                                      :source {:code "(defn sorted-map-by\n  ([comparator & keyvals]\n     (loop [in (seq keyvals)\n            out (PersistentTreeMap. (fn->comparator comparator) nil 0 nil 0)]\n       (if in\n         (recur (nnext in) (assoc out (first in) (second in)))\n         out))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [9167 9175]},
                                      :full-name "cljs.core/sorted-map-by",
                                      :docstring "keyval => key val\nReturns a new sorted map with supplied mappings, using the supplied comparator."},
           "cljs.core/symbol" {:ns "cljs.core",
                               :name "symbol",
                               :signature ["[name]" "[ns name]"],
                               :name-encode "symbol",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/symbol",
                               :source {:code "(defn symbol\n  ([name]\n   (cond (symbol? name) name\n         (string? name) (let [idx (.indexOf name \"/\")]\n                          (if (< idx 1)\n                            (symbol nil name)\n                            (symbol (.substring name 0 idx)\n                                    (.substring name (inc idx) (. name -length)))))\n         (var? name) (.-sym name)\n         (keyword? name) (recur (.-fqn name))\n         :else (throw (new js/Error \"no conversion to symbol\"))))\n  ([ns name]\n   (let [sym-str (if-not (nil? ns)\n                   (str ns \"/\" name)\n                   name)]\n     (Symbol. ns name sym-str nil nil))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [1138 1155]},
                               :full-name "cljs.core/symbol",
                               :docstring "Returns a Symbol with the given namespace and name. Arity-1 works\non strings, keywords, and vars."},
           "cljs.repl.server/lock" {:ns "cljs.repl.server",
                                    :name "lock",
                                    :name-encode "lock",
                                    :type "var",
                                    :full-name-encode "cljs.repl.server/lock",
                                    :source {:code "(def lock (Object.))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/clojure/cljs/repl/server.clj",
                                             :lines [22]},
                                    :full-name "cljs.repl.server/lock",
                                    :history [["+" "1.10.145"]]},
           "cljs.core/volatile?" {:ns "cljs.core",
                                  :name "volatile?",
                                  :signature ["[x]"],
                                  :name-encode "volatileQMARK",
                                  :history [["+" "0.0-2496"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/volatileQMARK",
                                  :source {:code "(defn volatile?\n  [x] (instance? Volatile x))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [4685 4687]},
                                  :full-name "cljs.core/volatile?",
                                  :docstring "Returns true if x is a volatile."},
           "cljs.core/MultiIterator" {:ns "cljs.core",
                                      :name "MultiIterator",
                                      :signature ["[iters]"],
                                      :name-encode "MultiIterator",
                                      :history [["+" "1.9.562"]],
                                      :type "type",
                                      :full-name-encode "cljs.core/MultiIterator",
                                      :source {:code "(deftype MultiIterator [iters]\n  Object\n  (hasNext [_]\n    (loop [iters (seq iters)]\n      (if-not (nil? iters)\n        (let [iter (first iters)]\n          (if-not ^boolean (.hasNext iter)\n            false\n            (recur (next iters))))\n        true)))\n  (next [_]\n    (let [nexts (array)]\n      (dotimes [i (alength iters)]\n        (aset nexts i (.next (aget iters i))))\n      (prim-seq nexts 0))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [4214 4228]},
                                      :full-name "cljs.core/MultiIterator"},
           "cljs.core/Delay" {:protocols #{"IDeref"
                                           "IPending"
                                           "IPrintWithWriter"},
                              :ns "cljs.core",
                              :name "Delay",
                              :signature ["[f value]"],
                              :name-encode "Delay",
                              :history [["+" "0.0-927"]],
                              :type "type",
                              :full-name-encode "cljs.core/Delay",
                              :source {:code "(deftype Delay [^:mutable f ^:mutable value]\n  IDeref\n  (-deref [_]\n    (when f\n      (set! value (f))\n      (set! f nil))\n    value)\n\n  IPending\n  (-realized? [x]\n    (not f))\n\n  IPrintWithWriter\n  (-pr-writer [x writer opts]\n    (-write writer \"#object[cljs.core.Delay \")\n    (pr-writer {:status (if (nil? f) :ready :pending), :val value} writer opts)\n    (-write writer \"]\")))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [10963 10979]},
                              :full-name "cljs.core/Delay"},
           "cljs.core/methods" {:ns "cljs.core",
                                :name "methods",
                                :signature ["[multifn]"],
                                :name-encode "methods",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/methods",
                                :source {:code "(defn methods\n  [multifn] (-methods multifn))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [11687 11689]},
                                :full-name "cljs.core/methods",
                                :docstring "Given a multimethod, returns a map of dispatch values -> dispatch fns"},
           "cljs.test/test-vars" {:ns "cljs.test",
                                  :name "test-vars",
                                  :signature ["[vars]"],
                                  :name-encode "test-vars",
                                  :history [["+" "0.0-2496"]],
                                  :type "function",
                                  :full-name-encode "cljs.test/test-vars",
                                  :source {:code "(defn test-vars\n  [vars]\n  (run-block (concat (test-vars-block vars)\n                     [(fn []\n                        (report {:type :end-test-vars :vars vars}))])))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/test.cljs",
                                           :lines [589 596]},
                                  :full-name "cljs.test/test-vars",
                                  :docstring "Groups vars by their namespace and runs test-var on them with\nappropriate fixtures assuming they are present in the current\ntesting environment."},
           "cljs.core/lazy-cat" {:ns "cljs.core",
                                 :name "lazy-cat",
                                 :signature ["[& colls]"],
                                 :name-encode "lazy-cat",
                                 :history [["+" "0.0-1803"]],
                                 :type "macro",
                                 :full-name-encode "cljs.core/lazy-cat",
                                 :source {:code "(core/defmacro lazy-cat\n  [& colls]\n  `(concat ~@(map #(core/list `lazy-seq %) colls)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/clojure/cljs/core.cljc",
                                          :lines [2904 2911]},
                                 :full-name "cljs.core/lazy-cat",
                                 :docstring "Expands to code which yields a lazy sequence of the concatenation\nof the supplied colls.  Each coll expr is not evaluated until it is\nneeded.\n\n(lazy-cat xs ys zs) === (concat (lazy-seq xs) (lazy-seq ys) (lazy-seq zs))"},
           "cljs.core/vector" {:ns "cljs.core",
                               :name "vector",
                               :signature ["[& args]"],
                               :name-encode "vector",
                               :history [["+" "0.0-927"]],
                               :type "function/macro",
                               :full-name-encode "cljs.core/vector",
                               :source {:code "(defn vector\n  [& args]\n  (if (and (instance? IndexedSeq args) (zero? (.-i args)))\n    (.fromArray PersistentVector (.-arr args) (not (array? (.-arr args))))\n    (vec args)))",
                                        :title "Function code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [5865 5870]},
                               :extra-sources [{:code "(core/defmacro vector\n  ([] '(.-EMPTY cljs.core/PersistentVector))\n  ([& xs]\n   (core/let [cnt (count xs)]\n     (if (core/< cnt 32)\n       `(cljs.core/PersistentVector. nil ~cnt 5\n          (.-EMPTY-NODE cljs.core/PersistentVector) (array ~@xs) nil)\n       (vary-meta\n         `(.fromArray cljs.core/PersistentVector (array ~@xs) true)\n         assoc :tag 'cljs.core/PersistentVector)))))",
                                                :title "Macro code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/clojure/cljs/core.cljc",
                                                :lines [2628 2637]}],
                               :full-name "cljs.core/vector",
                               :docstring "Creates a new vector containing the args."},
           "cljs.core/rand-int" {:ns "cljs.core",
                                 :name "rand-int",
                                 :signature ["[n]"],
                                 :name-encode "rand-int",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/rand-int",
                                 :source {:code "(defn rand-int\n  [n] (Math/floor (* (Math/random) n)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [11277 11279]},
                                 :full-name "cljs.core/rand-int",
                                 :docstring "Returns a random integer between 0 (inclusive) and n (exclusive)."},
           "cljs.core/m3-seed" {:ns "cljs.core",
                                :name "m3-seed",
                                :name-encode "m3-seed",
                                :type "var",
                                :full-name-encode "cljs.core/m3-seed",
                                :source {:code "(def m3-seed 0)",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [937]},
                                :full-name "cljs.core/m3-seed",
                                :history [["+" "0.0-2261"]]},
           "cljs.core/throw" {:ns "cljs.core",
                              :name "throw",
                              :signature ["[expr]"],
                              :name-encode "throw",
                              :history [["+" "0.0-927"]],
                              :type "special form",
                              :full-name-encode "cljs.core/throw",
                              :source {:code "(defmethod parse 'throw\n  [op env [_ throw-form :as form] name _]\n  (cond\n    (= 1 (count form))\n    (throw\n      (error env \"Too few arguments to throw, throw expects a single Error instance\"))\n    (< 2 (count form))\n    (throw\n      (error env \"Too many arguments to throw, throw expects a single Error instance\")))\n  (let [throw-expr (disallowing-recur (analyze (assoc env :context :expr) throw-form))]\n    {:env env :op :throw :form form\n     :exception throw-expr\n     :children [:exception]}))",
                                       :title "Parser code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/clojure/cljs/analyzer.cljc",
                                       :lines [1820 1832]},
                              :extra-sources ({:code "(defmethod emit* :throw\n  [{throw :exception :keys [env]}]\n  (if (= :expr (:context env))\n    (emits \"(function(){throw \" throw \"})()\")\n    (emitln \"throw \" throw \";\")))",
                                               :title "Emitting code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/clojure/cljs/compiler.cljc",
                                               :lines [687 691]}),
                              :full-name "cljs.core/throw",
                              :docstring "The expr is evaluated and thrown."},
           "cljs.core/PersistentQueue.EMPTY" {:ns "cljs.core",
                                              :name "PersistentQueue.EMPTY",
                                              :name-encode "PersistentQueueDOTEMPTY",
                                              :history [["+"
                                                         "0.0-927"]],
                                              :parent-type "PersistentQueue",
                                              :type "var",
                                              :full-name-encode "cljs.core/PersistentQueueDOTEMPTY",
                                              :source {:code "(set! (.-EMPTY PersistentQueue) (PersistentQueue. nil 0 nil [] empty-ordered-hash))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.12.38",
                                                       :filename "src/main/cljs/cljs/core.cljs",
                                                       :lines [6476]},
                                              :full-name "cljs.core/PersistentQueue.EMPTY"},
           "cljs.compiler.api/requires-compilation?" {:ns "cljs.compiler.api",
                                                      :name "requires-compilation?",
                                                      :signature ["[src dest]"
                                                                  "[src dest opts]"
                                                                  "[state src dest opts]"],
                                                      :name-encode "requires-compilationQMARK",
                                                      :history [["+"
                                                                 "0.0-3255"]],
                                                      :type "function",
                                                      :full-name-encode "cljs.compiler.api/requires-compilationQMARK",
                                                      :source {:code "(defn requires-compilation?\n  ([src dest] (requires-compilation? src dest nil))\n  ([src dest opts]\n   (requires-compilation? (or (ana-api/current-state)(ana-api/empty-state opts)) src dest opts))\n  ([state src dest opts]\n   (ana-api/with-state state\n     (binding [ana/*cljs-warning-handlers* (:warning-handlers opts ana/*cljs-warning-handlers*)]\n       (comp/requires-compilation? src dest opts)))))",
                                                               :title "Source code",
                                                               :repo "clojurescript",
                                                               :tag "r1.12.38",
                                                               :filename "src/main/clojure/cljs/compiler/api.clj",
                                                               :lines [49
                                                                       57]},
                                                      :full-name "cljs.compiler.api/requires-compilation?",
                                                      :docstring "Return true if the src file requires compilation."},
           "cljs.spec/spec?" {:ns "cljs.spec",
                              :name "spec?",
                              :signature ["[x]"],
                              :name-encode "specQMARK",
                              :history [["+" "1.9.14"]
                                        ["-" "1.9.542"]],
                              :type "function",
                              :full-name-encode "cljs.spec/specQMARK",
                              :source {:code "(defn spec?\n  [x]\n  (when (implements? Spec x)\n    x))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.9.521",
                                       :filename "src/main/cljs/cljs/spec.cljs",
                                       :lines [74 78]},
                              :full-name "cljs.spec/spec?",
                              :docstring "returns x if x is a spec object, else logical false",
                              :removed {:in "1.9.542",
                                        :last-seen "1.9.521"}},
           "cljs.core/unchecked-float" {:return-type number,
                                        :ns "cljs.core",
                                        :name "unchecked-float",
                                        :signature ["[x]"],
                                        :name-encode "unchecked-float",
                                        :history [["+" "0.0-1798"]],
                                        :type "function/macro",
                                        :full-name-encode "cljs.core/unchecked-float",
                                        :source {:code "(defn ^number unchecked-float [x] x)",
                                                 :title "Function code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/cljs/cljs/core.cljs",
                                                 :lines [2802]},
                                        :extra-sources [{:code "(core/defmacro unchecked-float [x] x)",
                                                         :title "Macro code",
                                                         :repo "clojurescript",
                                                         :tag "r1.12.38",
                                                         :filename "src/main/clojure/cljs/core.cljc",
                                                         :lines [1074]}],
                                        :full-name "cljs.core/unchecked-float"},
           "repl-options/prompt" {:ns "repl-options",
                                  :name "prompt",
                                  :name-encode "prompt",
                                  :type "option",
                                  :full-name-encode "repl-options/prompt",
                                  :full-name "repl-options/prompt",
                                  :history [["+" "0.0-2911"]]},
           "clojure.core.reducers/append!" {:ns "clojure.core.reducers",
                                            :name "append!",
                                            :signature ["[acc x]"],
                                            :name-encode "appendBANG",
                                            :history [["+" "0.0-1236"]],
                                            :type "function",
                                            :full-name-encode "clojure.core.reducers/appendBANG",
                                            :source {:code "(defn append!\n  [acc x]\n  (doto acc (.push x)))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/cljs/clojure/core/reducers.cljs",
                                                     :lines [232 235]},
                                            :full-name "clojure.core.reducers/append!",
                                            :docstring ".adds x to acc and returns acc"},
           "syntax/js-literal" {:syntax-equiv {:edn-url nil,
                                               :clj-url nil},
                                :ns "syntax",
                                :name "js-literal",
                                :name-encode "js-literal",
                                :history [["+" "0.0-2120"]],
                                :type "tagged literal",
                                :full-name-encode "syntax/js-literal",
                                :extra-sources ({:code "(defn read-js\n  [form]\n  (when-not (or (vector? form) (map? form))\n    (throw\n      #?(:clj  (RuntimeException.\n                 \"JavaScript literal must use map or vector notation\")\n         :cljs (js/Error.\n                 \"JavaScript literal must use map or vector notation\"))))\n  (when-not (or (not (map? form))\n                (every? valid-js-literal-key? (keys form)))\n    (throw\n      #?(:clj  (RuntimeException.\n                 \"JavaScript literal keys must be strings or unqualified keywords\")\n         :cljs (js/Error.\n                 \"JavaScript literal keys must be strings or unqualified keywords\"))))\n  (JSValue. form))",
                                                 :title "Reader code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/clojure/cljs/tagged_literals.cljc",
                                                 :lines [70 85]}
                                                {:code "(def ^:dynamic *cljs-data-readers*\n  (merge ;; assumes we can read all data_readers\n    #?(:clj *data-readers*)\n    {'queue read-queue\n     'uuid  read-uuid\n     'inst  read-inst\n     'js    read-js}))",
                                                 :title "Reader table",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/clojure/cljs/tagged_literals.cljc",
                                                 :lines [87 93]}),
                                :full-name "syntax/js-literal"},
           "cljs.core/NodeSeq" {:protocols #{"ISeqable"
                                             "IMeta"
                                             "IWithMeta"
                                             "IEmptyableCollection"
                                             "IReduce"
                                             "ISequential"
                                             "ISeq"
                                             "ICollection"
                                             "IHash"
                                             "IPrintWithWriter"
                                             "INext"
                                             "IEquiv"},
                                :ns "cljs.core",
                                :name "NodeSeq",
                                :signature ["[meta nodes i s __hash]"],
                                :name-encode "NodeSeq",
                                :history [["+" "0.0-1211"]],
                                :type "type",
                                :full-name-encode "cljs.core/NodeSeq",
                                :source {:code "(deftype NodeSeq [meta nodes i s ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (NodeSeq. new-meta nodes i s __hash)))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (.-EMPTY List))\n\n  ISequential\n  ISeq\n  (-first [coll]\n    (if (nil? s)\n      (MapEntry. (aget nodes i) (aget nodes (inc i)) nil)\n      (first s)))\n\n  (-rest [coll]\n    (let [ret (if (nil? s)\n                (create-inode-seq nodes (+ i 2) nil)\n                (create-inode-seq nodes i (next s)))]\n      (if-not (nil? ret) ret ())))\n\n  INext\n  (-next [coll]\n    (if (nil? s)\n      (create-inode-seq nodes (+ i 2) nil)\n      (create-inode-seq nodes i (next s))))\n\n  ISeqable\n  (-seq [this] this)\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [7924 7984]},
                                :full-name "cljs.core/NodeSeq"},
           "cljs.core/letfn" {:ns "cljs.core",
                              :name "letfn",
                              :signature ["[fnspecs & body]"],
                              :name-encode "letfn",
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :full-name-encode "cljs.core/letfn",
                              :source {:code "(defmacro letfn \n  {:added \"1.0\", :forms '[(letfn [fnspecs*] exprs*)],\n   :special-form true, :url nil}\n  [fnspecs & body] \n  `(letfn* ~(vec (interleave (map first fnspecs) \n                             (map #(cons `fn %) fnspecs)))\n           ~@body))",
                                       :title "Source code",
                                       :repo "clojure",
                                       :tag "clojure-1.10.0",
                                       :filename "src/clj/clojure/core.clj",
                                       :lines [6543 6554]},
                              :full-name "cljs.core/letfn",
                              :docstring "fnspec ==> (fname [params*] exprs) or (fname ([params*] exprs)+)\n\nTakes a vector of function specs and a body, and generates a set of\nbindings of functions to their names. All of the names are available\nin all of the definitions of the functions, as well as the body."},
           "cljs.core/recur" {:ns "cljs.core",
                              :name "recur",
                              :signature ["[exprs*]"],
                              :name-encode "recur",
                              :history [["+" "0.0-927"]],
                              :type "special form",
                              :full-name-encode "cljs.core/recur",
                              :source {:code "(defmethod parse 'recur\n  [op env [_ & exprs :as form] _ _]\n  (let [context (:context env)\n        frame (first *recur-frames*)\n        ;; Add dummy implicit target object if recuring to proto impl method head\n        add-implicit-target-object? (and (:protocol-impl frame)\n                                         (= (count exprs) (dec (count (:params frame)))))\n        exprs (cond->> exprs add-implicit-target-object? (cons nil))\n        exprs (disallowing-recur (vec (map #(analyze (assoc env :context :expr) %) exprs)))]\n    (when-not frame\n      (throw (error env \"Can't recur here\")))\n    (when-not (= (count exprs) (count (:params frame)))\n      (throw (error env (str \"recur argument count mismatch, expected: \"\n                          (count (:params frame)) \" args, got: \" (count exprs)))))\n    (when (and (:protocol-impl frame)\n               (not add-implicit-target-object?))\n      (warning :protocol-impl-recur-with-target env {:form (:form (first exprs))}))\n    (reset! (:flag frame) true)\n    (swap! (:tags frame) (fn [tags]\n                           (mapv (fn [tag expr]\n                                   ;; Widen by adding the type of the recur expression, except when recurring with a\n                                   ;; loop local: Since its final widened type is unknown, conservatively assume 'any.\n                                   (if (= :loop (:local expr))\n                                     'any\n                                     (add-types tag (:tag expr))))\n                             tags exprs)))\n    (assoc {:env env :op :recur :form form}\n      :frame frame\n      :exprs exprs\n      :children [:exprs])))",
                                       :title "Parser code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/clojure/cljs/analyzer.cljc",
                                       :lines [2531 2560]},
                              :extra-sources ({:code "(defmethod emit* :recur\n  [{:keys [frame exprs env]}]\n  (let [temps (vec (take (count exprs) (repeatedly gensym)))\n        params (:params frame)]\n    (dotimes [i (count exprs)]\n      (emitln \"var \" (temps i) \" = \" (exprs i) \";\"))\n    (dotimes [i (count exprs)]\n      (emitln (munge (params i)) \" = \" (temps i) \";\"))\n    (emitln \"continue;\")))",
                                               :title "Emitting code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/clojure/cljs/compiler.cljc",
                                               :lines [1115 1123]}),
                              :full-name "cljs.core/recur",
                              :docstring "Evaluates the exprs in order, then, in parallel, rebinds\nthe bindings of the recursion point to the values of the exprs.\nExecution then jumps back to the recursion point, a loop or fn method."},
           "cljs.reader/read-discard" {:ns "cljs.reader",
                                       :name "read-discard",
                                       :signature ["[rdr _]"],
                                       :name-encode "read-discard",
                                       :history [["+" "0.0-927"]
                                                 ["-" "1.9.854"]],
                                       :type "function",
                                       :full-name-encode "cljs.reader/read-discard",
                                       :source {:code "(defn read-discard\n  [rdr _]\n  (read rdr true nil true)\n  rdr)",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.9.671",
                                                :filename "src/main/cljs/cljs/reader.cljs",
                                                :lines [417 420]},
                                       :full-name "cljs.reader/read-discard",
                                       :removed {:in "1.9.854",
                                                 :last-seen "1.9.671"}},
           "cljs.js/wrap-error" {:ns "cljs.js",
                                 :name "wrap-error",
                                 :signature ["[ex]"],
                                 :name-encode "wrap-error",
                                 :history [["+" "1.7.10"]
                                           ["-" "1.7.28"]],
                                 :type "function",
                                 :full-name-encode "cljs.js/wrap-error",
                                 :source {:code "(defn wrap-error [ex]\n  {:error ex})",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.7.10",
                                          :filename "src/main/cljs/cljs/js.cljs",
                                          :lines [100 101]},
                                 :full-name "cljs.js/wrap-error",
                                 :removed {:in "1.7.28",
                                           :last-seen "1.7.10"}},
           "closure-warnings/lint-checks" {:ns "closure-warnings",
                                           :name "lint-checks",
                                           :name-encode "lint-checks",
                                           :type "warning",
                                           :full-name-encode "closure-warnings/lint-checks",
                                           :full-name "closure-warnings/lint-checks",
                                           :history [["+" "1.9.473"]]},
           "cljs.repl.server/read-headers" {:ns "cljs.repl.server",
                                            :name "read-headers",
                                            :signature ["[rdr]"],
                                            :name-encode "read-headers",
                                            :history [["+" "0.0-1503"]],
                                            :type "function",
                                            :full-name-encode "cljs.repl.server/read-headers",
                                            :source {:code "(defn read-headers [rdr]\n  (loop [next-line (.readLine rdr) header-lines []]\n    (if (= \"\" next-line)\n      header-lines ;; we're done reading headers\n      (recur\n        (.readLine rdr)\n        (conj header-lines next-line)))))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/clojure/cljs/repl/server.clj",
                                                     :lines [86 92]},
                                            :full-name "cljs.repl.server/read-headers"},
           "cljs.math/tan" {:return-type number,
                            :ns "cljs.math",
                            :name "tan",
                            :signature ["[a]"],
                            :name-encode "tan",
                            :history [["+" "1.11.50"]],
                            :type "function",
                            :full-name-encode "cljs.math/tan",
                            :source {:code "(defn ^number tan\n  {:added \"1.11.10\"}\n  [a] (Math/tan a))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/cljs/cljs/math.cljs",
                                     :lines [95 101]},
                            :full-name "cljs.math/tan",
                            :docstring "Returns the tangent of an angle.\nIf a is ##NaN, ##-Inf, ##Inf => ##NaN\nIf a is zero => zero with the same sign as a\nSee: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/tan"},
           "cljs.core/gen-apply-to" {:ns "cljs.core",
                                     :name "gen-apply-to",
                                     :signature ["[]"],
                                     :name-encode "gen-apply-to",
                                     :history [["+" "0.0-1211"]],
                                     :type "macro",
                                     :full-name-encode "cljs.core/gen-apply-to",
                                     :source {:code "(core/defmacro gen-apply-to []\n  `(do\n     (set! ~'*unchecked-if* true)\n     (defn ~'apply-to [~'f ~'argc ~'args]\n       (let [~'args (seq ~'args)]\n         (if (zero? ~'argc)\n           (~'f)\n           ~(gen-apply-to-helper))))\n     (set! ~'*unchecked-if* false)))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/clojure/cljs/core.cljc",
                                              :lines [2855 2863]},
                                     :full-name "cljs.core/gen-apply-to"},
           "cljs.core/inc" {:ns "cljs.core",
                            :name "inc",
                            :signature ["[x]"],
                            :name-encode "inc",
                            :history [["+" "0.0-927"]],
                            :type "function/macro",
                            :full-name-encode "cljs.core/inc",
                            :source {:code "(defn inc\n  [x] (cljs.core/+ x 1))",
                                     :title "Function code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [1467 1469]},
                            :extra-sources [{:code "(core/defmacro ^::ana/numeric inc [x]\n  `(+ ~x 1))",
                                             :title "Macro code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/clojure/cljs/core.cljc",
                                             :lines [1168 1169]}],
                            :full-name "cljs.core/inc",
                            :docstring "Returns a number one greater than num."},
           "cljs.core/NodeIterator" {:ns "cljs.core",
                                     :name "NodeIterator",
                                     :signature ["[arr i next-entry next-iter]"],
                                     :name-encode "NodeIterator",
                                     :history [["+" "1.7.28"]],
                                     :type "type",
                                     :full-name-encode "cljs.core/NodeIterator",
                                     :source {:code "(deftype NodeIterator [arr ^:mutable i ^:mutable next-entry ^:mutable next-iter]\n  Object\n  (advance [this]\n    (let [len (alength arr)]\n      (loop []\n        (if (< i len)\n          (let [key (aget arr i)\n                node-or-val (aget arr (inc i))\n                ^boolean found\n                (cond (some? key)\n                      (set! next-entry (MapEntry. key node-or-val nil))\n                      (some? node-or-val)\n                      (let [new-iter (-iterator node-or-val)]\n                        (if ^boolean (.hasNext new-iter)\n                          (set! next-iter new-iter)\n                          false))\n                      :else false)]\n            (set! i (+ i 2))\n            (if found true (recur)))\n          false))))\n  (hasNext [this]\n    (or (some? next-entry) (some? next-iter) (.advance this)))\n  (next [this]\n    (cond\n      (some? next-entry)\n      (let [ret next-entry]\n        (set! next-entry nil)\n        ret)\n      (some? next-iter)\n      (let [ret (.next next-iter)]\n        (when-not ^boolean (.hasNext next-iter)\n          (set! next-iter nil))\n        ret)\n      ^boolean (.advance this)\n      (.next this)\n      :else (throw (js/Error. \"No such element\"))))\n  (remove [_] (js/Error. \"Unsupported operation\")))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/cljs/cljs/core.cljs",
                                              :lines [7421 7457]},
                                     :full-name "cljs.core/NodeIterator"},
           "cljs.core/name" {:ns "cljs.core",
                             :name "name",
                             :signature ["[x]"],
                             :name-encode "name",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/name",
                             :source {:code "(defn name\n  [x]\n  (if (implements? INamed x)\n    (-name x)\n    (if (string? x)\n      x\n      (throw (js/Error. (str \"Doesn't support name: \" x))))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [9739 9746]},
                             :full-name "cljs.core/name",
                             :docstring "Returns the name String of a string, symbol or keyword."},
           "cljs.repl/decorate-specs" {:ns "cljs.repl",
                                       :name "decorate-specs",
                                       :signature ["[specs]"],
                                       :name-encode "decorate-specs",
                                       :history [["+" "0.0-3148"]],
                                       :type "function",
                                       :full-name-encode "cljs.repl/decorate-specs",
                                       :source {:code "(defn decorate-specs [specs]\n  (if-let [k (some #{:reload :reload-all} specs)]\n    (->> specs (remove #{k}) (map #(vary-meta % assoc :reload k)))\n    specs))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/clojure/cljs/repl.cljc",
                                                :lines [701 704]},
                                       :full-name "cljs.repl/decorate-specs"},
           "cljs.test/test-ns-block" {:ns "cljs.test",
                                      :name "test-ns-block",
                                      :signature ["[env [quote ns :as form]]"],
                                      :name-encode "test-ns-block",
                                      :history [["+" "0.0-2814"]],
                                      :type "macro",
                                      :full-name-encode "cljs.test/test-ns-block",
                                      :source {:code "(defmacro test-ns-block\n  ([env [quote ns :as form]]\n   (assert (and (= quote 'quote) (symbol? ns)) \"Argument to test-ns must be a quoted symbol\")\n   (assert (ana-api/find-ns ns) (str \"Namespace \" ns \" does not exist\"))\n   `[(fn []\n       (set-env! ~env)\n       (do-report {:type :begin-test-ns, :ns ~form})\n       ;; If the namespace has a test-ns-hook function, call that:\n       ~(if-let [v (ana-api/ns-resolve ns 'test-ns-hook)]\n          `(~(symbol (name ns) \"test-ns-hook\"))\n          ;; Otherwise, just test every var in the namespace.\n          `(block (test-all-vars-block ~form))))\n     (fn []\n       (do-report {:type :end-test-ns, :ns ~form}))]))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/test.cljc",
                                               :lines [368 383]},
                                      :full-name "cljs.test/test-ns-block",
                                      :docstring "Like test-ns, but returns a block for further composition and\nlater execution.  Does not clear the current env."},
           "cljs.math/ulp" {:return-type number,
                            :ns "cljs.math",
                            :name "ulp",
                            :signature ["[d]"],
                            :name-encode "ulp",
                            :history [["+" "1.11.50"]],
                            :type "function",
                            :full-name-encode "cljs.math/ulp",
                            :source {:code "(defn ^number ulp\n  {:added \"1.11.10\"}\n  [d]\n  (cond\n    ^boolean (js/isNaN d) d\n    ^boolean (js/isFinite d)\n    (let [e (get-exponent d)]\n      (case e\n        1024 (Math/abs d)  ;; EXP-MAX + 1\n        -1023 js/Number.MIN_VALUE  ;; EXP-MIN - 1\n        (let [e (- e (+ 31 SIGNIFICAND-WIDTH32))]  ;; SIGNIFICAND_WIDTH64 -1\n          (if (>= e EXP-MIN)\n            (power-of-two e)\n            (let [shift (- e (- EXP-MIN 31 SIGNIFICAND-WIDTH32))]\n              (if (< shift 32)\n                (hi-lo->double 0 (bit-shift-left 1 shift))\n                (hi-lo->double (bit-shift-left 1 (- shift 32)) 0)))))))\n    :default ##Inf))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/cljs/cljs/math.cljs",
                                     :lines [636 659]},
                            :full-name "cljs.math/ulp",
                            :docstring "Returns the size of an ulp (unit in last place) for d.\nIf d is ##NaN => ##NaN\nIf d is ##Inf or ##-Inf => ##Inf\nIf d is zero => Number/MIN_VALUE\nIf d is +/- Number/MAX_VALUE => 2^971\nSee: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#ulp-double-"},
           "cljs.core/cycle" {:ns "cljs.core",
                              :name "cycle",
                              :signature ["[coll]"],
                              :name-encode "cycle",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/cycle",
                              :source {:code "(defn cycle\n  [coll] (if-let [vals (seq coll)]\n           (Cycle. nil vals nil vals nil)\n           (.-EMPTY List)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [5013 5017]},
                              :full-name "cljs.core/cycle",
                              :docstring "Returns a lazy (infinite!) sequence of repetitions of the items in coll."},
           "cljs.spec.test/check-var" {:ns "cljs.spec.test",
                                       :name "check-var",
                                       :signature ["[v & opts]"],
                                       :name-encode "check-var",
                                       :history [["+" "1.9.14"]
                                                 ["-" "1.9.183"]],
                                       :type "function",
                                       :full-name-encode "cljs.spec.test/check-var",
                                       :source {:code "(defn check-var\n  [v & opts]\n  (let [fnspec (spec/get-spec v)]\n    (if (:args fnspec)\n      (apply check-fn @v fnspec opts)\n      (throw (js/Error. (str  \"No :args spec for \" v))))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.9.93",
                                                :filename "src/main/cljs/cljs/spec/test.cljs",
                                                :lines [68 83]},
                                       :full-name "cljs.spec.test/check-var",
                                       :docstring "Checks a var's specs using test.check. Optional args are\npassed through to test.check/quick-check:\n\n  num-tests     number of tests to run, default 100\n  seed          random seed\n  max-size      how large an input to generate, max 200\n  reporter-fn   reporting fn\n\nReturns a map as quick-check, with :explain-data added if\n:result is false.",
                                       :removed {:in "1.9.183",
                                                 :last-seen "1.9.93"}},
           "compiler-options/closure-generate-exports" {:ns "compiler-options",
                                                        :name "closure-generate-exports",
                                                        :name-encode "closure-generate-exports",
                                                        :type "option",
                                                        :full-name-encode "compiler-options/closure-generate-exports",
                                                        :full-name "compiler-options/closure-generate-exports",
                                                        :history [["+"
                                                                   "1.9.473"]]},
           "closure-warnings/duplicate-vars" {:ns "closure-warnings",
                                              :name "duplicate-vars",
                                              :name-encode "duplicate-vars",
                                              :type "warning",
                                              :full-name-encode "closure-warnings/duplicate-vars",
                                              :full-name "closure-warnings/duplicate-vars",
                                              :history [["+"
                                                         "1.9.473"]]},
           "warnings/unprovided" {:ns "warnings",
                                  :name "unprovided",
                                  :name-encode "unprovided",
                                  :type "warning",
                                  :full-name-encode "warnings/unprovided",
                                  :full-name "warnings/unprovided",
                                  :history [["+" "0.0-2173"]]},
           "cljs.spec/regex?" {:ns "cljs.spec",
                               :name "regex?",
                               :signature ["[x]"],
                               :name-encode "regexQMARK",
                               :history [["+" "1.9.14"]
                                         ["-" "1.9.542"]],
                               :type "function",
                               :full-name-encode "cljs.spec/regexQMARK",
                               :source {:code "(defn regex?\n  [x]\n  (c/and (::op x) x))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.9.521",
                                        :filename "src/main/cljs/cljs/spec.cljs",
                                        :lines [80 83]},
                               :full-name "cljs.spec/regex?",
                               :docstring "returns x if x is a (clojure.spec) regex op, else logical false",
                               :removed {:in "1.9.542",
                                         :last-seen "1.9.521"}},
           "cljs.core/rsubseq" {:ns "cljs.core",
                                :name "rsubseq",
                                :signature ["[sc test key]"
                                            "[sc start-test start-key end-test end-key]"],
                                :name-encode "rsubseq",
                                :history [["+" "0.0-1211"]],
                                :type "function",
                                :full-name-encode "cljs.core/rsubseq",
                                :source {:code "(defn rsubseq\n  ([sc test key]\n     (let [include (mk-bound-fn sc test key)]\n       (if (#{< <=} test)\n         (when-let [[e :as s] (-sorted-seq-from sc key false)]\n           (if (include e) s (next s)))\n         (take-while include (-sorted-seq sc false)))))\n  ([sc start-test start-key end-test end-key]\n     (when-let [[e :as s] (-sorted-seq-from sc end-key false)]\n       (take-while (mk-bound-fn sc start-test start-key)\n                   (if ((mk-bound-fn sc end-test end-key) e) s (next s))))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [9901 9914]},
                                :full-name "cljs.core/rsubseq",
                                :docstring "sc must be a sorted collection, test(s) one of <, <=, > or\n>=. Returns a reverse seq of those entries with keys ek for\nwhich (test (.. sc comparator (compare ek key)) 0) is true"},
           "cljs.core/locking" {:ns "cljs.core",
                                :name "locking",
                                :signature ["[x & forms]"],
                                :name-encode "locking",
                                :history [["+" "1.9.14"]],
                                :type "macro",
                                :full-name-encode "cljs.core/locking",
                                :source {:code "(core/defmacro locking\n  [x & forms]\n  `(do ~@forms))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/clojure/cljs/core.cljc",
                                         :lines [2985 2987]},
                                :full-name "cljs.core/locking"},
           "cljs.math/next-up" {:return-type number,
                                :ns "cljs.math",
                                :name "next-up",
                                :signature ["[d]"],
                                :name-encode "next-up",
                                :history [["+" "1.11.50"]],
                                :type "function",
                                :full-name-encode "cljs.math/next-up",
                                :source {:code "(defn ^number next-up\n  {:added \"1.11.10\"}\n  [d]\n  ;; Use a single conditional and handle the likely cases first\n  (if (< d js/Number.POSITIVE_INFINITY)\n    (let [a (js/ArrayBuffer. 8)\n          f (js/Float64Array. a)\n          i (js/Uint32Array. a)\n          ;; Add +0.0 to get rid of a -0.0 (+0.0 + -0.0 => +0.0)\n          _ (aset f 0 (+ d 0.0))\n          ht (aget i HI)\n          lt (aget i LO)\n          [hr lr] (if (zero? (bit-and ht INT32-NON-SIGN-BIT))\n                    (add64 ht lt 0 1)\n                    (add64 ht lt 0xFFFFFFFF 0xFFFFFFFF))]\n      (aset i HI hr)\n      (aset i LO lr)\n      (aget f 0))\n    ;; d is NaN or +Infinity\n    d))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/math.cljs",
                                         :lines [790 814]},
                                :full-name "cljs.math/next-up",
                                :docstring "Returns the adjacent double of d in the direction of ##Inf.\nIf d is ##NaN => ##NaN\nIf d is ##Inf => ##Inf\nIf d is zero => Number/MIN_VALUE\nSee: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#nextUp-double-"},
           "cljs.core/divide" {:ns "cljs.core",
                               :name "divide",
                               :signature ["[x]"
                                           "[x y]"
                                           "[x y & more]"],
                               :name-encode "divide",
                               :history [["+" "0.0-1798"]],
                               :type "macro",
                               :full-name-encode "cljs.core/divide",
                               :source {:code "(core/defmacro ^::ana/numeric divide\n  ([x] `(/ 1 ~x))\n  ([x y] (core/list 'js* \"(~{} / ~{})\" x y))\n  ([x y & more] `(/ (/ ~x ~y) ~@more)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/clojure/cljs/core.cljc",
                                        :lines [1135 1138]},
                               :full-name "cljs.core/divide"},
           "cljs.core/hash-ordered-coll" {:return-type number,
                                          :ns "cljs.core",
                                          :name "hash-ordered-coll",
                                          :signature ["[coll]"],
                                          :name-encode "hash-ordered-coll",
                                          :history [["+" "0.0-2261"]],
                                          :type "function",
                                          :full-name-encode "cljs.core/hash-ordered-coll",
                                          :source {:code "(defn ^number hash-ordered-coll\n  [coll]\n  (loop [n 0 hash-code 1 coll (seq coll)]\n    (if-not (nil? coll)\n      (recur (inc n) (bit-or (+ (imul 31 hash-code) (hash (first coll))) 0)\n        (next coll))\n      (mix-collection-hash hash-code n))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/cljs/cljs/core.cljs",
                                                   :lines [1376 1385]},
                                          :full-name "cljs.core/hash-ordered-coll",
                                          :docstring "Returns the hash code, consistent with =, for an external ordered\ncollection implementing Iterable.\nSee http://clojure.org/data_structures#hash for full algorithms."},
           "cljs.core/nil-iter" {:ns "cljs.core",
                                 :name "nil-iter",
                                 :signature ["[]"],
                                 :name-encode "nil-iter",
                                 :history [["+" "0.0-2301"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/nil-iter",
                                 :source {:code "(defn nil-iter []\n  (reify\n    Object\n    (hasNext [_] false)\n    (next [_] (js/Error. \"No such element\"))\n    (remove [_] (js/Error. \"Unsupported operation\"))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [4104 4109]},
                                 :full-name "cljs.core/nil-iter"},
           "cljs.analyzer.api/all-ns" {:ns "cljs.analyzer.api",
                                       :name "all-ns",
                                       :signature ["[]" "[state]"],
                                       :name-encode "all-ns",
                                       :history [["+" "0.0-2496"]],
                                       :type "function",
                                       :full-name-encode "cljs.analyzer.api/all-ns",
                                       :source {:code "(defn all-ns\n  ([]\n   (all-ns env/*compiler*))\n  ([state]\n   (keys (get @state ::ana/namespaces))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/clojure/cljs/analyzer/api.cljc",
                                                :lines [213 219]},
                                       :full-name "cljs.analyzer.api/all-ns",
                                       :docstring "Return all namespaces. Analagous to clojure.core/all-ns but\nreturns symbols identifying namespaces not Namespace instances."},
           "cljs.core/fn*" {:ns "cljs.core",
                            :name "fn*",
                            :name-encode "fnSTAR",
                            :history [["+" "0.0-927"]],
                            :type "special form",
                            :full-name-encode "cljs.core/fnSTAR",
                            :source {:code "(defmethod parse 'fn*\n  [op env [_ & args :as form] name _]\n  (let [named-fn?    (symbol? (first args))\n        [name meths] (if named-fn?\n                         [(first args) (next args)]\n                         [name (seq args)])\n        ;; turn (fn [] ...) into (fn ([]...))\n        meths        (if (vector? (first meths))\n                       (list meths)\n                       meths)\n        locals       (:locals env)\n        name-var     (fn-name-var env locals name)\n        env          (if (some? name)\n                       (update-in env [:fn-scope] conj name-var)\n                       env)\n        locals       (if (and (some? locals)\n                              named-fn?)\n                       (assoc locals name name-var)\n                       locals)\n        form-meta    (meta form)\n        type         (::type form-meta)\n        proto-impl   (::protocol-impl form-meta)\n        proto-inline (::protocol-inline form-meta)\n        menv         (-> env\n                         (cond->\n                           (> (count meths) 1)\n                           (assoc :context :expr))\n                         ;; clear loop flag since method bodies won't be in a loop at first\n                         ;; only tracking this to keep track of locals we need to capture\n                         (dissoc :in-loop)\n                         (merge {:protocol-impl proto-impl\n                                 :protocol-inline proto-inline}))\n        methods      (map #(disallowing-ns* (analyze-fn-method menv locals % type (nil? name))) meths)\n        mfa          (transduce (map :fixed-arity) max 0 methods)\n        variadic     (boolean (some :variadic? methods))\n        locals       (if named-fn?\n                       (update-in locals [name] assoc\n                         ;; TODO: can we simplify? - David\n                         :fn-var true\n                         :variadic? variadic\n                         :max-fixed-arity mfa\n                         :method-params (map :params methods))\n                       locals)\n        methods      (if (some? name)\n                       ;; a second pass with knowledge of our function-ness/arity\n                       ;; lets us optimize self calls\n                       (disallowing-ns* (analyze-fn-methods-pass2 menv locals type meths))\n                       (vec methods))\n        form         (vary-meta form dissoc ::protocol-impl ::protocol-inline ::type)\n        js-doc       (when (true? variadic)\n                       \"@param {...*} var_args\")\n        children     (if (some? name-var)\n                       [:local :methods]\n                       [:methods])\n        inferred-ret-tag (let [inferred-tags (map (partial infer-tag env) (map :body methods))]\n                           (when (apply = inferred-tags)\n                             (first inferred-tags)))\n        ast   (merge {:op :fn\n                      :env env\n                      :form form\n                      :name name-var\n                      :methods methods\n                      :variadic? variadic\n                      :tag 'function\n                      :inferred-ret-tag inferred-ret-tag\n                      :recur-frames *recur-frames*\n                      :in-loop (:in-loop env)\n                      :loop-lets *loop-lets*\n                      :jsdoc [js-doc]\n                      :max-fixed-arity mfa\n                      :protocol-impl proto-impl\n                      :protocol-inline proto-inline\n                      :children children}\n                     (when (some? name-var)\n                       {:local name-var}))]\n    (let [variadic-methods (into []\n                             (comp (filter :variadic?) (take 1))\n                             methods)\n          variadic-params  (if (pos? (count variadic-methods))\n                             (count (:params (nth variadic-methods 0)))\n                             0)\n          param-counts     (into [] (map (comp count :params)) methods)]\n      (when (< 1 (count variadic-methods))\n        (warning :multiple-variadic-overloads env {:name name-var}))\n      (when (not (or (zero? variadic-params) (== variadic-params (+ 1 mfa))))\n        (warning :variadic-max-arity env {:name name-var}))\n      (when (not= (distinct param-counts) param-counts)\n        (warning :overload-arity env {:name name-var})))\n    (analyze-wrap-meta ast)))",
                                     :title "Parser code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/clojure/cljs/analyzer.cljc",
                                     :lines [2234 2322]},
                            :extra-sources ({:code "(defmethod emit* :fn\n  [{variadic :variadic? :keys [name env methods max-fixed-arity recur-frames in-loop loop-lets]}]\n  ;;fn statements get erased, serve no purpose and can pollute scope if named\n  (when-not (= :statement (:context env))\n    (let [recur-params (mapcat :params (filter #(and % @(:flag %)) recur-frames))\n          loop-locals\n          (->> (concat recur-params\n                 ;; need to capture locals only if in recur fn or loop\n                 (when (or in-loop (seq recur-params))\n                   (mapcat :params loop-lets)))\n               (map munge)\n               seq)]\n      (when loop-locals\n        (when (= :return (:context env))\n            (emits \"return \"))\n        (emitln \"((function (\" (comma-sep (map munge loop-locals)) \"){\")\n        (when-not (= :return (:context env))\n            (emits \"return \")))\n      (if (= 1 (count methods))\n        (if variadic\n          (emit-variadic-fn-method (assoc (first methods) :name name))\n          (emit-fn-method (assoc (first methods) :name name)))\n        (let [name (or name (gensym))\n              mname (munge name)\n              maxparams (apply max-key count (map :params methods))\n              mmap (into {}\n                     (map (fn [method]\n                            [(munge (symbol (str mname \"__\" (count (:params method)))))\n                             method])\n                          methods))\n              ms (sort-by #(-> % second :params count) (seq mmap))]\n          (when (= :return (:context env))\n            (emits \"return \"))\n          (emitln \"(function() {\")\n          (emitln \"var \" mname \" = null;\")\n          (doseq [[n meth] ms]\n            (emits \"var \" n \" = \")\n            (if (:variadic? meth)\n              (emit-variadic-fn-method meth)\n              (emit-fn-method meth))\n            (emitln \";\"))\n            (emitln mname \" = function(\" (comma-sep (if variadic\n                                                      (concat (butlast maxparams) ['var_args])\n                                                      maxparams)) \"){\")\n          (when variadic\n            (emits \"var \")\n            (emit (last maxparams))\n            (emitln \" = var_args;\"))\n          (emitln \"switch(arguments.length){\")\n          (doseq [[n meth] ms]\n            (if (:variadic? meth)\n              (do (emitln \"default:\")\n                  (let [restarg (munge (gensym))]\n                    (emitln \"var \" restarg \" = null;\")\n                    (emitln \"if (arguments.length > \" max-fixed-arity \") {\")\n                    (let [a (emit-arguments-to-array max-fixed-arity)]\n                      (emitln restarg \" = new cljs.core.IndexedSeq(\" a \",0,null);\"))\n                    (emitln \"}\")\n                    (emitln \"return \" n \".cljs$core$IFn$_invoke$arity$variadic(\"\n                            (comma-sep (butlast maxparams))\n                            (when (> (count maxparams) 1) \", \")\n                            restarg \");\")))\n              (let [pcnt (count (:params meth))]\n                (emitln \"case \" pcnt \":\")\n                (emitln \"return \" n \".call(this\" (if (zero? pcnt) nil\n                                                     (list \",\" (comma-sep (take pcnt maxparams)))) \");\"))))\n          (emitln \"}\")\n          (let [arg-count-js (if (= 'self__ (-> ms first val :params first :name))\n                               \"(arguments.length - 1)\"\n                               \"arguments.length\")]\n            (emitln \"throw(new Error('Invalid arity: ' + \" arg-count-js \"));\"))\n          (emitln \"};\")\n          (when variadic\n            (emitln mname \".cljs$lang$maxFixedArity = \" max-fixed-arity \";\")\n            (emitln mname \".cljs$lang$applyTo = \" (some #(let [[n m] %] (when (:variadic? m) n)) ms) \".cljs$lang$applyTo;\"))\n          (doseq [[n meth] ms]\n            (let [c (count (:params meth))]\n              (if (:variadic? meth)\n                (emitln mname \".cljs$core$IFn$_invoke$arity$variadic = \" n \".cljs$core$IFn$_invoke$arity$variadic;\")\n                (emitln mname \".cljs$core$IFn$_invoke$arity$\" c \" = \" n \";\"))))\n          (emitln \"return \" mname \";\")\n          (emitln \"})()\")))\n      (when loop-locals\n        (emitln \";})(\" (comma-sep loop-locals) \"))\")))))",
                                             :title "Emitting code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/clojure/cljs/compiler.cljc",
                                             :lines [975 1058]}),
                            :full-name "cljs.core/fn*"},
           "cljs.spec.impl.gen/frequency" {:ns "cljs.spec.impl.gen",
                                           :name "frequency",
                                           :signature ["[& args]"],
                                           :name-encode "frequency",
                                           :history [["+" "1.9.456"]
                                                     ["-" "1.9.542"]],
                                           :type "function",
                                           :full-name-encode "cljs.spec.impl.gen/frequency",
                                           :source {:code "(lazy-combinators hash-map list map not-empty set vector vector-distinct fmap elements\n  bind choose one-of such-that tuple sample return\n  large-integer* double* frequency)",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.9.521",
                                                    :filename "src/main/cljs/cljs/spec/impl/gen.cljs",
                                                    :lines [69 71]},
                                           :full-name "cljs.spec.impl.gen/frequency",
                                           :docstring "Lazy loaded version of clojure.test.check.generators/frequency",
                                           :removed {:in "1.9.542",
                                                     :last-seen "1.9.521"}},
           "cljs.core/IUUID" {:ns "cljs.core",
                              :name "IUUID",
                              :name-encode "IUUID",
                              :implementations #{"UUID"},
                              :history [["+" "1.9.75"]],
                              :type "protocol",
                              :full-name-encode "cljs.core/IUUID",
                              :source {:code "(defprotocol IUUID)",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [11709]},
                              :full-name "cljs.core/IUUID",
                              :docstring "A marker protocol for UUIDs"},
           "cljs.test/run-all-tests" {:ns "cljs.test",
                                      :name "run-all-tests",
                                      :signature ["[]"
                                                  "[re]"
                                                  "[re env]"],
                                      :name-encode "run-all-tests",
                                      :history [["+" "0.0-2496"]],
                                      :type "macro",
                                      :full-name-encode "cljs.test/run-all-tests",
                                      :source {:code "(defmacro run-all-tests\n  ([] `(run-all-tests nil (empty-env)))\n  ([re] `(run-all-tests ~re (empty-env)))\n  ([re env]\n   `(run-tests ~env\n      ~@(map\n          (fn [ns] `(quote ~ns))\n          (cond->> (ana-api/all-ns)\n            re (filter #(re-matches re (name %))))))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/test.cljc",
                                               :lines [322 334]},
                                      :full-name "cljs.test/run-all-tests",
                                      :docstring "Runs all tests in all namespaces; prints results.\nOptional argument is a regular expression; only namespaces with\nnames matching the regular expression (with re-matches) will be\ntested."},
           "cljs.core/map" {:ns "cljs.core",
                            :name "map",
                            :signature ["[f]"
                                        "[f coll]"
                                        "[f c1 c2]"
                                        "[f c1 c2 c3]"
                                        "[f c1 c2 c3 & colls]"],
                            :name-encode "map",
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core/map",
                            :source {:code "(defn map\n  ([f]\n    (fn [rf]\n      (fn\n        ([] (rf))\n        ([result] (rf result))\n        ([result input]\n           (rf result (f input)))\n        ([result input & inputs]\n           (rf result (apply f input inputs))))))\n  ([f coll]\n   (lazy-seq\n    (when-let [s (seq coll)]\n      (if (chunked-seq? s)\n        (let [c (chunk-first s)\n              size (count c)\n              b (chunk-buffer size)]\n          (dotimes [i size]\n              (chunk-append b (f (-nth c i))))\n          (chunk-cons (chunk b) (map f (chunk-rest s))))\n        (cons (f (first s)) (map f (rest s)))))))\n  ([f c1 c2]\n   (lazy-seq\n    (let [s1 (seq c1) s2 (seq c2)]\n      (when (and s1 s2)\n        (cons (f (first s1) (first s2))\n              (map f (rest s1) (rest s2)))))))\n  ([f c1 c2 c3]\n   (lazy-seq\n    (let [s1 (seq c1) s2 (seq c2) s3 (seq c3)]\n      (when (and  s1 s2 s3)\n        (cons (f (first s1) (first s2) (first s3))\n              (map f (rest s1) (rest s2) (rest s3)))))))\n  ([f c1 c2 c3 & colls]\n   (let [step (fn step [cs]\n                 (lazy-seq\n                  (let [ss (map seq cs)]\n                    (when (every? identity ss)\n                      (cons (map first ss) (step (map rest ss)))))))]\n     (map #(apply f %) (step (conj colls c3 c2 c1))))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [4808 4853]},
                            :full-name "cljs.core/map",
                            :docstring "Returns a lazy sequence consisting of the result of applying f to\nthe set of first items of each coll, followed by applying f to the\nset of second items in each coll, until any one of the colls is\nexhausted.  Any remaining items in other colls are ignored. Function\nf should accept number-of-colls arguments. Returns a transducer when\nno collection is provided."},
           "cljs.spec.impl.gen/char" {:ns "cljs.spec.impl.gen",
                                      :name "char",
                                      :signature ["[& args]"],
                                      :name-encode "char",
                                      :history [["+" "1.9.14"]
                                                ["-" "1.9.542"]],
                                      :type "function",
                                      :full-name-encode "cljs.spec.impl.gen/char",
                                      :source {:code "(lazy-prims any any-printable boolean char char-alpha char-alphanumeric char-ascii double\n  int keyword keyword-ns large-integer ratio simple-type simple-type-printable\n  string string-ascii string-alphanumeric symbol symbol-ns uuid)",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.9.521",
                                               :filename "src/main/cljs/cljs/spec/impl/gen.cljs",
                                               :lines [73 75]},
                                      :full-name "cljs.spec.impl.gen/char",
                                      :docstring "Fn returning clojure.test.check.generators/char",
                                      :removed {:in "1.9.542",
                                                :last-seen "1.9.521"}},
           "cljs.core/ChunkBuffer" {:protocols #{"ICounted"},
                                    :ns "cljs.core",
                                    :name "ChunkBuffer",
                                    :signature ["[buf end]"],
                                    :name-encode "ChunkBuffer",
                                    :history [["+" "0.0-1424"]],
                                    :type "type",
                                    :full-name-encode "cljs.core/ChunkBuffer",
                                    :source {:code "(deftype ChunkBuffer [^:mutable buf ^:mutable end]\n  Object\n  (add [_ o]\n    (aset buf end o)\n    (set! end (inc end)))\n\n  (chunk [_]\n    (let [ret (ArrayChunk. buf 0 end)]\n      (set! buf nil)\n      ret))\n\n  ICounted\n  (-count [_] end))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [3589 3601]},
                                    :full-name "cljs.core/ChunkBuffer"},
           "cljs.js/eval*" {:ns "cljs.js",
                            :name "eval*",
                            :signature ["[bound-vars form opts cb]"],
                            :name-encode "evalSTAR",
                            :history [["+" "1.7.10"] ["-" "1.7.28"]],
                            :type "function",
                            :full-name-encode "cljs.js/evalSTAR",
                            :source {:code "(defn eval* [bound-vars form opts cb]\n  (let [the-ns     (or (:ns opts) 'cljs.user)\n        bound-vars (cond-> (merge bound-vars {:*cljs-ns* the-ns})\n                     (:source-map opts) (assoc :*sm-data* (sm-data)))]\n    (binding [env/*compiler*         (:*compiler* bound-vars)\n              *eval-fn*              (:*eval-fn* bound-vars)\n              ana/*cljs-ns*          (:*cljs-ns* bound-vars)\n              *ns*                   (create-ns (:*cljs-ns* bound-vars))\n              r/*data-readers*       (:*data-readers* bound-vars)\n              comp/*source-map-data* (:*sm-data* bound-vars)]\n      (let [aenv (ana/empty-env)\n            aenv (cond-> (assoc aenv :ns (ana/get-namespace ana/*cljs-ns*))\n                   (:context opts) (assoc :context (:context opts))\n                   (:def-emits-var opts) (assoc :def-emits-var true))\n            res  (try\n                   {:value (ana/analyze aenv form nil opts)}\n                   (catch :default cause\n                     (wrap-error\n                       (ana/error aenv\n                         (str \"Could not eval \" form) cause))))]\n        (if (:error res)\n          (cb res)\n          (let [ast (:value res)]\n            (if (= :ns (:op ast))\n              (ns-side-effects true bound-vars aenv ast opts\n                (fn [res]\n                  (if (:error res)\n                    (cb res)\n                    (let [src (str \"goog.provide(\\\"\" (munge (:name ast)) \"\\\")\")]\n                      (cb (*eval-fn* {:source src}))))))\n              (let [src (with-out-str (comp/emit ast))]\n                (cb (*eval-fn* {:source src}))))))))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.7.10",
                                     :filename "src/main/cljs/cljs/js.cljs",
                                     :lines [464 495]},
                            :full-name "cljs.js/eval*",
                            :removed {:in "1.7.28",
                                      :last-seen "1.7.10"}},
           "cljs.js/ns->relpath" {:ns "cljs.js",
                                  :name "ns->relpath",
                                  :signature ["[ns-sym]"],
                                  :name-encode "ns-GTrelpath",
                                  :history [["+" "1.7.10"]],
                                  :type "function",
                                  :full-name-encode "cljs.js/ns-GTrelpath",
                                  :source {:code "(defn ns->relpath\n  [ns-sym]\n  (string/replace (ana/munge-path ns-sym) \\. \\/))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/js.cljs",
                                           :lines [33 36]},
                                  :full-name "cljs.js/ns->relpath",
                                  :docstring "Given a namespace as a symbol return the relative path sans extension"},
           "cljs.repl/repl-read" {:ns "cljs.repl",
                                  :name "repl-read",
                                  :signature ["[request-prompt request-exit]"
                                              "[request-prompt request-exit opts]"],
                                  :name-encode "repl-read",
                                  :history [["+" "0.0-2719"]],
                                  :type "function",
                                  :full-name-encode "cljs.repl/repl-read",
                                  :source {:code "(defn repl-read\n  ([request-prompt request-exit]\n   (repl-read request-prompt request-exit *repl-opts*))\n  ([request-prompt request-exit opts]\n   (let [current-in *in*\n         bind-in?   (true? (:source-map-inline opts))]\n     (binding [*in* (if bind-in?\n                      ((:reader opts))\n                      *in*)]\n       (or ({:line-start request-prompt :stream-end request-exit}\n             (skip-whitespace *in*))\n         (let [input (reader/read {:read-cond :allow :features #{:cljs}} *in*)]\n           ;; Transfer 1-char buffer to original *in*\n           (readers/unread current-in (readers/read-char *in*))\n           (skip-if-eol (if bind-in? current-in *in*))\n           input))))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/clojure/cljs/repl.cljc",
                                           :lines [85 110]},
                                  :full-name "cljs.repl/repl-read",
                                  :docstring "Default :read hook for repl. Reads from *in* which must either be an\ninstance of LineNumberingPushbackReader or duplicate its behavior of both\nsupporting .unread and collapsing all of CR, LF, and CRLF into a single\n\\newline. repl-read:\n  - skips whitespace, then\n    - returns request-prompt on start of line, or\n    - returns request-exit on end of stream, or\n    - reads an object from the input stream, then\n      - skips the next input character if it's end of line, then\n      - returns the object."},
           "syntax/list" {:syntax-equiv {:edn-url nil, :clj-url nil},
                          :ns "syntax",
                          :name "list",
                          :name-encode "list",
                          :history [["+" "0.0-1853"]],
                          :type "syntax",
                          :full-name-encode "syntax/list",
                          :extra-sources ({:code "(defn- read-list\n  [rdr _ opts pending-forms]\n  (let [[start-line start-column] (starting-line-col-info rdr)\n        the-list (read-delimited :list \\) rdr opts pending-forms)\n        [end-line end-column] (ending-line-col-info rdr)]\n    (with-meta (if (empty? the-list)\n                 '()\n                 (clojure.lang.PersistentList/create the-list))\n      (when start-line\n        (merge\n         (when-let [file (get-file-name rdr)]\n           {:file file})\n         {:line start-line\n          :column start-column\n          :end-line end-line\n          :end-column end-column})))))",
                                           :title "Reader code",
                                           :repo "tools.reader",
                                           :tag "v1.3.6",
                                           :filename "src/main/clojure/clojure/tools/reader.clj",
                                           :lines [205 221]}
                                          {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                           :title "Reader table",
                                           :repo "tools.reader",
                                           :tag "v1.3.6",
                                           :filename "src/main/clojure/clojure/tools/reader.clj",
                                           :lines [788 807]}),
                          :full-name "syntax/list"},
           "warnings/private-var-access" {:ns "warnings",
                                          :name "private-var-access",
                                          :name-encode "private-var-access",
                                          :type "warning",
                                          :full-name-encode "warnings/private-var-access",
                                          :full-name "warnings/private-var-access",
                                          :history [["+" "1.10.439"]]},
           "cljs.core/seq-to-map-for-destructuring" {:ns "cljs.core",
                                                     :name "seq-to-map-for-destructuring",
                                                     :signature ["[s]"],
                                                     :name-encode "seq-to-map-for-destructuring",
                                                     :history [["+"
                                                                "1.11.50"]],
                                                     :type "function",
                                                     :full-name-encode "cljs.core/seq-to-map-for-destructuring",
                                                     :source {:code "(defn seq-to-map-for-destructuring\n  [s]\n  (if (next s)\n    (.createAsIfByAssoc PersistentArrayMap (to-array s))\n    (if (seq s) (first s) (.-EMPTY PersistentArrayMap))))",
                                                              :title "Source code",
                                                              :repo "clojurescript",
                                                              :tag "r1.12.38",
                                                              :filename "src/main/cljs/cljs/core.cljs",
                                                              :lines [9137
                                                                      9143]},
                                                     :full-name "cljs.core/seq-to-map-for-destructuring",
                                                     :docstring "Builds a map from a seq as described in\nhttps://clojure.org/reference/special_forms#keyword-arguments"},
           "cljs.core/amap" {:ns "cljs.core",
                             :name "amap",
                             :signature ["[a idx ret expr]"],
                             :name-encode "amap",
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :full-name-encode "cljs.core/amap",
                             :source {:code "(core/defmacro amap\n  [a idx ret expr]\n  `(let [a# ~a\n         l# (alength a#)\n         ~ret (cljs.core/aclone a#)]\n     (loop  [~idx 0]\n       (if (< ~idx l#)\n         (do\n           (aset ~ret ~idx ~expr)\n           (recur (inc ~idx)))\n         ~ret))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/clojure/cljs/core.cljc",
                                      :lines [2710 2724]},
                             :full-name "cljs.core/amap",
                             :docstring "Maps an expression across an array a, using an index named idx, and\nreturn value named ret, initialized to a clone of a, then setting\neach element of ret to the evaluation of expr, returning the new\narray ret."},
           "cljs.repl/repl-caught" {:ns "cljs.repl",
                                    :name "repl-caught",
                                    :signature ["[e repl-env opts]"],
                                    :name-encode "repl-caught",
                                    :history [["+" "0.0-2911"]],
                                    :type "function",
                                    :full-name-encode "cljs.repl/repl-caught",
                                    :source {:code "(defn repl-caught [e repl-env opts]\n  (if (and (instance? IExceptionInfo e)\n           (#{:js-eval-error :js-eval-exception} (:type (ex-data e))))\n    (let [{:keys [type repl-env error form js]} (ex-data e)]\n      (case type\n        :js-eval-error\n        (display-error repl-env error form opts)\n\n        :js-eval-exception\n        (display-error repl-env error form\n          (if (:repl-verbose opts)\n            #(prn \"Error evaluating:\" form :as js)\n            (constantly nil))\n          opts)))\n    (binding [*out* *err*]\n      (print (-> e Throwable->map ex-triage ex-str))\n      (flush))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/clojure/cljs/repl.cljc",
                                             :lines [982 998]},
                                    :full-name "cljs.repl/repl-caught"},
           "syntax/uuid-literal" {:syntax-equiv {:edn-url nil,
                                                 :clj-url nil},
                                  :ns "syntax",
                                  :name "uuid-literal",
                                  :name-encode "uuid-literal",
                                  :history [["+" "0.0-1424"]],
                                  :type "tagged literal",
                                  :full-name-encode "syntax/uuid-literal",
                                  :extra-sources ({:code "   (defn read-uuid\n     [form]\n     (when-not (string? form)\n       (throw (RuntimeException. \"UUID literal expects a string as its representation.\")))\n     (try\n       (java.util.UUID/fromString form)\n       (catch Throwable e\n         (throw (RuntimeException. (.getMessage e))))))",
                                                   :title "Reader code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/clojure/cljs/tagged_literals.cljc",
                                                   :lines [24 31]}
                                                  {:code "(def ^:dynamic *cljs-data-readers*\n  (merge ;; assumes we can read all data_readers\n    #?(:clj *data-readers*)\n    {'queue read-queue\n     'uuid  read-uuid\n     'inst  read-inst\n     'js    read-js}))",
                                                   :title "Reader table",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/clojure/cljs/tagged_literals.cljc",
                                                   :lines [87 93]}),
                                  :full-name "syntax/uuid-literal"},
           "clojure.zip/children" {:ns "clojure.zip",
                                   :name "children",
                                   :signature ["[loc]"],
                                   :name-encode "children",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "clojure.zip/children",
                                   :source {:code "(defn children\n  [loc]\n    (if (branch? loc)\n      ((:zip/children (meta loc)) (node loc))\n      (throw \"called children on a leaf node\")))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/clojure/zip.cljs",
                                            :lines [69 74]},
                                   :full-name "clojure.zip/children",
                                   :docstring "Returns a seq of the children of node at loc, which must be a branch"},
           "cljs.core/when-not" {:ns "cljs.core",
                                 :name "when-not",
                                 :signature ["[test & body]"],
                                 :name-encode "when-not",
                                 :history [["+" "0.0-927"]],
                                 :type "macro",
                                 :full-name-encode "cljs.core/when-not",
                                 :source {:code "(defmacro when-not\n  {:added \"1.0\"}\n  [test & body]\n    (list 'if test nil (cons 'do body)))",
                                          :title "Source code",
                                          :repo "clojure",
                                          :tag "clojure-1.10.0",
                                          :filename "src/clj/clojure/core.clj",
                                          :lines [499 503]},
                                 :full-name "cljs.core/when-not",
                                 :docstring "Evaluates test. If logical false, evaluates body in an implicit do."},
           "clojure.set/index" {:ns "clojure.set",
                                :name "index",
                                :signature ["[xrel ks]"],
                                :name-encode "index",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "clojure.set/index",
                                :source {:code "(defn index\n  [xrel ks]\n    (reduce\n     (fn [m x]\n       (let [ik (select-keys x ks)]\n         (assoc m ik (conj (get m ik #{}) x))))\n     {} xrel))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/clojure/set.cljs",
                                         :lines [87 95]},
                                :full-name "clojure.set/index",
                                :docstring "Returns a map of the distinct values of ks in the xrel mapped to a\nset of the maps in xrel with the corresponding values of ks."},
           "cljs.spec.impl.gen/simple-type" {:ns "cljs.spec.impl.gen",
                                             :name "simple-type",
                                             :signature ["[& args]"],
                                             :name-encode "simple-type",
                                             :history [["+" "1.9.14"]
                                                       ["-" "1.9.542"]],
                                             :type "function",
                                             :full-name-encode "cljs.spec.impl.gen/simple-type",
                                             :source {:code "(lazy-prims any any-printable boolean char char-alpha char-alphanumeric char-ascii double\n  int keyword keyword-ns large-integer ratio simple-type simple-type-printable\n  string string-ascii string-alphanumeric symbol symbol-ns uuid)",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.9.521",
                                                      :filename "src/main/cljs/cljs/spec/impl/gen.cljs",
                                                      :lines [73 75]},
                                             :full-name "cljs.spec.impl.gen/simple-type",
                                             :docstring "Fn returning clojure.test.check.generators/simple-type",
                                             :removed {:in "1.9.542",
                                                       :last-seen "1.9.521"}},
           "cljs.repl.browser/send-and-close" {:ns "cljs.repl.browser",
                                               :name "send-and-close",
                                               :signature ["[conn status form]"
                                                           "[conn status form content-type]"],
                                               :name-encode "send-and-close",
                                               :history [["+"
                                                          "0.0-927"]
                                                         ["-"
                                                          "0.0-1503"]],
                                               :type "function",
                                               :full-name-encode "cljs.repl.browser/send-and-close",
                                               :source {:code "(defn send-and-close\n  ([conn status form]\n     (send-and-close conn status form \"text/html\"))\n  ([conn status form content-type]\n     (let [utf-8-form (.getBytes form \"UTF-8\")\n           content-length (count utf-8-form)\n           headers (map #(.getBytes (str % \"\\r\\n\"))\n                        [(status-line status)\n                         \"Server: ClojureScript REPL\"\n                         (str \"Content-Type: \"\n                              content-type\n                              \"; charset=utf-8\")\n                         (str \"Content-Length: \" content-length)\n                         \"\"])]\n       (with-open [os (.getOutputStream conn)]\n         (do (doseq [header headers]\n               (.write os header 0 (count header)))\n             (.write os utf-8-form 0 content-length)\n             (.flush os)\n             (.close conn))))))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1450",
                                                        :filename "src/clj/cljs/repl/browser.clj",
                                                        :lines [69 90]},
                                               :full-name "cljs.repl.browser/send-and-close",
                                               :docstring "Use the passed connection to send a form to the browser. Send a\nproper HTTP response.",
                                               :removed {:in "0.0-1503",
                                                         :last-seen "0.0-1450"}},
           "cljs.build.api/compile" {:ns "cljs.build.api",
                                     :name "compile",
                                     :signature ["[opts compilable]"
                                                 "[state opts compilable]"],
                                     :name-encode "compile",
                                     :history [["+" "0.0-3291"]],
                                     :type "function",
                                     :full-name-encode "cljs.build.api/compile",
                                     :source {:code "(defn compile\n  ([opts compilable]\n   (compile (or (ana-api/current-state) (ana-api/empty-state opts)) opts compilable))\n  ([state opts compilable]\n   (ana-api/with-state state\n     (closure/compile compilable opts))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/clojure/cljs/build/api.clj",
                                              :lines [194 200]},
                                     :full-name "cljs.build.api/compile",
                                     :docstring "Given a Compilable, compile it and return an IJavaScript."},
           "cljs.core/chunked-seq?" {:ns "cljs.core",
                                     :name "chunked-seq?",
                                     :signature ["[x]"],
                                     :name-encode "chunked-seqQMARK",
                                     :history [["+" "0.0-1424"]],
                                     :type "function",
                                     :full-name-encode "cljs.core/chunked-seqQMARK",
                                     :source {:code "(defn chunked-seq?\n  [x] (implements? IChunkedSeq x))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/cljs/cljs/core.cljs",
                                              :lines [2238 2240]},
                                     :full-name "cljs.core/chunked-seq?",
                                     :docstring "Return true if x satisfies IChunkedSeq."},
           "cljs.spec.impl.gen/map" {:ns "cljs.spec.impl.gen",
                                     :name "map",
                                     :signature ["[& args]"],
                                     :name-encode "map",
                                     :history [["+" "1.9.14"]
                                               ["-" "1.9.542"]],
                                     :type "function",
                                     :full-name-encode "cljs.spec.impl.gen/map",
                                     :source {:code "(lazy-combinators hash-map list map not-empty set vector vector-distinct fmap elements\n  bind choose one-of such-that tuple sample return\n  large-integer* double* frequency)",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.9.521",
                                              :filename "src/main/cljs/cljs/spec/impl/gen.cljs",
                                              :lines [69 71]},
                                     :full-name "cljs.spec.impl.gen/map",
                                     :docstring "Lazy loaded version of clojure.test.check.generators/map",
                                     :removed {:in "1.9.542",
                                               :last-seen "1.9.521"}},
           "clojure.browser.dom/log" {:ns "clojure.browser.dom",
                                      :name "log",
                                      :signature ["[& args]"],
                                      :name-encode "log",
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "clojure.browser.dom/log",
                                      :source {:code "(defn log [& args]\n  (.log js/console (apply pr-str args)))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/clojure/browser/dom.cljs",
                                               :lines [20 21]},
                                      :full-name "clojure.browser.dom/log"},
           "cljs.spec/coll-checker" {:ns "cljs.spec",
                                     :name "coll-checker",
                                     :signature ["[pred]"],
                                     :name-encode "coll-checker",
                                     :history [["+" "1.9.14"]
                                               ["-" "1.9.183"]],
                                     :type "function",
                                     :full-name-encode "cljs.spec/coll-checker",
                                     :source {:code "(defn coll-checker\n  [pred]\n  (let [check? #(valid? pred %)]\n    (fn [coll]\n      (c/or (nil? coll)\n            (c/and\n              (coll? coll)\n              (every? check? (take *coll-check-limit* coll)))))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.9.93",
                                              :filename "src/main/cljs/cljs/spec.cljs",
                                              :lines [1178 1186]},
                                     :full-name "cljs.spec/coll-checker",
                                     :docstring "returns a predicate function that checks *coll-check-limit* items in a collection with pred",
                                     :removed {:in "1.9.183",
                                               :last-seen "1.9.93"}},
           "cljs.core/Vector.fromArray" {:ns "cljs.core",
                                         :name "Vector.fromArray",
                                         :signature ["[xs]"],
                                         :name-encode "VectorDOTfromArray",
                                         :history [["+" "0.0-927"]
                                                   ["-" "0.0-1798"]],
                                         :parent-type "Vector",
                                         :type "function",
                                         :full-name-encode "cljs.core/VectorDOTfromArray",
                                         :source {:code "(set! cljs.core.Vector/fromArray (fn [xs] (Vector. nil xs nil)))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1586",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [2861]},
                                         :full-name "cljs.core/Vector.fromArray",
                                         :removed {:in "0.0-1798",
                                                   :last-seen "0.0-1586"}},
           "cljs.repl/ns-info" {:ns "cljs.repl",
                                :name "ns-info",
                                :signature ["[f]"],
                                :name-encode "ns-info",
                                :history [["+" "0.0-2814"]],
                                :type "function",
                                :full-name-encode "cljs.repl/ns-info",
                                :source {:code "(defn ns-info\n  [f]\n  (let [f' (js-src->cljs-src f)]\n    (when (and f' (.exists f'))\n      (ana/parse-ns f'))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/clojure/cljs/repl.cljc",
                                         :lines [295 301]},
                                :full-name "cljs.repl/ns-info",
                                :docstring "Given a path to a js source file return the ns info for the corresponding\nClojureScript file if it exists."},
           "cljs.spec.alpha/*coll-error-limit*" {:ns "cljs.spec.alpha",
                                                 :name "*coll-error-limit*",
                                                 :name-encode "STARcoll-error-limitSTAR",
                                                 :type "dynamic var",
                                                 :full-name-encode "cljs.spec.alpha/STARcoll-error-limitSTAR",
                                                 :source {:code "(def ^:dynamic *coll-error-limit*\n  20)",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r1.12.38",
                                                          :filename "src/main/cljs/cljs/spec/alpha.cljs",
                                                          :lines [35
                                                                  37]},
                                                 :full-name "cljs.spec.alpha/*coll-error-limit*",
                                                 :history [["+"
                                                            "1.9.542"]]},
           "cljs.core/make-array" {:return-type array,
                                   :ns "cljs.core",
                                   :name "make-array",
                                   :signature ["[size]"
                                               "[type size]"
                                               "[type size & more-sizes]"],
                                   :name-encode "make-array",
                                   :history [["+" "0.0-1211"]],
                                   :type "function/macro",
                                   :full-name-encode "cljs.core/make-array",
                                   :source {:code "(defn ^array make-array\n  ([size]\n     (js/Array. size))\n  ([type size]\n     (make-array size))\n  ([type size & more-sizes]\n    (let [dims more-sizes\n          dimarray (make-array size)]\n      (dotimes [i (alength dimarray)]\n        (aset dimarray i (apply make-array nil dims)))\n      dimarray)))",
                                            :title "Function code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [422 436]},
                                   :extra-sources [{:code "(core/defmacro make-array\n  ([size]\n   (vary-meta\n     (if (core/number? size)\n       `(array ~@(take size (repeat nil)))\n       `(js/Array. ~size))\n     assoc :tag 'array))\n  ([type size]\n   `(cljs.core/make-array ~size))\n  ([type size & more-sizes]\n   (vary-meta\n     `(let [dims#     (list ~@more-sizes)\n            dimarray# (cljs.core/make-array ~size)]\n        (dotimes [i# (alength dimarray#)]\n          (aset dimarray# i# (apply cljs.core/make-array nil dims#)))\n        dimarray#)\n     assoc :tag 'array)))",
                                                    :title "Macro code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/clojure/cljs/core.cljc",
                                                    :lines [2601 2617]}],
                                   :full-name "cljs.core/make-array",
                                   :docstring "Construct a JavaScript array of the specified dimensions. Accepts ignored\ntype argument for compatibility with Clojure. Note that there is no efficient\nway to allocate multi-dimensional arrays in JavaScript; as such, this function\nwill run in polynomial time when called with 3 or more arguments."},
           "compiler-options/install-deps" {:ns "compiler-options",
                                            :name "install-deps",
                                            :name-encode "install-deps",
                                            :type "option",
                                            :full-name-encode "compiler-options/install-deps",
                                            :full-name "compiler-options/install-deps",
                                            :history [["+" "1.9.854"]]},
           "cljs.core/sorted-set-by" {:ns "cljs.core",
                                      :name "sorted-set-by",
                                      :signature ["[comparator & keys]"],
                                      :name-encode "sorted-set-by",
                                      :history [["+" "0.0-1211"]],
                                      :type "function",
                                      :full-name-encode "cljs.core/sorted-set-by",
                                      :source {:code "(defn sorted-set-by\n  ([comparator & keys]\n   (reduce -conj\n           (PersistentTreeSet. nil (sorted-map-by comparator) 0)\n           keys)))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [9681 9686]},
                                      :full-name "cljs.core/sorted-set-by",
                                      :docstring "Returns a new sorted set with supplied keys, using the supplied comparator."},
           "cljs.repl.node/repl-env" {:ns "cljs.repl.node",
                                      :name "repl-env",
                                      :signature ["[& {:as options}]"],
                                      :name-encode "repl-env",
                                      :history [["+" "0.0-2629"]],
                                      :type "function",
                                      :full-name-encode "cljs.repl.node/repl-env",
                                      :source {:code "(defn repl-env\n  [& {:as options}]\n  (repl-env* options))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/clojure/cljs/repl/node.clj",
                                               :lines [246 250]},
                                      :full-name "cljs.repl.node/repl-env",
                                      :docstring "Construct a Node.js evalution environment. Can supply :host, :port\nand :path (a vector used as the NODE_PATH)."},
           "cljs.spec.impl.gen/for-all*" {:ns "cljs.spec.impl.gen",
                                          :name "for-all*",
                                          :signature ["[& args]"],
                                          :name-encode "for-allSTAR",
                                          :history [["+" "1.9.14"]
                                                    ["-" "1.9.542"]],
                                          :type "function",
                                          :full-name-encode "cljs.spec.impl.gen/for-allSTAR",
                                          :source {:code "(defn for-all*\n  [& args]\n  (apply @for-all*-ref args))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.9.521",
                                                   :filename "src/main/cljs/cljs/spec/impl/gen.cljs",
                                                   :lines [36 39]},
                                          :full-name "cljs.spec.impl.gen/for-all*",
                                          :docstring "Dynamically loaded clojure.test.check.properties/for-all*.",
                                          :removed {:in "1.9.542",
                                                    :last-seen "1.9.521"}},
           "syntax/impure" {:syntax-equiv {:edn-url nil, :clj-url nil},
                            :ns "syntax",
                            :name "impure",
                            :name-encode "impure",
                            :type "convention",
                            :full-name-encode "syntax/impure",
                            :full-name "syntax/impure",
                            :history [["+" "0.0-927"]]},
           "warnings/fn-deprecated" {:ns "warnings",
                                     :name "fn-deprecated",
                                     :name-encode "fn-deprecated",
                                     :type "warning",
                                     :full-name-encode "warnings/fn-deprecated",
                                     :full-name "warnings/fn-deprecated",
                                     :history [["+" "0.0-1835"]]},
           "cljs.pprint/*print-pprint-dispatch*" {:ns "cljs.pprint",
                                                  :name "*print-pprint-dispatch*",
                                                  :name-encode "STARprint-pprint-dispatchSTAR",
                                                  :history [["+"
                                                             "0.0-3255"]],
                                                  :type "dynamic var",
                                                  :full-name-encode "cljs.pprint/STARprint-pprint-dispatchSTAR",
                                                  :source {:code "(defonce ^{:added \"1.2\", :dynamic true} *print-pprint-dispatch* nil)",
                                                           :title "Source code",
                                                           :repo "clojurescript",
                                                           :tag "r1.12.38",
                                                           :filename "src/main/cljs/cljs/pprint.cljs",
                                                           :lines [620
                                                                   624]},
                                                  :full-name "cljs.pprint/*print-pprint-dispatch*",
                                                  :docstring "The pretty print dispatch function. Use with-pprint-dispatch or\nset-pprint-dispatch to modify."},
           "cljs.core/partition-by" {:ns "cljs.core",
                                     :name "partition-by",
                                     :signature ["[f]" "[f coll]"],
                                     :name-encode "partition-by",
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "cljs.core/partition-by",
                                     :source {:code "(defn partition-by\n  ([f]\n     (fn [rf]\n       (let [a (array-list)\n             pa (volatile! ::none)]\n         (fn\n           ([] (rf))\n           ([result]\n              (let [result (if (.isEmpty a)\n                             result\n                             (let [v (vec (.toArray a))]\n                               ;;clear first!\n                               (.clear a)\n                               (unreduced (rf result v))))]\n                (rf result)))\n           ([result input]\n              (let [pval @pa\n                    val (f input)]\n                (vreset! pa val)\n                (if (or (keyword-identical? pval ::none)\n                        (= val pval))\n                  (do\n                    (.add a input)\n                    result)\n                  (let [v (vec (.toArray a))]\n                    (.clear a)\n                    (let [ret (rf result v)]\n                      (when-not (reduced? ret)\n                        (.add a input))\n                      ret)))))))))\n  ([f coll]\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (let [fst (first s)\n               fv (f fst)\n               run (cons fst (take-while #(= fv (f %)) (next s)))]\n           (cons run (partition-by f (lazy-seq (drop (count run) s)))))))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/cljs/cljs/core.cljs",
                                              :lines [10243 10282]},
                                     :full-name "cljs.core/partition-by",
                                     :docstring "Applies f to each value in coll, splitting it each time f returns a\nnew value.  Returns a lazy seq of partitions.  Returns a stateful\ntransducer when no collection is provided."},
           "cljs.repl/skip-if-eol" {:ns "cljs.repl",
                                    :name "skip-if-eol",
                                    :signature ["[s]"],
                                    :name-encode "skip-if-eol",
                                    :history [["+" "0.0-2719"]],
                                    :type "function",
                                    :full-name-encode "cljs.repl/skip-if-eol",
                                    :source {:code "(defn skip-if-eol\n  [s]\n  (let [c (readers/read-char s)]\n    (case c\n      \\newline :line-start\n      nil :stream-end\n      (do (readers/unread s c) :body))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/clojure/cljs/repl.cljc",
                                             :lines [52 64]},
                                    :full-name "cljs.repl/skip-if-eol",
                                    :docstring "If the next character on stream s is a newline, skips it, otherwise\nleaves the stream untouched. Returns :line-start, :stream-end, or :body\nto indicate the relative location of the next character on s. The stream\nmust either be an instance of LineNumberingPushbackReader or duplicate\nits behavior of both supporting .unread and collapsing all of CR, LF, and\nCRLF to a single \\newline."},
           "cljs.core/sort-by" {:ns "cljs.core",
                                :name "sort-by",
                                :signature ["[keyfn coll]"
                                            "[keyfn comp coll]"],
                                :name-encode "sort-by",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/sort-by",
                                :source {:code "(defn sort-by\n  ([keyfn coll]\n   (sort-by keyfn compare coll))\n  ([keyfn comp coll]\n     (sort (fn [x y] ((fn->comparator comp) (keyfn x) (keyfn y))) coll)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [2530 2538]},
                                :full-name "cljs.core/sort-by",
                                :docstring "Returns a sorted sequence of the items in coll, where the sort\norder is determined by comparing (keyfn item).  Comp can be\nboolean-valued comparison function, or a -/0/+ valued comparator.\nComp defaults to compare."},
           "cljs.test/assert-expr" {:ns "cljs.test",
                                    :name "assert-expr",
                                    :signature ["[menv msg form]"],
                                    :name-encode "assert-expr",
                                    :history [["+" "1.8.51"]],
                                    :type "multimethod",
                                    :full-name-encode "cljs.test/assert-expr",
                                    :source {:code "(defmulti assert-expr \n  (fn [menv msg form]\n    (cond\n      (nil? form) :always-fail\n      (seq? form) (first form)\n      :else :default)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/test.cljc",
                                             :lines [76 81]},
                                    :extra-sources ({:code "(defmethod assert-expr :always-fail [menv msg form]\n  ;; nil test: always fail\n  (let [{:keys [file line end-line column end-column]} (meta form)]\n    `(report {:type :fail, :message ~msg\n              :file ~file :line ~line :end-line ~end-line :column ~column :end-column ~end-column})))",
                                                     :title "Dispatch method",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/cljs/cljs/test.cljc",
                                                     :lines [83 87]}
                                                    {:code "(defmethod assert-expr :default [menv msg form]\n  (if (and (sequential? form)\n           (function? menv (first form)))\n    (assert-predicate msg form)\n    (assert-any msg form)))",
                                                     :title "Dispatch method",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/cljs/cljs/test.cljc",
                                                     :lines [89 93]}
                                                    {:code "(defmethod assert-expr 'instance? [menv msg form]\n  ;; Test if x is an instance of y.\n  (let [{:keys [file line end-line column end-column]} (meta form)]\n    `(let [klass# ~(nth form 1)\n           object# ~(nth form 2)]\n       (let [result# (instance? klass# object#)]\n         (if result#\n           (report\n            {:type :pass, :message ~msg,\n             :file ~file :line ~line :end-line ~end-line :column ~column :end-column ~end-column\n             :expected '~form, :actual (type object#)})\n           (report\n            {:type :fail, :message ~msg,\n             :file ~file :line ~line :end-line ~end-line :column ~column :end-column ~end-column\n             :expected '~form, :actual (type object#)}))\n         result#))))",
                                                     :title "Dispatch method",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/cljs/cljs/test.cljc",
                                                     :lines [95 110]}
                                                    {:code "(defmethod assert-expr 'thrown? [menv msg form]\n  ;; (is (thrown? c expr))\n  ;; Asserts that evaluating expr throws an exception of class c.\n  ;; Returns the exception thrown.\n  (let [{:keys [file line end-line column end-column]} (meta form)\n        klass (second form)\n        body (nthnext form 2)]\n    `(try\n       ~@body\n       (report\n        {:type :fail, :message ~msg,\n         :file ~file :line ~line :end-line ~end-line :column ~column :end-column ~end-column\n         :expected '~form, :actual nil})\n       (catch ~klass e#\n         (report\n          {:type :pass, :message ~msg,\n           :file ~file :line ~line :end-line ~end-line :column ~column :end-column ~end-column\n           :expected '~form, :actual e#})\n         e#))))",
                                                     :title "Dispatch method",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/cljs/cljs/test.cljc",
                                                     :lines [112 130]}
                                                    {:code "(defmethod assert-expr 'thrown-with-msg? [menv msg form]\n  ;; (is (thrown-with-msg? c re expr))\n  ;; Asserts that evaluating expr throws an exception of class c.\n  ;; Also asserts that the message string of the exception matches\n  ;; (with re-find) the regular expression re.\n  (let [{:keys [file line end-line column end-column]} (meta form)\n        klass (nth form 1)\n        re (nth form 2)\n        body (nthnext form 3)]\n    `(try\n       ~@body\n       (report {:type :fail, :message ~msg, :expected '~form, :actual nil\n                :file ~file :line ~line :end-line ~end-line :column ~column :end-column ~end-column})\n       (catch ~klass e#\n         (let [m# (.-message e#)]\n           (if (re-find ~re m#)\n             (report\n              {:type :pass, :message ~msg,\n               :file ~file :line ~line :end-line ~end-line :column ~column :end-column ~end-column\n               :expected '~form, :actual e#})\n             (report\n              {:type :fail, :message ~msg,\n               :file ~file :line ~line :end-line ~end-line :column ~column :end-column ~end-column\n               :expected '~form, :actual e#}))\n           e#)))))",
                                                     :title "Dispatch method",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/cljs/cljs/test.cljc",
                                                     :lines [132 156]}),
                                    :full-name "cljs.test/assert-expr"},
           "cljs.core/caching-hash" {:ns "cljs.core",
                                     :name "caching-hash",
                                     :signature ["[coll hash-fn hash-key]"],
                                     :name-encode "caching-hash",
                                     :history [["+" "0.0-1211"]
                                               ["-" "1.9.493"]
                                               ["+" "1.9.494"]],
                                     :type "macro",
                                     :full-name-encode "cljs.core/caching-hash",
                                     :source {:code "(core/defmacro caching-hash [coll hash-fn hash-key]\n  (core/assert (clojure.core/symbol? hash-key) \"hash-key is substituted twice\")\n  `(let [h# ~hash-key]\n     (if-not (nil? h#)\n       h#\n       (let [h# (~hash-fn ~coll)]\n         (set! ~hash-key h#)\n         h#))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/clojure/cljs/core.cljc",
                                              :lines [1255 1262]},
                                     :full-name "cljs.core/caching-hash"},
           "cljs.core/ns-imports" {:ns "cljs.core",
                                   :name "ns-imports",
                                   :signature ["[quoted-ns]"],
                                   :name-encode "ns-imports",
                                   :history [["+" "1.9.854"]],
                                   :type "macro",
                                   :full-name-encode "cljs.core/ns-imports",
                                   :source {:code "(core/defmacro ns-imports\n  [quoted-ns]\n  (core/assert (core/and (seq? quoted-ns)\n                         (= (first quoted-ns) 'quote)\n                         (core/symbol? (second quoted-ns)))\n    \"Argument to ns-imports must be a quoted symbol\")\n  (core/let [ns (second quoted-ns)]\n    `(into {}\n       [~@(map\n            (core/fn [[ctor qualified-ctor]]\n              `[(symbol ~(name ctor)) ~(symbol qualified-ctor)])\n            (get-in @env/*compiler* [:cljs.analyzer/namespaces ns :imports]))])))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/clojure/cljs/core.cljc",
                                            :lines [2938 2950]},
                                   :full-name "cljs.core/ns-imports",
                                   :docstring "Returns a map of the import mappings for the namespace."},
           "cljs.core/with-meta" {:ns "cljs.core",
                                  :name "with-meta",
                                  :signature ["[o meta]"],
                                  :name-encode "with-meta",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/with-meta",
                                  :source {:code "(defn with-meta\n  [o meta]\n  (if (js-fn? o)\n    (MetaFn. o meta)\n    (when-not (nil? o)\n      (-with-meta o meta))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [2127 2134]},
                                  :full-name "cljs.core/with-meta",
                                  :docstring "Returns an object of the same type and value as obj, with\nmap m as its metadata."},
           "cljs.core/NeverEquiv" {:protocols #{"IEquiv"},
                                   :ns "cljs.core",
                                   :name "NeverEquiv",
                                   :signature ["[]"],
                                   :name-encode "NeverEquiv",
                                   :history [["+" "0.0-927"]],
                                   :type "type",
                                   :full-name-encode "cljs.core/NeverEquiv",
                                   :source {:code "(deftype NeverEquiv []\n  Object\n  (equiv [this other]\n    (-equiv this other))\n  IEquiv\n  (-equiv [o other] false))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [6480 6485]},
                                   :full-name "cljs.core/NeverEquiv"},
           "repl-options/wrap" {:ns "repl-options",
                                :name "wrap",
                                :name-encode "wrap",
                                :type "option",
                                :full-name-encode "repl-options/wrap",
                                :full-name "repl-options/wrap",
                                :history [["+" "0.0-2985"]]},
           "cljs.analyzer.api/in-cljs-user" {:ns "cljs.analyzer.api",
                                             :name "in-cljs-user",
                                             :signature ["[env & body]"],
                                             :name-encode "in-cljs-user",
                                             :history [["+"
                                                        "0.0-2629"]],
                                             :type "macro",
                                             :full-name-encode "cljs.analyzer.api/in-cljs-user",
                                             :source {:code "(defmacro in-cljs-user\n  [env & body]\n  `(binding [cljs.analyzer/*cljs-ns* 'cljs.user]\n     (cljs.env/with-compiler-env ~env\n       ~@body)))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.12.38",
                                                      :filename "src/main/clojure/cljs/analyzer/api.cljc",
                                                      :lines [280 286]},
                                             :full-name "cljs.analyzer.api/in-cljs-user",
                                             :docstring "Binds cljs.analyzer/*cljs-ns* to 'cljs.user and uses the given compilation\nenvironment atom and runs body."},
           "cljs.core/select-keys" {:ns "cljs.core",
                                    :name "select-keys",
                                    :signature ["[map keyseq]"],
                                    :name-encode "select-keys",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/select-keys",
                                    :source {:code "(defn select-keys\n  [map keyseq]\n    (loop [ret {} keys (seq keyseq)]\n      (if keys\n        (let [key   (first keys)\n              entry (get map key ::not-found)]\n          (recur\n           (if (not= entry ::not-found)\n             (assoc ret key entry)\n             ret)\n           (next keys)))\n        (-with-meta ret (meta map)))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [9359 9371]},
                                    :full-name "cljs.core/select-keys",
                                    :docstring "Returns a map containing only those entries in map whose key is in keys"},
           "cljs.spec.alpha/Spec" {:ns "cljs.spec.alpha",
                                   :name "Spec",
                                   :name-encode "Spec",
                                   :history [["+" "1.9.542"]],
                                   :type "protocol",
                                   :full-name-encode "cljs.spec.alpha/Spec",
                                   :source {:code "(defprotocol Spec\n  (conform* [spec x])\n  (unform* [spec y])\n  (explain* [spec path via in x])\n  (gen* [spec overrides path rmap])\n  (with-gen* [spec gfn])\n  (describe* [spec]))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/spec/alpha.cljs",
                                            :lines [39 45]},
                                   :methods [{:name "conform*",
                                              :signature ["[spec x]"],
                                              :docstring nil}
                                             {:name "unform*",
                                              :signature ["[spec y]"],
                                              :docstring nil}
                                             {:name "explain*",
                                              :signature ["[spec path via in x]"],
                                              :docstring nil}
                                             {:name "gen*",
                                              :signature ["[spec overrides path rmap]"],
                                              :docstring nil}
                                             {:name "with-gen*",
                                              :signature ["[spec gfn]"],
                                              :docstring nil}
                                             {:name "describe*",
                                              :signature ["[spec]"],
                                              :docstring nil}],
                                   :full-name "cljs.spec.alpha/Spec"},
           "cljs.spec/with-instrument-disabled" {:ns "cljs.spec",
                                                 :name "with-instrument-disabled",
                                                 :signature ["[& body]"],
                                                 :name-encode "with-instrument-disabled",
                                                 :history [["+"
                                                            "1.9.14"]
                                                           ["-"
                                                            "1.9.183"]],
                                                 :type "macro",
                                                 :full-name-encode "cljs.spec/with-instrument-disabled",
                                                 :source {:code "(defmacro with-instrument-disabled\n  [& body]\n  `(binding [cljs.spec/*instrument-enabled* nil]\n     ~@body))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r1.9.93",
                                                          :filename "src/main/cljs/cljs/spec.cljc",
                                                          :lines [380
                                                                  384]},
                                                 :full-name "cljs.spec/with-instrument-disabled",
                                                 :docstring "Disables instrument's checking of calls, within a scope.",
                                                 :removed {:in "1.9.183",
                                                           :last-seen "1.9.93"}},
           "warnings/protocol-with-overwriting-method" {:ns "warnings",
                                                        :name "protocol-with-overwriting-method",
                                                        :name-encode "protocol-with-overwriting-method",
                                                        :type "warning",
                                                        :full-name-encode "warnings/protocol-with-overwriting-method",
                                                        :full-name "warnings/protocol-with-overwriting-method",
                                                        :history [["+"
                                                                   "1.10.597"]]},
           "cljs.core/ISeq" {:ns "cljs.core",
                             :name "ISeq",
                             :name-encode "ISeq",
                             :implementations #{"Cycle"
                                                "PersistentQueue"
                                                "PersistentArrayMapSeq"
                                                "EmptyList"
                                                "Iterate"
                                                "ValSeq"
                                                "IntegerRange"
                                                "ChunkedCons"
                                                "Range"
                                                "PersistentQueueSeq"
                                                "ChunkedSeq"
                                                "ArrayNodeSeq"
                                                "KeySeq"
                                                "IntegerRangeChunk"
                                                "IndexedSeq"
                                                "PersistentTreeMapSeq"
                                                "ES6IteratorSeq"
                                                "RSeq"
                                                "NodeSeq"
                                                "List"
                                                "Repeat"
                                                "Cons"
                                                "LazySeq"},
                             :history [["+" "0.0-927"]],
                             :type "protocol",
                             :full-name-encode "cljs.core/ISeq",
                             :source {:code "(defprotocol ISeq\n  (-first [coll]\n    \"Returns the first item in the collection coll. Used by cljs.core/first.\")\n  (^clj -rest [coll]\n    \"Returns a new collection of coll without the first item. It should\n     always return a seq, e.g.\n     (rest []) => ()\n     (rest nil) => ()\"))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [620 628]},
                             :methods [{:name "-first",
                                        :signature ["[coll]"],
                                        :docstring "Returns the first item in the collection coll. Used by cljs.core/first."}
                                       {:name "-rest",
                                        :signature ["[coll]"],
                                        :docstring "Returns a new collection of coll without the first item. It should\n     always return a seq, e.g.\n     (rest []) => ()\n     (rest nil) => ()"}],
                             :full-name "cljs.core/ISeq",
                             :docstring "Protocol for collections to provide access to their items as sequences."},
           "cljs.core/disj!" {:ns "cljs.core",
                              :name "disj!",
                              :signature ["[tcoll val]"
                                          "[tcoll val & vals]"],
                              :name-encode "disjBANG",
                              :history [["+" "0.0-1211"]],
                              :type "function",
                              :full-name-encode "cljs.core/disjBANG",
                              :source {:code "(defn disj!\n  ([tcoll val]\n    (-disjoin! tcoll val))\n  ([tcoll val & vals]\n    (let [ntcoll (-disjoin! tcoll val)]\n      (if vals\n        (recur ntcoll (first vals) (next vals))\n        ntcoll))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [3956 3965]},
                              :full-name "cljs.core/disj!",
                              :docstring "disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\ndoes not contain key(s)."},
           "cljs.core/partitionv-all" {:ns "cljs.core",
                                       :name "partitionv-all",
                                       :signature ["[n]"
                                                   "[n coll]"
                                                   "[n step coll]"],
                                       :name-encode "partitionv-all",
                                       :history [["+" "1.11.121"]],
                                       :type "function",
                                       :full-name-encode "cljs.core/partitionv-all",
                                       :source {:code "(defn partitionv-all\n  ([n]\n   (partition-all n))\n  ([n coll]\n   (partitionv-all n n coll))\n  ([n step coll]\n   (lazy-seq\n     (when-let [s (seq coll)]\n       (let [seg (into [] (take n) coll)]\n         (cons seg (partitionv-all n step (drop step s))))))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/core.cljs",
                                                :lines [9847 9859]},
                                       :full-name "cljs.core/partitionv-all",
                                       :docstring "Returns a lazy sequence of vector partitions, but may include\npartitions with fewer than n items at the end.\nReturns a stateful transducer when no collection is provided."},
           "cljs.core/neg-int?" {:return-type boolean,
                                 :ns "cljs.core",
                                 :name "neg-int?",
                                 :signature ["[x]"],
                                 :name-encode "neg-intQMARK",
                                 :history [["+" "1.9.75"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/neg-intQMARK",
                                 :source {:code "(defn ^boolean neg-int?\n  [x]\n  (cond\n    (integer? x) (neg? x)\n\n    (instance? goog.math.Integer x)\n    (.isNegative x)\n\n    (instance? goog.math.Long x)\n    (.isNegative x)\n\n    :else false))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [2365 2377]},
                                 :full-name "cljs.core/neg-int?",
                                 :docstring "Return true if x satisfies int? and is negative."},
           "cljs.test/try-expr" {:ns "cljs.test",
                                 :name "try-expr",
                                 :signature ["[msg form]"],
                                 :name-encode "try-expr",
                                 :history [["+" "0.0-2496"]],
                                 :type "macro",
                                 :full-name-encode "cljs.test/try-expr",
                                 :source {:code "(defmacro try-expr\n  [msg form]\n  (let [{:keys [file line end-line column end-column]} (meta form)]\n    `(try\n       ~(assert-expr &env msg form)\n       (catch :default t#\n         (report\n          {:type :error, :message ~msg,\n           :file ~file :line ~line :end-line ~end-line :column ~column :end-column ~end-column\n           :expected '~form, :actual t#})))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/test.cljc",
                                          :lines [158 169]},
                                 :full-name "cljs.test/try-expr",
                                 :docstring "Used by the 'is' macro to catch unexpected exceptions.\nYou don't call this."},
           "warnings/js-used-as-alias" {:ns "warnings",
                                        :name "js-used-as-alias",
                                        :name-encode "js-used-as-alias",
                                        :type "warning",
                                        :full-name-encode "warnings/js-used-as-alias",
                                        :full-name "warnings/js-used-as-alias",
                                        :history [["+" "1.12.35"]]},
           "closure-warnings/misplaced-type-annotation" {:ns "closure-warnings",
                                                         :name "misplaced-type-annotation",
                                                         :name-encode "misplaced-type-annotation",
                                                         :type "warning",
                                                         :full-name-encode "closure-warnings/misplaced-type-annotation",
                                                         :full-name "closure-warnings/misplaced-type-annotation",
                                                         :history [["+"
                                                                    "1.9.473"]]},
           "cljs.pprint/pprint-indent" {:ns "cljs.pprint",
                                        :name "pprint-indent",
                                        :signature ["[relative-to n]"],
                                        :name-encode "pprint-indent",
                                        :history [["+" "0.0-3255"]],
                                        :type "function",
                                        :full-name-encode "cljs.pprint/pprint-indent",
                                        :source {:code "(defn pprint-indent\n  [relative-to n]\n  (check-enumerated-arg relative-to #{:block :current})\n  (indent *out* relative-to n))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/cljs/cljs/pprint.cljs",
                                                 :lines [855 866]},
                                        :full-name "cljs.pprint/pprint-indent",
                                        :docstring "Create an indent at this point in the pretty printing stream. This defines how\nfollowing lines are indented. relative-to can be either :block or :current depending\nwhether the indent should be computed relative to the start of the logical block or\nthe current column position. n is an offset.\n\nThis function is intended for use when writing custom dispatch functions.\n\nOutput is sent to *out* which must be a pretty printing writer."},
           "cljs.core/type->str" {:ns "cljs.core",
                                  :name "type->str",
                                  :signature ["[ty]"],
                                  :name-encode "type-GTstr",
                                  :history [["+" "0.0-1859"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/type-GTstr",
                                  :source {:code "(defn type->str [ty]\n  (if-let [s (.-cljs$lang$ctorStr ty)]\n    s\n    (str ty)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [332 335]},
                                  :full-name "cljs.core/type->str"},
           "clojure.walk/postwalk-replace" {:ns "clojure.walk",
                                            :name "postwalk-replace",
                                            :signature ["[smap form]"],
                                            :name-encode "postwalk-replace",
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "clojure.walk/postwalk-replace",
                                            :source {:code "(defn postwalk-replace\n  {:added \"1.1\"}\n  [smap form]\n  (postwalk (fn [x] (if (contains? smap x) (smap x) x)) form))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/cljs/clojure/walk.cljs",
                                                     :lines [92 98]},
                                            :full-name "clojure.walk/postwalk-replace",
                                            :docstring "Recursively transforms form by replacing keys in smap with their\nvalues.  Like clojure/replace but works on any data structure.  Does\nreplacement at the leaves of the tree first."},
           "cljs.core/ES6SetEntriesIterator" {:ns "cljs.core",
                                              :name "ES6SetEntriesIterator",
                                              :signature ["[s]"],
                                              :name-encode "ES6SetEntriesIterator",
                                              :history [["+"
                                                         "0.0-2371"]],
                                              :type "type",
                                              :full-name-encode "cljs.core/ES6SetEntriesIterator",
                                              :source {:code "(deftype ES6SetEntriesIterator [^:mutable s]\n  Object\n  (next [_]\n    (if-not (nil? s)\n      (let [x (first s)]\n        (set! s (next s))\n        #js {:value #js [x x] :done false})\n      #js {:value nil :done true})))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.12.38",
                                                       :filename "src/main/cljs/cljs/core.cljs",
                                                       :lines [6699
                                                               6706]},
                                              :full-name "cljs.core/ES6SetEntriesIterator"},
           "clojure.browser.repl/HOST" {:ns "clojure.browser.repl",
                                        :name "HOST",
                                        :name-encode "HOST",
                                        :type "var",
                                        :full-name-encode "clojure.browser.repl/HOST",
                                        :source {:code "(goog-define HOST)",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/cljs/clojure/browser/repl.cljs",
                                                 :lines [31]},
                                        :full-name "clojure.browser.repl/HOST",
                                        :history [["+" "1.10.63"]]},
           "cljs.core/pr-with-opts" {:ns "cljs.core",
                                     :name "pr-with-opts",
                                     :signature ["[objs opts]"],
                                     :name-encode "pr-with-opts",
                                     :history [["+" "0.0-927"]
                                               ["-" "0.0-1503"]],
                                     :type "function",
                                     :full-name-encode "cljs.core/pr-with-opts",
                                     :source {:code "(defn pr-with-opts\n  [objs opts]\n  (doseq [string (pr-seq (first objs) opts)]\n    (string-print string))\n  (doseq [obj (next objs)]\n    (string-print \" \")\n    (doseq [string (pr-seq obj opts)]\n      (string-print string))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1450",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [6171 6180]},
                                     :full-name "cljs.core/pr-with-opts",
                                     :docstring "Prints a sequence of objects using string-print, observing all\nthe options given in opts",
                                     :removed {:in "0.0-1503",
                                               :last-seen "0.0-1450"}},
           "cljs.core/->>" {:ns "cljs.core",
                            :name "->>",
                            :signature ["[x & forms]"],
                            :name-encode "-GTGT",
                            :history [["+" "0.0-927"]],
                            :type "macro",
                            :full-name-encode "cljs.core/-GTGT",
                            :source {:code "(defmacro ->>\n  {:added \"1.1\"}\n  [x & forms]\n  (loop [x x, forms forms]\n    (if forms\n      (let [form (first forms)\n            threaded (if (seq? form)\n              (with-meta `(~(first form) ~@(next form)  ~x) (meta form))\n              (list form x))]\n        (recur threaded (next forms)))\n      x)))",
                                     :title "Source code",
                                     :repo "clojure",
                                     :tag "clojure-1.10.0",
                                     :filename "src/clj/clojure/core.clj",
                                     :lines [1693 1707]},
                            :full-name "cljs.core/->>",
                            :docstring "Threads the expr through the forms. Inserts x as the\nlast item in the first form, making a list of it if it is not a\nlist already. If there are more forms, inserts the first form as the\nlast item in second form, etc."},
           "cljs.analyzer.api/empty-state" {:ns "cljs.analyzer.api",
                                            :name "empty-state",
                                            :signature ["[]" "[opts]"],
                                            :name-encode "empty-state",
                                            :history [["+" "1.7.10"]],
                                            :type "function",
                                            :full-name-encode "cljs.analyzer.api/empty-state",
                                            :source {:code "(defn empty-state\n  ([]\n   (if-not (nil? env/*compiler*)\n     env/*compiler*\n     (env/default-compiler-env)))\n  ([opts]\n   (env/default-compiler-env opts)))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/clojure/cljs/analyzer/api.cljc",
                                                     :lines [25 34]},
                                            :full-name "cljs.analyzer.api/empty-state",
                                            :docstring "Creates an empty compilation state Atom<Map>. The optional opts arg is a map\nrepresenting the compiler configuration. See the documentation\nfor details: https://clojurescript.org/reference/compiler-options"},
           "cljs.spec.gen.alpha/uuid" {:ns "cljs.spec.gen.alpha",
                                       :name "uuid",
                                       :signature ["[& args]"],
                                       :name-encode "uuid",
                                       :history [["+" "1.9.542"]],
                                       :type "function",
                                       :full-name-encode "cljs.spec.gen.alpha/uuid",
                                       :source {:code "(lazy-prims any any-printable boolean char char-alpha char-alphanumeric char-ascii double\n  int keyword keyword-ns large-integer ratio simple-type simple-type-printable\n  string string-ascii string-alphanumeric symbol symbol-ns uuid)",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/spec/gen/alpha.cljs",
                                                :lines [74 76]},
                                       :full-name "cljs.spec.gen.alpha/uuid",
                                       :docstring "Fn returning clojure.test.check.generators/uuid"},
           "cljs.core/defonce" {:ns "cljs.core",
                                :name "defonce",
                                :signature ["[x init]"],
                                :name-encode "defonce",
                                :history [["+" "0.0-2156"]],
                                :type "macro",
                                :full-name-encode "cljs.core/defonce",
                                :source {:code "(core/defmacro defonce\n  [x init]\n  (core/let [qualified (if (namespace x)\n                         x\n                         (symbol (core/str (core/-> &env :ns :name)) (name x)))]\n    `(when-not (exists? ~qualified)\n       (def ~x ~init))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/clojure/cljs/core.cljc",
                                         :lines [619 627]},
                                :full-name "cljs.core/defonce",
                                :docstring "defs name to have the root value of init iff the named var has no root value,\nelse init is unevaluated"},
           "cljs.core/nil?" {:return-type boolean,
                             :ns "cljs.core",
                             :name "nil?",
                             :signature ["[x]"],
                             :name-encode "nilQMARK",
                             :history [["+" "0.0-927"]],
                             :type "function/macro",
                             :full-name-encode "cljs.core/nilQMARK",
                             :source {:code "(defn ^boolean nil?\n  [x]\n  (coercive-= x nil))",
                                      :title "Function code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [241 244]},
                             :extra-sources [{:code "(core/defmacro nil? [x]\n  `(coercive-= ~x nil))",
                                              :title "Macro code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/clojure/cljs/core.cljc",
                                              :lines [899 900]}],
                             :full-name "cljs.core/nil?",
                             :docstring "Returns true if x is nil, false otherwise."},
           "cljs.spec.gen.alpha/symbol-ns" {:ns "cljs.spec.gen.alpha",
                                            :name "symbol-ns",
                                            :signature ["[& args]"],
                                            :name-encode "symbol-ns",
                                            :history [["+" "1.9.542"]],
                                            :type "function",
                                            :full-name-encode "cljs.spec.gen.alpha/symbol-ns",
                                            :source {:code "(lazy-prims any any-printable boolean char char-alpha char-alphanumeric char-ascii double\n  int keyword keyword-ns large-integer ratio simple-type simple-type-printable\n  string string-ascii string-alphanumeric symbol symbol-ns uuid)",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/cljs/cljs/spec/gen/alpha.cljs",
                                                     :lines [74 76]},
                                            :full-name "cljs.spec.gen.alpha/symbol-ns",
                                            :docstring "Fn returning clojure.test.check.generators/symbol-ns"},
           "cljs.spec/assert" {:ns "cljs.spec",
                               :name "assert",
                               :signature ["[spec x]"],
                               :name-encode "assert",
                               :history [["+" "1.9.216"]
                                         ["-" "1.9.542"]],
                               :type "macro",
                               :full-name-encode "cljs.spec/assert",
                               :source {:code "(defmacro assert\n  [spec x]\n  `(if *compile-asserts*\n     (if *runtime-asserts*\n       (assert* ~spec ~x)\n       ~x)\n    ~x))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.9.521",
                                        :filename "src/main/cljs/cljs/spec.cljc",
                                        :lines [532 548]},
                               :full-name "cljs.spec/assert",
                               :docstring "spec-checking assert expression. Returns x if x is valid? according\nto spec, else throws an error with explain-data plus ::failure of\n:assertion-failed.\nCan be disabled at either compile time or runtime:\nIf *compile-asserts* is false at compile time, compiles to x. Defaults\nto the negation value of the ':elide-asserts' compiler option, or true if\nnot set.\nIf (check-asserts?) is false at runtime, always returns x. Defaults to\nvalue of 'cljs.spec/*runtime-asserts*', or false if not set. You can\ntoggle check-asserts? with (check-asserts bool).",
                               :removed {:in "1.9.542",
                                         :last-seen "1.9.521"}},
           "cljs.core/any?" {:ns "cljs.core",
                             :name "any?",
                             :signature ["[x]"],
                             :name-encode "anyQMARK",
                             :history [["+" "1.9.183"]],
                             :type "function",
                             :full-name-encode "cljs.core/anyQMARK",
                             :source {:code "(defn any?\n  [x] true)",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [287 289]},
                             :full-name "cljs.core/any?",
                             :docstring "Returns true if given any argument."},
           "cljs.repl.rhino/bootjs" {:return-type String,
                                     :ns "cljs.repl.rhino",
                                     :name "bootjs",
                                     :name-encode "bootjs",
                                     :history [["+" "0.0-927"]
                                               ["-" "1.10.738"]],
                                     :type "var",
                                     :full-name-encode "cljs.repl.rhino/bootjs",
                                     :source {:code "(def ^String bootjs\n  (str \"var global = this;\\n\"\n       \"var CLOSURE_IMPORT_SCRIPT = function(src) {\\n\"\n       \"    var ns = \\\"cljs.repl.rhino\\\",\"\n       \"        name = \\\"load-file\\\",\"\n       \"        loadFile = Packages.clojure.lang.RT[\\\"var\\\"](ns,name);\\n\"\n       \"    if(src) loadFile.invoke(___repl_env, __repl_opts, src);\\n\"\n       \"    return true;\\n\"\n       \"};\\n\"))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.10.597",
                                              :filename "src/main/clojure/cljs/repl/rhino.clj",
                                              :lines [25 33]},
                                     :full-name "cljs.repl.rhino/bootjs",
                                     :removed {:in "1.10.738",
                                               :last-seen "1.10.597"}},
           "cljs.core/load-file*" {:ns "cljs.core",
                                   :name "load-file*",
                                   :signature ["[f]"],
                                   :name-encode "load-fileSTAR",
                                   :history [["+" "0.0-2719"]
                                             ["-" "1.9.493"]
                                             ["+" "1.9.494"]],
                                   :type "macro",
                                   :full-name-encode "cljs.core/load-fileSTAR",
                                   :source {:code "(core/defmacro load-file* [f]\n  `(goog/nodeGlobalRequire ~f))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/clojure/cljs/core.cljc",
                                            :lines [3093 3094]},
                                   :full-name "cljs.core/load-file*"},
           "cljs.core/load-namespace" {:ns "cljs.core",
                                       :name "load-namespace",
                                       :name-encode "load-namespace",
                                       :history [["+" "0.0-927"]],
                                       :type "special form (repl)",
                                       :full-name-encode "cljs.core/load-namespace",
                                       :source {:code "(def default-special-fns\n  (let [load-file-fn\n        (fn self\n          ([repl-env env form]\n            (self repl-env env form nil))\n          ([repl-env env [_ file :as form] opts]\n            (load-file repl-env file opts)))\n        in-ns-fn\n        (fn self\n          ([repl-env env form]\n           (self repl-env env form nil))\n          ([repl-env env [_ [quote ns-name] :as form] _]\n            ;; guard against craziness like '5 which wreaks havoc\n           (when-not (and (= quote 'quote) (symbol? ns-name))\n             (throw (IllegalArgumentException. \"Argument to in-ns must be a symbol.\")))\n           (when-not (ana/get-namespace ns-name)\n             (swap! env/*compiler* assoc-in [::ana/namespaces ns-name] {:name ns-name})\n             (-evaluate repl-env \"<cljs repl>\" 1\n               (str \"goog.provide('\" (comp/munge ns-name) \"');\")))\n           (set! ana/*cljs-ns* ns-name)))\n        load-fn\n        (fn self\n          ([repl-env env form]\n           (self env repl-env form nil))\n          ([repl-env env [_ & paths :as form] opts]\n           (let [cp-paths (map load-path->cp-path paths)]\n             (run! #(load-file repl-env % opts) cp-paths))))]\n    (wrap-special-fns wrap-self\n     {'in-ns in-ns-fn\n      'clojure.core/in-ns in-ns-fn\n      'load-file load-file-fn\n      'clojure.core/load-file load-file-fn\n      'load-namespace\n      (fn self\n        ([repl-env env form]\n         (self env repl-env form nil))\n        ([repl-env env [_ ns :as form] opts]\n         (load-namespace repl-env ns opts)))\n      'load load-fn\n      'clojure.core/load load-fn})))",
                                                :title "repl specials table",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/clojure/cljs/repl.cljc",
                                                :lines [754 793]},
                                       :full-name "cljs.core/load-namespace",
                                       :repl-only? true},
           "clojure.walk/stringify-keys" {:ns "clojure.walk",
                                          :name "stringify-keys",
                                          :signature ["[m]"],
                                          :name-encode "stringify-keys",
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "clojure.walk/stringify-keys",
                                          :source {:code "(defn stringify-keys\n  {:added \"1.1\"}\n  [m]\n  (let [f (fn [[k v]] (if (keyword? k) [(name k) v] [k v]))]\n    ;; only apply to maps\n    (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/cljs/clojure/walk.cljs",
                                                   :lines [76 82]},
                                          :full-name "clojure.walk/stringify-keys",
                                          :docstring "Recursively transforms all map keys from keywords to strings."},
           "cljs.spec/multi-spec" {:ns "cljs.spec",
                                   :name "multi-spec",
                                   :signature ["[mm retag]"],
                                   :name-encode "multi-spec",
                                   :history [["+" "1.9.14"]
                                             ["-" "1.9.542"]],
                                   :type "macro",
                                   :full-name-encode "cljs.spec/multi-spec",
                                   :source {:code "(defmacro multi-spec\n  [mm retag]\n  `(multi-spec-impl '~(res &env mm) (var ~mm) ~retag))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.9.521",
                                            :filename "src/main/cljs/cljs/spec.cljc",
                                            :lines [86 113]},
                                   :full-name "cljs.spec/multi-spec",
                                   :docstring "Takes the name of a spec/predicate-returning multimethod and a\ntag-restoring keyword or fn (retag).  Returns a spec that when\nconforming or explaining data will pass it to the multimethod to get\nan appropriate spec. You can e.g. use multi-spec to dynamically and\nextensibly associate specs with 'tagged' data (i.e. data where one\nof the fields indicates the shape of the rest of the structure).\n\n(defmulti mspec :tag)\n\nThe methods should ignore their argument and return a predicate/spec:\n(defmethod mspec :int [_] (s/keys :req-un [::tag ::i]))\n\nretag is used during generation to retag generated values with\nmatching tags. retag can either be a keyword, at which key the\ndispatch-tag will be assoc'ed, or a fn of generated value and\ndispatch-tag that should return an appropriately retagged value.\n\nNote that because the tags themselves comprise an open set,\nthe tag key spec cannot enumerate the values, but can e.g.\ntest for keyword?.\n\nNote also that the dispatch values of the multimethod will be\nincluded in the path, i.e. in reporting and gen overrides, even\nthough those values are not evident in the spec.",
                                   :removed {:in "1.9.542",
                                             :last-seen "1.9.521"}},
           "clojure.browser.repl/order" {:ns "clojure.browser.repl",
                                         :name "order",
                                         :name-encode "order",
                                         :type "var",
                                         :full-name-encode "clojure.browser.repl/order",
                                         :source {:code "(def order (atom 0))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/cljs/clojure/browser/repl.cljs",
                                                  :lines [96]},
                                         :full-name "clojure.browser.repl/order",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/memoize" {:ns "cljs.core",
                                :name "memoize",
                                :signature ["[f]"],
                                :name-encode "memoize",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/memoize",
                                :source {:code "(defn memoize\n  [f]\n  (let [mem (atom {})]\n    (fn [& args]\n      (let [v (get @mem args lookup-sentinel)]\n        (if (identical? v lookup-sentinel)\n          (let [ret (apply f args)]\n            (swap! mem assoc args ret)\n            ret)\n          v)))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [11240 11253]},
                                :full-name "cljs.core/memoize",
                                :docstring "Returns a memoized version of a referentially transparent function. The\nmemoized version of the function keeps a cache of the mapping from arguments\nto results and, when calls with the same arguments are repeated often, has\nhigher performance at the expense of higher memory use."},
           "warnings/undeclared" {:ns "warnings",
                                  :name "undeclared",
                                  :name-encode "undeclared",
                                  :type "warning",
                                  :full-name-encode "warnings/undeclared",
                                  :full-name "warnings/undeclared",
                                  :history [["+" "0.0-1835"]
                                            ["-" "0.0-2014"]],
                                  :removed {:in "0.0-2014",
                                            :last-seen "0.0-1978"}},
           "cljs.core/pr-sequential" {:ns "cljs.core",
                                      :name "pr-sequential",
                                      :signature ["[print-one begin sep end opts coll]"],
                                      :name-encode "pr-sequential",
                                      :history [["+" "0.0-927"]
                                                ["-" "0.0-1798"]],
                                      :type "function",
                                      :full-name-encode "cljs.core/pr-sequential",
                                      :source {:code "(defn ^:deprecated pr-sequential\n  [print-one begin sep end opts coll]\n  (concat [begin]\n          (flatten1\n            (interpose [sep] (map #(print-one % opts) coll)))\n          [end]))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1586",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [6210 6217]},
                                      :full-name "cljs.core/pr-sequential",
                                      :docstring "Do not use this.  It is kept for backwards compatibility with the\nold IPrintable protocol.",
                                      :removed {:in "0.0-1798",
                                                :last-seen "0.0-1586"}},
           "cljs.js/load-source-map!" {:ns "cljs.js",
                                       :name "load-source-map!",
                                       :signature ["[state ns sm-json]"],
                                       :name-encode "load-source-mapBANG",
                                       :history [["+" "1.7.10"]],
                                       :type "function",
                                       :full-name-encode "cljs.js/load-source-mapBANG",
                                       :source {:code "(defn load-source-map! [state ns sm-json]\n  (let [sm (sm/decode (.parse js/JSON sm-json))]\n    (swap! state assoc-in [:source-maps ns] sm)))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/js.cljs",
                                                :lines [144 146]},
                                       :full-name "cljs.js/load-source-map!"},
           "warnings/undeclared-ns" {:ns "warnings",
                                     :name "undeclared-ns",
                                     :name-encode "undeclared-ns",
                                     :type "warning",
                                     :full-name-encode "warnings/undeclared-ns",
                                     :full-name "warnings/undeclared-ns",
                                     :history [["+" "0.0-2014"]]},
           "cljs.build.api/get-node-deps" {:ns "cljs.build.api",
                                           :name "get-node-deps",
                                           :signature ["[dependencies]"
                                                       "[dependencies opts]"],
                                           :name-encode "get-node-deps",
                                           :history [["+" "1.9.854"]],
                                           :type "function",
                                           :full-name-encode "cljs.build.api/get-node-deps",
                                           :source {:code "(defn get-node-deps\n  ([dependencies]\n   (if (compiler-opts? dependencies)\n     (get-node-deps (keys (:npm-deps dependencies)) dependencies)\n     (get-node-deps dependencies\n       (when-let [state (ana-api/current-state)]\n         (:options @state)))))\n  ([dependencies opts]\n   {:pre [(sequential? dependencies)]}\n   (closure/index-node-modules\n     (distinct (concat (keys (:npm-deps opts)) (map str dependencies)))\n     opts)))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/clojure/cljs/build/api.clj",
                                                    :lines [273 290]},
                                           :full-name "cljs.build.api/get-node-deps",
                                           :docstring "EXPERIMENTAL: Get the Node.js dependency graph of the supplied dependencies.\nDependencies must be a sequence of strings or symbols naming packages or paths\nwithin packages (e.g. [react \"react-dom/server\"] or a valid compiler options\nmap. Assumes dependencies have been been previously installed, either by\n`cljs.build.api/install-node-deps!` or by an NPM client, and reside in the\n`node_modules` directory."},
           "cljs.math/sin" {:return-type number,
                            :ns "cljs.math",
                            :name "sin",
                            :signature ["[a]"],
                            :name-encode "sin",
                            :history [["+" "1.11.50"]],
                            :type "function",
                            :full-name-encode "cljs.math/sin",
                            :source {:code "(defn ^number sin\n  {:added \"1.11.10\"}\n  [a] (Math/sin a))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/cljs/cljs/math.cljs",
                                     :lines [80 86]},
                            :full-name "cljs.math/sin",
                            :docstring "Returns the sine of an angle.\nIf a is ##NaN, ##-Inf, ##Inf => ##NaN\nIf a is zero => zero with the same sign as a\nSee: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sin"},
           "clojure.zip/make-node" {:ns "clojure.zip",
                                    :name "make-node",
                                    :signature ["[loc node children]"],
                                    :name-encode "make-node",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "clojure.zip/make-node",
                                    :source {:code "(defn make-node\n  [loc node children]\n    ((:zip/make-node (meta loc)) node children))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/clojure/zip.cljs",
                                             :lines [76 80]},
                                    :full-name "clojure.zip/make-node",
                                    :docstring "Returns a new branch node, given an existing node and new\nchildren. The loc is only used to supply the constructor."},
           "syntax/deref" {:syntax-equiv {:edn-url nil, :clj-url nil},
                           :ns "syntax",
                           :name "deref",
                           :name-encode "deref",
                           :history [["+" "0.0-1853"]],
                           :type "syntax",
                           :full-name-encode "syntax/deref",
                           :extra-sources ({:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                            :title "Reader table",
                                            :repo "tools.reader",
                                            :tag "v1.3.6",
                                            :filename "src/main/clojure/clojure/tools/reader.clj",
                                            :lines [788 807]}),
                           :full-name "syntax/deref"},
           "cljs.spec.test/check-1" {:ns "cljs.spec.test",
                                     :name "check-1",
                                     :signature ["[[quote s :as qs] f spec opts]"],
                                     :name-encode "check-1",
                                     :history [["+" "1.9.183"]
                                               ["-" "1.9.542"]],
                                     :type "macro",
                                     :full-name-encode "cljs.spec.test/check-1",
                                     :source {:code "(defmacro check-1\n  [[quote s :as qs] f spec opts]\n  (let [{:keys [name] :as v} (when qs (ana-api/resolve &env s))]\n    `(let [s#        '~name\n           opts#     ~opts\n           v#        ~(when v `(var ~name))\n           spec#     (or ~spec ~(when v `(s/get-spec (var ~name))))\n           re-inst?# (and v# (seq (unstrument '~name)) true)\n           f#        (or ~f (when v# @v#))]\n       (try\n         (cond\n           (nil? f#)\n           {:failure (ex-info \"No fn to spec\" {::s/failure :no-fn})\n            :sym     s# :spec spec#}\n\n           (:args spec#)\n           (let [tcret# (quick-check f# spec# opts#)]\n             (make-check-result s# spec# tcret#))\n\n           :default\n           {:failure (ex-info \"No :args spec\" {::s/failure :no-args-spec})\n            :sym     s# :spec spec#})\n         (finally\n           (when re-inst?# (instrument '~name)))))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.9.521",
                                              :filename "src/main/cljs/cljs/spec/test.cljc",
                                              :lines [150 173]},
                                     :full-name "cljs.spec.test/check-1",
                                     :removed {:in "1.9.542",
                                               :last-seen "1.9.521"}},
           "cljs.core/PersistentVector.EMPTY" {:ns "cljs.core",
                                               :name "PersistentVector.EMPTY",
                                               :name-encode "PersistentVectorDOTEMPTY",
                                               :history [["+"
                                                          "0.0-1006"]],
                                               :parent-type "PersistentVector",
                                               :type "var",
                                               :full-name-encode "cljs.core/PersistentVectorDOTEMPTY",
                                               :source {:code "(set! (.-EMPTY PersistentVector)\n  (PersistentVector. nil 0 5 (.-EMPTY-NODE PersistentVector) (array) empty-ordered-hash))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.12.38",
                                                        :filename "src/main/cljs/cljs/core.cljs",
                                                        :lines [5825
                                                                5826]},
                                               :full-name "cljs.core/PersistentVector.EMPTY"},
           "cljs.reader/float-pattern" {:ns "cljs.reader",
                                        :name "float-pattern",
                                        :name-encode "float-pattern",
                                        :history [["+" "0.0-927"]
                                                  ["-" "1.9.854"]],
                                        :type "var",
                                        :full-name-encode "cljs.reader/float-pattern",
                                        :source {:code "(def float-pattern (re-pattern \"^([-+]?[0-9]+(\\\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?$\"))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.9.671",
                                                 :filename "src/main/cljs/cljs/reader.cljs",
                                                 :lines [101]},
                                        :full-name "cljs.reader/float-pattern",
                                        :removed {:in "1.9.854",
                                                  :last-seen "1.9.671"}},
           "cljs.core/find-ns-obj" {:ns "cljs.core",
                                    :name "find-ns-obj",
                                    :signature ["[ns]"],
                                    :name-encode "find-ns-obj",
                                    :history [["+" "1.7.10"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/find-ns-obj",
                                    :source {:code "(defn find-ns-obj\n  [ns]\n  (let [munged-ns (munge (str ns))\n        segs (.split munged-ns \".\")]\n    (case *target*\n      \"nodejs\"  (if ^boolean js/COMPILED\n                  ; Under simple optimizations on nodejs, namespaces will be in module\n                  ; rather than global scope and must be accessed by a direct call to eval.\n                  ; The first segment may refer to an undefined variable, so its evaluation\n                  ; may throw ReferenceError.\n                  (find-ns-obj*\n                    (try\n                      (let [ctxt (js/eval (first segs))]\n                        (when (and ctxt (object? ctxt))\n                          ctxt))\n                      (catch js/ReferenceError e\n                        nil))\n                    (next segs))\n                  (find-ns-obj* goog/global segs))\n      (\"default\" \"webworker\") (find-ns-obj* goog/global segs)\n      (throw (js/Error. (str \"find-ns-obj not supported for target \" *target*))))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [12141 12162]},
                                    :full-name "cljs.core/find-ns-obj",
                                    :docstring "Bootstrap only."},
           "cljs.spec.gen.alpha/bind" {:ns "cljs.spec.gen.alpha",
                                       :name "bind",
                                       :signature ["[& args]"],
                                       :name-encode "bind",
                                       :history [["+" "1.9.542"]],
                                       :type "function",
                                       :full-name-encode "cljs.spec.gen.alpha/bind",
                                       :source {:code "(lazy-combinators hash-map list map not-empty set vector vector-distinct fmap elements\n  bind choose one-of such-that tuple sample return\n  large-integer* double* frequency shuffle)",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/spec/gen/alpha.cljs",
                                                :lines [70 72]},
                                       :full-name "cljs.spec.gen.alpha/bind",
                                       :docstring "Lazy loaded version of clojure.test.check.generators/bind"},
           "cljs.core/ancestors" {:ns "cljs.core",
                                  :name "ancestors",
                                  :signature ["[tag]" "[h tag]"],
                                  :name-encode "ancestors",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/ancestors",
                                  :source {:code "(defn ancestors\n  ([tag] (ancestors @(get-global-hierarchy) tag))\n  ([h tag] (not-empty (get (:ancestors h) tag))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [11345 11351]},
                                  :full-name "cljs.core/ancestors",
                                  :docstring "Returns the immediate and indirect parents of tag, either via a JavaScript type\ninheritance relationship or a relationship established via derive. h\nmust be a hierarchy obtained from make-hierarchy, if not supplied\ndefaults to the global hierarchy"},
           "cljs.js/compile-str" {:ns "cljs.js",
                                  :name "compile-str",
                                  :signature ["[state source cb]"
                                              "[state source name cb]"
                                              "[state source name opts cb]"],
                                  :name-encode "compile-str",
                                  :history [["+" "1.7.28"]],
                                  :type "function",
                                  :full-name-encode "cljs.js/compile-str",
                                  :source {:code "(defn compile-str\n  ([state source cb]\n   (compile-str state source nil cb))\n  ([state source name cb]\n   (compile-str state source name nil cb))\n  ([state source name opts cb]\n   {:pre [(atom? state) (string? source)\n          (valid-name? name) (valid-opts? opts) (fn? cb)]}\n   (compile-str*\n     {:*compiler*     state\n      :*data-readers* tags/*cljs-data-readers*\n      :*cljs-dep-set* ana/*cljs-dep-set*\n      :*analyze-deps* (:analyze-deps opts true)\n      :*load-macros*  (:load-macros opts true)\n      :*load-fn*      (or (:load opts) *load-fn*)\n      :*eval-fn*      (or (:eval opts) *eval-fn*)\n      :*sm-data*      (when (:source-map opts) (sm-data))}\n     source name opts cb)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/js.cljs",
                                           :lines [974 1034]},
                                  :full-name "cljs.js/compile-str",
                                  :docstring "Compile ClojureScript source into JavaScript. The parameters:\n\nstate (atom)\n  the compiler state\n\nsource (string)\n  the ClojureScript source\n\nname (symbol or string)\n  optional, the name of the source - used as key in :source-maps\n\nopts (map)\n  compilation options.\n\n   :eval             - eval function to invoke, see *eval-fn*\n   :load             - library resolution function, see *load-fn*\n   :source-map       - set to true to generate inline source map information\n   :def-emits-var    - sets whether def (and derived) forms return either a Var\n                       (if set to true) or the def init value (if false). Default\n                       is false.\n   :checked-arrays   - if :warn or :error, checks inferred types and values passed\n                       to aget/aset. Logs for incorrect values if :warn, throws if\n                       :error. Defaults to false.\n   :static-fns       - employ static dispatch to specific function arities in\n                       emitted JavaScript, as opposed to making use of the\n                       `call` construct. Defaults to false.\n   :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\n                       unknown functions, but instead direct invokes via\n                       `f(a0,a1...)`. Defaults to `false`.\n   :target           - use `:nodejs` if targeting Node.js. Takes no other options\n                       at the moment.\n   :ns               - optional, the namespace in which to evaluate the source.\n   :verbose          - optional, emit details from compiler activity. Defaults to\n                       false.\n   :context          - optional, sets the context for the source. Possible values\n                       are `:expr`, `:statement` and `:return`. Defaults to\n                       `:statement`.\n\ncb (function)\n  callback, will be invoked with a map. If successful the map will contain\n  a key :value with the compilation result (string). If unsuccessful the map\n  will contain a key :error with an ex-info instance describing the cause\n  of failure."},
           "cljs.core/integer?" {:ns "cljs.core",
                                 :name "integer?",
                                 :signature ["[n]"],
                                 :name-encode "integerQMARK",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/integerQMARK",
                                 :source {:code "(defn integer?\n  [n]\n  (and (number? n)\n       (not ^boolean (js/isNaN n))\n       (not (identical? n js/Infinity))\n       (== (js/parseFloat n) (js/parseInt n 10))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [2329 2335]},
                                 :full-name "cljs.core/integer?",
                                 :docstring "Returns true if n is a JavaScript number with no decimal part."},
           "compiler-options/cache-analysis" {:ns "compiler-options",
                                              :name "cache-analysis",
                                              :name-encode "cache-analysis",
                                              :type "option",
                                              :full-name-encode "compiler-options/cache-analysis",
                                              :full-name "compiler-options/cache-analysis",
                                              :history [["+"
                                                         "0.0-2511"]]},
           "cljs.js/compile" {:ns "cljs.js",
                              :name "compile",
                              :signature ["[state source cb]"
                                          "[state source name cb]"
                                          "[state source name opts cb]"],
                              :name-encode "compile",
                              :history [["+" "1.7.10"] ["-" "1.7.28"]],
                              :type "function",
                              :full-name-encode "cljs.js/compile",
                              :source {:code "(defn compile\n  ([state source cb]\n   (compile state source nil cb))\n  ([state source name cb]\n   (compile state source name nil cb))\n  ([state source name opts cb]\n   {:pre [(atom? state) (string? source)\n          (valid-name? name) (valid-opts? opts) (fn? cb)]}\n   (compile*\n     {:*compiler*     state\n      :*data-readers* tags/*cljs-data-readers*\n      :*analyze-deps* (or (:analyze-deps opts) true)\n      :*load-macros*  (or (:load-macros opts) true)\n      :*load-fn*      (or (:load opts) *load-fn*)\n      :*eval-fn*      (or (:eval opts) *eval-fn*)\n      :*sm-data*      (when (:source-map opts) (sm-data))}\n     source name opts cb)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.7.10",
                                       :filename "src/main/cljs/cljs/js.cljs",
                                       :lines [580 618]},
                              :full-name "cljs.js/compile",
                              :docstring "Compile ClojureScript source into JavaScript. The parameters:\n\nstate (atom)\n  the compiler state\n\nsource (string)\n  the ClojureScript source\n\nname (symbol)\n  optional, the name of the source\n\nopts (map)\n  compilation options.\n\n  :load       - library resolution function, see *load-fn*\n  :source-map - set to true to generate inline source map information\n\ncb (function)\n  callback, will be invoked with a map. If successful the map will contain\n  a key :value with the compilation result (string). If unsuccessful the map\n  will contain a key :error with an ex-info instance describing the cause\n  of failure.",
                              :removed {:in "1.7.28",
                                        :last-seen "1.7.10"}},
           "cljs.core/HashMap.EMPTY" {:ns "cljs.core",
                                      :name "HashMap.EMPTY",
                                      :name-encode "HashMapDOTEMPTY",
                                      :history [["+" "0.0-927"]
                                                ["-" "0.0-1798"]],
                                      :parent-type "HashMap",
                                      :type "var",
                                      :full-name-encode "cljs.core/HashMapDOTEMPTY",
                                      :source {:code "(set! cljs.core.HashMap/EMPTY (HashMap. nil 0 (js-obj) 0))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1586",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [3830]},
                                      :full-name "cljs.core/HashMap.EMPTY",
                                      :removed {:in "0.0-1798",
                                                :last-seen "0.0-1586"}},
           "cljs.core/int?" {:ns "cljs.core",
                             :name "int?",
                             :signature ["[x]"],
                             :name-encode "intQMARK",
                             :history [["+" "1.9.75"]],
                             :type "function",
                             :full-name-encode "cljs.core/intQMARK",
                             :source {:code "(defn int?\n  [x]\n  (or (integer? x)\n      (instance? goog.math.Integer x)\n      (instance? goog.math.Long x)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [2341 2347]},
                             :full-name "cljs.core/int?",
                             :docstring "Return true if x satisfies integer? or is an instance of goog.math.Integer\nor goog.math.Long."},
           "cljs.core/Vector.EMPTY" {:ns "cljs.core",
                                     :name "Vector.EMPTY",
                                     :name-encode "VectorDOTEMPTY",
                                     :history [["+" "0.0-927"]
                                               ["-" "0.0-1798"]],
                                     :parent-type "Vector",
                                     :type "var",
                                     :full-name-encode "cljs.core/VectorDOTEMPTY",
                                     :source {:code "(set! cljs.core.Vector/EMPTY (Vector. nil (array) 0))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1586",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [2859]},
                                     :full-name "cljs.core/Vector.EMPTY",
                                     :removed {:in "0.0-1798",
                                               :last-seen "0.0-1586"}},
           "clojure.zip/xml-zip" {:ns "clojure.zip",
                                  :name "xml-zip",
                                  :signature ["[root]"],
                                  :name-encode "xml-zip",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.zip/xml-zip",
                                  :source {:code "(defn xml-zip\n  [root]\n    (zipper (complement string?) \n            (comp seq :content)\n            (fn [node children]\n              (assoc node :content (and children (apply vector children))))\n            root))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/clojure/zip.cljs",
                                           :lines [50 58]},
                                  :full-name "clojure.zip/xml-zip",
                                  :docstring "Returns a zipper for xml elements (as from xml/parse),\ngiven a root element"},
           "clojure.walk/walk" {:ns "clojure.walk",
                                :name "walk",
                                :signature ["[inner outer form]"],
                                :name-encode "walk",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "clojure.walk/walk",
                                :source {:code "(defn walk\n  {:added \"1.1\"}\n  [inner outer form]\n  (cond\n    (list? form)      (outer (apply list (map inner form)))\n    (map-entry? form)\n    (outer (MapEntry. (inner (key form)) (inner (val form)) nil))\n    (seq? form)       (outer (doall (map inner form)))\n    (record? form)    (outer (reduce (fn [r x] (conj r (inner x))) form form))\n    (coll? form)      (outer (into (empty form) (map inner form)))\n    :else             (outer form)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/clojure/walk.cljs",
                                         :lines [37 52]},
                                :full-name "clojure.walk/walk",
                                :docstring "Traverses form, an arbitrary data structure.  inner and outer are\nfunctions.  Applies inner to each element of form, building up a\ndata structure of the same type, then applies outer to the result.\nRecognizes all Clojure data structures. Consumes seqs as with doall."},
           "cljs.spec.gen.alpha/generate" {:ns "cljs.spec.gen.alpha",
                                           :name "generate",
                                           :signature ["[generator]"],
                                           :name-encode "generate",
                                           :history [["+" "1.9.542"]],
                                           :type "function",
                                           :full-name-encode "cljs.spec.gen.alpha/generate",
                                           :source {:code "(defn generate\n    [generator]\n    (@g generator))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/cljs/cljs/spec/gen/alpha.cljs",
                                                    :lines [51 54]},
                                           :full-name "cljs.spec.gen.alpha/generate",
                                           :docstring "Generate a single value using generator."},
           "cljs.math/multiply-exact" {:return-type number,
                                       :ns "cljs.math",
                                       :name "multiply-exact",
                                       :signature ["[x y]"],
                                       :name-encode "multiply-exact",
                                       :history [["+" "1.11.50"]],
                                       :type "function",
                                       :full-name-encode "cljs.math/multiply-exact",
                                       :source {:code "(defn ^number multiply-exact\n  {:added \"1.11.10\"}\n  [x y]\n  (let [r (* x y)]\n    (if (or (> r js/Number.MAX_SAFE_INTEGER) (< r js/Number.MIN_SAFE_INTEGER))\n      (throw (ex-info \"Integer overflow\" {:fn \"multiply-exact\"}))\n      r)))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/math.cljs",
                                                :lines [534 541]},
                                       :full-name "cljs.math/multiply-exact",
                                       :docstring "Returns the product of x and y, throws ArithmeticException on overflow. "},
           "cljs.core/ifn?" {:ns "cljs.core",
                             :name "ifn?",
                             :signature ["[f]"],
                             :name-encode "ifnQMARK",
                             :history [["+" "0.0-1211"]],
                             :type "function",
                             :full-name-encode "cljs.core/ifnQMARK",
                             :source {:code "(defn ifn?\n  [f]\n  (or (fn? f) (satisfies? IFn f)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [2324 2327]},
                             :full-name "cljs.core/ifn?",
                             :docstring "Returns true if f returns true for fn? or satisfies IFn."},
           "cljs.analyzer.api/the-ns" {:ns "cljs.analyzer.api",
                                       :name "the-ns",
                                       :signature ["[ns]"
                                                   "[state sym]"],
                                       :name-encode "the-ns",
                                       :history [["+" "1.12.35"]],
                                       :type "function",
                                       :full-name-encode "cljs.analyzer.api/the-ns",
                                       :source {:code "(defn the-ns\n  ([ns]\n   (the-ns env/*compiler* ns))\n  ([state sym]\n   {:pre [(symbol? sym)]}\n   (or (find-ns state sym)\n       (throw (ex-info (str \"No namespace found: \" sym) {:ns sym})))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/clojure/cljs/analyzer/api.cljc",
                                                :lines [230 238]},
                                       :full-name "cljs.analyzer.api/the-ns",
                                       :docstring "Given a namespace return the corresponding namespace analysis map, throwing an\nexception if not found. Analagous to clojure.core/the-ns."},
           "cljs.core/Cycle" {:protocols #{"ISeqable"
                                           "IMeta"
                                           "IWithMeta"
                                           "IEmptyableCollection"
                                           "IPending"
                                           "IReduce"
                                           "ISequential"
                                           "ISeq"
                                           "ICollection"
                                           "IPrintWithWriter"
                                           "INext"},
                              :ns "cljs.core",
                              :name "Cycle",
                              :signature ["[meta all prev current _next]"],
                              :name-encode "Cycle",
                              :history [["+" "1.10.63"]],
                              :type "type",
                              :full-name-encode "cljs.core/Cycle",
                              :source {:code "(deftype Cycle [meta all prev ^:mutable current ^:mutable _next]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (currentval [coll]\n    (when-not ^seq current\n      (if-let [c (next prev)]\n        (set! current c)\n        (set! current all)))\n    current)\n\n  IPending\n  (-realized? [coll]\n    (some? current))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (Cycle. new-meta all prev current _next)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll]\n    (first (.currentval coll)))\n  (-rest [coll]\n    (when (nil? _next)\n      (set! _next (Cycle. nil all (.currentval coll) nil nil)))\n    _next)\n\n  INext\n  (-next [coll]\n    (-rest coll))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (.-EMPTY List))\n\n  ISequential\n  ISeqable\n  (-seq [coll] coll)\n\n  IReduce\n  (-reduce [coll f]\n    (loop [s (.currentval coll) ret (first s)]\n      (let [s   (or (next s) all)\n            ret (f ret (first s))]\n        (if (reduced? ret)\n          @ret\n          (recur s ret)))))\n  (-reduce [coll f start]\n    (loop [s (.currentval coll) ret start]\n      (let [ret (f ret (first s))]\n        (if (reduced? ret)\n          @ret\n          (recur (or (next s) all) ret))))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [4952 5011]},
                              :full-name "cljs.core/Cycle"},
           "cljs.core/bit-xor" {:ns "cljs.core",
                                :name "bit-xor",
                                :signature ["[x y]" "[x y & more]"],
                                :name-encode "bit-xor",
                                :history [["+" "0.0-927"]],
                                :type "function/macro",
                                :full-name-encode "cljs.core/bit-xor",
                                :source {:code "(defn bit-xor\n  ([x y] (cljs.core/bit-xor x y))\n  ([x y & more]\n     (reduce bit-xor (cljs.core/bit-xor x y) more)))",
                                         :title "Function code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [2937 2941]},
                                :extra-sources [{:code "(core/defmacro ^::ana/numeric bit-xor\n  ([x y] (core/list 'js* \"(~{} ^ ~{})\" x y))\n  ([x y & more] `(bit-xor (bit-xor ~x ~y) ~@more)))",
                                                 :title "Macro code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/clojure/cljs/core.cljc",
                                                 :lines [1214 1216]}],
                                :full-name "cljs.core/bit-xor",
                                :docstring "Bitwise exclusive or"},
           "clojure.set/union" {:ns "clojure.set",
                                :name "union",
                                :signature ["[]"
                                            "[s1]"
                                            "[s1 s2]"
                                            "[s1 s2 & sets]"],
                                :name-encode "union",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "clojure.set/union",
                                :source {:code "(defn union\n  ([] #{})\n  ([s1] s1)\n  ([s1 s2]\n     (if (< (count s1) (count s2))\n       (reduce conj s2 s1)\n       (reduce conj s1 s2)))\n  ([s1 s2 & sets]\n     (let [bubbled-sets (bubble-max-key count (conj sets s2 s1))]\n       (reduce into (first bubbled-sets) (rest bubbled-sets)))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/clojure/set.cljs",
                                         :lines [19 29]},
                                :full-name "clojure.set/union",
                                :docstring "Return a set that is the union of the input sets"},
           "cljs.repl/tear-down" {:ns "cljs.repl",
                                  :name "tear-down",
                                  :signature ["[repl-env]"],
                                  :name-encode "tear-down",
                                  :history [["+" "1.10.63"]],
                                  :type "function",
                                  :full-name-encode "cljs.repl/tear-down",
                                  :source {:code "(defn tear-down [repl-env]\n  (-tear-down repl-env))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/clojure/cljs/repl.cljc",
                                           :lines [136 137]},
                                  :full-name "cljs.repl/tear-down"},
           "cljs.spec.test/checkable-syms*" {:ns "cljs.spec.test",
                                             :name "checkable-syms*",
                                             :signature ["[]"
                                                         "[opts]"],
                                             :name-encode "checkable-symsSTAR",
                                             :history [["+" "1.9.183"]
                                                       ["-" "1.9.542"]],
                                             :type "function",
                                             :full-name-encode "cljs.spec.test/checkable-symsSTAR",
                                             :source {:code "(defn checkable-syms*\n  ([]\n    (checkable-syms* nil))\n  ([opts]\n   (reduce into #{}\n     [(filter fn-spec-name? (keys @s/registry-ref))\n      (keys (:spec opts))])))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.9.521",
                                                      :filename "src/main/cljs/cljs/spec/test.cljc",
                                                      :lines [185 191]},
                                             :full-name "cljs.spec.test/checkable-syms*",
                                             :removed {:in "1.9.542",
                                                       :last-seen "1.9.521"}},
           "compiler-options/rename-prefix" {:ns "compiler-options",
                                             :name "rename-prefix",
                                             :name-encode "rename-prefix",
                                             :type "option",
                                             :full-name-encode "compiler-options/rename-prefix",
                                             :full-name "compiler-options/rename-prefix",
                                             :history [["+" "1.9.946"]]},
           "cljs.spec.alpha/fspec" {:ns "cljs.spec.alpha",
                                    :name "fspec",
                                    :signature ["[& {:keys [args ret fn gen], :or {ret (quote cljs.core/any?)}}]"],
                                    :name-encode "fspec",
                                    :history [["+" "1.9.542"]],
                                    :type "macro",
                                    :full-name-encode "cljs.spec.alpha/fspec",
                                    :source {:code "(defmacro fspec\n  [& {:keys [args ret fn gen] :or {ret `cljs.core/any?}}]\n  (let [env &env]\n    `(fspec-impl (spec ~args) '~(res env args)\n                           (spec ~ret) '~(res env ret)\n                           (spec ~fn) '~(res env fn) ~gen)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/spec/alpha.cljc",
                                             :lines [388 406]},
                                    :full-name "cljs.spec.alpha/fspec",
                                    :docstring "takes :args :ret and (optional) :fn kwargs whose values are preds\nand returns a spec whose conform/explain take a fn and validates it\nusing generative testing. The conformed value is always the fn itself.\n\nSee 'fdef' for a single operation that creates an fspec and\nregisters it, as well as a full description of :args, :ret and :fn\n\nfspecs can generate functions that validate the arguments and\nfabricate a return value compliant with the :ret spec, ignoring\nthe :fn spec if present.\n\nOptionally takes :gen generator-fn, which must be a fn of no args\nthat returns a test.check generator."},
           "cljs.core/case" {:ns "cljs.core",
                             :name "case",
                             :signature ["[e & clauses]"],
                             :name-encode "case",
                             :history [["+" "0.0-1211"]],
                             :type "macro",
                             :full-name-encode "cljs.core/case",
                             :source {:code "(core/defmacro case\n  [e & clauses]\n  (core/let [esym    (gensym)\n             default (if (odd? (count clauses))\n                       (last clauses)\n                       `(throw\n                          (js/Error.\n                            (cljs.core/str \"No matching clause: \" ~esym))))\n             env     &env\n             pairs   (reduce\n                       (core/fn [m [test expr]]\n                         (core/cond\n                           (seq? test)\n                           (reduce\n                             (core/fn [m test]\n                               (core/let [test (if (core/symbol? test)\n                                                 (core/list 'quote test)\n                                                 test)]\n                                 (assoc-test m test expr env)))\n                             m test)\n                           (core/symbol? test)\n                           (assoc-test m (core/list 'quote test) expr env)\n                           :else\n                           (assoc-test m test expr env)))\n                     {} (partition 2 clauses))\n             tests   (keys pairs)]\n    (core/cond\n      (every? (some-fn core/number? core/string? #?(:clj core/char? :cljs (core/fnil core/char? :nonchar)) #(const? env %)) tests)\n      (core/let [no-default (if (odd? (count clauses)) (butlast clauses) clauses)\n                 tests      (mapv #(if (seq? %) (vec %) [%]) (take-nth 2 no-default))\n                 thens      (vec (take-nth 2 (drop 1 no-default)))]\n        `(let [~esym ~e] (case* ~esym ~tests ~thens ~default)))\n\n      (every? core/keyword? tests)\n      (core/let [no-default (if (odd? (count clauses)) (butlast clauses) clauses)\n                 kw-str #(.substring (core/str %) 1)\n                 tests (mapv #(if (seq? %) (mapv kw-str %) [(kw-str %)]) (take-nth 2 no-default))\n                 thens (vec (take-nth 2 (drop 1 no-default)))]\n        `(let [~esym ~e\n               ~esym (if (keyword? ~esym) (.-fqn ~(vary-meta esym assoc :tag 'cljs.core/Keyword)) nil)]\n           (case* ~esym ~tests ~thens ~default)))\n\n      ;; equality\n      :else\n      `(let [~esym ~e]\n         (cond\n           ~@(mapcat (core/fn [[m c]] `((cljs.core/= ~m ~esym) ~c)) pairs)\n           :else ~default)))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/clojure/cljs/core.cljc",
                                      :lines [2362 2431]},
                             :full-name "cljs.core/case",
                             :docstring "Takes an expression, and a set of clauses.\n\nEach clause can take the form of either:\n\ntest-constant result-expr\n\n(test-constant1 ... test-constantN)  result-expr\n\nThe test-constants are not evaluated. They must be compile-time\nliterals, and need not be quoted.  If the expression is equal to a\ntest-constant, the corresponding result-expr is returned. A single\ndefault expression can follow the clauses, and its value will be\nreturned if no clause matches. If no default expression is provided\nand no clause matches, an Error is thrown.\n\nUnlike cond and condp, case does a constant-time dispatch, the\nclauses are not considered sequentially.  All manner of constant\nexpressions are acceptable in case, including numbers, strings,\nsymbols, keywords, and (ClojureScript) composites thereof. Note that since\nlists are used to group multiple constants that map to the same\nexpression, a vector can be used to match a list if needed. The\ntest-constants need not be all of the same type."},
           "cljs.repl/IJavaScriptEnv" {:ns "cljs.repl",
                                       :name "IJavaScriptEnv",
                                       :name-encode "IJavaScriptEnv",
                                       :history [["+" "0.0-927"]],
                                       :type "protocol",
                                       :full-name-encode "cljs.repl/IJavaScriptEnv",
                                       :source {:code "(defprotocol IJavaScriptEnv\n  (-setup [repl-env opts] \"initialize the environment\")\n  (-evaluate [repl-env filename line js] \"evaluate a javascript string\")\n  (-load [repl-env provides url] \"load code at url into the environment\")\n  (-tear-down [repl-env] \"dispose of the environment\"))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/clojure/cljs/repl.cljc",
                                                :lines [121 125]},
                                       :methods [{:name "-setup",
                                                  :signature ["[repl-env opts]"],
                                                  :docstring "initialize the environment"}
                                                 {:name "-evaluate",
                                                  :signature ["[repl-env filename line js]"],
                                                  :docstring "evaluate a javascript string"}
                                                 {:name "-load",
                                                  :signature ["[repl-env provides url]"],
                                                  :docstring "load code at url into the environment"}
                                                 {:name "-tear-down",
                                                  :signature ["[repl-env]"],
                                                  :docstring "dispose of the environment"}],
                                       :full-name "cljs.repl/IJavaScriptEnv"},
           "cljs.reader/PushbackReader" {:ns "cljs.reader",
                                         :name "PushbackReader",
                                         :name-encode "PushbackReader",
                                         :history [["+" "0.0-927"]
                                                   ["-" "1.9.854"]],
                                         :type "protocol",
                                         :full-name-encode "cljs.reader/PushbackReader",
                                         :source {:code "(defprotocol PushbackReader\n  (read-char [reader] \"Returns the next char from the Reader,\nnil if the end of stream has been reached\")\n  (unread [reader ch] \"Push back a single character on to the stream\"))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.9.671",
                                                  :filename "src/main/cljs/cljs/reader.cljs",
                                                  :lines [14 17]},
                                         :methods [{:name "read-char",
                                                    :signature ["[reader]"],
                                                    :docstring "Returns the next char from the Reader,\nnil if the end of stream has been reached"}
                                                   {:name "unread",
                                                    :signature ["[reader ch]"],
                                                    :docstring "Push back a single character on to the stream"}],
                                         :full-name "cljs.reader/PushbackReader",
                                         :removed {:in "1.9.854",
                                                   :last-seen "1.9.671"}},
           "cljs.core/nat-int?" {:ns "cljs.core",
                                 :name "nat-int?",
                                 :signature ["[x]"],
                                 :name-encode "nat-intQMARK",
                                 :history [["+" "1.9.75"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/nat-intQMARK",
                                 :source {:code "(defn nat-int?\n  [x]\n  (cond\n    (integer? x)\n    (not (neg? x))\n\n    (instance? goog.math.Integer x)\n    (not (.isNegative x))\n\n    (instance? goog.math.Long x)\n    (not (.isNegative x))\n\n    :else false))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [2379 2392]},
                                 :full-name "cljs.core/nat-int?",
                                 :docstring "Return true if x satisfies int? and is a natural integer value."},
           "cljs.repl.rhino/-main" {:ns "cljs.repl.rhino",
                                    :name "-main",
                                    :signature ["[& args]"],
                                    :name-encode "-main",
                                    :history [["+" "0.0-3165"]
                                              ["-" "1.10.738"]],
                                    :type "function",
                                    :full-name-encode "cljs.repl.rhino/-main",
                                    :source {:code "(defn -main [& args]\n  (apply cli/main repl-env args))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.10.597",
                                             :filename "src/main/clojure/cljs/repl/rhino.clj",
                                             :lines [232 233]},
                                    :full-name "cljs.repl.rhino/-main",
                                    :removed {:in "1.10.738",
                                              :last-seen "1.10.597"}},
           "cljs.repl.nashorn/repl-env*" {:ns "cljs.repl.nashorn",
                                          :name "repl-env*",
                                          :signature ["[{:keys [debug], :as opts}]"],
                                          :name-encode "repl-envSTAR",
                                          :history [["+" "0.0-3030"]
                                                    ["-" "1.10.738"]],
                                          :type "function",
                                          :full-name-encode "cljs.repl.nashorn/repl-envSTAR",
                                          :source {:code "(defn repl-env* [{:keys [debug] :as opts}]\n      (let [engine (create-engine opts)]\n        (merge\n          (NashornEnv. engine debug)\n          opts)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.10.597",
                                                   :filename "src/main/clojure/cljs/repl/nashorn.clj",
                                                   :lines [160 164]},
                                          :full-name "cljs.repl.nashorn/repl-env*",
                                          :removed {:in "1.10.738",
                                                    :last-seen "1.10.597"}},
           "compiler-options/warning-handlers" {:ns "compiler-options",
                                                :name "warning-handlers",
                                                :name-encode "warning-handlers",
                                                :type "option",
                                                :full-name-encode "compiler-options/warning-handlers",
                                                :full-name "compiler-options/warning-handlers",
                                                :history [["+"
                                                           "1.7.10"]]},
           "cljs.core/isa?" {:return-type boolean,
                             :ns "cljs.core",
                             :name "isa?",
                             :signature ["[child parent]"
                                         "[h child parent]"],
                             :name-encode "isaQMARK",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/isaQMARK",
                             :source {:code "(defn ^boolean isa?\n  ([child parent] (isa? @(get-global-hierarchy) child parent))\n  ([h child parent]\n     (or (= child parent)\n         ;; (and (class? parent) (class? child)\n         ;;    (. ^Class parent isAssignableFrom child))\n         (contains? ((:ancestors h) child) parent)\n         ;;(and (class? child) (some #(contains? ((:ancestors h) %) parent) (supers child)))\n         (and (vector? parent) (vector? child)\n              (== (count parent) (count child))\n              (loop [ret true i 0]\n                (if (or (not ret) (== i (count parent)))\n                  ret\n                  (recur (isa? h (child i) (parent i)) (inc i))))))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [11317 11335]},
                             :full-name "cljs.core/isa?",
                             :docstring "Returns true if (= child parent), or child is directly or indirectly derived from\nparent, either via a JavaScript type inheritance relationship or a\nrelationship established via derive. h must be a hierarchy obtained\nfrom make-hierarchy, if not supplied defaults to the global\nhierarchy"},
           "cljs.core/abs" {:return-type number,
                            :ns "cljs.core",
                            :name "abs",
                            :signature ["[a]"],
                            :name-encode "abs",
                            :history [["+" "1.11.50"]],
                            :type "function",
                            :full-name-encode "cljs.core/abs",
                            :source {:code "(defn ^number abs\n  {:added \"1.11.10\"}\n  [a] (Math/abs a))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [2766 2769]},
                            :full-name "cljs.core/abs",
                            :docstring "Returns the absolute value of a."},
           "cljs.repl.node/-main" {:ns "cljs.repl.node",
                                   :name "-main",
                                   :signature ["[& args]"],
                                   :name-encode "-main",
                                   :history [["+" "0.0-3165"]],
                                   :type "function",
                                   :full-name-encode "cljs.repl.node/-main",
                                   :source {:code "(defn -main [& args]\n  (apply cli/main repl-env args))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/clojure/cljs/repl/node.clj",
                                            :lines [252 253]},
                                   :full-name "cljs.repl.node/-main"},
           "cljs.repl/compilable?" {:ns "cljs.repl",
                                    :name "compilable?",
                                    :signature ["[input]"],
                                    :name-encode "compilableQMARK",
                                    :history [["+" "1.10.191"]],
                                    :type "function",
                                    :full-name-encode "cljs.repl/compilableQMARK",
                                    :source {:code "(defn compilable? [input]\n  (contains? input :source-file))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/clojure/cljs/repl.cljc",
                                             :lines [206 207]},
                                    :full-name "cljs.repl/compilable?"},
           "cljs.spec.impl.gen/dynaload" {:ns "cljs.spec.impl.gen",
                                          :name "dynaload",
                                          :signature ["[[quote s]]"],
                                          :name-encode "dynaload",
                                          :history [["+" "1.9.14"]
                                                    ["-" "1.9.542"]],
                                          :type "macro",
                                          :full-name-encode "cljs.spec.impl.gen/dynaload",
                                          :source {:code "(defmacro dynaload [[quote s]]\n  (let [xs     (string/split (namespace s) #\"\\.\")\n        cnt    (count xs)\n        checks (map\n                 (fn [n xs]\n                   `(c/exists? ~(symbol (string/join \".\" (take n xs)))))\n                 (range 2 cnt)\n                 (repeat xs))]\n    `(cljs.spec.impl.gen/LazyVar.\n       (fn []\n         (if (and ~@checks (c/exists? ~s))\n           ~(vary-meta s assoc :cljs.analyzer/no-resolve true)\n           (throw\n             (js/Error.\n               (str \"Var \" '~s \" does not exist, \"\n                    (namespace '~s) \" never required\")))))\n       nil)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.9.521",
                                                   :filename "src/main/cljs/cljs/spec/impl/gen.cljc",
                                                   :lines [14 30]},
                                          :full-name "cljs.spec.impl.gen/dynaload",
                                          :removed {:in "1.9.542",
                                                    :last-seen "1.9.521"}},
           "cljs.pprint/PrettyFlush" {:ns "cljs.pprint",
                                      :name "PrettyFlush",
                                      :name-encode "PrettyFlush",
                                      :history [["+" "0.0-2496"]
                                                ["-" "0.0-3255"]],
                                      :type "protocol",
                                      :full-name-encode "cljs.pprint/PrettyFlush",
                                      :source {:code "(defprotocol PrettyFlush (ppflush [this]))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r3211",
                                               :filename "src/cljs/cljs/pprint.cljs",
                                               :lines [120]},
                                      :methods [{:name "ppflush",
                                                 :signature ["[this]"],
                                                 :docstring nil}],
                                      :full-name "cljs.pprint/PrettyFlush",
                                      :removed {:in "0.0-3255",
                                                :last-seen "0.0-3211"}},
           "cljs.build.api/add-dependencies" {:ns "cljs.build.api",
                                              :name "add-dependencies",
                                              :signature ["[opts & ijss]"],
                                              :name-encode "add-dependencies",
                                              :history [["+"
                                                         "0.0-3291"]],
                                              :type "function",
                                              :full-name-encode "cljs.build.api/add-dependencies",
                                              :source {:code "(defn add-dependencies\n  [opts & ijss]\n  (closure/add-dependencies opts ijss))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.12.38",
                                                       :filename "src/main/clojure/cljs/build/api.clj",
                                                       :lines [149
                                                               154]},
                                              :full-name "cljs.build.api/add-dependencies",
                                              :docstring "DEPRECATED: Given one or more IJavaScript objects in dependency order, produce\na new sequence of IJavaScript objects which includes the input list\nplus all dependencies in dependency order."},
           "clojure.browser.net/xhr-connection" {:ns "clojure.browser.net",
                                                 :name "xhr-connection",
                                                 :signature ["[]"],
                                                 :name-encode "xhr-connection",
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.browser.net/xhr-connection",
                                                 :source {:code "(defn xhr-connection\n  []\n  (XhrIo.))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r1.12.38",
                                                          :filename "src/main/cljs/clojure/browser/net.cljs",
                                                          :lines [82
                                                                  85]},
                                                 :full-name "clojure.browser.net/xhr-connection",
                                                 :docstring "Returns an XhrIo connection"},
           "cljs.spec/fn-specs" {:ns "cljs.spec",
                                 :name "fn-specs",
                                 :signature ["[v]"],
                                 :name-encode "fn-specs",
                                 :history [["+" "1.9.14"]
                                           ["-" "1.9.75"]],
                                 :type "function",
                                 :full-name-encode "cljs.spec/fn-specs",
                                 :source {:code "(defn fn-specs\n  [v]\n  (let [s (->sym v)\n        reg (registry)]\n    (reduce\n      (fn [m role]\n        (assoc m role (get reg (fn-spec-sym s role))))\n      {}\n      fn-spec-roles)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.9.36",
                                          :filename "src/main/cljs/cljs/spec.cljs",
                                          :lines [264 273]},
                                 :full-name "cljs.spec/fn-specs",
                                 :docstring "Returns :args/:ret/:fn map of specs for var or symbol v.",
                                 :removed {:in "1.9.75",
                                           :last-seen "1.9.36"}},
           "cljs.core/js-fn?" {:ns "cljs.core",
                               :name "js-fn?",
                               :signature ["[x]"],
                               :name-encode "js-fnQMARK",
                               :history [["+" "1.10.844"]],
                               :type "macro",
                               :full-name-encode "cljs.core/js-fnQMARK",
                               :source {:code "(core/defmacro js-fn? [x]\n  (bool-expr (core/list 'js* \"typeof ~{} === 'function'\" x)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/clojure/cljs/core.cljc",
                                        :lines [973 974]},
                               :full-name "cljs.core/js-fn?"},
           "cljs.core/as->" {:ns "cljs.core",
                             :name "as->",
                             :signature ["[expr name & forms]"],
                             :name-encode "as-GT",
                             :history [["+" "0.0-1798"]],
                             :type "macro",
                             :full-name-encode "cljs.core/as-GT",
                             :source {:code "(defmacro as->\n  {:added \"1.5\"}\n  [expr name & forms]\n  `(let [~name ~expr\n         ~@(interleave (repeat name) (butlast forms))]\n     ~(if (empty? forms)\n        name\n        (last forms))))",
                                      :title "Source code",
                                      :repo "clojure",
                                      :tag "clojure-1.10.0",
                                      :filename "src/clj/clojure/core.clj",
                                      :lines [7572 7582]},
                             :full-name "cljs.core/as->",
                             :docstring "Binds name to expr, evaluates the first form in the lexical context\nof that binding, then binds name to that result, repeating for each\nsuccessive form, returning the result of the last form."},
           "clojure.core.reducers/reducer" {:ns "clojure.core.reducers",
                                            :name "reducer",
                                            :signature ["[coll xf]"],
                                            :name-encode "reducer",
                                            :history [["+" "0.0-1236"]],
                                            :type "function",
                                            :full-name-encode "clojure.core.reducers/reducer",
                                            :source {:code "(defn reducer\n  ([coll xf]\n     (reify\n       cljs.core/IReduce\n       (-reduce [this f1]\n         (-reduce this f1 (f1)))\n       (-reduce [_ f1 init]\n         (-reduce coll (xf f1) init)))))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/cljs/clojure/core/reducers.cljs",
                                                     :lines [66 77]},
                                            :full-name "clojure.core.reducers/reducer",
                                            :docstring "Given a reducible collection, and a transformation function xf,\nreturns a reducible collection, where any supplied reducing\nfn will be transformed by xf. xf is a function of reducing fn to\nreducing fn."},
           "cljs.repl.server/gzip" {:return-type bytes,
                                    :ns "cljs.repl.server",
                                    :name "gzip",
                                    :signature ["[bytes]"],
                                    :name-encode "gzip",
                                    :history [["+" "1.10.126"]],
                                    :type "function",
                                    :full-name-encode "cljs.repl.server/gzip",
                                    :source {:code "(defn ^bytes gzip [^bytes bytes]\n  (let [baos (ByteArrayOutputStream. (count bytes))]\n    (try\n      (let [gzos (GZIPOutputStream. baos)]\n        (try\n          (.write gzos bytes)\n          (finally\n            (.close gzos))))\n      (finally\n        (.close baos)))\n    (.toByteArray baos)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/clojure/cljs/repl/server.clj",
                                             :lines [132 142]},
                                    :full-name "cljs.repl.server/gzip"},
           "warnings/protocol-invalid-method" {:ns "warnings",
                                               :name "protocol-invalid-method",
                                               :name-encode "protocol-invalid-method",
                                               :type "warning",
                                               :full-name-encode "warnings/protocol-invalid-method",
                                               :full-name "warnings/protocol-invalid-method",
                                               :history [["+"
                                                          "0.0-2341"]]},
           "cljs.core/uuid" {:ns "cljs.core",
                             :name "uuid",
                             :signature ["[s]"],
                             :name-encode "uuid",
                             :history [["+" "0.0-3291"]],
                             :type "function",
                             :full-name-encode "cljs.core/uuid",
                             :source {:code "(defn uuid\n  [s]\n  (assert (string? s))\n  (UUID. (.toLowerCase s) nil))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [11739 11743]},
                             :full-name "cljs.core/uuid",
                             :docstring "Returns a UUID consistent with the string s."},
           "cljs.spec.gen.alpha/char-alphanumeric" {:ns "cljs.spec.gen.alpha",
                                                    :name "char-alphanumeric",
                                                    :signature ["[& args]"],
                                                    :name-encode "char-alphanumeric",
                                                    :history [["+"
                                                               "1.9.542"]],
                                                    :type "function",
                                                    :full-name-encode "cljs.spec.gen.alpha/char-alphanumeric",
                                                    :source {:code "(lazy-prims any any-printable boolean char char-alpha char-alphanumeric char-ascii double\n  int keyword keyword-ns large-integer ratio simple-type simple-type-printable\n  string string-ascii string-alphanumeric symbol symbol-ns uuid)",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r1.12.38",
                                                             :filename "src/main/cljs/cljs/spec/gen/alpha.cljs",
                                                             :lines [74
                                                                     76]},
                                                    :full-name "cljs.spec.gen.alpha/char-alphanumeric",
                                                    :docstring "Fn returning clojure.test.check.generators/char-alphanumeric"},
           "cljs.core/subs" {:ns "cljs.core",
                             :name "subs",
                             :signature ["[s start]" "[s start end]"],
                             :name-encode "subs",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/subs",
                             :source {:code "(defn subs\n  ([s start] ^string (.substring s start))\n  ([s start end] ^string (.substring s start end)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [3064 3068]},
                             :full-name "cljs.core/subs",
                             :docstring "Returns the substring of s beginning at start inclusive, and ending\nat end (defaults to length of string), exclusive."},
           "syntax/unquote" {:syntax-equiv {:edn-url nil,
                                            :clj-url nil},
                             :ns "syntax",
                             :name "unquote",
                             :name-encode "unquote",
                             :history [["+" "0.0-1853"]],
                             :type "syntax",
                             :full-name-encode "syntax/unquote",
                             :extra-sources ({:code "(defn- read-unquote\n  [rdr comma opts pending-forms]\n  (if-let [ch (peek-char rdr)]\n    (if (identical? \\@ ch)\n      ((wrapping-reader 'clojure.core/unquote-splicing) (doto rdr read-char) \\@ opts pending-forms)\n      ((wrapping-reader 'clojure.core/unquote) rdr \\~ opts pending-forms))))",
                                              :title "Reader code",
                                              :repo "tools.reader",
                                              :tag "v1.3.6",
                                              :filename "src/main/clojure/clojure/tools/reader.clj",
                                              :lines [598 603]}
                                             {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                              :title "Reader table",
                                              :repo "tools.reader",
                                              :tag "v1.3.6",
                                              :filename "src/main/clojure/clojure/tools/reader.clj",
                                              :lines [788 807]}),
                             :full-name "syntax/unquote"},
           "cljs.core/float?" {:ns "cljs.core",
                               :name "float?",
                               :signature ["[x]"],
                               :name-encode "floatQMARK",
                               :history [["+" "1.9.293"]],
                               :type "function",
                               :full-name-encode "cljs.core/floatQMARK",
                               :source {:code "(defn float?\n  [x]\n  (number? x))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [2394 2397]},
                               :full-name "cljs.core/float?",
                               :docstring "Returns true for JavaScript numbers, false otherwise."},
           "cljs.core/symbol?" {:return-type boolean,
                                :ns "cljs.core",
                                :name "symbol?",
                                :signature ["[x]"],
                                :name-encode "symbolQMARK",
                                :history [["+" "0.0-927"]],
                                :type "function/macro",
                                :full-name-encode "cljs.core/symbolQMARK",
                                :source {:code "(defn ^boolean symbol?\n  [x]\n  (instance? Symbol x))",
                                         :title "Function code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [1075 1078]},
                                :extra-sources [{:code "(core/defmacro symbol? [x]\n  (bool-expr `(instance? Symbol ~x)))",
                                                 :title "Macro code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/clojure/cljs/core.cljc",
                                                 :lines [1013 1014]}],
                                :full-name "cljs.core/symbol?",
                                :docstring "Return true if x is a Symbol"},
           "warnings/infer-warning" {:ns "warnings",
                                     :name "infer-warning",
                                     :name-encode "infer-warning",
                                     :type "warning",
                                     :full-name-encode "warnings/infer-warning",
                                     :full-name "warnings/infer-warning",
                                     :history [["+" "1.9.456"]]},
           "compiler-options/language-in" {:ns "compiler-options",
                                           :name "language-in",
                                           :name-encode "language-in",
                                           :type "option",
                                           :full-name-encode "compiler-options/language-in",
                                           :full-name "compiler-options/language-in",
                                           :history [["+" "0.0-2197"]]},
           "clojure.data/Diff" {:ns "clojure.data",
                                :name "Diff",
                                :name-encode "Diff",
                                :history [["+" "0.0-1503"]],
                                :type "protocol",
                                :full-name-encode "clojure.data/Diff",
                                :source {:code "(defprotocol Diff\n  (diff-similar [a b] \"Implementation detail. Subject to change.\"))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/clojure/data.cljs",
                                         :lines [79 81]},
                                :methods [{:name "diff-similar",
                                           :signature ["[a b]"],
                                           :docstring "Implementation detail. Subject to change."}],
                                :full-name "clojure.data/Diff",
                                :docstring "Implementation detail. Subject to change."},
           "clojure.string/replace" {:return-type string,
                                     :ns "clojure.string",
                                     :name "replace",
                                     :signature ["[s match replacement]"],
                                     :name-encode "replace",
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "clojure.string/replace",
                                     :source {:code "(defn ^string replace\n  [s match replacement]\n  (cond\n    (string? match)\n    (.replace s (js/RegExp. (gstring/regExpEscape match) \"g\") replacement)\n\n    (instance? js/RegExp match)\n    (if (string? replacement)\n      (replace-all s match replacement)\n      (replace-all s match (replace-with replacement)))\n\n    :else (throw (str \"Invalid match arg: \" match))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/cljs/clojure/string.cljs",
                                              :lines [44 74]},
                                     :full-name "clojure.string/replace",
                                     :docstring "Replaces all instance of match with replacement in s.\n\nmatch/replacement can be:\n\nstring / string\npattern / (string or function of match).\n\nSee also replace-first.\n\nThe replacement is literal (i.e. none of its characters are treated\nspecially) for all cases above except pattern / string.\n\nFor pattern / string, $1, $2, etc. in the replacement string are\nsubstituted with the string that matched the corresponding\nparenthesized group in the pattern.\n\nExample:\n(clojure.string/replace \"Almost Pig Latin\" #\"\\b(\\w)(\\w+)\\b\" \"$2$1ay\")\n-> \"lmostAay igPay atinLay\""},
           "cljs.spec/unstrument*" {:ns "cljs.spec",
                                    :name "unstrument*",
                                    :signature ["[v]"],
                                    :name-encode "unstrumentSTAR",
                                    :history [["+" "1.9.14"]
                                              ["-" "1.9.183"]],
                                    :type "function",
                                    :full-name-encode "cljs.spec/unstrumentSTAR",
                                    :source {:code "(defn unstrument*\n  [v]\n  (locking instrumented-vars\n           (when-let [{:keys [raw wrapped]} (get @instrumented-vars v)]\n             (let [current @v]\n               (when (= wrapped current)\n                 (swap! instrumented-vars dissoc v)\n                 raw)))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.9.93",
                                             :filename "src/main/cljs/cljs/spec.cljs",
                                             :lines [345 352]},
                                    :full-name "cljs.spec/unstrument*",
                                    :removed {:in "1.9.183",
                                              :last-seen "1.9.93"}},
           "cljs.core/string?" {:return-type boolean,
                                :ns "cljs.core",
                                :name "string?",
                                :signature ["[x]"],
                                :name-encode "stringQMARK",
                                :history [["+" "0.0-927"]],
                                :type "function/macro",
                                :full-name-encode "cljs.core/stringQMARK",
                                :source {:code "(defn ^boolean string?\n  [x]\n  (identical? \"string\" (goog/typeOf x)))",
                                         :title "Function code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [277 280]},
                                :extra-sources [{:code "(core/defmacro string? [x]\n  (bool-expr (core/list 'js* \"typeof ~{} === 'string'\" x)))",
                                                 :title "Macro code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/clojure/cljs/core.cljc",
                                                 :lines [970 971]}],
                                :full-name "cljs.core/string?",
                                :docstring "Returns true if x is a JavaScript string."},
           "cljs.core/*target*" {:ns "cljs.core",
                                 :name "*target*",
                                 :name-encode "STARtargetSTAR",
                                 :history [["+" "0.0-2985"]],
                                 :type "dynamic var",
                                 :full-name-encode "cljs.core/STARtargetSTAR",
                                 :source {:code "(goog-define\n  ^{:dynamic true}\n  *target* \"default\")",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [42 48]},
                                 :full-name "cljs.core/*target*",
                                 :docstring "Var bound to the name value of the compiler build :target option.\nFor example, if the compiler build :target is :nodejs, *target* will be bound\nto \"nodejs\". *target* is a Google Closure define and can be set by compiler\n:closure-defines option."},
           "cljs.core/*exec-tap-fn*" {:ns "cljs.core",
                                      :name "*exec-tap-fn*",
                                      :signature ["[f]"],
                                      :name-encode "STARexec-tap-fnSTAR",
                                      :history [["+" "1.10.63"]],
                                      :type "dynamic var",
                                      :full-name-encode "cljs.core/STARexec-tap-fnSTAR",
                                      :source {:code "(defn ^{:dynamic true}\n  *exec-tap-fn*\n  [f]\n  (and\n    (exists? js/setTimeout)\n    ;; See CLJS-3274 - workaround for recent WebKit releases\n    (boolean (js/setTimeout f 0))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [79 86]},
                                      :full-name "cljs.core/*exec-tap-fn*",
                                      :docstring "Arranges to have tap functions executed via the supplied f, a\nfunction of no arguments. Returns true if successful, false otherwise."},
           "cljs.core/Namespace" {:protocols #{"IHash" "IEquiv"},
                                  :ns "cljs.core",
                                  :name "Namespace",
                                  :signature ["[obj name]"],
                                  :name-encode "Namespace",
                                  :history [["+" "1.7.10"]],
                                  :type "type",
                                  :full-name-encode "cljs.core/Namespace",
                                  :source {:code "(deftype Namespace [obj name]\n  Object\n  (findInternedVar [this sym]\n    (let [k (munge (str sym))]\n      (when ^boolean (gobject/containsKey obj k)\n        (let [var-sym (symbol (str name) (str sym))\n              var-meta {:ns this}]\n          (Var. (ns-lookup obj k) var-sym var-meta)))))\n  (getName [_] name)\n  (toString [_]\n    (str name))\n  IEquiv\n  (-equiv [_ other]\n    (if (instance? Namespace other)\n      (= name (.-name other))\n      false))\n  IHash\n  (-hash [_]\n    (hash name)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [12109 12127]},
                                  :full-name "cljs.core/Namespace"},
           "cljs.core/partition-all" {:ns "cljs.core",
                                      :name "partition-all",
                                      :signature ["[n]"
                                                  "[n coll]"
                                                  "[n step coll]"],
                                      :name-encode "partition-all",
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "cljs.core/partition-all",
                                      :source {:code "(defn partition-all\n  ([n]\n   (fn [rf]\n     (let [a (array-list)]\n       (fn\n         ([] (rf))\n         ([result]\n            (let [result (if (.isEmpty a)\n                           result\n                           (let [v (vec (.toArray a))]\n                             ;;clear first!\n                             (.clear a)\n                             (unreduced (rf result v))))]\n              (rf result)))\n         ([result input]\n            (.add a input)\n            (if (== n (.size a))\n              (let [v (vec (.toArray a))]\n                (.clear a)\n                (rf result v))\n              result))))))\n  ([n coll]\n     (partition-all n n coll))\n  ([n step coll]\n     (lazy-seq\n      (when-let [s (seq coll)]\n        (cons (take n s) (partition-all n step (drop step s)))))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [9789 9818]},
                                      :full-name "cljs.core/partition-all",
                                      :docstring "Returns a lazy sequence of lists like partition, but may include\npartitions with fewer than n items at the end.  Returns a stateful\ntransducer when no collection is provided."},
           "cljs.core/Var" {:protocols #{"IFn"
                                         "IMeta"
                                         "IWithMeta"
                                         "IDeref"
                                         "Fn"
                                         "IHash"
                                         "IPrintWithWriter"
                                         "IEquiv"},
                            :ns "cljs.core",
                            :name "Var",
                            :signature ["[val sym _meta]"],
                            :name-encode "Var",
                            :history [["+" "0.0-2496"]],
                            :type "type",
                            :full-name-encode "cljs.core/Var",
                            :source {:code "(deftype Var [val sym _meta]\n  Object\n  (isMacro [_]\n    (. (val) -cljs$lang$macro))\n  (toString [_]\n    (str \"#'\" sym))\n  IDeref\n  (-deref [_] (val))\n  IMeta\n  (-meta [_] _meta)\n  IWithMeta\n  (-with-meta [_ new-meta]\n    (Var. val sym new-meta))\n  IEquiv\n  (-equiv [this other]\n    (if (instance? Var other)\n      (= (.-sym this) (.-sym other))\n      false))\n  IHash\n  (-hash [_]\n    (hash-symbol sym))\n  Fn\n  IFn\n  (-invoke [_]\n    ((val)))\n  (-invoke [_ a]\n    ((val) a))\n  (-invoke [_ a b]\n    ((val) a b))\n  (-invoke [_ a b c]\n    ((val) a b c))\n  (-invoke [_ a b c d]\n    ((val) a b c d))\n  (-invoke [_ a b c d e]\n    ((val) a b c d e))\n  (-invoke [_ a b c d e f]\n    ((val) a b c d e f))\n  (-invoke [_ a b c d e f g]\n    ((val) a b c d e f g))\n  (-invoke [_ a b c d e f g h]\n    ((val) a b c d e f g h))\n  (-invoke [_ a b c d e f g h i]\n    ((val) a b c d e f g h i))\n  (-invoke [_ a b c d e f g h i j]\n    ((val) a b c d e f g h i j))\n  (-invoke [_ a b c d e f g h i j k]\n    ((val) a b c d e f g h i j k))\n  (-invoke [_ a b c d e f g h i j k l]\n    ((val) a b c d e f g h i j k l))\n  (-invoke [_ a b c d e f g h i j k l m]\n    ((val) a b c d e f g h i j k l m))\n  (-invoke [_ a b c d e f g h i j k l m n]\n    ((val) a b c d e f g h i j k l m n))\n  (-invoke [_ a b c d e f g h i j k l m n o]\n    ((val) a b c d e f g h i j k l m n o))\n  (-invoke [_ a b c d e f g h i j k l m n o p]\n    ((val) a b c d e f g h i j k l m n o p))\n  (-invoke [_ a b c d e f g h i j k l m n o p q]\n    ((val) a b c d e f g h i j k l m n o p q))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r]\n    ((val) a b c d e f g h i j k l m n o p q r))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r s]\n    ((val) a b c d e f g h i j k l m n o p q r s))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r s t]\n    ((val) a b c d e f g h i j k l m n o p q r s t))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r s t rest]\n    (apply (val) a b c d e f g h i j k l m n o p q r s t rest)))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [1157 1223]},
                            :full-name "cljs.core/Var"},
           "cljs.core/RedNode" {:protocols #{"IFn"
                                             "ISeqable"
                                             "IMeta"
                                             "IWithMeta"
                                             "IReversible"
                                             "IStack"
                                             "IEmptyableCollection"
                                             "ICounted"
                                             "IReduce"
                                             "ILookup"
                                             "ISequential"
                                             "ICollection"
                                             "IHash"
                                             "IComparable"
                                             "IPrintWithWriter"
                                             "IIndexed"
                                             "IAssociative"
                                             "IVector"
                                             "IFind"
                                             "IEquiv"
                                             "IMapEntry"},
                                :ns "cljs.core",
                                :name "RedNode",
                                :signature ["[key val left right __hash]"],
                                :name-encode "RedNode",
                                :history [["+" "0.0-1211"]],
                                :type "type",
                                :full-name-encode "cljs.core/RedNode",
                                :source {:code "(deftype RedNode [key val left right ^:mutable __hash]\n  Object\n  (add-left [node ins]\n    (RedNode. key val ins right nil))\n\n  (add-right [node ins]\n    (RedNode. key val left ins nil))\n\n  (remove-left [node del]\n    (RedNode. key val del right nil))\n\n  (remove-right [node del]\n    (RedNode. key val left del nil))\n\n  (blacken [node]\n    (BlackNode. key val left right nil))\n\n  (redden [node]\n    (throw (js/Error. \"red-black tree invariant violation\")))\n\n  (balance-left [node parent]\n    (cond\n      (instance? RedNode left)\n      (RedNode. key val\n                (.blacken left)\n                (BlackNode. (.-key parent) (.-val parent) right (.-right parent) nil)\n                nil)\n\n      (instance? RedNode right)\n      (RedNode. (.-key right) (.-val right)\n                (BlackNode. key val left (.-left right) nil)\n                (BlackNode. (.-key parent) (.-val parent)\n                            (.-right right)\n                            (.-right parent)\n                            nil)\n                nil)\n\n      :else\n      (BlackNode. (.-key parent) (.-val parent) node (.-right parent) nil)))\n\n  (balance-right [node parent]\n    (cond\n      (instance? RedNode right)\n      (RedNode. key val\n                (BlackNode. (.-key parent) (.-val parent)\n                            (.-left parent)\n                            left\n                            nil)\n                (.blacken right)\n                nil)\n\n      (instance? RedNode left)\n      (RedNode. (.-key left) (.-val left)\n                (BlackNode. (.-key parent) (.-val parent)\n                            (.-left parent)\n                            (.-left left)\n                            nil)\n                (BlackNode. key val (.-right left) right nil)\n                nil)\n\n      :else\n      (BlackNode. (.-key parent) (.-val parent) (.-left parent) node nil)))\n\n  (replace [node key val left right]\n    (RedNode. key val left right nil))\n\n  (kv-reduce [node f init]\n    (tree-map-kv-reduce node f init))\n\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IMapEntry\n  (-key [node] key)\n  (-val [node] val)\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IMeta\n  (-meta [node] nil)\n\n  IWithMeta\n  (-with-meta [node meta]\n    (-with-meta [key val] meta))\n\n  IStack\n  (-peek [node] val)\n\n  (-pop [node] [key])\n\n  ICollection\n  (-conj [node o] [key val o])\n\n  IEmptyableCollection\n  (-empty [node] nil)\n\n  ISequential\n  ISeqable\n  (-seq [node] (IndexedSeq. #js [key val] 0 nil))\n\n  IReversible\n  (-rseq [node] (IndexedSeq. #js [val key] 0 nil))\n\n  ICounted\n  (-count [node] 2)\n\n  IIndexed\n  (-nth [node n]\n    (cond (== n 0) key\n          (== n 1) val\n          :else    (throw (js/Error. \"Index out of bounds\"))))\n\n  (-nth [node n not-found]\n    (cond (== n 0) key\n          (== n 1) val\n          :else    not-found))\n\n  ILookup\n  (-lookup [node k] (-nth node k nil))\n  (-lookup [node k not-found] (-nth node k not-found))\n\n  IAssociative\n  (-assoc [node k v]\n    (assoc [key val] k v))\n  (-contains-key? [node k]\n    (or (== k 0) (== k 1)))\n\n  IFind\n  (-find [node k]\n    (case k\n      0 (MapEntry. 0 key nil)\n      1 (MapEntry. 1 val nil)\n      nil))\n\n  IVector\n  (-assoc-n [node n v]\n    (-assoc-n [key val] n v))\n\n  IReduce\n  (-reduce [node f]\n    (ci-reduce node f))\n\n  (-reduce [node f start]\n    (ci-reduce node f start))\n\n  IFn\n  (-invoke [node k]\n    (-nth node k))\n\n  (-invoke [node k not-found]\n    (-nth node k not-found)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [8688 8848]},
                                :full-name "cljs.core/RedNode"},
           "cljs.repl/IParseStacktrace" {:ns "cljs.repl",
                                         :name "IParseStacktrace",
                                         :name-encode "IParseStacktrace",
                                         :history [["+" "0.0-2843"]],
                                         :type "protocol",
                                         :full-name-encode "cljs.repl/IParseStacktrace",
                                         :source {:code "(defprotocol IParseStacktrace\n  (-parse-stacktrace [repl-env stacktrace error build-options]\n    \"Given the original JavaScript stacktrace string, the entire original error\n     value and current compiler build options, parse the stacktrace into the\n     canonical form:\n\n     [{:file <string>\n       :function <string>\n       :line <integer>\n       :column <integer>}*]\n\n     :file must be a URL path (without protocol) relative to :output-dir. If\n     no source file can be supplied (such as REPL defs), :file may be a custom\n     identifier string surrounded by angle brackets, i.e. \\\"<cljs repl>\\\".\"))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/clojure/cljs/repl.cljc",
                                                  :lines [161 174]},
                                         :methods [{:name "-parse-stacktrace",
                                                    :signature ["[repl-env stacktrace error build-options]"],
                                                    :docstring "Given the original JavaScript stacktrace string, the entire original error\n     value and current compiler build options, parse the stacktrace into the\n     canonical form:\n\n     [{:file <string>\n       :function <string>\n       :line <integer>\n       :column <integer>}*]\n\n     :file must be a URL path (without protocol) relative to :output-dir. If\n     no source file can be supplied (such as REPL defs), :file may be a custom\n     identifier string surrounded by angle brackets, i.e. \"<cljs repl>\"."}],
                                         :full-name "cljs.repl/IParseStacktrace"},
           "cljs.core/ExceptionInfo" {:protocols #{"IPrintWithWriter"},
                                      :ns "cljs.core",
                                      :name "ExceptionInfo",
                                      :signature ["[message data cause]"],
                                      :name-encode "ExceptionInfo",
                                      :history [["+" "0.0-1576"]],
                                      :type "type",
                                      :full-name-encode "cljs.core/ExceptionInfo",
                                      :source {:code "(defn ^{:jsdoc [\"@constructor\"]}\n  ExceptionInfo [message data cause]\n  (let [e (js/Error. message)]\n    (this-as this\n      (set! (.-message this) message)\n      (set! (.-data this) data)\n      (set! (.-cause this) cause)\n      (do\n        (set! (.-name this) (.-name e))\n        ;; non-standard\n        (set! (.-description this) (.-description e))\n        (set! (.-number this) (.-number e))\n        (set! (.-fileName this) (.-fileName e))\n        (set! (.-lineNumber this) (.-lineNumber e))\n        (set! (.-columnNumber this) (.-columnNumber e))\n        (set! (.-stack this) (.-stack e)))\n      this)))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [11779 11795]},
                                      :full-name "cljs.core/ExceptionInfo"},
           "cljs.core/merge-with" {:ns "cljs.core",
                                   :name "merge-with",
                                   :signature ["[f & maps]"],
                                   :name-encode "merge-with",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/merge-with",
                                   :source {:code "(defn merge-with\n  [f & maps]\n  (when (some identity maps)\n    (let [merge-entry (fn [m e]\n                        (let [k (key e) v (val e)]\n                          (if (contains? m k)\n                            (assoc m k (f (get m k) v))\n                            (assoc m k v))))\n          merge2 (fn [m1 m2]\n                   (reduce merge-entry (or m1 {}) (seq m2)))]\n      (reduce merge2 maps))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [9343 9357]},
                                   :full-name "cljs.core/merge-with",
                                   :docstring "Returns a map that consists of the rest of the maps conj-ed onto\nthe first.  If a key occurs in more than one map, the mapping(s)\nfrom the latter (left-to-right) will be combined with the mapping in\nthe result by calling (f val-in-result val-in-latter)."},
           "cljs.repl/repl-quit-prompt" {:ns "cljs.repl",
                                         :name "repl-quit-prompt",
                                         :signature ["[]"],
                                         :name-encode "repl-quit-prompt",
                                         :history [["+" "0.0-3148"]],
                                         :type "function",
                                         :full-name-encode "cljs.repl/repl-quit-prompt",
                                         :source {:code "(defn repl-quit-prompt []\n  (println \"To quit, type:\" :cljs/quit))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/clojure/cljs/repl.cljc",
                                                  :lines [808 809]},
                                         :full-name "cljs.repl/repl-quit-prompt"},
           "compiler-options/stable-names" {:ns "compiler-options",
                                            :name "stable-names",
                                            :name-encode "stable-names",
                                            :type "option",
                                            :full-name-encode "compiler-options/stable-names",
                                            :full-name "compiler-options/stable-names",
                                            :history [["+" "1.10.63"]]},
           "cljs.core/key" {:ns "cljs.core",
                            :name "key",
                            :signature ["[map-entry]"],
                            :name-encode "key",
                            :history [["+" "0.0-1211"]],
                            :type "function",
                            :full-name-encode "cljs.core/key",
                            :source {:code "(defn key\n  [map-entry]\n  (-key map-entry))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [9251 9254]},
                            :full-name "cljs.core/key",
                            :docstring "Returns the key of the map entry."},
           "clojure.browser.dom/set-properties" {:ns "clojure.browser.dom",
                                                 :name "set-properties",
                                                 :signature ["[e m]"],
                                                 :name-encode "set-properties",
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.browser.dom/set-properties",
                                                 :source {:code "(defn set-properties\n  [e m]\n  (gdom/setProperties (ensure-element e)\n                      (apply gobject/create (interleave (keys m) (vals m)))))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r1.12.38",
                                                          :filename "src/main/cljs/clojure/browser/dom.cljs",
                                                          :lines [136
                                                                  140]},
                                                 :full-name "clojure.browser.dom/set-properties",
                                                 :docstring "Set properties on an element"},
           "clojure.data/diff" {:ns "clojure.data",
                                :name "diff",
                                :signature ["[a b]"],
                                :name-encode "diff",
                                :history [["+" "0.0-1503"]],
                                :type "function",
                                :full-name-encode "clojure.data/diff",
                                :source {:code "(defn diff\n  [a b]\n  (if (= a b)\n    [nil nil a]\n    (if (= (equality-partition a) (equality-partition b))\n      (diff-similar a b)\n      (atom-diff a b))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/clojure/data.cljs",
                                         :lines [144 161]},
                                :full-name "clojure.data/diff",
                                :docstring "Recursively compares a and b, returning a tuple of\n[things-only-in-a things-only-in-b things-in-both].\nComparison rules:\n\n* For equal a and b, return [nil nil a].\n* Maps are subdiffed where keys match and values differ.\n* Sets are never subdiffed.\n* All sequential things are treated as associative collections\n  by their indexes, with results returned as vectors.\n* Everything else (including strings!) is treated as\n  an atom and compared for equality."},
           "cljs.core/ITransientAssociative" {:ns "cljs.core",
                                              :name "ITransientAssociative",
                                              :name-encode "ITransientAssociative",
                                              :implementations #{"TransientArrayMap"
                                                                 "TransientVector"
                                                                 "TransientHashMap"},
                                              :history [["+"
                                                         "0.0-1211"]],
                                              :type "protocol",
                                              :full-name-encode "cljs.core/ITransientAssociative",
                                              :source {:code "(defprotocol ITransientAssociative\n  (^clj -assoc! [tcoll key val]\n    \"Returns a new transient collection of tcoll with a mapping from key to\n     val added to it.\"))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.12.38",
                                                       :filename "src/main/cljs/cljs/core.cljs",
                                                       :lines [812
                                                               816]},
                                              :methods [{:name "-assoc!",
                                                         :signature ["[tcoll key val]"],
                                                         :docstring "Returns a new transient collection of tcoll with a mapping from key to\n     val added to it."}],
                                              :full-name "cljs.core/ITransientAssociative",
                                              :docstring "Protocol for adding associativity to transient collections."},
           "cljs.build.api/index-ijs" {:ns "cljs.build.api",
                                       :name "index-ijs",
                                       :signature ["[xs]"],
                                       :name-encode "index-ijs",
                                       :history [["+" "1.10.738"]],
                                       :type "function",
                                       :full-name-encode "cljs.build.api/index-ijs",
                                       :source {:code "(defn index-ijs\n  [xs]\n  (reduce\n    (fn [index x]\n      (merge index\n        (zipmap (:provides x) (repeat x))))\n    {} xs))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/clojure/cljs/build/api.clj",
                                                :lines [90 98]},
                                       :full-name "cljs.build.api/index-ijs",
                                       :docstring "Given a sequence of cljs.closure/IJavaScript values, create an index using\n:provides. The original values will appear under each :provide."},
           "cljs.core/trampoline" {:ns "cljs.core",
                                   :name "trampoline",
                                   :signature ["[f]" "[f & args]"],
                                   :name-encode "trampoline",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/trampoline",
                                   :source {:code "(defn trampoline\n  ([f]\n     (let [ret (f)]\n       (if (fn? ret)\n         (recur ret)\n         ret)))\n  ([f & args]\n     (trampoline #(apply f args))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [11255 11269]},
                                   :full-name "cljs.core/trampoline",
                                   :docstring "trampoline can be used to convert algorithms requiring mutual\nrecursion without stack consumption. Calls f with supplied args, if\nany. If f returns a fn, calls that fn with no arguments, and\ncontinues to repeat, until the return value is not a fn, then\nreturns that non-fn value. Note that if you want to return a fn as a\nfinal value, you must wrap it in some data structure and unpack it\nafter trampoline returns."},
           "cljs.test/test-ns" {:ns "cljs.test",
                                :name "test-ns",
                                :signature ["[ns]"
                                            "[env [quote ns :as form]]"],
                                :name-encode "test-ns",
                                :history [["+" "0.0-2496"]],
                                :type "macro",
                                :full-name-encode "cljs.test/test-ns",
                                :source {:code "(defmacro test-ns\n  ([ns] `(test-ns (empty-env) ~ns))\n  ([env [quote ns :as form]]\n   `(run-block\n     (concat (test-ns-block ~env ~form)\n             [(fn []\n                (clear-env!))]))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/test.cljc",
                                         :lines [385 397]},
                                :full-name "cljs.test/test-ns",
                                :docstring "If the namespace defines a function named test-ns-hook, calls that.\nOtherwise, calls test-all-vars on the namespace.  'ns' is a\nnamespace object or a symbol.\n\nInternally binds *report-counters* to a ref initialized to\n*initial-report-counters*.  "},
           "cljs.core/double?" {:ns "cljs.core",
                                :name "double?",
                                :signature ["[x]"],
                                :name-encode "doubleQMARK",
                                :history [["+" "1.9.293"]],
                                :type "function",
                                :full-name-encode "cljs.core/doubleQMARK",
                                :source {:code "(defn double?\n  [x]\n  (number? x))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [2399 2402]},
                                :full-name "cljs.core/double?",
                                :docstring "Returns true for JavaScript numbers, false otherwise."},
           "compiler-options/fingerprint" {:ns "compiler-options",
                                           :name "fingerprint",
                                           :name-encode "fingerprint",
                                           :type "option",
                                           :full-name-encode "compiler-options/fingerprint",
                                           :full-name "compiler-options/fingerprint",
                                           :history [["+" "1.10.439"]]},
           "cljs.core/implements?" {:ns "cljs.core",
                                    :name "implements?",
                                    :signature ["[psym x]"],
                                    :name-encode "implementsQMARK",
                                    :history [["+" "0.0-2014"]],
                                    :type "macro",
                                    :full-name-encode "cljs.core/implementsQMARK",
                                    :source {:code "(core/defmacro implements?\n  [psym x]\n  (core/let [p          (:name\n                          (cljs.analyzer/resolve-var\n                            (dissoc &env :locals) psym))\n             prefix     (protocol-prefix p)\n             xsym       (bool-expr (gensym))\n             [part bit] (fast-path-protocols p)\n             msym       (symbol\n                          (core/str \"-cljs$lang$protocol_mask$partition\" part \"$\"))]\n    (core/if-not (core/symbol? x)\n      `(let [~xsym ~x]\n         (if ~xsym\n           (if (or ~(if bit `(unsafe-bit-and (. ~xsym ~msym) ~bit) false)\n                    (identical? cljs.core/PROTOCOL_SENTINEL (. ~xsym ~(symbol (core/str \"-\" prefix)))))\n             true\n             false)\n           false))\n      `(if-not (nil? ~x)\n         (if (or ~(if bit `(unsafe-bit-and (. ~x ~msym) ~bit) false)\n                  (identical? cljs.core/PROTOCOL_SENTINEL (. ~x ~(symbol (core/str \"-\" prefix)))))\n           true\n           false)\n         false))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/clojure/cljs/core.cljc",
                                             :lines [2184 2208]},
                                    :full-name "cljs.core/implements?",
                                    :docstring "EXPERIMENTAL"},
           "cljs.core/PersistentHashSet.createWithCheck" {:ns "cljs.core",
                                                          :name "PersistentHashSet.createWithCheck",
                                                          :signature ["[items]"],
                                                          :name-encode "PersistentHashSetDOTcreateWithCheck",
                                                          :history [["+"
                                                                     "1.9.456"]],
                                                          :parent-type "PersistentHashSet",
                                                          :type "function",
                                                          :full-name-encode "cljs.core/PersistentHashSetDOTcreateWithCheck",
                                                          :source {:code "(set! (.-createWithCheck PersistentHashSet)\n      (fn [items]\n        (let [len (alength items)\n              t (-as-transient (.-EMPTY PersistentHashSet))]\n          (dotimes [i len]\n            (-conj! t (aget items i))\n            (when-not (= (count t) (inc i))\n              (throw (js/Error. (str \"Duplicate key: \" (aget items i))))))\n          (-persistent! t))))",
                                                                   :title "Source code",
                                                                   :repo "clojurescript",
                                                                   :tag "r1.12.38",
                                                                   :filename "src/main/cljs/cljs/core.cljs",
                                                                   :lines [9490
                                                                           9498]},
                                                          :full-name "cljs.core/PersistentHashSet.createWithCheck"},
           "cljs.repl.browser/handle-connection" {:ns "cljs.repl.browser",
                                                  :name "handle-connection",
                                                  :signature ["[opts conn]"],
                                                  :name-encode "handle-connection",
                                                  :history [["+"
                                                             "0.0-927"]
                                                            ["-"
                                                             "0.0-1503"]],
                                                  :type "function",
                                                  :full-name-encode "cljs.repl.browser/handle-connection",
                                                  :source {:code "(defn handle-connection\n  [opts conn]\n  (let [rdr (BufferedReader. (InputStreamReader. (.getInputStream conn)))]\n    (if-let [request (read-request rdr)]\n      (case (:method request)\n        :get (handle-get opts conn request)\n        :post (handle-post conn (read-string (:content request)))\n        (.close conn))\n      (.close conn))))",
                                                           :title "Source code",
                                                           :repo "clojurescript",
                                                           :tag "r1450",
                                                           :filename "src/clj/cljs/repl/browser.clj",
                                                           :lines [248
                                                                   256]},
                                                  :full-name "cljs.repl.browser/handle-connection",
                                                  :removed {:in "0.0-1503",
                                                            :last-seen "0.0-1450"}},
           "cljs.js/prefix" {:ns "cljs.js",
                             :name "prefix",
                             :signature ["[s pre]"],
                             :name-encode "prefix",
                             :history [["+" "1.7.10"] ["-" "1.7.28"]],
                             :type "function",
                             :full-name-encode "cljs.js/prefix",
                             :source {:code "(defn prefix [s pre]\n  (str pre s))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.7.10",
                                      :filename "src/main/cljs/cljs/js.cljs",
                                      :lines [128 129]},
                             :full-name "cljs.js/prefix",
                             :removed {:in "1.7.28",
                                       :last-seen "1.7.10"}},
           "clojure.browser.repl/send-print" {:ns "clojure.browser.repl",
                                              :name "send-print",
                                              :signature ["[url data]"
                                                          "[url data n]"],
                                              :name-encode "send-print",
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "clojure.browser.repl/send-print",
                                              :source {:code "(defn send-print\n  ([url data]\n   (send-print url data 0))\n  ([url data n]\n   (let [conn (net/xhr-connection)]\n     (event/listen conn :error\n       (fn [_]\n         (if (< n 10)\n           (send-print url data (inc n))\n           (.log js/console (str \"Could not send \" data \" after \" n \" attempts.\")))))\n     (net/transmit conn url \"POST\" data nil 0))))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.12.38",
                                                       :filename "src/main/cljs/clojure/browser/repl.cljs",
                                                       :lines [82 94]},
                                              :full-name "clojure.browser.repl/send-print",
                                              :docstring "Send data to be printed in the REPL. If there is an error, try again\nup to 10 times."},
           "cljs.build.api/inputs" {:ns "cljs.build.api",
                                    :name "inputs",
                                    :signature ["[& xs]"],
                                    :name-encode "inputs",
                                    :history [["+" "0.0-3208"]],
                                    :type "function",
                                    :full-name-encode "cljs.build.api/inputs",
                                    :source {:code "(defn inputs\n  [& xs]\n  (reify\n    closure/Inputs\n    (-paths [_]\n      (map io/file xs))\n    closure/Compilable\n    (-compile [_ opts]\n      (letfn [(compile-input [x]\n                (let [compiled (closure/-compile x opts)]\n                  (if (sequential? compiled)\n                    compiled\n                    [compiled])))]\n        (mapcat compile-input xs)))\n    (-find-sources [_ opts]\n      (mapcat #(closure/-find-sources % opts) xs))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/clojure/cljs/build/api.clj",
                                             :lines [175 192]},
                                    :full-name "cljs.build.api/inputs",
                                    :docstring "Given a list of directories and files, return a compilable object that may\nbe passed to build or watch."},
           "cljs.core/ICounted" {:ns "cljs.core",
                                 :name "ICounted",
                                 :name-encode "ICounted",
                                 :implementations #{"Subvec"
                                                    "PersistentQueue"
                                                    "PersistentHashMap"
                                                    "PersistentTreeSet"
                                                    "PersistentArrayMapSeq"
                                                    "RedNode"
                                                    "TransientArrayMap"
                                                    "EmptyList"
                                                    "ObjMap"
                                                    "ArrayChunk"
                                                    "BlackNode"
                                                    "PersistentVector"
                                                    "ChunkBuffer"
                                                    "IntegerRange"
                                                    "TransientVector"
                                                    "IntegerRangeChunk"
                                                    "IndexedSeq"
                                                    "PersistentTreeMap"
                                                    "PersistentTreeMapSeq"
                                                    "RSeq"
                                                    "PersistentArrayMap"
                                                    "PersistentHashSet"
                                                    "List"
                                                    "TransientHashMap"
                                                    "nil"
                                                    "MapEntry"
                                                    "TransientHashSet"},
                                 :history [["+" "0.0-927"]],
                                 :type "protocol",
                                 :full-name-encode "cljs.core/ICounted",
                                 :source {:code "(defprotocol ICounted\n  (^number -count [coll]\n    \"Calculates the count of coll in constant time. Used by cljs.core/count.\"))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [589 592]},
                                 :methods [{:name "-count",
                                            :signature ["[coll]"],
                                            :docstring "Calculates the count of coll in constant time. Used by cljs.core/count."}],
                                 :full-name "cljs.core/ICounted",
                                 :docstring "Protocol for adding the ability to count a collection in constant time."},
           "cljs.core/quote" {:ns "cljs.core",
                              :name "quote",
                              :signature ["[form]"],
                              :name-encode "quote",
                              :history [["+" "0.0-927"]],
                              :type "special form",
                              :full-name-encode "cljs.core/quote",
                              :source {:code "(defmethod parse 'quote\n  [_ env [_ x :as form] _ _]\n  (when (not= 2 (count form))\n    (throw (error env \"Wrong number of args to quote\")))\n  (let [expr (analyze-const env x)]\n    {:op :quote\n     :literal? true\n     :expr expr\n     :env env\n     :form form\n     :tag (:tag expr)\n     :children [:expr]}))",
                                       :title "Parser code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/clojure/cljs/analyzer.cljc",
                                       :lines [2573 2584]},
                              :extra-sources ({:code "(defmethod emit* :quote\n  [{:keys [expr]}]\n  (emit expr))",
                                               :title "Emitting code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/clojure/cljs/compiler.cljc",
                                               :lines [617 619]}),
                              :full-name "cljs.core/quote",
                              :docstring "Yields the unevaluated form."},
           "cljs.spec.alpha/every-kv" {:ns "cljs.spec.alpha",
                                       :name "every-kv",
                                       :signature ["[kpred vpred & opts]"],
                                       :name-encode "every-kv",
                                       :history [["+" "1.9.542"]],
                                       :type "macro",
                                       :full-name-encode "cljs.spec.alpha/every-kv",
                                       :source {:code "(defmacro every-kv\n  [kpred vpred & opts]\n  (let [desc `(every-kv ~(res &env kpred) ~(res &env vpred) ~@(res-kind &env opts))]\n    `(every (tuple ~kpred ~vpred) ::kfn (fn [i# v#] (nth v# 0)) :into {} ::describe '~desc ~@opts)))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/spec/alpha.cljc",
                                                :lines [281 290]},
                                       :full-name "cljs.spec.alpha/every-kv",
                                       :docstring "like 'every' but takes separate key and val preds and works on associative collections.\n\nSame options as 'every', :into defaults to {}\n\nSee also - map-of"},
           "cljs.repl.node/thread-name" {:ns "cljs.repl.node",
                                         :name "thread-name",
                                         :signature ["[]"],
                                         :name-encode "thread-name",
                                         :history [["+" "1.10.217"]],
                                         :type "function",
                                         :full-name-encode "cljs.repl.node/thread-name",
                                         :source {:code "(defn thread-name []\n  (let [name (.getName (Thread/currentThread))]\n    (if (string/starts-with? name \"nREPL\") \"main\" name)))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/clojure/cljs/repl/node.clj",
                                                  :lines [31 33]},
                                         :full-name "cljs.repl.node/thread-name"},
           "cljs.core/IEquiv" {:ns "cljs.core",
                               :name "IEquiv",
                               :name-encode "IEquiv",
                               :implementations #{"Subvec"
                                                  "TaggedLiteral"
                                                  "Symbol"
                                                  "PersistentQueue"
                                                  "PersistentHashMap"
                                                  "PersistentTreeSet"
                                                  "js/Date"
                                                  "PersistentArrayMapSeq"
                                                  "RedNode"
                                                  "EmptyList"
                                                  "ObjMap"
                                                  "BlackNode"
                                                  "PersistentVector"
                                                  "ValSeq"
                                                  "IntegerRange"
                                                  "ChunkedCons"
                                                  "Range"
                                                  "PersistentQueueSeq"
                                                  "ChunkedSeq"
                                                  "ArrayNodeSeq"
                                                  "KeySeq"
                                                  "IndexedSeq"
                                                  "Namespace"
                                                  "number"
                                                  "PersistentTreeMap"
                                                  "PersistentTreeMapSeq"
                                                  "RSeq"
                                                  "PersistentArrayMap"
                                                  "Keyword"
                                                  "PersistentHashSet"
                                                  "NodeSeq"
                                                  "List"
                                                  "Atom"
                                                  "Repeat"
                                                  "Cons"
                                                  "Var"
                                                  "default"
                                                  "LazySeq"
                                                  "NeverEquiv"
                                                  "MapEntry"
                                                  "UUID"},
                               :history [["+" "0.0-927"]],
                               :type "protocol",
                               :full-name-encode "cljs.core/IEquiv",
                               :source {:code "(defprotocol IEquiv\n  (^boolean -equiv [o other]\n    \"Returns true if o and other are equal, false otherwise.\"))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [723 726]},
                               :methods [{:name "-equiv",
                                          :signature ["[o other]"],
                                          :docstring "Returns true if o and other are equal, false otherwise."}],
                               :full-name "cljs.core/IEquiv",
                               :docstring "Protocol for adding value comparison functionality to a type."},
           "cljs.pprint/print-length-loop" {:ns "cljs.pprint",
                                            :name "print-length-loop",
                                            :signature ["[bindings & body]"],
                                            :name-encode "print-length-loop",
                                            :history [["+" "0.0-3255"]],
                                            :type "macro",
                                            :full-name-encode "cljs.pprint/print-length-loop",
                                            :source {:code "(defmacro print-length-loop\n  [bindings & body]\n  (let [count-var (gensym \"length-count\")\n        mod-body (pll-mod-body &env count-var body)]\n    `(loop ~(apply vector count-var 0 bindings)\n       (if (or (not cljs.core/*print-length*) (< ~count-var cljs.core/*print-length*))\n         (do ~@mod-body)\n         (~'-write cljs.core/*out* \"...\")))))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/cljs/cljs/pprint.cljc",
                                                     :lines [102 111]},
                                            :full-name "cljs.pprint/print-length-loop",
                                            :docstring "A version of loop that iterates at most *print-length* times. This is designed\nfor use in pretty-printer dispatch functions."},
           "cljs.core/TransformerIterator" {:protocols #{"IPrintWithWriter"},
                                            :ns "cljs.core",
                                            :name "TransformerIterator",
                                            :signature ["[buffer _next completed xf sourceIter multi]"],
                                            :name-encode "TransformerIterator",
                                            :history [["+" "1.9.562"]],
                                            :type "type",
                                            :full-name-encode "cljs.core/TransformerIterator",
                                            :source {:code "(deftype TransformerIterator [^:mutable buffer ^:mutable _next ^:mutable completed ^:mutable xf sourceIter multi]\n  Object\n  (step [this]\n    (if-not (identical? _next NONE)\n      true\n      (loop []\n        (if (identical? _next NONE)\n          (if ^boolean (.isEmpty buffer)\n            (if ^boolean completed\n              false\n              (if ^boolean (.hasNext sourceIter)\n                (let [iter (if ^boolean multi\n                             (apply xf (cons nil (.next sourceIter)))\n                             (xf nil (.next sourceIter)))]\n                  (when (reduced? iter)\n                    (xf nil)\n                    (set! completed true))\n                  (recur))\n                (do\n                  (xf nil)\n                  (set! completed true)\n                  (recur))))\n            (do\n              (set! _next (.remove buffer))\n              (recur)))\n          true))))\n  (hasNext [this]\n    (.step this))\n  (next [this]\n    (if ^boolean (.hasNext this)\n      (let [ret _next]\n        (set! _next NONE)\n        ret)\n      (throw (js/Error. \"No such element\"))))\n  (remove [_]\n    (js/Error. \"Unsupported operation\")))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/cljs/cljs/core.cljs",
                                                     :lines [4241
                                                             4276]},
                                            :full-name "cljs.core/TransformerIterator"},
           "cljs.core/reduce-kv" {:ns "cljs.core",
                                  :name "reduce-kv",
                                  :signature ["[f init coll]"],
                                  :name-encode "reduce-kv",
                                  :history [["+" "0.0-1211"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/reduce-kv",
                                  :source {:code "(defn reduce-kv\n  ([f init coll]\n    (if (satisfies? IKVReduce coll)\n      (-kv-reduce coll f init)\n      (reduce (fn [ret me]\n                (f ret (-key me) (-val me)))\n        init coll))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [2636 2648]},
                                  :full-name "cljs.core/reduce-kv",
                                  :docstring "Reduces an associative collection. f should be a function of 3\narguments. Returns the result of applying f to init, the first key\nand the first value in coll, then applying f to that result and the\n2nd key and value, etc. If coll contains no entries, returns init\nand f is not called. Note that reduce-kv is supported on vectors,\nwhere the keys will be the ordinals."},
           "cljs.core/js-delete" {:ns "cljs.core",
                                  :name "js-delete",
                                  :signature ["[obj key]"],
                                  :name-encode "js-delete",
                                  :history [["+" "0.0-927"]],
                                  :type "function/macro",
                                  :full-name-encode "cljs.core/js-delete",
                                  :source {:code "(defn js-delete\n  [obj key]\n  (cljs.core/js-delete obj key))",
                                           :title "Function code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [2256 2260]},
                                  :extra-sources [{:code "(core/defmacro js-delete [obj key]\n  (core/list 'js* \"delete ~{}[~{}]\" obj key))",
                                                   :title "Macro code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/clojure/cljs/core.cljc",
                                                   :lines [926 927]}],
                                  :full-name "cljs.core/js-delete",
                                  :docstring "Delete a property from a JavaScript object.\nReturns true upon success, false otherwise."},
           "syntax/NaN" {:syntax-equiv {:edn-url nil, :clj-url nil},
                         :ns "syntax",
                         :name "NaN",
                         :name-encode "NaN",
                         :history [["+" "1.9.946"]],
                         :type "symbolic value",
                         :full-name-encode "syntax/NaN",
                         :extra-sources ({:code "(defn- read-symbolic-value\n  [rdr _ opts pending-forms]\n  (let [sym (read* rdr true nil opts pending-forms)]\n    (case sym\n      Inf Double/POSITIVE_INFINITY\n      -Inf Double/NEGATIVE_INFINITY\n      NaN Double/NaN\n      (err/reader-error rdr (str \"Invalid token: ##\" sym)))))",
                                          :title "Reader code",
                                          :repo "tools.reader",
                                          :tag "v1.3.6",
                                          :filename "src/main/clojure/clojure/tools/reader.clj",
                                          :lines [412 419]}
                                         {:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    \\? read-cond\n    \\: read-namespaced-map\n    \\# read-symbolic-value\n    nil))",
                                          :title "Reader table",
                                          :repo "tools.reader",
                                          :tag "v1.3.6",
                                          :filename "src/main/clojure/clojure/tools/reader.clj",
                                          :lines [809 823]}),
                         :full-name "syntax/NaN"},
           "cljs.core/PersistentTreeSet.EMPTY" {:ns "cljs.core",
                                                :name "PersistentTreeSet.EMPTY",
                                                :name-encode "PersistentTreeSetDOTEMPTY",
                                                :history [["+"
                                                           "0.0-1211"]],
                                                :parent-type "PersistentTreeSet",
                                                :type "var",
                                                :full-name-encode "cljs.core/PersistentTreeSetDOTEMPTY",
                                                :source {:code "(set! (.-EMPTY PersistentTreeSet)\n  (PersistentTreeSet. nil (.-EMPTY PersistentTreeMap) empty-unordered-hash))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1.12.38",
                                                         :filename "src/main/cljs/cljs/core.cljs",
                                                         :lines [9640
                                                                 9641]},
                                                :full-name "cljs.core/PersistentTreeSet.EMPTY"},
           "cljs.core/comment" {:ns "cljs.core",
                                :name "comment",
                                :signature ["[& body]"],
                                :name-encode "comment",
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :full-name-encode "cljs.core/comment",
                                :source {:code "(defmacro comment\n  {:added \"1.0\"}\n  [& body])",
                                         :title "Source code",
                                         :repo "clojure",
                                         :tag "clojure-1.10.0",
                                         :filename "src/clj/clojure/core.clj",
                                         :lines [4711 4714]},
                                :full-name "cljs.core/comment",
                                :docstring "Ignores body, yields nil"},
           "compiler-options/ignore-js-module-exts" {:ns "compiler-options",
                                                     :name "ignore-js-module-exts",
                                                     :name-encode "ignore-js-module-exts",
                                                     :type "option",
                                                     :full-name-encode "compiler-options/ignore-js-module-exts",
                                                     :full-name "compiler-options/ignore-js-module-exts",
                                                     :history [["+"
                                                                "1.10.63"]]},
           "cljs.reader/special-symbols" {:ns "cljs.reader",
                                          :name "special-symbols",
                                          :signature ["[t not-found]"],
                                          :name-encode "special-symbols",
                                          :history [["+" "0.0-927"]
                                                    ["-" "1.9.854"]],
                                          :type "function",
                                          :full-name-encode "cljs.reader/special-symbols",
                                          :source {:code "(defn special-symbols [t not-found]\n  (cond\n    (identical? t \"nil\") nil\n    (identical? t \"true\") true\n    (identical? t \"false\") false\n    (identical? t \"/\") '/\n    :else not-found))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.9.671",
                                                   :filename "src/main/cljs/cljs/reader.cljs",
                                                   :lines [331 337]},
                                          :full-name "cljs.reader/special-symbols",
                                          :removed {:in "1.9.854",
                                                    :last-seen "1.9.671"}},
           "compiler-options/output-wrapper" {:ns "compiler-options",
                                              :name "output-wrapper",
                                              :name-encode "output-wrapper",
                                              :type "option",
                                              :full-name-encode "compiler-options/output-wrapper",
                                              :full-name "compiler-options/output-wrapper",
                                              :history [["+"
                                                         "0.0-1513"]]},
           "cljs.js/analyze-str" {:ns "cljs.js",
                                  :name "analyze-str",
                                  :signature ["[state source cb]"
                                              "[state source name cb]"
                                              "[state source name opts cb]"],
                                  :name-encode "analyze-str",
                                  :history [["+" "1.7.28"]],
                                  :type "function",
                                  :full-name-encode "cljs.js/analyze-str",
                                  :source {:code "(defn analyze-str\n  ([state source cb]\n   (analyze-str state source nil cb))\n  ([state source name cb]\n   (analyze-str state source name nil cb))\n  ([state source name opts cb]\n   {:pre [(atom? state) (string? source)\n          (valid-name? name) (valid-opts? opts) (fn? cb)]}\n   (analyze-str*\n     {:*compiler*     state\n      :*data-readers* tags/*cljs-data-readers*\n      :*passes*       (or (:passes opts) ana/*passes*)\n      :*analyze-deps* (:analyze-deps opts true)\n      :*cljs-dep-set* ana/*cljs-dep-set*\n      :*load-macros*  (:load-macros opts true)\n      :*load-fn*      (or (:load opts) *load-fn*)\n      :*eval-fn*      (or (:eval opts) *eval-fn*)}\n     source name opts cb)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/js.cljs",
                                           :lines [724 785]},
                                  :full-name "cljs.js/analyze-str",
                                  :docstring "Analyze ClojureScript source. The compiler state will be populated with\nthe results of analyzes. The parameters:\n\nstate (atom)\n  the compiler state\n\nsource (string)\n  the ClojureScript source\n\nname (symbol or string)\n  optional, the name of the source\n\nopts (map)\n  compilation options.\n\n   :eval             - eval function to invoke, see *eval-fn*\n   :load             - library resolution function, see *load-fn*\n   :source-map       - set to true to generate inline source map information\n   :def-emits-var    - sets whether def (and derived) forms return either a Var\n                       (if set to true) or the def init value (if false).\n                       Defaults to false.\n   :checked-arrays   - if :warn or :error, checks inferred types and values passed\n                       to aget/aset. Logs for incorrect values if :warn, throws if\n                       :error. Defaults to false.\n   :static-fns       - employ static dispatch to specific function arities in\n                       emitted JavaScript, as opposed to making use of the\n                       `call` construct. Defaults to false.\n   :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\n                       unknown functions, but instead direct invokes via\n                       `f(a0,a1...)`. Defaults to `false`.\n   :target           - use `:nodejs` if targeting Node.js. Takes no other options\n                       at the moment.\n   :ns               - optional, the namespace in which to evaluate the source.\n   :verbose          - optional, emit details from compiler activity. Defaults to\n                       false.\n   :context          - optional, sets the context for the source. Possible values\n                       are `:expr`, `:statement` and `:return`. Defaults to\n                       `:statement`.\n\ncb (function)\n  callback, will be invoked with a map. If successful the map will contain\n  a key :value, the actual value is not meaningful. If unsuccessful the\n  map will contain a key :error with an ex-info instance describing the cause\n  of failure."},
           "cljs.core/record?" {:ns "cljs.core",
                                :name "record?",
                                :signature ["[x]"],
                                :name-encode "recordQMARK",
                                :history [["+" "0.0-3255"]],
                                :type "function",
                                :full-name-encode "cljs.core/recordQMARK",
                                :source {:code "(defn record?\n  [x]\n  (satisfies? IRecord x))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [2227 2230]},
                                :full-name "cljs.core/record?",
                                :docstring "Return true if x satisfies IRecord"},
           "cljs.spec/unstrument-all" {:ns "cljs.spec",
                                       :name "unstrument-all",
                                       :signature ["[]"],
                                       :name-encode "unstrument-all",
                                       :history [["+" "1.9.14"]
                                                 ["-" "1.9.183"]],
                                       :type "macro",
                                       :full-name-encode "cljs.spec/unstrument-all",
                                       :source {:code "(defmacro unstrument-all\n  []\n  `(do\n     ~@(map #(list 'cljs.spec/unstrument %) (speced-vars*))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.9.93",
                                                :filename "src/main/cljs/cljs/spec.cljc",
                                                :lines [480 484]},
                                       :full-name "cljs.spec/unstrument-all",
                                       :docstring "Call unstrument for all speced-vars. Idempotent",
                                       :removed {:in "1.9.183",
                                                 :last-seen "1.9.93"}},
           "cljs.core/js*" {:ns "cljs.core",
                            :name "js*",
                            :name-encode "jsSTAR",
                            :history [["+" "0.0-927"]],
                            :type "special form",
                            :full-name-encode "cljs.core/jsSTAR",
                            :source {:code "(defmethod parse 'js*\n  [op env [_ jsform & args :as form] _ _]\n  (when-not (string? jsform)\n    (throw (error env \"Invalid js* form\")))\n  (if (some? args)\n    (analyze-js-star env jsform args form)\n    (let [code      (apply str (js-star-interp env jsform))\n          tag       (get-js-tag form)\n          form-meta (meta form)\n          js-op     (:js-op form-meta)\n          numeric   (:numeric form-meta)]\n      {:op :js\n       :env env\n       :form form\n       :code code\n       :tag tag\n       :js-op js-op\n       :numeric numeric})))",
                                     :title "Parser code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/clojure/cljs/analyzer.cljc",
                                     :lines [3728 3745]},
                            :extra-sources ({:code "(defmethod emit* :js\n  [{:keys [op env code segs args]}]\n  (if (and code #?(:clj  (.startsWith ^String (string/trim code) \"/*\")\n                   :cljs (gstring/startsWith (string/trim code) \"/*\")))\n    (emits code)\n    (emit-wrap env\n      (if code\n        (emits code)\n        (emits (interleave (concat segs (repeat nil))\n                           (concat args [nil])))))))",
                                             :title "Emitting code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/clojure/cljs/compiler.cljc",
                                             :lines [1435 1444]}),
                            :full-name "cljs.core/js*"},
           "cljs.build.api/source-on-disk" {:ns "cljs.build.api",
                                            :name "source-on-disk",
                                            :signature ["[opts ijs]"],
                                            :name-encode "source-on-disk",
                                            :history [["+" "0.0-3291"]],
                                            :type "function",
                                            :full-name-encode "cljs.build.api/source-on-disk",
                                            :source {:code "(defn source-on-disk\n  [opts ijs]\n  (closure/source-on-disk opts ijs))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/clojure/cljs/build/api.clj",
                                                     :lines [109 113]},
                                            :full-name "cljs.build.api/source-on-disk",
                                            :docstring "Ensure that the given IJavaScript exists on disk in the output directory.\nReturn updated IJavaScript with the new location if necessary."},
           "cljs.repl.node/setup" {:ns "cljs.repl.node",
                                   :name "setup",
                                   :signature ["[repl-env]"
                                               "[{:keys [host port socket state], :as repl-env} opts]"],
                                   :name-encode "setup",
                                   :history [["+" "0.0-2629"]],
                                   :type "function",
                                   :full-name-encode "cljs.repl.node/setup",
                                   :source {:code "(defn setup\n  ([repl-env] (setup repl-env nil))\n  ([{:keys [host port socket state] :as repl-env} opts]\n   (let [tname (thread-name)]\n     (.put results tname (LinkedBlockingQueue.))\n     (.put outs tname *out*)\n     (.put errs tname *err*))\n   (locking lock\n     (when-not @socket\n       (let [output-dir   (io/file (util/output-directory opts))\n             _            (.mkdirs output-dir)\n             of           (io/file output-dir \"node_repl.js\")\n             _            (spit of\n                            (string/replace (slurp (io/resource \"cljs/repl/node_repl.js\"))\n                              \"var PORT = 5001;\"\n                              (str \"var PORT = \" (:port repl-env) \";\")))\n             proc         (.start (build-process opts repl-env of))\n             env          (ana/empty-env)\n             core         (io/resource \"cljs/core.cljs\")\n             ;; represent paths as vectors so we can emit JS arrays, this is to\n             ;; paper over Windows issues with minimum hassle - David\n             path         (.getPath (.getCanonicalFile output-dir))\n             [fc & cs]    (rest (util/path-seq path)) ;; remove leading empty string\n             root         (.substring path 0 (+ (.indexOf path fc) (count fc)))\n             root-path    (vec (cons root cs))\n             rewrite-path (conj root-path \"goog\")]\n         (reset! (:proc repl-env) proc)\n         (loop [r nil]\n           (when-not (= r \"ready\")\n             (Thread/sleep 50)\n             (try\n               (reset! socket (create-socket host port))\n               (catch Exception e))\n             (if @socket\n               (recur (read-response (:in @socket)))\n               (recur nil))))\n         (.start (Thread. (bound-fn [] (event-loop proc (:in @socket)))))\n         ;; compile cljs.core & its dependencies, goog/base.js must be available\n         ;; for bootstrap to load, use new closure/compile as it can handle\n         ;; resources in JARs\n         (let [core-js (closure/compile core\n                         (assoc opts :output-file\n                                     (closure/src-file->target-file\n                                       core (dissoc opts :output-dir))))\n               deps    (closure/add-dependencies opts core-js)]\n           ;; output unoptimized code and only the deps file for all compiled\n           ;; namespaces, we don't need the bootstrap target file\n           (apply closure/output-unoptimized\n             (assoc (assoc opts :target :none)\n               :output-to (.getPath (io/file output-dir \"node_repl_deps.js\")))\n             deps))\n         ;; bootstrap, replace __dirname as __dirname won't be set\n         ;; properly due to how we are running it - David\n         (node-eval repl-env\n           (-> (slurp (io/resource \"cljs/bootstrap_nodejs.js\"))\n             (string/replace \"path.resolve(__dirname, \\\"..\\\", \\\"base.js\\\")\"\n               (platform-path (conj rewrite-path \"bootstrap\" \"..\" \"base.js\")))\n             (string/replace\n               \"path.join(\\\".\\\", \\\"..\\\", src)\"\n               (str \"path.join(\" (platform-path rewrite-path) \", src)\"))\n             (string/replace \"path.resolve(__dirname, \\\"..\\\", src)\"\n               (str \"path.join(\" (platform-path rewrite-path) \", src)\"))\n             (string/replace\n               \"var CLJS_ROOT = \\\".\\\";\"\n               (str \"var CLJS_ROOT = \" (platform-path root-path) \";\"))))\n         ;; load the deps file so we can goog.require cljs.core etc.\n         (node-eval repl-env\n           (str \"require(\"\n             (platform-path (conj root-path \"node_repl_deps.js\"))\n             \")\"))\n         ;; load cljs.core, setup printing\n         (repl/evaluate-form repl-env env \"<cljs repl>\"\n           '(do\n              (.require js/goog \"cljs.core\")\n              (enable-console-print!)))\n         (bootstrap/install-repl-goog-require repl-env env)\n         (node-eval repl-env\n           (str \"goog.global.CLOSURE_UNCOMPILED_DEFINES = \"\n             (json/write-str (:closure-defines opts)) \";\")))))\n   (swap! state update :listeners inc)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/clojure/cljs/repl/node.clj",
                                            :lines [125 204]},
                                   :full-name "cljs.repl.node/setup"},
           "cljs.core/BitmapIndexedNode.EMPTY" {:ns "cljs.core",
                                                :name "BitmapIndexedNode.EMPTY",
                                                :name-encode "BitmapIndexedNodeDOTEMPTY",
                                                :history [["+"
                                                           "0.0-1211"]],
                                                :parent-type "BitmapIndexedNode",
                                                :type "var",
                                                :full-name-encode "cljs.core/BitmapIndexedNodeDOTEMPTY",
                                                :source {:code "(set! (.-EMPTY BitmapIndexedNode) (BitmapIndexedNode. nil 0 (make-array 0)))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1.12.38",
                                                         :filename "src/main/cljs/cljs/core.cljs",
                                                         :lines [7661]},
                                                :full-name "cljs.core/BitmapIndexedNode.EMPTY"},
           "cljs.reader/register-default-tag-parser!" {:ns "cljs.reader",
                                                       :name "register-default-tag-parser!",
                                                       :signature ["[f]"],
                                                       :name-encode "register-default-tag-parserBANG",
                                                       :history [["+"
                                                                  "0.0-1576"]],
                                                       :type "function",
                                                       :full-name-encode "cljs.reader/register-default-tag-parserBANG",
                                                       :source {:code "(defn register-default-tag-parser!\n  [f]\n  (let [old-parser @*default-data-reader-fn*]\n    (swap! *default-data-reader-fn* (fn [_] f))\n    old-parser))",
                                                                :title "Source code",
                                                                :repo "clojurescript",
                                                                :tag "r1.12.38",
                                                                :filename "src/main/cljs/cljs/reader.cljs",
                                                                :lines [204
                                                                        208]},
                                                       :full-name "cljs.reader/register-default-tag-parser!"},
           "cljs.spec.impl.gen/string-alphanumeric" {:ns "cljs.spec.impl.gen",
                                                     :name "string-alphanumeric",
                                                     :signature ["[& args]"],
                                                     :name-encode "string-alphanumeric",
                                                     :history [["+"
                                                                "1.9.14"]
                                                               ["-"
                                                                "1.9.542"]],
                                                     :type "function",
                                                     :full-name-encode "cljs.spec.impl.gen/string-alphanumeric",
                                                     :source {:code "(lazy-prims any any-printable boolean char char-alpha char-alphanumeric char-ascii double\n  int keyword keyword-ns large-integer ratio simple-type simple-type-printable\n  string string-ascii string-alphanumeric symbol symbol-ns uuid)",
                                                              :title "Source code",
                                                              :repo "clojurescript",
                                                              :tag "r1.9.521",
                                                              :filename "src/main/cljs/cljs/spec/impl/gen.cljs",
                                                              :lines [73
                                                                      75]},
                                                     :full-name "cljs.spec.impl.gen/string-alphanumeric",
                                                     :docstring "Fn returning clojure.test.check.generators/string-alphanumeric",
                                                     :removed {:in "1.9.542",
                                                               :last-seen "1.9.521"}},
           "cljs.core/alength" {:return-type number,
                                :ns "cljs.core",
                                :name "alength",
                                :signature ["[array]"],
                                :name-encode "alength",
                                :history [["+" "0.0-927"]],
                                :type "function/macro",
                                :full-name-encode "cljs.core/alength",
                                :source {:code "(defn ^number alength\n  [array]\n  (cljs.core/alength array))",
                                         :title "Function code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [523 526]},
                                :extra-sources [{:code "(core/defmacro alength [a]\n  (vary-meta\n    (core/list 'js* \"~{}.length\" a)\n    assoc :tag 'number))",
                                                 :title "Macro code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/clojure/cljs/core.cljc",
                                                 :lines [2705 2708]}],
                                :full-name "cljs.core/alength",
                                :docstring "Returns the length of the array. Works on arrays of all types."},
           "cljs.core/mk-bound-fn" {:ns "cljs.core",
                                    :name "mk-bound-fn",
                                    :signature ["[sc test key]"],
                                    :name-encode "mk-bound-fn",
                                    :history [["+" "0.0-1211"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/mk-bound-fn",
                                    :source {:code "(defn mk-bound-fn\n  [sc test key]\n  (fn [e]\n    (let [comp (-comparator sc)]\n      (test (comp (-entry-key sc e) key) 0))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [9880 9884]},
                                    :full-name "cljs.core/mk-bound-fn"},
           "cljs.spec.test/unstrument-1" {:ns "cljs.spec.test",
                                          :name "unstrument-1",
                                          :signature ["[[quote s]]"],
                                          :name-encode "unstrument-1",
                                          :history [["+" "1.9.183"]
                                                    ["-" "1.9.542"]],
                                          :type "macro",
                                          :full-name-encode "cljs.spec.test/unstrument-1",
                                          :source {:code "(defmacro unstrument-1\n  [[quote s]]\n  (when-let [v (ana-api/resolve &env s)]\n    (when (@instrumented-vars (:name v))\n      (swap! instrumented-vars disj (:name v))\n      `(let [raw# (unstrument-1* ~s (var ~s))]\n         (when raw# (set! ~s raw#))\n         '~(:name v)))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.9.521",
                                                   :filename "src/main/cljs/cljs/spec/test.cljc",
                                                   :lines [43 50]},
                                          :full-name "cljs.spec.test/unstrument-1",
                                          :removed {:in "1.9.542",
                                                    :last-seen "1.9.521"}},
           "cljs.spec.impl.gen/generate" {:ns "cljs.spec.impl.gen",
                                          :name "generate",
                                          :signature ["[generator]"],
                                          :name-encode "generate",
                                          :history [["+" "1.9.14"]
                                                    ["-" "1.9.542"]],
                                          :type "function",
                                          :full-name-encode "cljs.spec.impl.gen/generate",
                                          :source {:code "(defn generate\n    [generator]\n    (@g generator))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.9.521",
                                                   :filename "src/main/cljs/cljs/spec/impl/gen.cljs",
                                                   :lines [50 53]},
                                          :full-name "cljs.spec.impl.gen/generate",
                                          :docstring "Generate a single value using generator.",
                                          :removed {:in "1.9.542",
                                                    :last-seen "1.9.521"}},
           "cljs.math/cos" {:return-type number,
                            :ns "cljs.math",
                            :name "cos",
                            :signature ["[a]"],
                            :name-encode "cos",
                            :history [["+" "1.11.50"]],
                            :type "function",
                            :full-name-encode "cljs.math/cos",
                            :source {:code "(defn ^number cos\n  {:added \"1.11.10\"}\n  [a] (Math/cos a))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/cljs/cljs/math.cljs",
                                     :lines [88 93]},
                            :full-name "cljs.math/cos",
                            :docstring "Returns the cosine of an angle.\nIf a is ##NaN, ##-Inf, ##Inf => ##NaN\nSee: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/cos"},
           "cljs.reader/validate-unicode-escape" {:ns "cljs.reader",
                                                  :name "validate-unicode-escape",
                                                  :signature ["[unicode-pattern reader escape-char unicode-str]"],
                                                  :name-encode "validate-unicode-escape",
                                                  :history [["+"
                                                             "0.0-1424"]
                                                            ["-"
                                                             "1.9.854"]],
                                                  :type "function",
                                                  :full-name-encode "cljs.reader/validate-unicode-escape",
                                                  :source {:code "(defn validate-unicode-escape [unicode-pattern reader escape-char unicode-str]\n  (if (re-matches unicode-pattern unicode-str)\n    unicode-str\n    (reader-error reader \"Unexpected unicode escape \\\\\" escape-char unicode-str)))",
                                                           :title "Source code",
                                                           :repo "clojurescript",
                                                           :tag "r1.9.671",
                                                           :filename "src/main/cljs/cljs/reader.cljs",
                                                           :lines [185
                                                                   188]},
                                                  :full-name "cljs.reader/validate-unicode-escape",
                                                  :removed {:in "1.9.854",
                                                            :last-seen "1.9.671"}},
           "cljs.core/inst-ms" {:ns "cljs.core",
                                :name "inst-ms",
                                :signature ["[inst]"],
                                :name-encode "inst-ms",
                                :history [["+" "1.9.75"]],
                                :type "function",
                                :full-name-encode "cljs.core/inst-ms",
                                :source {:code "(defn inst-ms\n  [inst]\n  (inst-ms* inst))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [1435 1438]},
                                :full-name "cljs.core/inst-ms",
                                :docstring "Return the number of milliseconds since January 1, 1970, 00:00:00 GMT"},
           "cljs.spec/inst-in-range?" {:ns "cljs.spec",
                                       :name "inst-in-range?",
                                       :signature ["[start end inst]"],
                                       :name-encode "inst-in-rangeQMARK",
                                       :history [["+" "1.9.75"]
                                                 ["-" "1.9.542"]],
                                       :type "function",
                                       :full-name-encode "cljs.spec/inst-in-rangeQMARK",
                                       :source {:code "(defn inst-in-range?\n  [start end inst]\n  (c/and (inst? inst)\n         (let [t (inst-ms inst)]\n           (c/and (<= (inst-ms start) t) (< t (inst-ms end))))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.9.521",
                                                :filename "src/main/cljs/cljs/spec.cljs",
                                                :lines [1384 1389]},
                                       :full-name "cljs.spec/inst-in-range?",
                                       :docstring "Return true if inst at or after start and before end",
                                       :removed {:in "1.9.542",
                                                 :last-seen "1.9.521"}},
           "cljs.spec.gen.alpha/delay" {:ns "cljs.spec.gen.alpha",
                                        :name "delay",
                                        :signature ["[& body]"],
                                        :name-encode "delay",
                                        :history [["+" "1.9.542"]],
                                        :type "macro",
                                        :full-name-encode "cljs.spec.gen.alpha/delay",
                                        :source {:code "(defmacro delay\n  [& body]\n  `(delay-impl (c/delay ~@body)))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/cljs/cljs/spec/gen/alpha.cljc",
                                                 :lines [25 30]},
                                        :full-name "cljs.spec.gen.alpha/delay",
                                        :docstring "given body that returns a generator, returns a\ngenerator that delegates to that, but delays\ncreation until used."},
           "cljs.js/analyze-deps" {:ns "cljs.js",
                                   :name "analyze-deps",
                                   :signature ["[bound-vars ana-env lib deps cb]"
                                               "[bound-vars ana-env lib deps opts cb]"],
                                   :name-encode "analyze-deps",
                                   :history [["+" "1.7.10"]
                                             ["-" "1.7.28"]],
                                   :type "function",
                                   :full-name-encode "cljs.js/analyze-deps",
                                   :source {:code "(defn analyze-deps\n  ([bound-vars ana-env lib deps cb]\n   (analyze-deps bound-vars ana-env lib deps nil cb))\n  ([bound-vars ana-env lib deps opts cb]\n   (let [compiler @(:*compiler* bound-vars)]\n     (binding [ana/*cljs-dep-set* (vary-meta (conj (:*cljs-dep-set* bound-vars) lib)\n                                    update-in [:dep-path] conj lib)]\n       (assert (every? #(not (contains? (:*cljs-dep-set* bound-vars) %)) deps)\n         (str \"Circular dependency detected \"\n           (-> (:*cljs-dep-set* bound-vars) meta :dep-path)))\n       (if (seq deps)\n         (let [dep (first deps)]\n           (try\n             ((:*load-fn* bound-vars) {:name dep :path (ns->relpath dep)}\n              (fn [resource]\n                (assert (or (map? resource) (nil? resource))\n                  \"*load-fn* may only return a map or nil\")\n                (if resource\n                  (let [{:keys [name lang source]} resource]\n                    (condp = lang\n                      :clj (analyze* bound-vars source name opts\n                             (fn [res]\n                               (if-not (:error res)\n                                 (analyze-deps bound-vars ana-env lib (next deps) opts cb)\n                                 (cb res))))\n                      :js (analyze-deps bound-vars ana-env lib (next deps) opts cb)\n                      (wrap-error\n                        (ana/error ana-env\n                          (str \"Invalid :lang specified \" lang \", only :clj or :js allowed\")))))\n                  (cb (wrap-error\n                        (ana/error ana-env\n                          (ana/error-message :undeclared-ns\n                            {:ns-sym dep :js-provide (name dep)})))))))\n             (catch :default cause\n               (cb (wrap-error\n                     (ana/error ana-env\n                       (str \"Could not analyze dep \" dep) cause))))))\n         (cb {:value nil}))))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.7.10",
                                            :filename "src/main/cljs/cljs/js.cljs",
                                            :lines [261 298]},
                                   :full-name "cljs.js/analyze-deps",
                                   :removed {:in "1.7.28",
                                             :last-seen "1.7.10"}},
           "repl-options/static-dir" {:ns "repl-options",
                                      :name "static-dir",
                                      :name-encode "static-dir",
                                      :type "option",
                                      :full-name-encode "repl-options/static-dir",
                                      :full-name "repl-options/static-dir",
                                      :history [["+" "0.0-1211"]]},
           "cljs.core/VectorNode" {:ns "cljs.core",
                                   :name "VectorNode",
                                   :signature ["[edit arr]"],
                                   :name-encode "VectorNode",
                                   :history [["+" "0.0-1211"]],
                                   :type "type",
                                   :full-name-encode "cljs.core/VectorNode",
                                   :source {:code "(deftype VectorNode [edit arr])",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [5481]},
                                   :full-name "cljs.core/VectorNode"},
           "cljs.core/string-hash-cache-count" {:ns "cljs.core",
                                                :name "string-hash-cache-count",
                                                :name-encode "string-hash-cache-count",
                                                :type "var",
                                                :full-name-encode "cljs.core/string-hash-cache-count",
                                                :source {:code "(def string-hash-cache-count 0)",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1.12.38",
                                                         :filename "src/main/cljs/cljs/core.cljs",
                                                         :lines [993]},
                                                :full-name "cljs.core/string-hash-cache-count",
                                                :history [["+"
                                                           "0.0-1424"]]},
           "cljs.spec.impl.gen/string" {:ns "cljs.spec.impl.gen",
                                        :name "string",
                                        :signature ["[& args]"],
                                        :name-encode "string",
                                        :history [["+" "1.9.14"]
                                                  ["-" "1.9.542"]],
                                        :type "function",
                                        :full-name-encode "cljs.spec.impl.gen/string",
                                        :source {:code "(lazy-prims any any-printable boolean char char-alpha char-alphanumeric char-ascii double\n  int keyword keyword-ns large-integer ratio simple-type simple-type-printable\n  string string-ascii string-alphanumeric symbol symbol-ns uuid)",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.9.521",
                                                 :filename "src/main/cljs/cljs/spec/impl/gen.cljs",
                                                 :lines [73 75]},
                                        :full-name "cljs.spec.impl.gen/string",
                                        :docstring "Fn returning clojure.test.check.generators/string",
                                        :removed {:in "1.9.542",
                                                  :last-seen "1.9.521"}},
           "cljs.core/tree-seq" {:ns "cljs.core",
                                 :name "tree-seq",
                                 :signature ["[branch? children root]"],
                                 :name-encode "tree-seq",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/tree-seq",
                                 :source {:code "(defn tree-seq\n  [branch? children root]\n   (let [walk (fn walk [node]\n                (lazy-seq\n                 (cons node\n                  (when (branch? node)\n                    (mapcat walk (children node))))))]\n     (walk root)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [5313 5326]},
                                 :full-name "cljs.core/tree-seq",
                                 :docstring "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\nbranch? must be a fn of one arg that returns true if passed a node\nthat can have children (but may not).  children must be a fn of one\narg that returns a sequence of the children. Will only be called on\nnodes for which branch? returns true. Root is the root node of the\ntree."},
           "cljs.reader/read-unmatched-delimiter" {:ns "cljs.reader",
                                                   :name "read-unmatched-delimiter",
                                                   :signature ["[rdr ch]"],
                                                   :name-encode "read-unmatched-delimiter",
                                                   :history [["+"
                                                              "0.0-927"]
                                                             ["-"
                                                              "1.9.854"]],
                                                   :type "function",
                                                   :full-name-encode "cljs.reader/read-unmatched-delimiter",
                                                   :source {:code "(defn read-unmatched-delimiter\n  [rdr ch]\n  (reader-error rdr \"Unmatched delimiter \" ch))",
                                                            :title "Source code",
                                                            :repo "clojurescript",
                                                            :tag "r1.9.671",
                                                            :filename "src/main/cljs/cljs/reader.cljs",
                                                            :lines [265
                                                                    267]},
                                                   :full-name "cljs.reader/read-unmatched-delimiter",
                                                   :removed {:in "1.9.854",
                                                             :last-seen "1.9.671"}},
           "clojure.core.reducers/take-while" {:ns "clojure.core.reducers",
                                               :name "take-while",
                                               :signature ["[pred]"
                                                           "[pred coll]"],
                                               :name-encode "take-while",
                                               :history [["+"
                                                          "0.0-1236"]],
                                               :type "function",
                                               :full-name-encode "clojure.core.reducers/take-while",
                                               :source {:code "(defcurried take-while\n  {}\n  [pred coll]\n  (reducer coll\n   (fn [f1]\n     (rfn [f1 k]\n          ([ret k v]\n             (if (pred k v)\n               (f1 ret k v)\n               (reduced ret)))))))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.12.38",
                                                        :filename "src/main/cljs/clojure/core/reducers.cljs",
                                                        :lines [152
                                                                162]},
                                               :full-name "clojure.core.reducers/take-while",
                                               :docstring "Ends the reduction of coll when (pred val) returns logical false."},
           "cljs.reader/register-tag-parser!" {:ns "cljs.reader",
                                               :name "register-tag-parser!",
                                               :signature ["[tag f]"],
                                               :name-encode "register-tag-parserBANG",
                                               :history [["+"
                                                          "0.0-1236"]],
                                               :type "function",
                                               :full-name-encode "cljs.reader/register-tag-parserBANG",
                                               :source {:code "(defn register-tag-parser!\n  [tag f]\n  (let [old-parser (get @*tag-table* tag)]\n    (swap! *tag-table* assoc tag f)\n    old-parser))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.12.38",
                                                        :filename "src/main/cljs/cljs/reader.cljs",
                                                        :lines [192
                                                                196]},
                                               :full-name "cljs.reader/register-tag-parser!"},
           "cljs.core/every-pred" {:ns "cljs.core",
                                   :name "every-pred",
                                   :signature ["[p]"
                                               "[p1 p2]"
                                               "[p1 p2 p3]"
                                               "[p1 p2 p3 & ps]"],
                                   :name-encode "every-pred",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/every-pred",
                                   :source {:code "(defn every-pred\n  ([p]\n     (fn ep1\n       ([] true)\n       ([x] (boolean (p x)))\n       ([x y] (boolean (and (p x) (p y))))\n       ([x y z] (boolean (and (p x) (p y) (p z))))\n       ([x y z & args] (boolean (and (ep1 x y z)\n                                     (every? p args))))))\n  ([p1 p2]\n     (fn ep2\n       ([] true)\n       ([x] (boolean (and (p1 x) (p2 x))))\n       ([x y] (boolean (and (p1 x) (p1 y) (p2 x) (p2 y))))\n       ([x y z] (boolean (and (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z))))\n       ([x y z & args] (boolean (and (ep2 x y z)\n                                     (every? #(and (p1 %) (p2 %)) args))))))\n  ([p1 p2 p3]\n     (fn ep3\n       ([] true)\n       ([x] (boolean (and (p1 x) (p2 x) (p3 x))))\n       ([x y] (boolean (and (p1 x) (p1 y) (p2 x) (p2 y) (p3 x) (p3 y))))\n       ([x y z] (boolean (and (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z) (p3 x) (p3 y) (p3 z))))\n       ([x y z & args] (boolean (and (ep3 x y z)\n                                     (every? #(and (p1 %) (p2 %) (p3 %)) args))))))\n  ([p1 p2 p3 & ps]\n     (let [ps (list* p1 p2 p3 ps)]\n       (fn epn\n         ([] true)\n         ([x] (every? #(% x) ps))\n         ([x y] (every? #(and (% x) (% y)) ps))\n         ([x y z] (every? #(and (% x) (% y) (% z)) ps))\n         ([x y z & args] (boolean (and (epn x y z)\n                                       (every? #(every? % args) ps))))))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [4730 4767]},
                                   :full-name "cljs.core/every-pred",
                                   :docstring "Takes a set of predicates and returns a function f that returns true if all of its\ncomposing predicates return a logical true value against all of its arguments, else it returns\nfalse. Note that f is short-circuiting in that it will stop execution on the first\nargument that triggers a logical false result against the original predicates."},
           "cljs.core/swap-vals!" {:ns "cljs.core",
                                   :name "swap-vals!",
                                   :signature ["[a f]"
                                               "[a f x]"
                                               "[a f x y]"
                                               "[a f x y & more]"],
                                   :name-encode "swap-valsBANG",
                                   :history [["+" "1.9.946"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/swap-valsBANG",
                                   :source {:code "(defn swap-vals!\n  {:added \"1.9\"}\n  ([a f]\n   (if (instance? Atom a)\n     (reset-vals! a (f (.-state a)))\n     [(-deref a) (-swap! a f)]))\n  ([a f x]\n   (if (instance? Atom a)\n     (reset-vals! a (f (.-state a) x))\n     [(-deref a) (-swap! a f x)]))\n  ([a f x y]\n   (if (instance? Atom a)\n     (reset-vals! a (f (.-state a) x y))\n     [(-deref a) (-swap! a f x y)]))\n  ([a f x y & more]\n   (if (instance? Atom a)\n     (reset-vals! a (apply f (.-state a) x y more))\n     [(-deref a) (-swap! a f x y more)])))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [4622 4643]},
                                   :full-name "cljs.core/swap-vals!",
                                   :docstring "Atomically swaps the value of atom to be:\n(apply f current-value-of-atom args). Note that f may be called\nmultiple times, and thus should be free of side effects.\nReturns [old new], the value of the atom before and after the swap."},
           "cljs.spec.gen.alpha/such-that" {:ns "cljs.spec.gen.alpha",
                                            :name "such-that",
                                            :signature ["[& args]"],
                                            :name-encode "such-that",
                                            :history [["+" "1.9.542"]],
                                            :type "function",
                                            :full-name-encode "cljs.spec.gen.alpha/such-that",
                                            :source {:code "(lazy-combinators hash-map list map not-empty set vector vector-distinct fmap elements\n  bind choose one-of such-that tuple sample return\n  large-integer* double* frequency shuffle)",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/cljs/cljs/spec/gen/alpha.cljs",
                                                     :lines [70 72]},
                                            :full-name "cljs.spec.gen.alpha/such-that",
                                            :docstring "Lazy loaded version of clojure.test.check.generators/such-that"},
           "cljs.core/PersistentHashSet" {:protocols #{"IFn"
                                                       "ISeqable"
                                                       "IMeta"
                                                       "IWithMeta"
                                                       "IEditableCollection"
                                                       "IEmptyableCollection"
                                                       "ISet"
                                                       "ICounted"
                                                       "ILookup"
                                                       "ICollection"
                                                       "IHash"
                                                       "IPrintWithWriter"
                                                       "IIterable"
                                                       "IEquiv"
                                                       "ICloneable"},
                                          :ns "cljs.core",
                                          :name "PersistentHashSet",
                                          :signature ["[meta hash-map __hash]"],
                                          :name-encode "PersistentHashSet",
                                          :history [["+" "0.0-1211"]],
                                          :type "type",
                                          :full-name-encode "cljs.core/PersistentHashSet",
                                          :source {:code "(deftype PersistentHashSet [meta hash-map ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (keys [coll]\n    (es6-iterator (seq coll)))\n  (entries [coll]\n    (es6-set-entries-iterator (seq coll)))\n  (values [coll]\n    (es6-iterator (seq coll)))\n  (has [coll k]\n    (contains? coll k))\n  (forEach [coll f]\n    (doseq [[k v] coll]\n      (f v k)))\n\n  ICloneable\n  (-clone [_] (PersistentHashSet. meta hash-map __hash))\n\n  IIterable\n  (-iterator [coll]\n    (HashSetIter. (-iterator hash-map)))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (PersistentHashSet. new-meta hash-map __hash)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll o]\n    (PersistentHashSet. meta (assoc hash-map o nil) nil))\n\n  IEmptyableCollection\n  (-empty [coll] (-with-meta (.-EMPTY PersistentHashSet) meta))\n\n  IEquiv\n  (-equiv [coll other]\n    (and\n     (set? other)\n     (== (count coll) (count other))\n     ^boolean\n     (try\n       (reduce-kv\n         #(or (contains? other %2) (reduced false))\n         true hash-map)\n       (catch js/Error ex\n         false))))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-unordered-coll __hash))\n\n  ISeqable\n  (-seq [coll] (keys hash-map))\n\n  ICounted\n  (-count [coll] (-count hash-map))\n\n  ILookup\n  (-lookup [coll v]\n    (-lookup coll v nil))\n  (-lookup [coll v not-found]\n    (if-let [entry (-find hash-map v)]\n      (key entry)\n      not-found))\n\n  ISet\n  (-disjoin [coll v]\n    (PersistentHashSet. meta (-dissoc hash-map v) nil))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found))\n\n  IEditableCollection\n  (-as-transient [coll] (TransientHashSet. (-as-transient hash-map))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/cljs/cljs/core.cljs",
                                                   :lines [9387 9469]},
                                          :full-name "cljs.core/PersistentHashSet"},
           "cljs.repl/doc" {:ns "cljs.repl",
                            :name "doc",
                            :signature ["[name]"],
                            :name-encode "doc",
                            :history [["+" "0.0-2496"]],
                            :type "macro",
                            :full-name-encode "cljs.repl/doc",
                            :source {:code "(defmacro doc\n  [name]\n  `(print\n     (binding [cljs.core/*print-newline* true]\n       (with-out-str\n         ~(if-let [special-name ('{& fn catch try finally try} name)]\n            `(doc ~special-name)\n            (cond\n              (special-doc-map name)\n              `(cljs.repl/print-doc (quote ~(special-doc name)))\n\n              (repl-special-doc-map name)\n              `(cljs.repl/print-doc (quote ~(repl-special-doc name)))\n\n              (keyword? name)\n              `(cljs.repl/print-doc {:spec ~name :doc (cljs.spec.alpha/describe ~name)})\n\n              (ana-api/find-ns name)\n              `(cljs.repl/print-doc\n                 (quote ~(select-keys (ana-api/find-ns name) [:name :doc])))\n\n              (ana-api/resolve &env name)\n              `(cljs.repl/print-doc\n                 (quote ~(let [var (ana-api/resolve &env name)\n                               m (select-keys var\n                                   [:ns :name :doc :forms :arglists :macro :url])]\n                           (cond-> (update-in m [:name] clojure.core/name)\n                             (:protocol-symbol var)\n                             (assoc :protocol true\n                                    :methods\n                                    (->> (get-in var [:protocol-info :methods])\n                                      (map (fn [[fname sigs]]\n                                             [fname {:doc (:doc\n                                                            (ana-api/resolve &env\n                                                              (symbol (str (:ns var)) (str fname))))\n                                                     :arglists (seq sigs)}]))\n                                      (into {})))))))))))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/clojure/cljs/repl.cljc",
                                     :lines [1431 1469]},
                            :full-name "cljs.repl/doc",
                            :docstring "Prints documentation for a var or special form given its name,\nor for a spec if given a keyword"},
           "cljs.core/use-macros" {:ns "cljs.core",
                                   :name "use-macros",
                                   :signature ["[& args]"],
                                   :name-encode "use-macros",
                                   :history [["+" "1.9.183"]],
                                   :type "macro",
                                   :full-name-encode "cljs.core/use-macros",
                                   :source {:code "(core/defmacro use-macros\n  [& args]\n  `(~'ns* ~(cons :use-macros args)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/clojure/cljs/core.cljc",
                                            :lines [3065 3068]},
                                   :full-name "cljs.core/use-macros",
                                   :docstring "Similar to use but only for macros."},
           "clojure.set/rename-keys" {:ns "clojure.set",
                                      :name "rename-keys",
                                      :signature ["[map kmap]"],
                                      :name-encode "rename-keys",
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "clojure.set/rename-keys",
                                      :source {:code "(defn rename-keys\n  [map kmap]\n    (reduce\n     (fn [m [old new]]\n       (if (contains? map old)\n         (assoc m new (get map old))\n         m))\n     (apply dissoc map (keys kmap)) kmap))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/clojure/set.cljs",
                                               :lines [72 80]},
                                      :full-name "clojure.set/rename-keys",
                                      :docstring "Returns the map with the keys in kmap renamed to the vals in kmap"},
           "closure-warnings/suspicious-code" {:ns "closure-warnings",
                                               :name "suspicious-code",
                                               :name-encode "suspicious-code",
                                               :type "warning",
                                               :full-name-encode "closure-warnings/suspicious-code",
                                               :full-name "closure-warnings/suspicious-code",
                                               :history [["+"
                                                          "1.9.473"]]},
           "cljs.core/peek" {:ns "cljs.core",
                             :name "peek",
                             :signature ["[coll]"],
                             :name-encode "peek",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/peek",
                             :source {:code "(defn peek\n  [coll]\n  (when-not (nil? coll)\n    (-peek coll)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [2143 2148]},
                             :full-name "cljs.core/peek",
                             :docstring "For a list or queue, same as first, for a vector, same as, but much\nmore efficient than, last. If the collection is empty, returns nil."},
           "closure-warnings/missing-return" {:ns "closure-warnings",
                                              :name "missing-return",
                                              :name-encode "missing-return",
                                              :type "warning",
                                              :full-name-encode "closure-warnings/missing-return",
                                              :full-name "closure-warnings/missing-return",
                                              :history [["+"
                                                         "1.9.473"]]},
           "cljs.spec.alpha/MAX_INT" {:ns "cljs.spec.alpha",
                                      :name "MAX_INT",
                                      :name-encode "MAX_INT",
                                      :type "var",
                                      :full-name-encode "cljs.spec.alpha/MAX_INT",
                                      :source {:code "(def ^:const MAX_INT 9007199254740991)",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/spec/alpha.cljs",
                                               :lines [19]},
                                      :full-name "cljs.spec.alpha/MAX_INT",
                                      :history [["+" "1.9.542"]]},
           "cljs.core/pr-str-with-opts" {:ns "cljs.core",
                                         :name "pr-str-with-opts",
                                         :signature ["[objs opts]"],
                                         :name-encode "pr-str-with-opts",
                                         :history [["+" "0.0-927"]],
                                         :type "function",
                                         :full-name-encode "cljs.core/pr-str-with-opts",
                                         :source {:code "(defn pr-str-with-opts\n  [objs opts]\n  (if (empty? objs)\n    \"\"\n    (str (pr-sb-with-opts objs opts))))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/cljs/cljs/core.cljs",
                                                  :lines [10613 10619]},
                                         :full-name "cljs.core/pr-str-with-opts",
                                         :docstring "Prints a sequence of objects to a string, observing all the\noptions given in opts"},
           "cljs.core/IChunk" {:ns "cljs.core",
                               :name "IChunk",
                               :name-encode "IChunk",
                               :implementations #{"ArrayChunk"
                                                  "IntegerRangeChunk"},
                               :history [["+" "0.0-1424"]],
                               :type "protocol",
                               :full-name-encode "cljs.core/IChunk",
                               :source {:code "(defprotocol IChunk\n  (-drop-first [coll]\n    \"Return a new chunk of coll with the first item removed.\"))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [841 844]},
                               :methods [{:name "-drop-first",
                                          :signature ["[coll]"],
                                          :docstring "Return a new chunk of coll with the first item removed."}],
                               :full-name "cljs.core/IChunk",
                               :docstring "Protocol for accessing the items of a chunk."},
           "cljs.core/ITransientVector" {:ns "cljs.core",
                                         :name "ITransientVector",
                                         :name-encode "ITransientVector",
                                         :implementations #{"TransientVector"},
                                         :history [["+" "0.0-1211"]],
                                         :type "protocol",
                                         :full-name-encode "cljs.core/ITransientVector",
                                         :source {:code "(defprotocol ITransientVector\n  (^clj -assoc-n! [tcoll n val]\n    \"Returns tcoll with value val added at position n.\")\n  (^clj -pop! [tcoll]\n    \"Returns tcoll with the last item removed from it.\"))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/cljs/cljs/core.cljs",
                                                  :lines [823 828]},
                                         :methods [{:name "-assoc-n!",
                                                    :signature ["[tcoll n val]"],
                                                    :docstring "Returns tcoll with value val added at position n."}
                                                   {:name "-pop!",
                                                    :signature ["[tcoll]"],
                                                    :docstring "Returns tcoll with the last item removed from it."}],
                                         :full-name "cljs.core/ITransientVector",
                                         :docstring "Protocol for adding vector functionality to transient collections."},
           "cljs.core/IPrintWithWriter" {:ns "cljs.core",
                                         :name "IPrintWithWriter",
                                         :name-encode "IPrintWithWriter",
                                         :implementations #{"Subvec"
                                                            "TaggedLiteral"
                                                            "Symbol"
                                                            "Cycle"
                                                            "PersistentQueue"
                                                            "PersistentHashMap"
                                                            "PersistentTreeSet"
                                                            "PersistentArrayMapSeq"
                                                            "Delay"
                                                            "RedNode"
                                                            "EmptyList"
                                                            "TransformerIterator"
                                                            "ObjMap"
                                                            "Iterate"
                                                            "BlackNode"
                                                            "PersistentVector"
                                                            "ValSeq"
                                                            "IntegerRange"
                                                            "ChunkedCons"
                                                            "Range"
                                                            "PersistentQueueSeq"
                                                            "ChunkedSeq"
                                                            "ArrayNodeSeq"
                                                            "KeySeq"
                                                            "IndexedSeq"
                                                            "ExceptionInfo"
                                                            "PersistentTreeMap"
                                                            "PersistentTreeMapSeq"
                                                            "ES6IteratorSeq"
                                                            "RSeq"
                                                            "PersistentArrayMap"
                                                            "Keyword"
                                                            "PersistentHashSet"
                                                            "NodeSeq"
                                                            "List"
                                                            "Atom"
                                                            "Repeat"
                                                            "Cons"
                                                            "Var"
                                                            "LazySeq"
                                                            "Eduction"
                                                            "MapEntry"
                                                            "UUID"
                                                            "Volatile"},
                                         :history [["+" "0.0-1503"]],
                                         :type "protocol",
                                         :full-name-encode "cljs.core/IPrintWithWriter",
                                         :source {:code "(defprotocol IPrintWithWriter\n  (-pr-writer [o writer opts]))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/cljs/cljs/core.cljs",
                                                  :lines [776 782]},
                                         :methods [{:name "-pr-writer",
                                                    :signature ["[o writer opts]"],
                                                    :docstring nil}],
                                         :full-name "cljs.core/IPrintWithWriter",
                                         :docstring "The old IPrintable protocol's implementation consisted of building a giant\n   list of strings to concatenate.  This involved lots of concat calls,\n   intermediate vectors, and lazy-seqs, and was very slow in some older JS\n   engines.  IPrintWithWriter implements printing via the IWriter protocol, so it\n   be implemented efficiently in terms of e.g. a StringBuffer append."},
           "cljs.spec.impl.gen/keyword-ns" {:ns "cljs.spec.impl.gen",
                                            :name "keyword-ns",
                                            :signature ["[& args]"],
                                            :name-encode "keyword-ns",
                                            :history [["+" "1.9.14"]
                                                      ["-" "1.9.542"]],
                                            :type "function",
                                            :full-name-encode "cljs.spec.impl.gen/keyword-ns",
                                            :source {:code "(lazy-prims any any-printable boolean char char-alpha char-alphanumeric char-ascii double\n  int keyword keyword-ns large-integer ratio simple-type simple-type-printable\n  string string-ascii string-alphanumeric symbol symbol-ns uuid)",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.9.521",
                                                     :filename "src/main/cljs/cljs/spec/impl/gen.cljs",
                                                     :lines [73 75]},
                                            :full-name "cljs.spec.impl.gen/keyword-ns",
                                            :docstring "Fn returning clojure.test.check.generators/keyword-ns",
                                            :removed {:in "1.9.542",
                                                      :last-seen "1.9.521"}},
           "cljs.core/test" {:ns "cljs.core",
                             :name "test",
                             :signature ["[v]"],
                             :name-encode "test",
                             :history [["+" "0.0-2496"]],
                             :type "function",
                             :full-name-encode "cljs.core/test",
                             :source {:code "(defn test\n  [v]\n  (let [f (if (instance? Var v)\n            (-> v meta :test)\n            (some-> v .-cljs$lang$test))]\n    (if f\n      (do (f) :ok)\n      :no-test)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [11888 11902]},
                             :full-name "cljs.core/test",
                             :docstring "test [v] - if var, finds fn at key :test in var metadata, if function, finds\nspecial test property. Calls it, presuming failure will throw exception.\n\nExamples:\n\n(test my-fn) ;; :ok\n(test #'my-fn) ;; :ok"},
           "cljs.math/atan2" {:return-type number,
                              :ns "cljs.math",
                              :name "atan2",
                              :signature ["[y x]"],
                              :name-encode "atan2",
                              :history [["+" "1.11.50"]],
                              :type "function",
                              :full-name-encode "cljs.math/atan2",
                              :source {:code "(defn ^number atan2\n  {:added \"1.11.10\"}\n  [y x] (Math/atan2 y x))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/math.cljs",
                                       :lines [478 484]},
                              :full-name "cljs.math/atan2",
                              :docstring "Returns the angle theta from the conversion of rectangular coordinates (x, y) to polar coordinates (r, theta).\nComputes the phase theta by computing an arc tangent of y/x in the range of -pi to pi.\nFor more details on special cases, see:\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/atan"},
           "cljs.core/map?" {:ns "cljs.core",
                             :name "map?",
                             :signature ["[x]"],
                             :name-encode "mapQMARK",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/mapQMARK",
                             :source {:code "(defn map?\n  [x]\n  (if (nil? x)\n    false\n    (satisfies? IMap x)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [2220 2225]},
                             :full-name "cljs.core/map?",
                             :docstring "Return true if x satisfies IMap"},
           "compiler-options/elide-asserts" {:ns "compiler-options",
                                             :name "elide-asserts",
                                             :name-encode "elide-asserts",
                                             :type "option",
                                             :full-name-encode "compiler-options/elide-asserts",
                                             :full-name "compiler-options/elide-asserts",
                                             :history [["+"
                                                        "0.0-2156"]]},
           "syntax/predicate" {:syntax-equiv {:edn-url nil,
                                              :clj-url nil},
                               :ns "syntax",
                               :name "predicate",
                               :name-encode "predicate",
                               :type "convention",
                               :full-name-encode "syntax/predicate",
                               :full-name "syntax/predicate",
                               :history [["+" "0.0-927"]]},
           "cljs.repl.node/node-eval" {:ns "cljs.repl.node",
                                       :name "node-eval",
                                       :signature ["[repl-env js]"],
                                       :name-encode "node-eval",
                                       :history [["+" "0.0-2629"]],
                                       :type "function",
                                       :full-name-encode "cljs.repl.node/node-eval",
                                       :source {:code "(defn node-eval\n  [repl-env js]\n  (let [tname (thread-name)\n        {:keys [out]} @(:socket repl-env)]\n    (write out (json/write-str {:type \"eval\" :repl tname :form js}))\n    (let [result (.take ^LinkedBlockingQueue (.get results tname))]\n      (condp = (:status result)\n        \"success\"\n        {:status :success\n         :value (:value result)}\n\n        \"exception\"\n        {:status :exception\n         :value (:value result)}))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/clojure/cljs/repl/node.clj",
                                                :lines [61 75]},
                                       :full-name "cljs.repl.node/node-eval",
                                       :docstring "Evaluate a JavaScript string in the Node REPL process."},
           "closure-warnings/report-unknown-types" {:ns "closure-warnings",
                                                    :name "report-unknown-types",
                                                    :name-encode "report-unknown-types",
                                                    :type "warning",
                                                    :full-name-encode "closure-warnings/report-unknown-types",
                                                    :full-name "closure-warnings/report-unknown-types",
                                                    :history [["+"
                                                               "1.9.473"]]},
           "cljs.reader/StringPushbackReader" {:protocols #{"PushbackReader"},
                                               :ns "cljs.reader",
                                               :name "StringPushbackReader",
                                               :signature ["[s buffer idx]"],
                                               :name-encode "StringPushbackReader",
                                               :history [["+"
                                                          "0.0-927"]
                                                         ["-"
                                                          "1.9.854"]],
                                               :type "type",
                                               :full-name-encode "cljs.reader/StringPushbackReader",
                                               :source {:code "(deftype StringPushbackReader [s buffer ^:mutable idx]\n  PushbackReader\n  (read-char [reader]\n    (if (zero? (alength buffer))\n      (do\n        (set! idx (inc idx))\n        (aget s idx))\n      (.pop buffer)))\n  (unread [reader ch]\n    (.push buffer ch)))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.9.671",
                                                        :filename "src/main/cljs/cljs/reader.cljs",
                                                        :lines [19 28]},
                                               :full-name "cljs.reader/StringPushbackReader",
                                               :removed {:in "1.9.854",
                                                         :last-seen "1.9.671"}},
           "cljs.pprint/code-dispatch" {:ns "cljs.pprint",
                                        :name "code-dispatch",
                                        :name-encode "code-dispatch",
                                        :history [["+" "0.0-3255"]],
                                        :type "multimethod",
                                        :full-name-encode "cljs.pprint/code-dispatch",
                                        :source {:code "(defmulti\n  code-dispatch\n  {:added \"1.2\" :arglists '[[object]]}\n  type-dispatcher)",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/cljs/cljs/pprint.cljs",
                                                 :lines [3203 3207]},
                                        :full-name "cljs.pprint/code-dispatch",
                                        :docstring "The pretty print dispatch function for pretty printing Clojure code."},
           "cljs.spec.alpha/Specize" {:ns "cljs.spec.alpha",
                                      :name "Specize",
                                      :name-encode "Specize",
                                      :history [["+" "1.9.542"]],
                                      :type "protocol",
                                      :full-name-encode "cljs.spec.alpha/Specize",
                                      :source {:code "(defprotocol Specize\n  (specize* [_] [_ form]))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/spec/alpha.cljs",
                                               :lines [131 132]},
                                      :methods [{:name "specize*",
                                                 :signature ["[_]"
                                                             "[_ form]"],
                                                 :docstring nil}],
                                      :full-name "cljs.spec.alpha/Specize"},
           "cljs.spec.test/run-tests" {:ns "cljs.spec.test",
                                       :name "run-tests",
                                       :signature ["[]" "[& ns-syms]"],
                                       :name-encode "run-tests",
                                       :history [["+" "1.9.14"]
                                                 ["-" "1.9.183"]],
                                       :type "macro",
                                       :full-name-encode "cljs.spec.test/run-tests",
                                       :source {:code "(defmacro run-tests\n  ([]\n   `(cljs.spec.test/run-tests '~ana/*cljs-ns*))\n  ([& ns-syms]\n   `(cljs.spec.test/run-var-tests\n      (->> #?(:clj  ~(spec/speced-vars* ns-syms)\n              :cljs ~(cljs.spec$macros/speced-vars* ns-syms))\n        (filter (fn [v#] (:args (cljs.spec/get-spec v#))))))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.9.93",
                                                :filename "src/main/cljs/cljs/spec/test.cljc",
                                                :lines [15 24]},
                                       :full-name "cljs.spec.test/run-tests",
                                       :docstring "Like run-all-tests, but scoped to specific namespaces, or to\n*ns* if no ns-sym are specified.",
                                       :removed {:in "1.9.183",
                                                 :last-seen "1.9.93"}},
           "cljs.core/PersistentTreeMap" {:protocols #{"IFn"
                                                       "ISeqable"
                                                       "IMap"
                                                       "IMeta"
                                                       "IWithMeta"
                                                       "IKVReduce"
                                                       "IReversible"
                                                       "IEmptyableCollection"
                                                       "ICounted"
                                                       "ILookup"
                                                       "ISorted"
                                                       "ICollection"
                                                       "IHash"
                                                       "IPrintWithWriter"
                                                       "IAssociative"
                                                       "IFind"
                                                       "IEquiv"
                                                       "ICloneable"},
                                          :ns "cljs.core",
                                          :name "PersistentTreeMap",
                                          :signature ["[comp tree cnt meta __hash]"],
                                          :name-encode "PersistentTreeMap",
                                          :history [["+" "0.0-1211"]],
                                          :type "type",
                                          :full-name-encode "cljs.core/PersistentTreeMap",
                                          :source {:code "(deftype PersistentTreeMap [comp tree cnt meta ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (keys [coll]\n    (es6-iterator (keys coll)))\n  (entries [coll]\n    (es6-entries-iterator (seq coll)))\n  (values [coll]\n    (es6-iterator (vals coll)))\n  (has [coll k]\n    (contains? coll k))\n  (get [coll k not-found]\n    (-lookup coll k not-found))\n  (forEach [coll f]\n    (doseq [[k v] coll]\n      (f v k)))\n\n  (entry-at [coll k]\n    (loop [t tree]\n      (if-not (nil? t)\n        (let [c (comp k (.-key t))]\n          (cond (zero? c) t\n                (neg? c)  (recur (.-left t))\n                :else     (recur (.-right t)))))))\n\n  ICloneable\n  (-clone [_] (PersistentTreeMap. comp tree cnt meta __hash))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (PersistentTreeMap. comp tree cnt new-meta __hash)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (loop [ret coll es (seq entry)]\n        (if (nil? es)\n          ret\n          (let [e (first es)]\n            (if (vector? e)\n              (recur (-assoc ret (-nth e 0) (-nth e 1))\n                     (next es))\n              (throw (js/Error. \"conj on a map takes map entries or seqables of map entries\"))))))))\n\n  IEmptyableCollection\n  (-empty [coll] (PersistentTreeMap. comp nil 0 meta 0))\n\n  IEquiv\n  (-equiv [coll other] (equiv-map coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-unordered-coll __hash))\n\n  ICounted\n  (-count [coll] cnt)\n\n  IKVReduce\n  (-kv-reduce [coll f init]\n    (if-not (nil? tree)\n      (unreduced (tree-map-kv-reduce tree f init))\n      init))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found))\n\n  ISeqable\n  (-seq [coll]\n    (if (pos? cnt)\n      (create-tree-map-seq tree true cnt)))\n\n  IReversible\n  (-rseq [coll]\n    (if (pos? cnt)\n      (create-tree-map-seq tree false cnt)))\n\n  ILookup\n  (-lookup [coll k]\n    (-lookup coll k nil))\n\n  (-lookup [coll k not-found]\n    (let [n (.entry-at coll k)]\n      (if-not (nil? n)\n        (.-val n)\n        not-found)))\n\n  IAssociative\n  (-assoc [coll k v]\n    (let [found (array nil)\n          t     (tree-map-add comp tree k v found)]\n      (if (nil? t)\n        (let [found-node (nth found 0)]\n          (if (= v (.-val found-node))\n            coll\n            (PersistentTreeMap. comp (tree-map-replace comp tree k v) cnt meta nil)))\n        (PersistentTreeMap. comp (.blacken t) (inc cnt) meta nil))))\n\n  (-contains-key? [coll k]\n    (not (nil? (.entry-at coll k))))\n\n  IFind\n  (-find [coll k]\n    (.entry-at coll k))\n\n  IMap\n  (-dissoc [coll k]\n    (let [found (array nil)\n          t     (tree-map-remove comp tree k found)]\n      (if (nil? t)\n        (if (nil? (nth found 0))\n          coll\n          (PersistentTreeMap. comp nil 0 meta nil))\n        (PersistentTreeMap. comp (.blacken t) (dec cnt) meta nil))))\n\n  ISorted\n  (-sorted-seq [coll ascending?]\n    (if (pos? cnt)\n      (create-tree-map-seq tree ascending? cnt)))\n\n  (-sorted-seq-from [coll k ascending?]\n    (if (pos? cnt)\n      (loop [stack nil t tree]\n        (if-not (nil? t)\n          (let [c (comp k (.-key t))]\n            (cond\n              (zero? c)  (PersistentTreeMapSeq. nil (conj stack t) ascending? -1 nil)\n              ascending? (if (neg? c)\n                           (recur (conj stack t) (.-left t))\n                           (recur stack          (.-right t)))\n              :else      (if (pos? c)\n                           (recur (conj stack t) (.-right t))\n                           (recur stack          (.-left t)))))\n          (when-not (nil? stack)\n            (PersistentTreeMapSeq. nil stack ascending? -1 nil))))))\n\n  (-entry-key [coll entry] (key entry))\n\n  (-comparator [coll] comp))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/cljs/cljs/core.cljs",
                                                   :lines [8959 9108]},
                                          :full-name "cljs.core/PersistentTreeMap"},
           "cljs.core/HashMap.fromArrays" {:ns "cljs.core",
                                           :name "HashMap.fromArrays",
                                           :signature ["[ks vs]"],
                                           :name-encode "HashMapDOTfromArrays",
                                           :history [["+" "0.0-927"]
                                                     ["-" "0.0-1798"]],
                                           :parent-type "HashMap",
                                           :type "function",
                                           :full-name-encode "cljs.core/HashMapDOTfromArrays",
                                           :source {:code "(set! cljs.core.HashMap/fromArrays (fn [ks vs]\n  (let [len (alength ks)]\n    (loop [i 0, out cljs.core.HashMap/EMPTY]\n      (if (< i len)\n        (recur (inc i) (assoc out (aget ks i) (aget vs i)))\n        out)))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1586",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [3832 3837]},
                                           :full-name "cljs.core/HashMap.fromArrays",
                                           :removed {:in "0.0-1798",
                                                     :last-seen "0.0-1586"}},
           "cljs.core/deref" {:ns "cljs.core",
                              :name "deref",
                              :signature ["[o]"],
                              :name-encode "deref",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/deref",
                              :source {:code "(defn deref\n  [o]\n  (-deref o))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [1499 1505]},
                              :full-name "cljs.core/deref",
                              :docstring "Also reader macro: @var/@atom/@delay. Returns the\nmost-recently-committed value of ref. When applied to a var\nor atom, returns its current state. When applied to a delay, forces\nit if not already forced. See also - realized?."},
           "cljs.core/reductions" {:ns "cljs.core",
                                   :name "reductions",
                                   :signature ["[f coll]"
                                               "[f init coll]"],
                                   :name-encode "reductions",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/reductions",
                                   :source {:code "(defn reductions\n  ([f coll]\n   (lazy-seq\n     (if-let [s (seq coll)]\n       (reductions f (first s) (rest s))\n       (list (f)))))\n  ([f init coll]\n   (if (reduced? init)\n     (list @init)\n     (cons init\n       (lazy-seq\n         (when-let [s (seq coll)]\n           (reductions f (f init (first s)) (rest s))))))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [10293 10307]},
                                   :full-name "cljs.core/reductions",
                                   :docstring "Returns a lazy seq of the intermediate values of the reduction (as\nper reduce) of coll by f, starting with init."},
           "cljs.spec.test.alpha/with-instrument-disabled" {:ns "cljs.spec.test.alpha",
                                                            :name "with-instrument-disabled",
                                                            :signature ["[& body]"],
                                                            :name-encode "with-instrument-disabled",
                                                            :history [["+"
                                                                       "1.9.542"]],
                                                            :type "macro",
                                                            :full-name-encode "cljs.spec.test.alpha/with-instrument-disabled",
                                                            :source {:code "(defmacro with-instrument-disabled\n  [& body]\n  ;; Note: In order to read the value of this private var, we employ interop\n  ;; rather than derefing a var special. This eases specing core functions\n  ;; (and infinite recursion) by avoiding code generated by the var special,\n  ;; and also produces more compact / efficient code.\n  `(let [orig# (.-*instrument-enabled* js/cljs.spec.test.alpha)]\n     (set! *instrument-enabled* nil)\n     (try\n       ~@body\n       (finally\n         (set! *instrument-enabled* orig#)))))",
                                                                     :title "Source code",
                                                                     :repo "clojurescript",
                                                                     :tag "r1.12.38",
                                                                     :filename "src/main/cljs/cljs/spec/test/alpha.cljc",
                                                                     :lines [46
                                                                             58]},
                                                            :full-name "cljs.spec.test.alpha/with-instrument-disabled",
                                                            :docstring "Disables instrument's checking of calls, within a scope."},
           "cljs.spec.gen.alpha/any-printable" {:ns "cljs.spec.gen.alpha",
                                                :name "any-printable",
                                                :signature ["[& args]"],
                                                :name-encode "any-printable",
                                                :history [["+"
                                                           "1.9.542"]],
                                                :type "function",
                                                :full-name-encode "cljs.spec.gen.alpha/any-printable",
                                                :source {:code "(lazy-prims any any-printable boolean char char-alpha char-alphanumeric char-ascii double\n  int keyword keyword-ns large-integer ratio simple-type simple-type-printable\n  string string-ascii string-alphanumeric symbol symbol-ns uuid)",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1.12.38",
                                                         :filename "src/main/cljs/cljs/spec/gen/alpha.cljs",
                                                         :lines [74
                                                                 76]},
                                                :full-name "cljs.spec.gen.alpha/any-printable",
                                                :docstring "Fn returning clojure.test.check.generators/any-printable"},
           "cljs.core/false?" {:return-type boolean,
                               :ns "cljs.core",
                               :name "false?",
                               :signature ["[x]"],
                               :name-encode "falseQMARK",
                               :history [["+" "0.0-927"]],
                               :type "function/macro",
                               :full-name-encode "cljs.core/falseQMARK",
                               :source {:code "(defn ^boolean false?\n  [x] (cljs.core/false? x))",
                                        :title "Function code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [2282 2284]},
                               :extra-sources [{:code "(core/defmacro false? [x]\n  (bool-expr (core/list 'js* \"~{} === false\" x)))",
                                                :title "Macro code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/clojure/cljs/core.cljc",
                                                :lines [967 968]}],
                               :full-name "cljs.core/false?",
                               :docstring "Returns true if x is the value false, false otherwise."},
           "warnings/undeclared-protocol-symbol" {:ns "warnings",
                                                  :name "undeclared-protocol-symbol",
                                                  :name-encode "undeclared-protocol-symbol",
                                                  :type "warning",
                                                  :full-name-encode "warnings/undeclared-protocol-symbol",
                                                  :full-name "warnings/undeclared-protocol-symbol",
                                                  :history [["+"
                                                             "0.0-2014"]]},
           "cljs.core/bit-flip" {:ns "cljs.core",
                                 :name "bit-flip",
                                 :signature ["[x n]"],
                                 :name-encode "bit-flip",
                                 :history [["+" "0.0-927"]],
                                 :type "function/macro",
                                 :full-name-encode "cljs.core/bit-flip",
                                 :source {:code "(defn bit-flip\n  [x n]\n  (cljs.core/bit-flip x n))",
                                          :title "Function code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [2966 2969]},
                                 :extra-sources [{:code "(core/defmacro ^::ana/numeric bit-flip [x n]\n  (core/list 'js* \"(~{} ^ (1 << ~{}))\" x n))",
                                                  :title "Macro code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/clojure/cljs/core.cljc",
                                                  :lines [1225 1226]}],
                                 :full-name "cljs.core/bit-flip",
                                 :docstring "Flip bit at index n"},
           "cljs.test/deftest" {:ns "cljs.test",
                                :name "deftest",
                                :signature ["[name & body]"],
                                :name-encode "deftest",
                                :history [["+" "0.0-2496"]],
                                :type "macro",
                                :full-name-encode "cljs.test/deftest",
                                :source {:code "(defmacro deftest\n  [name & body]\n  (when ana/*load-tests*\n    `(do\n       (def ~(vary-meta name assoc :test `(fn [] ~@body))\n         (fn [] (cljs.test/test-var (.-cljs$lang$var ~name))))\n       (set! (.-cljs$lang$var ~name) (var ~name)))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/test.cljc",
                                         :lines [230 246]},
                                :full-name "cljs.test/deftest",
                                :docstring "Defines a test function with no arguments.  Test functions may call\nother tests, so tests may be composed.  If you compose tests, you\nshould also define a function named test-ns-hook; run-tests will\ncall test-ns-hook instead of testing all vars.\n\nNote: Actually, the test body goes in the :test metadata on the var,\nand the real function (the value of the var) calls test-var on\nitself.\n\nWhen cljs.analyzer/*load-tests* is false, deftest is ignored."},
           "cljs.spec.impl.gen/keyword" {:ns "cljs.spec.impl.gen",
                                         :name "keyword",
                                         :signature ["[& args]"],
                                         :name-encode "keyword",
                                         :history [["+" "1.9.14"]
                                                   ["-" "1.9.542"]],
                                         :type "function",
                                         :full-name-encode "cljs.spec.impl.gen/keyword",
                                         :source {:code "(lazy-prims any any-printable boolean char char-alpha char-alphanumeric char-ascii double\n  int keyword keyword-ns large-integer ratio simple-type simple-type-printable\n  string string-ascii string-alphanumeric symbol symbol-ns uuid)",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.9.521",
                                                  :filename "src/main/cljs/cljs/spec/impl/gen.cljs",
                                                  :lines [73 75]},
                                         :full-name "cljs.spec.impl.gen/keyword",
                                         :docstring "Fn returning clojure.test.check.generators/keyword",
                                         :removed {:in "1.9.542",
                                                   :last-seen "1.9.521"}},
           "cljs.core/ISet" {:ns "cljs.core",
                             :name "ISet",
                             :name-encode "ISet",
                             :implementations #{"PersistentTreeSet"
                                                "PersistentHashSet"},
                             :history [["+" "0.0-927"]],
                             :type "protocol",
                             :full-name-encode "cljs.core/ISet",
                             :source {:code "(defprotocol ISet\n  (^clj -disjoin [coll v]\n    \"Returns a new collection of coll that does not contain v.\"))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [670 673]},
                             :methods [{:name "-disjoin",
                                        :signature ["[coll v]"],
                                        :docstring "Returns a new collection of coll that does not contain v."}],
                             :full-name "cljs.core/ISet",
                             :docstring "Protocol for adding set functionality to a collection."},
           "repl-options/working-dir" {:ns "repl-options",
                                       :name "working-dir",
                                       :name-encode "working-dir",
                                       :type "option",
                                       :full-name-encode "repl-options/working-dir",
                                       :full-name "repl-options/working-dir",
                                       :history [["+" "0.0-971"]]},
           "cljs.core/require" {:ns "cljs.core",
                                :name "require",
                                :signature ["[& args]"],
                                :name-encode "require",
                                :history [["+" "0.0-2629"]],
                                :type "macro",
                                :full-name-encode "cljs.core/require",
                                :source {:code "(core/defmacro require\n  [& args]\n  `(~'ns* ~(cons :require args)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/clojure/cljs/core.cljc",
                                         :lines [2992 3045]},
                                :full-name "cljs.core/require",
                                :docstring "Loads libs, skipping any that are already loaded. Each argument is\neither a libspec that identifies a lib or a flag that modifies how all the identified\nlibs are loaded. Use :require in the ns macro in preference to calling this\ndirectly.\n\nLibs\n\nA 'lib' is a named set of resources in classpath whose contents define a\nlibrary of ClojureScript code. Lib names are symbols and each lib is associated\nwith a ClojureScript namespace. A lib's name also locates its root directory\nwithin classpath using Java's package name to classpath-relative path mapping.\nAll resources in a lib should be contained in the directory structure under its\nroot directory. All definitions a lib makes should be in its associated namespace.\n\n'require loads a lib by loading its root resource. The root resource path\nis derived from the lib name in the following manner:\nConsider a lib named by the symbol 'x.y.z; it has the root directory\n<classpath>/x/y/, and its root resource is <classpath>/x/y/z.clj. The root\nresource should contain code to create the lib's namespace (usually by using\nthe ns macro) and load any additional lib resources.\n\nLibspecs\n\nA libspec is a lib name or a vector containing a lib name followed by\noptions expressed as sequential keywords and arguments.\n\nRecognized options:\n:as takes a symbol as its argument and makes that symbol an alias to the\n  lib's namespace in the current namespace.\n:refer takes a list of symbols to refer from the namespace.\n:refer-macros takes a list of macro symbols to refer from the namespace.\n:include-macros true causes macros from the namespace to be required.\n:rename specifies a map from referred var names to different\n  symbols (and can be used to prevent clashes)\n\n\nFlags\n\nA flag is a keyword.\nRecognized flags: :reload, :reload-all, :verbose\n:reload forces loading of all the identified libs even if they are\n  already loaded\n:reload-all implies :reload and also forces loading of all libs that the\n  identified libs directly or indirectly load via require or use\n:verbose triggers printing information about each load, alias, and refer\n\nExample:\n\nThe following would load the library clojure.string :as string.\n\n(require '[clojure.string :as string])"},
           "cljs.core/StringIter" {:ns "cljs.core",
                                   :name "StringIter",
                                   :signature ["[s i]"],
                                   :name-encode "StringIter",
                                   :history [["+" "0.0-2301"]],
                                   :type "type",
                                   :full-name-encode "cljs.core/StringIter",
                                   :source {:code "(deftype StringIter [s ^:mutable i]\n  Object\n  (hasNext [_] (< i (.-length s)))\n  (next [_]\n    (let [ret (.charAt s i)]\n      (set! i (inc i))\n      ret))\n  (remove [_] (js/Error. \"Unsupported operation\")))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [4111 4118]},
                                   :full-name "cljs.core/StringIter"},
           "cljs.spec.gen.alpha/string-alphanumeric" {:ns "cljs.spec.gen.alpha",
                                                      :name "string-alphanumeric",
                                                      :signature ["[& args]"],
                                                      :name-encode "string-alphanumeric",
                                                      :history [["+"
                                                                 "1.9.542"]],
                                                      :type "function",
                                                      :full-name-encode "cljs.spec.gen.alpha/string-alphanumeric",
                                                      :source {:code "(lazy-prims any any-printable boolean char char-alpha char-alphanumeric char-ascii double\n  int keyword keyword-ns large-integer ratio simple-type simple-type-printable\n  string string-ascii string-alphanumeric symbol symbol-ns uuid)",
                                                               :title "Source code",
                                                               :repo "clojurescript",
                                                               :tag "r1.12.38",
                                                               :filename "src/main/cljs/cljs/spec/gen/alpha.cljs",
                                                               :lines [74
                                                                       76]},
                                                      :full-name "cljs.spec.gen.alpha/string-alphanumeric",
                                                      :docstring "Fn returning clojure.test.check.generators/string-alphanumeric"},
           "cljs.core/LazySeq" {:protocols #{"ISeqable"
                                             "IMeta"
                                             "IWithMeta"
                                             "IEmptyableCollection"
                                             "IPending"
                                             "IReduce"
                                             "ISequential"
                                             "ISeq"
                                             "ICollection"
                                             "IHash"
                                             "IPrintWithWriter"
                                             "INext"
                                             "IEquiv"},
                                :ns "cljs.core",
                                :name "LazySeq",
                                :signature ["[meta fn s __hash]"],
                                :name-encode "LazySeq",
                                :history [["+" "0.0-927"]],
                                :type "type",
                                :full-name-encode "cljs.core/LazySeq",
                                :source {:code "(deftype LazySeq [meta ^:mutable fn ^:mutable s ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (sval [coll]\n    (if (nil? fn)\n      s\n      (do\n        (set! s (fn))\n        (set! fn nil)\n        s)))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IPending\n  (-realized? [coll]\n    (not fn))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (LazySeq. new-meta #(-seq coll) nil __hash)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll]\n    (-seq coll)\n    (when-not (nil? s)\n      (first s)))\n  (-rest [coll]\n    (-seq coll)\n    (if-not (nil? s)\n      (rest s)\n      ()))\n\n  INext\n  (-next [coll]\n    (-seq coll)\n    (when-not (nil? s)\n      (next s)))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (-with-meta (.-EMPTY List) meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (.sval coll)\n    (when-not (nil? s)\n      (loop [ls s]\n        (if (instance? LazySeq ls)\n          (recur (.sval ls))\n          (do (set! s ls)\n              (seq s))))))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [3506 3583]},
                                :full-name "cljs.core/LazySeq"},
           "cljs.core/pop!" {:ns "cljs.core",
                             :name "pop!",
                             :signature ["[tcoll]"],
                             :name-encode "popBANG",
                             :history [["+" "0.0-1211"]],
                             :type "function",
                             :full-name-encode "cljs.core/popBANG",
                             :source {:code "(defn pop!\n  [tcoll]\n  (-pop! tcoll))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [3950 3954]},
                             :full-name "cljs.core/pop!",
                             :docstring "Removes the last item from a transient vector. If\nthe collection is empty, throws an exception. Returns tcoll"},
           "cljs.analyzer.api/with-state" {:ns "cljs.analyzer.api",
                                           :name "with-state",
                                           :signature ["[state & body]"],
                                           :name-encode "with-state",
                                           :history [["+" "1.7.10"]],
                                           :type "macro",
                                           :full-name-encode "cljs.analyzer.api/with-state",
                                           :source {:code "(defmacro with-state\n  [state & body]\n  `(env/with-compiler-env ~state\n     ~@body))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/clojure/cljs/analyzer/api.cljc",
                                                    :lines [51 55]},
                                           :full-name "cljs.analyzer.api/with-state",
                                           :docstring "Run the body with the given compilation state Atom<Map>."},
           "cljs.spec.alpha/alt" {:ns "cljs.spec.alpha",
                                  :name "alt",
                                  :signature ["[& key-pred-forms]"],
                                  :name-encode "alt",
                                  :history [["+" "1.9.542"]],
                                  :type "macro",
                                  :full-name-encode "cljs.spec.alpha/alt",
                                  :source {:code "(defmacro alt\n  [& key-pred-forms]\n  (let [pairs (partition 2 key-pred-forms)\n        keys (mapv first pairs)\n        pred-forms (mapv second pairs)\n        pf (mapv #(res &env %) pred-forms)]\n    (clojure.core/assert (clojure.core/and (even? (count key-pred-forms)) (every? keyword? keys)) \"alt expects k1 p1 k2 p2..., where ks are keywords\")\n    `(alt-impl ~keys ~pred-forms '~pf)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/spec/alpha.cljc",
                                           :lines [339 354]},
                                  :full-name "cljs.spec.alpha/alt",
                                  :docstring "Takes key+pred pairs, e.g.\n\n(s/alt :even even? :small #(< % 42))\n\nReturns a regex op that returns a map entry containing the key of the\nfirst matching pred and the corresponding value. Thus the\n'key' and 'val' functions can be used to refer generically to the\ncomponents of the tagged return."},
           "cljs.reader/parse-timestamp" {:ns "cljs.reader",
                                          :name "parse-timestamp",
                                          :signature ["[ts]"],
                                          :name-encode "parse-timestamp",
                                          :history [["+" "0.0-1424"]],
                                          :type "function",
                                          :full-name-encode "cljs.reader/parse-timestamp",
                                          :source {:code "(defn parse-timestamp\n  [ts]\n  (if-let [[years months days hours minutes seconds ms offset]\n           (parse-and-validate-timestamp ts)]\n    (js/Date.\n      (- (.UTC js/Date years (dec months) days hours minutes seconds ms)\n        (* offset 60 1000)))\n    (throw (js/Error. (str \"Unrecognized date/time syntax: \" ts)))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/cljs/cljs/reader.cljs",
                                                   :lines [83 90]},
                                          :full-name "cljs.reader/parse-timestamp"},
           "cljs.build.api/ns->location" {:ns "cljs.build.api",
                                          :name "ns->location",
                                          :signature ["[ns]"
                                                      "[ns compiler-env]"],
                                          :name-encode "ns-GTlocation",
                                          :history [["+" "0.0-3291"]],
                                          :type "function",
                                          :full-name-encode "cljs.build.api/ns-GTlocation",
                                          :source {:code "(defn ns->location\n  ([ns]\n   (ns->location ns (or (ana-api/current-state) (ana-api/empty-state))))\n  ([ns compiler-env]\n   (closure/source-for-namespace ns compiler-env)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/clojure/cljs/build/api.clj",
                                                   :lines [120 128]},
                                          :full-name "cljs.build.api/ns->location",
                                          :docstring "Given a namespace and compilation environment return the relative path and\nuri of the corresponding source regardless of the source language extension:\n.cljs, .cljc, .js. Returns a map containing :relative-path a string, and\n:uri a URL."},
           "cljs.core/*warn-on-infer*" {:ns "cljs.core",
                                        :name "*warn-on-infer*",
                                        :name-encode "STARwarn-on-inferSTAR",
                                        :type "var",
                                        :full-name-encode "cljs.core/STARwarn-on-inferSTAR",
                                        :source {:code "(def *warn-on-infer* false)",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/cljs/cljs/core.cljs",
                                                 :lines [33]},
                                        :full-name "cljs.core/*warn-on-infer*",
                                        :history [["+" "1.9.456"]]},
           "compiler-options/source-map-timestamp" {:ns "compiler-options",
                                                    :name "source-map-timestamp",
                                                    :name-encode "source-map-timestamp",
                                                    :type "option",
                                                    :full-name-encode "compiler-options/source-map-timestamp",
                                                    :full-name "compiler-options/source-map-timestamp",
                                                    :history [["+"
                                                               "0.0-2505"]]},
           "warnings/non-dynamic-earmuffed-var" {:ns "warnings",
                                                 :name "non-dynamic-earmuffed-var",
                                                 :name-encode "non-dynamic-earmuffed-var",
                                                 :type "warning",
                                                 :full-name-encode "warnings/non-dynamic-earmuffed-var",
                                                 :full-name "warnings/non-dynamic-earmuffed-var",
                                                 :history [["+"
                                                            "1.10.439"]]},
           "cljs.repl/mapped-stacktrace" {:ns "cljs.repl",
                                          :name "mapped-stacktrace",
                                          :signature ["[stacktrace]"
                                                      "[stacktrace opts]"],
                                          :name-encode "mapped-stacktrace",
                                          :history [["+" "0.0-2843"]],
                                          :type "function",
                                          :full-name-encode "cljs.repl/mapped-stacktrace",
                                          :source {:code "(defn mapped-stacktrace\n  ([stacktrace] (mapped-stacktrace stacktrace nil))\n  ([stacktrace opts]\n   (vec\n     (let [mapped-frames (map (memoize #(mapped-frame % opts)) stacktrace)]\n       ;; take each non-nil :call and optionally merge it into :function one-level up\n       ;; to avoid replacing with local symbols, we only replace munged name if we can munge call symbol back to it\n       (map #(merge-with (fn [munged-fn-name unmunged-call-name]\n                           (if (= munged-fn-name (string/replace (cljs.compiler/munge unmunged-call-name) \".\" \"$\"))\n                             unmunged-call-name\n                             munged-fn-name)) %1 %2)\n         (map #(dissoc % :call) mapped-frames)\n         (concat (rest (map #(if (:call %)\n                              (hash-map :function (:call %))\n                              {})\n                         mapped-frames)) [{}]))))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/clojure/cljs/repl.cljc",
                                                   :lines [364 392]},
                                          :full-name "cljs.repl/mapped-stacktrace",
                                          :docstring "Given a vector representing the canonicalized JavaScript stacktrace\nreturn the ClojureScript stacktrace. The canonical stacktrace must be\nin the form:\n\n [{:file <string>\n   :function <string>\n   :line <integer>\n   :column <integer>}*]\n\n:file must be a URL path (without protocol) relative to :output-dir or a\nidentifier delimited by angle brackets. The returned mapped stacktrace will\nalso contain :url entries to the original sources if it can be determined\nfrom the classpath."},
           "cljs.repl.rhino/IEval" {:ns "cljs.repl.rhino",
                                    :name "IEval",
                                    :name-encode "IEval",
                                    :history [["+" "0.0-927"]
                                              ["-" "1.10.738"]],
                                    :type "protocol",
                                    :full-name-encode "cljs.repl.rhino/IEval",
                                    :source {:code "(defprotocol IEval\n  (-eval [this env filename line]))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.10.597",
                                             :filename "src/main/clojure/cljs/repl/rhino.clj",
                                             :lines [38 39]},
                                    :methods [{:name "-eval",
                                               :signature ["[this env filename line]"],
                                               :docstring nil}],
                                    :full-name "cljs.repl.rhino/IEval",
                                    :removed {:in "1.10.738",
                                              :last-seen "1.10.597"}},
           "cljs.core/chunk-first" {:ns "cljs.core",
                                    :name "chunk-first",
                                    :signature ["[s]"],
                                    :name-encode "chunk-first",
                                    :history [["+" "0.0-1424"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/chunk-first",
                                    :source {:code "(defn chunk-first [s]\n  (-chunked-first s))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [3722 3723]},
                                    :full-name "cljs.core/chunk-first"},
           "cljs.core/ChunkedSeq" {:protocols #{"IChunkedNext"
                                                "ISeqable"
                                                "IMeta"
                                                "IWithMeta"
                                                "IEmptyableCollection"
                                                "IReduce"
                                                "ISequential"
                                                "ISeq"
                                                "ICollection"
                                                "IHash"
                                                "IDrop"
                                                "ASeq"
                                                "IPrintWithWriter"
                                                "IChunkedSeq"
                                                "INext"
                                                "IEquiv"},
                                   :ns "cljs.core",
                                   :name "ChunkedSeq",
                                   :signature ["[vec node i off meta __hash]"],
                                   :name-encode "ChunkedSeq",
                                   :history [["+" "0.0-1424"]],
                                   :type "type",
                                   :full-name-encode "cljs.core/ChunkedSeq",
                                   :source {:code "(deftype ChunkedSeq [vec node i off meta ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (chunked-seq vec node i off new-meta)))\n  IMeta\n  (-meta [coll] meta)\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ASeq\n  ISeq\n  (-first [coll]\n    (aget node off))\n  (-rest [coll]\n    (if (< (inc off) (alength node))\n      (let [s (chunked-seq vec node i (inc off))]\n        (if (nil? s)\n          ()\n          s))\n      (-chunked-rest coll)))\n\n  INext\n  (-next [coll]\n    (if (< (inc off) (alength node))\n      (let [s (chunked-seq vec node i (inc off))]\n        (if (nil? s)\n          nil\n          s))\n      (-chunked-next coll)))\n\n  IDrop\n  (-drop [coll n]\n    (let [o (+ off n)]\n      (if (< o (alength node))\n        (chunked-seq vec node i o)\n        (let [i (+ i o)]\n          (if (< i (-count vec))\n            (let [new-offset (js-mod i 32)]\n              (chunked-seq vec (unchecked-array-for vec i) (- i new-offset) new-offset))\n            nil)))))\n\n  ICollection\n  (-conj [coll o]\n    (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll]\n    ())\n\n  IChunkedSeq\n  (-chunked-first [coll]\n    (array-chunk node off))\n  (-chunked-rest [coll]\n    (let [end (+ i (alength node))]\n      (if (< end (-count vec))\n        (chunked-seq vec (unchecked-array-for vec end) end 0)\n        ())))\n\n  IChunkedNext\n  (-chunked-next [coll]\n    (let [end (+ i (alength node))]\n      (when (< end (-count vec))\n        (chunked-seq vec (unchecked-array-for vec end) end 0))))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  IReduce\n  (-reduce [coll f]\n    (pv-reduce vec f (+ i off) (count vec)))\n\n  (-reduce [coll f start]\n    (pv-reduce vec f start (+ i off) (count vec))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [5874 5967]},
                                   :full-name "cljs.core/ChunkedSeq"},
           "cljs.test/testing" {:ns "cljs.test",
                                :name "testing",
                                :signature ["[string & body]"],
                                :name-encode "testing",
                                :history [["+" "0.0-2496"]],
                                :type "macro",
                                :full-name-encode "cljs.test/testing",
                                :source {:code "(defmacro testing\n  ([string & body]\n   `(do\n      (update-current-env! [:testing-contexts] conj ~string)\n      (try\n        ~@body\n        (finally\n          (update-current-env! [:testing-contexts] rest))))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/test.cljc",
                                         :lines [216 225]},
                                :full-name "cljs.test/testing",
                                :docstring "Adds a new string to the list of testing contexts.  May be nested,\nbut must occur inside a test function (deftest)."},
           "cljs.analyzer.api/resolve" {:ns "cljs.analyzer.api",
                                        :name "resolve",
                                        :signature ["[env sym]"],
                                        :name-encode "resolve",
                                        :history [["+" "0.0-2496"]],
                                        :type "function",
                                        :full-name-encode "cljs.analyzer.api/resolve",
                                        :source {:code "(defn resolve\n  [env sym]\n  {:pre [(map? env) (symbol? sym)]}\n  (try\n    (binding [ana/*private-var-access-nowarn* true]\n      (ana/resolve-var env sym\n        (ana/confirm-var-exists-throw)))\n    (catch #?(:clj Exception :cljs :default) e\n      (ana/resolve-macro-var env sym))))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/clojure/cljs/analyzer/api.cljc",
                                                 :lines [201 211]},
                                        :full-name "cljs.analyzer.api/resolve",
                                        :docstring "Given an analysis environment resolve a var. Analogous to\nclojure.core/resolve"},
           "cljs.repl.browser/start-server" {:ns "cljs.repl.browser",
                                             :name "start-server",
                                             :signature ["[opts]"],
                                             :name-encode "start-server",
                                             :history [["+" "0.0-927"]
                                                       ["-"
                                                        "0.0-1503"]],
                                             :type "function",
                                             :full-name-encode "cljs.repl.browser/start-server",
                                             :source {:code "(defn start-server\n  [opts]\n  (let [ss (ServerSocket. (:port opts))]\n    (future (server-loop opts ss))\n    (swap! server-state (fn [old] (assoc old :socket ss :port (:port opts))))))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1450",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [265 270]},
                                             :full-name "cljs.repl.browser/start-server",
                                             :docstring "Start the server on the specified port.",
                                             :removed {:in "0.0-1503",
                                                       :last-seen "0.0-1450"}},
           "cljs.spec/keys*" {:ns "cljs.spec",
                              :name "keys*",
                              :signature ["[& kspecs]"],
                              :name-encode "keysSTAR",
                              :history [["+" "1.9.14"]
                                        ["-" "1.9.542"]],
                              :type "macro",
                              :full-name-encode "cljs.spec/keysSTAR",
                              :source {:code "(defmacro keys*\n  [& kspecs]\n  `(let [mspec# (keys ~@kspecs)]\n     (with-gen (cljs.spec/& (* (cat ::k keyword? ::v cljs.core/any?)) ::kvs->map mspec#)\n       (fn [] (gen/fmap (fn [m#] (apply concat m#)) (gen mspec#))))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.9.521",
                                       :filename "src/main/cljs/cljs/spec.cljc",
                                       :lines [437 454]},
                              :full-name "cljs.spec/keys*",
                              :docstring "takes the same arguments as spec/keys and returns a regex op that matches sequences of key/values,\nconverts them into a map, and conforms that map with a corresponding\nspec/keys call:\n\nuser=> (s/conform (s/keys :req-un [::a ::c]) {:a 1 :c 2})\n{:a 1, :c 2}\nuser=> (s/conform (s/keys* :req-un [::a ::c]) [:a 1 :c 2])\n{:a 1, :c 2}\n\nthe resulting regex op can be composed into a larger regex:\n\nuser=> (s/conform (s/cat :i1 integer? :m (s/keys* :req-un [::a ::c]) :i2 integer?) [42 :a 1 :c 2 :d 4 99])\n{:i1 42, :m {:a 1, :c 2, :d 4}, :i2 99}",
                              :removed {:in "1.9.542",
                                        :last-seen "1.9.521"}},
           "cljs.core/*2" {:ns "cljs.core",
                           :name "*2",
                           :name-encode "STAR2",
                           :history [["+" "0.0-927"]],
                           :type "dynamic var",
                           :full-name-encode "cljs.core/STAR2",
                           :source {:code "(def\n  ^{:dynamic true}\n  *2)",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r1.12.38",
                                    :filename "src/main/cljs/cljs/core.cljs",
                                    :lines [212 215]},
                           :full-name "cljs.core/*2",
                           :docstring "bound in a repl thread to the second most recent value printed"},
           "closure-warnings/closure-dep-method-usage-checks" {:ns "closure-warnings",
                                                               :name "closure-dep-method-usage-checks",
                                                               :name-encode "closure-dep-method-usage-checks",
                                                               :type "warning",
                                                               :full-name-encode "closure-warnings/closure-dep-method-usage-checks",
                                                               :full-name "closure-warnings/closure-dep-method-usage-checks",
                                                               :history [["+"
                                                                          "1.9.473"]]},
           "cljs.repl.server/send-and-close" {:ns "cljs.repl.server",
                                              :name "send-and-close",
                                              :signature ["[conn status form]"
                                                          "[conn status form content-type]"
                                                          "[conn status form content-type encoding]"
                                                          "[conn status form content-type encoding gzip?]"],
                                              :name-encode "send-and-close",
                                              :history [["+"
                                                         "0.0-1503"]],
                                              :type "function",
                                              :full-name-encode "cljs.repl.server/send-and-close",
                                              :source {:code "(defn send-and-close\n  ([conn status form]\n    (send-and-close conn status form \"text/html\"))\n  ([conn status form content-type]\n    (send-and-close conn status form content-type \"UTF-8\"))\n  ([conn status form content-type encoding]\n    (send-and-close conn status form content-type encoding false))\n  ([conn status form content-type encoding gzip?]\n    (let [byte-form (cond-> (.getBytes form encoding) gzip? gzip)\n          content-length (count byte-form)\n          headers (map #(.getBytes (str % \"\\r\\n\"))\n                    (cond->\n                      [(status-line status)\n                       \"Server: ClojureScript REPL\"\n                       (if (not= content-type \"application/wasm\")\n                         (str \"Content-Type: \"\n                              content-type\n                              \"; charset=\" encoding)\n                         (str \"Content-Type: \"\n                              content-type))\n                       (str \"Content-Length: \" content-length)]\n                      gzip? (conj \"Content-Encoding: gzip\")\n                      true (conj \"\")))]\n      (with-open [os (.getOutputStream conn)]\n        (doseq [header headers]\n          (.write os header 0 (count header)))\n        (.write os byte-form 0 content-length)\n        (.flush os)\n        (.close conn)))))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.12.38",
                                                       :filename "src/main/clojure/cljs/repl/server.clj",
                                                       :lines [144
                                                               174]},
                                              :full-name "cljs.repl.server/send-and-close",
                                              :docstring "Use the passed connection to send a form to the browser. Send a\nproper HTTP response."},
           "cljs.test/ns?" {:ns "cljs.test",
                            :name "ns?",
                            :signature ["[x]"],
                            :name-encode "nsQMARK",
                            :history [["+" "1.8.51"]],
                            :type "function",
                            :full-name-encode "cljs.test/nsQMARK",
                            :source {:code "(defn ns? [x]\n  (and (seq? x) (= (first x) 'quote)))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/cljs/cljs/test.cljc",
                                     :lines [270 271]},
                            :full-name "cljs.test/ns?"},
           "compiler-options/compiler-stats" {:ns "compiler-options",
                                              :name "compiler-stats",
                                              :name-encode "compiler-stats",
                                              :type "option",
                                              :full-name-encode "compiler-options/compiler-stats",
                                              :full-name "compiler-options/compiler-stats",
                                              :history [["+"
                                                         "0.0-2629"]]},
           "clojure.browser.event/total-listener-count" {:ns "clojure.browser.event",
                                                         :name "total-listener-count",
                                                         :signature ["[]"],
                                                         :name-encode "total-listener-count",
                                                         :history [["+"
                                                                    "0.0-927"]],
                                                         :type "function",
                                                         :full-name-encode "clojure.browser.event/total-listener-count",
                                                         :source {:code "(defn total-listener-count []\n  (events/getTotalListenerCount))",
                                                                  :title "Source code",
                                                                  :repo "clojurescript",
                                                                  :tag "r1.12.38",
                                                                  :filename "src/main/cljs/clojure/browser/event.cljs",
                                                                  :lines [87
                                                                          88]},
                                                         :full-name "clojure.browser.event/total-listener-count"},
           "cljs.spec/keys" {:ns "cljs.spec",
                             :name "keys",
                             :signature ["[& {:keys [req req-un opt opt-un gen]}]"],
                             :name-encode "keys",
                             :history [["+" "1.9.14"] ["-" "1.9.542"]],
                             :type "macro",
                             :full-name-encode "cljs.spec/keys",
                             :source {:code "(defmacro keys\n  [& {:keys [req req-un opt opt-un gen]}]\n  (let [unk #(-> % name keyword)\n        req-keys (filterv keyword? (flatten req))\n        req-un-specs (filterv keyword? (flatten req-un))\n        _ (clojure.core/assert (every? #(clojure.core/and (keyword? %) (namespace %)) (concat req-keys req-un-specs opt opt-un))\n                  \"all keys must be namespace-qualified keywords\")\n        req-specs (into req-keys req-un-specs)\n        req-keys (into req-keys (map unk req-un-specs))\n        opt-keys (into (vec opt) (map unk opt-un))\n        opt-specs (into (vec opt) opt-un)\n        gx (gensym)\n        parse-req (fn [rk f]\n                    (map (fn [x]\n                           (if (keyword? x)\n                             `(contains? ~gx ~(f x))\n                             (walk/postwalk\n                               (fn [y] (if (keyword? y) `(contains? ~gx ~(f y)) y))\n                               x)))\n                         rk))\n        pred-exprs [`(map? ~gx)]\n        pred-exprs (into pred-exprs (parse-req req identity))\n        pred-exprs (into pred-exprs (parse-req req-un unk))\n        keys-pred `(fn* [~gx] (c/and ~@pred-exprs))\n        pred-exprs (mapv (fn [e] `(fn* [~gx] ~e)) pred-exprs)\n        pred-forms (walk/postwalk #(res &env %) pred-exprs)]\n    ;; `(map-spec-impl ~req-keys '~req ~opt '~pred-forms ~pred-exprs ~gen)\n    `(map-spec-impl {:req '~req :opt '~opt :req-un '~req-un :opt-un '~opt-un\n                     :req-keys '~req-keys :req-specs '~req-specs\n                     :opt-keys '~opt-keys :opt-specs '~opt-specs\n                     :pred-forms '~pred-forms\n                     :pred-exprs ~pred-exprs\n                     :keys-pred ~keys-pred\n                     :gfn ~gen})))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.9.521",
                                      :filename "src/main/cljs/cljs/spec.cljc",
                                      :lines [115 175]},
                             :full-name "cljs.spec/keys",
                             :docstring "Creates and returns a map validating spec. :req and :opt are both\nvectors of namespaced-qualified keywords. The validator will ensure\nthe :req keys are present. The :opt keys serve as documentation and\nmay be used by the generator.\n\nThe :req key vector supports 'and' and 'or' for key groups:\n\n(s/keys :req [::x ::y (or ::secret (and ::user ::pwd))] :opt [::z])\n\nThere are also -un versions of :req and :opt. These allow\nyou to connect unqualified keys to specs.  In each case, fully\nqualfied keywords are passed, which name the specs, but unqualified\nkeys (with the same name component) are expected and checked at\nconform-time, and generated during gen:\n\n(s/keys :req-un [:my.ns/x :my.ns/y])\n\nThe above says keys :x and :y are required, and will be validated\nand generated by specs (if they exist) named :my.ns/x :my.ns/y\nrespectively.\n\nIn addition, the values of *all* namespace-qualified keys will be validated\n(and possibly destructured) by any registered specs. Note: there is\nno support for inline value specification, by design.\n\nOptionally takes :gen generator-fn, which must be a fn of no args that\nreturns a test.check generator.",
                             :removed {:in "1.9.542",
                                       :last-seen "1.9.521"}},
           "cljs.core/goog-define" {:ns "cljs.core",
                                    :name "goog-define",
                                    :signature ["[sym default]"],
                                    :name-encode "goog-define",
                                    :history [["+" "1.7.48"]],
                                    :type "macro",
                                    :full-name-encode "cljs.core/goog-define",
                                    :source {:code "(core/defmacro goog-define\n  [sym default]\n  (assert-args goog-define\n   (core/or (core/string? default)\n            (core/number? default)\n            (core/true? default)\n            (core/false? default)) \"a string, number or boolean as default value\")\n  (core/let [defname (comp/munge (core/str *ns* \"/\" sym))\n             type    (core/cond\n                       (core/string? default) \"string\"\n                       (core/number? default) \"number\"\n                       (core/or (core/true? default) (core/false? default)) \"boolean\")]\n    `(~(if (:def-emits-var &env) `return-first `do)\n       (declare ~(core/vary-meta sym\n                   (core/fn [m]\n                     (core/cond-> m\n                       (core/not (core/contains? m :tag))\n                       (core/assoc :tag (core/symbol type))\n                       ))))\n       (def ~(vary-meta sym assoc :goog-define type) (goog/define ~defname ~default)))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/clojure/cljs/core.cljc",
                                             :lines [738 770]},
                                    :full-name "cljs.core/goog-define",
                                    :docstring "Defines a var using `goog.define`. Passed default value must be\nstring, number or boolean.\n\nDefault value can be overridden at compile time using the\ncompiler option `:closure-defines`.\n\nExample:\n  (ns your-app.core)\n  (goog-define DEBUG! false)\n  ;; can be overridden with\n  :closure-defines {\"your_app.core.DEBUG_BANG_\" true}\n  or\n  :closure-defines {your-app.core/DEBUG! true}"},
           "compiler-options/process-shim" {:ns "compiler-options",
                                            :name "process-shim",
                                            :name-encode "process-shim",
                                            :type "option",
                                            :full-name-encode "compiler-options/process-shim",
                                            :full-name "compiler-options/process-shim",
                                            :history [["+" "1.9.854"]]},
           "cljs.core/MultiStepper" {:ns "cljs.core",
                                     :name "MultiStepper",
                                     :signature ["[xform iters nexts]"],
                                     :name-encode "MultiStepper",
                                     :history [["+" "0.0-2301"]
                                               ["-" "1.9.562"]],
                                     :type "type",
                                     :full-name-encode "cljs.core/MultiStepper",
                                     :source {:code "(deftype MultiStepper [xform iters nexts]\n  Object\n  (hasNext [_]\n    (loop [iters (seq iters)]\n      (if-not (nil? iters)\n        (let [iter (first iters)]\n          (if-not ^boolean (.hasNext iter)\n            false\n            (recur (next iters))))\n        true)))\n  (next [_]\n    (dotimes [i (alength iters)]\n      (aset nexts i (.next (aget iters i))))\n    (prim-seq nexts 0))\n  (step [this lt]\n    (loop []\n      (if (and (not (nil? (.-stepper lt)))\n               (.hasNext this))\n        (if (reduced? (apply xform (cons lt (.next this))))\n          (when-not (nil? (.-rest lt))\n            (set! (.. lt -rest -stepper) nil))\n          (recur))))\n    (when-not (nil? (.-stepper lt))\n      (xform lt))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.9.542",
                                              :filename "src/main/cljs/cljs/core.cljs",
                                              :lines [3905 3928]},
                                     :full-name "cljs.core/MultiStepper",
                                     :removed {:in "1.9.562",
                                               :last-seen "1.9.542"}},
           "cljs.core/alter-meta!" {:ns "cljs.core",
                                    :name "alter-meta!",
                                    :signature ["[iref f & args]"],
                                    :name-encode "alter-metaBANG",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/alter-metaBANG",
                                    :source {:code "(defn alter-meta!\n  [iref f & args]\n  (set! (.-meta iref) (apply f (.-meta iref) args)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [10902 10909]},
                                    :full-name "cljs.core/alter-meta!",
                                    :docstring "Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\n\n(apply f its-current-meta args)\n\nf must be free of side-effects"},
           "clojure.browser.dom/click-element" {:ns "clojure.browser.dom",
                                                :name "click-element",
                                                :signature ["[e]"],
                                                :name-encode "click-element",
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "clojure.browser.dom/click-element",
                                                :source {:code "(defn click-element\n  [e]\n  (.click (ensure-element e) ()))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1.12.38",
                                                         :filename "src/main/cljs/clojure/browser/dom.cljs",
                                                         :lines [147
                                                                 149]},
                                                :full-name "clojure.browser.dom/click-element"},
           "cljs.spec/*recursion-limit*" {:ns "cljs.spec",
                                          :name "*recursion-limit*",
                                          :name-encode "STARrecursion-limitSTAR",
                                          :history [["+" "1.9.14"]
                                                    ["-" "1.9.542"]],
                                          :type "dynamic var",
                                          :full-name-encode "cljs.spec/STARrecursion-limitSTAR",
                                          :source {:code "(def ^:dynamic *recursion-limit*\n  \"A soft limit on how many times a branching spec (or/alt/*/opt-keys/multi-spec)\n  can be recursed through during generation. After this a\n  non-recursive branch will be chosen.\"\n  4)",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.9.521",
                                                   :filename "src/main/cljs/cljs/spec.cljs",
                                                   :lines [21 25]},
                                          :full-name "cljs.spec/*recursion-limit*",
                                          :removed {:in "1.9.542",
                                                    :last-seen "1.9.521"}},
           "cljs.core/*assert*" {:ns "cljs.core",
                                 :name "*assert*",
                                 :name-encode "STARassertSTAR",
                                 :type "dynamic var",
                                 :full-name-encode "cljs.core/STARassertSTAR",
                                 :source {:code "(def\n  ^{:dynamic true}\n  *assert* true)",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [67 69]},
                                 :full-name "cljs.core/*assert*",
                                 :history [["+" "1.7.10"]]},
           "cljs.core/seq-iter" {:ns "cljs.core",
                                 :name "seq-iter",
                                 :signature ["[coll]"],
                                 :name-encode "seq-iter",
                                 :history [["+" "0.0-2301"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/seq-iter",
                                 :source {:code "(defn seq-iter [coll]\n  (SeqIter. INIT coll))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [4156 4157]},
                                 :full-name "cljs.core/seq-iter"},
           "closure-warnings/constant-property" {:ns "closure-warnings",
                                                 :name "constant-property",
                                                 :name-encode "constant-property",
                                                 :type "warning",
                                                 :full-name-encode "closure-warnings/constant-property",
                                                 :full-name "closure-warnings/constant-property",
                                                 :history [["+"
                                                            "0.0-2120"]]},
           "clojure.string/includes?" {:return-type boolean,
                                       :ns "clojure.string",
                                       :name "includes?",
                                       :signature ["[s substr]"],
                                       :name-encode "includesQMARK",
                                       :history [["+" "1.7.145"]],
                                       :type "function",
                                       :full-name-encode "clojure.string/includesQMARK",
                                       :source {:code "(defn ^boolean includes?\n  [s substr]\n  (gstring/contains s substr))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/clojure/string.cljs",
                                                :lines [287 290]},
                                       :full-name "clojure.string/includes?",
                                       :docstring "True if s includes substr."},
           "cljs.core/unchecked-remainder-int" {:ns "cljs.core",
                                                :name "unchecked-remainder-int",
                                                :signature ["[x n]"],
                                                :name-encode "unchecked-remainder-int",
                                                :history [["+"
                                                           "0.0-1798"]],
                                                :type "function/macro",
                                                :full-name-encode "cljs.core/unchecked-remainder-int",
                                                :source {:code "(defn unchecked-remainder-int [x n]\n  (cljs.core/unchecked-remainder-int x n))",
                                                         :title "Function code",
                                                         :repo "clojurescript",
                                                         :tag "r1.12.38",
                                                         :filename "src/main/cljs/cljs/core.cljs",
                                                         :lines [2864
                                                                 2865]},
                                                :extra-sources [{:code "(core/defmacro ^::ana/numeric unchecked-remainder-int\n  ([x n] `(core/mod ~x ~n)))",
                                                                 :title "Macro code",
                                                                 :repo "clojurescript",
                                                                 :tag "r1.12.38",
                                                                 :filename "src/main/clojure/cljs/core.cljc",
                                                                 :lines [1110
                                                                         1111]}],
                                                :full-name "cljs.core/unchecked-remainder-int"},
           "compiler-options/closure-variable-map-out" {:ns "compiler-options",
                                                        :name "closure-variable-map-out",
                                                        :name-encode "closure-variable-map-out",
                                                        :type "option",
                                                        :full-name-encode "compiler-options/closure-variable-map-out",
                                                        :full-name "compiler-options/closure-variable-map-out",
                                                        :history [["+"
                                                                   "1.10.63"]]},
           "cljs.math/sqrt" {:return-type number,
                             :ns "cljs.math",
                             :name "sqrt",
                             :signature ["[a]"],
                             :name-encode "sqrt",
                             :history [["+" "1.11.50"]],
                             :type "function",
                             :full-name-encode "cljs.math/sqrt",
                             :source {:code "(defn ^number sqrt\n  {:added \"1.11.10\"}\n  [a] (Math/sqrt a))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/math.cljs",
                                      :lines [167 174]},
                             :full-name "cljs.math/sqrt",
                             :docstring "Returns the positive square root of a.\nIf a is ##NaN or negative => ##NaN\nIf a is ##Inf => ##Inf\nIf a is zero => a\nSee: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sqrt"},
           "cljs.spec/explain-data*" {:ns "cljs.spec",
                                      :name "explain-data*",
                                      :signature ["[spec path via in x]"],
                                      :name-encode "explain-dataSTAR",
                                      :history [["+" "1.9.14"]
                                                ["-" "1.9.542"]],
                                      :type "function",
                                      :full-name-encode "cljs.spec/explain-dataSTAR",
                                      :source {:code "(defn explain-data* [spec path via in x]\n  (when-let [probs (explain* (specize spec) path via in x)]\n    (when-not (empty? probs)\n      {::problems probs})))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.9.521",
                                               :filename "src/main/cljs/cljs/spec.cljs",
                                               :lines [200 203]},
                                      :full-name "cljs.spec/explain-data*",
                                      :removed {:in "1.9.542",
                                                :last-seen "1.9.521"}},
           "cljs.core/bit-shift-right-zero-fill" {:ns "cljs.core",
                                                  :name "bit-shift-right-zero-fill",
                                                  :signature ["[x n]"],
                                                  :name-encode "bit-shift-right-zero-fill",
                                                  :history [["+"
                                                             "0.0-1211"]],
                                                  :type "function/macro",
                                                  :full-name-encode "cljs.core/bit-shift-right-zero-fill",
                                                  :source {:code "(defn bit-shift-right-zero-fill\n  [x n] (cljs.core/bit-shift-right-zero-fill x n))",
                                                           :title "Function code",
                                                           :repo "clojurescript",
                                                           :tag "r1.12.38",
                                                           :filename "src/main/cljs/cljs/core.cljs",
                                                           :lines [2993
                                                                   2995]},
                                                  :extra-sources [{:code "(core/defmacro ^::ana/numeric bit-shift-right-zero-fill [x n]\n  (core/list 'js* \"(~{} >>> ~{})\" x n))",
                                                                   :title "Macro code",
                                                                   :repo "clojurescript",
                                                                   :tag "r1.12.38",
                                                                   :filename "src/main/clojure/cljs/core.cljc",
                                                                   :lines [1237
                                                                           1238]}],
                                                  :full-name "cljs.core/bit-shift-right-zero-fill",
                                                  :docstring "DEPRECATED: Bitwise shift right with zero fill"},
           "cljs.repl.rhino/repl-env*" {:ns "cljs.repl.rhino",
                                        :name "repl-env*",
                                        :signature ["[opts]"],
                                        :name-encode "repl-envSTAR",
                                        :history [["+" "0.0-3030"]
                                                  ["-" "1.10.738"]],
                                        :type "function",
                                        :full-name-encode "cljs.repl.rhino/repl-envSTAR",
                                        :source {:code "(defn repl-env*\n  [opts]\n  (let [cx (Context/enter)]\n    ;; just avoid the 64K method limit\n    ;; Rhino is slow even with optimizations enabled\n    (.setOptimizationLevel cx -1)\n    (merge (RhinoEnv.)\n      {:cx cx\n       :scope (.initStandardObjects cx)})))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.10.597",
                                                 :filename "src/main/clojure/cljs/repl/rhino.clj",
                                                 :lines [216 224]},
                                        :full-name "cljs.repl.rhino/repl-env*",
                                        :removed {:in "1.10.738",
                                                  :last-seen "1.10.597"}},
           "cljs.core/when-some" {:ns "cljs.core",
                                  :name "when-some",
                                  :signature ["[bindings & body]"],
                                  :name-encode "when-some",
                                  :history [["+" "0.0-2261"]],
                                  :type "macro",
                                  :full-name-encode "cljs.core/when-some",
                                  :source {:code "(defmacro when-some\n  {:added \"1.6\"}\n  [bindings & body]\n  (assert-args\n     (vector? bindings) \"a vector for its binding\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n   (let [form (bindings 0) tst (bindings 1)]\n    `(let [temp# ~tst]\n       (if (nil? temp#)\n         nil\n         (let [~form temp#]\n           ~@body)))))",
                                           :title "Source code",
                                           :repo "clojure",
                                           :tag "clojure-1.10.0",
                                           :filename "src/clj/clojure/core.clj",
                                           :lines [1896 1911]},
                                  :full-name "cljs.core/when-some",
                                  :docstring "bindings => binding-form test\n\nWhen test is not nil, evaluates body with binding-form bound to the\nvalue of test"},
           "cljs.repl.browser/server-loop" {:ns "cljs.repl.browser",
                                            :name "server-loop",
                                            :signature ["[opts server-socket]"],
                                            :name-encode "server-loop",
                                            :history [["+" "0.0-927"]
                                                      ["-" "0.0-1503"]],
                                            :type "function",
                                            :full-name-encode "cljs.repl.browser/server-loop",
                                            :source {:code "(defn server-loop\n  [opts server-socket]\n  (let [conn (.accept server-socket)]\n    (do (.setKeepAlive conn true)\n        (future (handle-connection opts conn))\n        (recur opts server-socket))))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1450",
                                                     :filename "src/clj/cljs/repl/browser.clj",
                                                     :lines [258 263]},
                                            :full-name "cljs.repl.browser/server-loop",
                                            :removed {:in "0.0-1503",
                                                      :last-seen "0.0-1450"}},
           "cljs.spec.test.alpha/distinct-by" {:ns "cljs.spec.test.alpha",
                                               :name "distinct-by",
                                               :signature ["[f coll]"],
                                               :name-encode "distinct-by",
                                               :history [["+"
                                                          "1.9.542"]],
                                               :type "function",
                                               :full-name-encode "cljs.spec.test.alpha/distinct-by",
                                               :source {:code "(defn distinct-by\n  ([f coll]\n   (let [step (fn step [xs seen]\n                (lazy-seq\n                  ((fn [[x :as xs] seen]\n                     (when-let [s (seq xs)]\n                       (let [v (f x)]\n                         (if (contains? seen v)\n                           (recur (rest s) seen)\n                           (cons x (step (rest s) (conj seen v)))))))\n                    xs seen)))]\n     (step coll #{}))))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.12.38",
                                                        :filename "src/main/cljs/cljs/spec/test/alpha.cljs",
                                                        :lines [20 31]},
                                               :full-name "cljs.spec.test.alpha/distinct-by"},
           "cljs.reader/read-meta" {:ns "cljs.reader",
                                    :name "read-meta",
                                    :signature ["[rdr _]"],
                                    :name-encode "read-meta",
                                    :history [["+" "0.0-927"]
                                              ["-" "1.9.854"]],
                                    :type "function",
                                    :full-name-encode "cljs.reader/read-meta",
                                    :source {:code "(defn read-meta\n  [rdr _]\n  (let [m (desugar-meta (read rdr true nil true))]\n    (when-not (map? m)\n      (reader-error rdr \"Metadata must be Symbol,Keyword,String or Map\"))\n    (let [o (read rdr true nil true)]\n      (if (satisfies? IWithMeta o)\n        (with-meta o (merge (meta o) m))\n        (reader-error rdr \"Metadata can only be applied to IWithMetas\")))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.9.671",
                                             :filename "src/main/cljs/cljs/reader.cljs",
                                             :lines [399 407]},
                                    :full-name "cljs.reader/read-meta",
                                    :removed {:in "1.9.854",
                                              :last-seen "1.9.671"}},
           "cljs.spec.alpha/check-asserts" {:ns "cljs.spec.alpha",
                                            :name "check-asserts",
                                            :signature ["[flag]"],
                                            :name-encode "check-asserts",
                                            :history [["+" "1.9.542"]],
                                            :type "function",
                                            :full-name-encode "cljs.spec.alpha/check-asserts",
                                            :source {:code "(defn check-asserts\n  [^boolean flag]\n  (set! *runtime-asserts* flag))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/cljs/cljs/spec/alpha.cljs",
                                                     :lines [1490
                                                             1496]},
                                            :full-name "cljs.spec.alpha/check-asserts",
                                            :docstring "Enable or disable spec asserts that have been compiled\nwith '*compile-asserts*' true.  See 'assert'.\nInitially set to boolean value of cljs.spec.alpha/*runtime-asserts*.\nDefaults to false."},
           "cljs.repl.server/send-404" {:ns "cljs.repl.server",
                                        :name "send-404",
                                        :signature ["[conn path]"],
                                        :name-encode "send-404",
                                        :history [["+" "0.0-1503"]],
                                        :type "function",
                                        :full-name-encode "cljs.repl.server/send-404",
                                        :source {:code "(defn send-404 [conn path]\n  (send-and-close conn 404\n    (str\n      \"<html><body>\"\n      \"<h2>Page not found</h2>\"\n      \"No page \" path \" found on this server.\"\n      \"</body></html>\")\n    \"text/html\"))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/clojure/cljs/repl/server.clj",
                                                 :lines [176 183]},
                                        :full-name "cljs.repl.server/send-404"},
           "closure-warnings/too-many-type-params" {:ns "closure-warnings",
                                                    :name "too-many-type-params",
                                                    :name-encode "too-many-type-params",
                                                    :type "warning",
                                                    :full-name-encode "closure-warnings/too-many-type-params",
                                                    :full-name "closure-warnings/too-many-type-params",
                                                    :history [["+"
                                                               "1.10.217"]]},
           "syntax/ignore" {:syntax-equiv {:edn-url nil, :clj-url nil},
                            :ns "syntax",
                            :name "ignore",
                            :name-encode "ignore",
                            :history [["+" "0.0-1853"]],
                            :type "syntax",
                            :full-name-encode "syntax/ignore",
                            :extra-sources ({:code "(defn- read-discard\n  [rdr _ opts pending-forms]\n  (doto rdr\n    (read* true nil opts pending-forms)))",
                                             :title "Reader code",
                                             :repo "tools.reader",
                                             :tag "v1.3.6",
                                             :filename "src/main/clojure/clojure/tools/reader.clj",
                                             :lines [406 410]}
                                            {:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    \\? read-cond\n    \\: read-namespaced-map\n    \\# read-symbolic-value\n    nil))",
                                             :title "Reader table",
                                             :repo "tools.reader",
                                             :tag "v1.3.6",
                                             :filename "src/main/clojure/clojure/tools/reader.clj",
                                             :lines [809 823]}),
                            :full-name "syntax/ignore"},
           "cljs.core/qualified-ident?" {:ns "cljs.core",
                                         :name "qualified-ident?",
                                         :signature ["[x]"],
                                         :name-encode "qualified-identQMARK",
                                         :history [["+" "1.9.75"]],
                                         :type "function",
                                         :full-name-encode "cljs.core/qualified-identQMARK",
                                         :source {:code "(defn qualified-ident?\n  [x] (boolean (and (ident? x) (namespace x) true)))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/cljs/cljs/core.cljs",
                                                  :lines [3462 3464]},
                                         :full-name "cljs.core/qualified-ident?",
                                         :docstring "Return true if x is a symbol or keyword with a namespace"},
           "cljs.spec.alpha/multi-spec" {:ns "cljs.spec.alpha",
                                         :name "multi-spec",
                                         :signature ["[mm retag]"],
                                         :name-encode "multi-spec",
                                         :history [["+" "1.9.542"]],
                                         :type "macro",
                                         :full-name-encode "cljs.spec.alpha/multi-spec",
                                         :source {:code "(defmacro multi-spec\n  [mm retag]\n  `(multi-spec-impl '~(res &env mm) (var ~mm) ~retag))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/cljs/cljs/spec/alpha.cljc",
                                                  :lines [106 133]},
                                         :full-name "cljs.spec.alpha/multi-spec",
                                         :docstring "Takes the name of a spec/predicate-returning multimethod and a\ntag-restoring keyword or fn (retag).  Returns a spec that when\nconforming or explaining data will pass it to the multimethod to get\nan appropriate spec. You can e.g. use multi-spec to dynamically and\nextensibly associate specs with 'tagged' data (i.e. data where one\nof the fields indicates the shape of the rest of the structure).\n\n(defmulti mspec :tag)\n\nThe methods should ignore their argument and return a predicate/spec:\n(defmethod mspec :int [_] (s/keys :req-un [::tag ::i]))\n\nretag is used during generation to retag generated values with\nmatching tags. retag can either be a keyword, at which key the\ndispatch-tag will be assoc'ed, or a fn of generated value and\ndispatch-tag that should return an appropriately retagged value.\n\nNote that because the tags themselves comprise an open set,\nthe tag key spec cannot enumerate the values, but can e.g.\ntest for keyword?.\n\nNote also that the dispatch values of the multimethod will be\nincluded in the path, i.e. in reporting and gen overrides, even\nthough those values are not evident in the spec."},
           "cljs.test/test-var-block" {:ns "cljs.test",
                                       :name "test-var-block",
                                       :signature ["[v]"],
                                       :name-encode "test-var-block",
                                       :history [["+" "0.0-2814"]],
                                       :type "function",
                                       :full-name-encode "cljs.test/test-var-block",
                                       :source {:code "(defn test-var-block\n  [v]\n  (if-let [t (:test (meta v))]\n    (test-var-block* v t)))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/test.cljs",
                                                :lines [489 494]},
                                       :full-name "cljs.test/test-var-block",
                                       :docstring "Like test-var, but returns a block for further composition and\nlater execution."},
           "syntax/destructure-vector" {:syntax-equiv {:edn-url nil,
                                                       :clj-url nil},
                                        :ns "syntax",
                                        :name "destructure-vector",
                                        :name-encode "destructure-vector",
                                        :history [["+" "0.0-927"]],
                                        :type "binding",
                                        :full-name-encode "syntax/destructure-vector",
                                        :source {:code "(core/defn destructure [bindings]\n  (core/let [bents (partition 2 bindings)\n             pb (core/fn pb [bvec b v]\n                  (core/let [pvec\n                             (core/fn [bvec b val]\n                               (core/let [gvec (gensym \"vec__\")\n                                          gseq (gensym \"seq__\")\n                                          gfirst (gensym \"first__\")\n                                          has-rest (some #{'&} b)]\n                                 (core/loop [ret (core/let [ret (conj bvec gvec val)]\n                                                   (if has-rest\n                                                     (conj ret gseq (core/list `seq gvec))\n                                                     ret))\n                                             n 0\n                                             bs b\n                                             seen-rest? false]\n                                   (if (seq bs)\n                                     (core/let [firstb (first bs)]\n                                       (core/cond\n                                         (= firstb '&) (recur (pb ret (second bs) gseq)\n                                                              n\n                                                              (nnext bs)\n                                                              true)\n                                         (= firstb :as) (pb ret (second bs) gvec)\n                                         :else (if seen-rest?\n                                                 (throw #?(:clj (new Exception \"Unsupported binding form, only :as can follow & parameter\")\n                                                           :cljs (new js/Error \"Unsupported binding form, only :as can follow & parameter\")))\n                                                 (recur (pb (if has-rest\n                                                              (conj ret\n                                                                    gfirst `(first ~gseq)\n                                                                    gseq `(next ~gseq))\n                                                              ret)\n                                                            firstb\n                                                            (if has-rest\n                                                              gfirst\n                                                              (core/list `nth gvec n nil)))\n                                                        (core/inc n)\n                                                        (next bs)\n                                                        seen-rest?))))\n                                     ret))))\n                             pmap\n                             (core/fn [bvec b v]\n                               (core/let [gmap (gensym \"map__\")\n                                          defaults (:or b)]\n                                 (core/loop [ret (core/-> bvec (conj gmap) (conj v)\n                                                          (conj gmap) (conj `(--destructure-map ~gmap))\n                                                     ((core/fn [ret]\n                                                        (if (:as b)\n                                                          (conj ret (:as b) gmap)\n                                                          ret))))\n                                             bes (core/let [transforms\n                                                            (reduce\n                                                              (core/fn [transforms mk]\n                                                                (if (core/keyword? mk)\n                                                                  (core/let [mkns (namespace mk)\n                                                                        mkn (name mk)]\n                                                                    (core/cond (= mkn \"keys\") (assoc transforms mk #(keyword (core/or mkns (namespace %)) (name %)))\n                                                                               (= mkn \"syms\") (assoc transforms mk #(core/list `quote (symbol (core/or mkns (namespace %)) (name %))))\n                                                                               (= mkn \"strs\") (assoc transforms mk core/str)\n                                                                               :else transforms))\n                                                                  transforms))\n                                                              {}\n                                                              (keys b))]\n                                                   (reduce\n                                                     (core/fn [bes entry]\n                                                       (reduce #(assoc %1 %2 ((val entry) %2))\n                                                         (dissoc bes (key entry))\n                                                         ((key entry) bes)))\n                                                     (dissoc b :as :or)\n                                                     transforms))]\n                                   (if (seq bes)\n                                     (core/let [bb (key (first bes))\n                                                bk (val (first bes))\n                                                local (if #?(:clj  (core/instance? clojure.lang.Named bb)\n                                                             :cljs (cljs.core/implements? INamed bb))\n                                                          (with-meta (symbol nil (name bb)) (meta bb))\n                                                        bb)\n                                                bv (if (contains? defaults local)\n                                                     (core/list 'cljs.core/get gmap bk (defaults local))\n                                                     (core/list 'cljs.core/get gmap bk))]\n                                       (recur\n                                         (if (core/or (core/keyword? bb) (core/symbol? bb)) ;(ident? bb)\n                                           (core/-> ret (conj local bv))\n                                           (pb ret bb bv))\n                                              (next bes)))\n                                     ret))))]\n                    (core/cond\n                      (core/symbol? b) (core/-> bvec (conj (if (namespace b) (symbol (name b)) b)) (conj v))\n                      (core/keyword? b) (core/-> bvec (conj (symbol (name b))) (conj v))\n                      (vector? b) (pvec bvec b v)\n                      (map? b) (pmap bvec b v)\n                      :else (throw\n                             #?(:clj (new Exception (core/str \"Unsupported binding form: \" b))\n                                :cljs (new js/Error (core/str \"Unsupported binding form: \" b)))))))\n             process-entry (core/fn [bvec b] (pb bvec (first b) (second b)))]\n    (if (every? core/symbol? (map first bents))\n      bindings\n      (core/if-let [kwbs (seq (filter #(core/keyword? (first %)) bents))]\n        (throw\n          #?(:clj (new Exception (core/str \"Unsupported binding key: \" (ffirst kwbs)))\n             :cljs (new js/Error (core/str \"Unsupported binding key: \" (ffirst kwbs)))))\n        (reduce process-entry [] bents)))))",
                                                 :title "Parser code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/clojure/cljs/core.cljc",
                                                 :lines [629 730]},
                                        :full-name "syntax/destructure-vector"},
           "cljs.core/range" {:ns "cljs.core",
                              :name "range",
                              :signature ["[]"
                                          "[end]"
                                          "[start end]"
                                          "[start end step]"],
                              :name-encode "range",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/range",
                              :source {:code "(defn range\n  ([] (range 0 (.-MAX_VALUE js/Number) 1))\n  ([end] (range 0 end 1))\n  ([start end] (range start end 1))\n  ([start end step]\n   (cond\n     (pos? step)\n     (if (<= end start)\n       ()\n       (if (and (integer? start) (integer? end) (integer? step))\n         (IntegerRange. nil start end step (range-count start end step) nil)\n         (Range. nil start end step nil nil nil)))\n\n     (neg? step)\n     (if (>= end start)\n       ()\n       (if (and (integer? start) (integer? end) (integer? step))\n         (IntegerRange. nil start end step (range-count start end step) nil)\n         (Range. nil start end step nil nil nil)))\n\n     :else\n     (if (== end start)\n       ()\n       (repeat start)))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [10189 10215]},
                              :full-name "cljs.core/range",
                              :docstring "Returns a lazy seq of nums from start (inclusive) to end\n(exclusive), by step, where start defaults to 0, step to 1,\nand end to infinity."},
           "cljs.repl.browser/read-post" {:ns "cljs.repl.browser",
                                          :name "read-post",
                                          :signature ["[line rdr]"],
                                          :name-encode "read-post",
                                          :history [["+" "0.0-927"]
                                                    ["-" "0.0-1503"]],
                                          :type "function",
                                          :full-name-encode "cljs.repl.browser/read-post",
                                          :source {:code "(defn read-post [line rdr]\n  (let [[_ path _] (str/split line #\" \")\n        headers (parse-headers (read-headers rdr))\n        content-length (Integer/parseInt (:content-length headers))\n        content (char-array content-length)]\n    (io! (.read rdr content 0 content-length)\n         {:method :post\n          :path path\n          :headers headers\n          :content (String. content)})))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1450",
                                                   :filename "src/clj/cljs/repl/browser.clj",
                                                   :lines [143 152]},
                                          :full-name "cljs.repl.browser/read-post",
                                          :removed {:in "0.0-1503",
                                                    :last-seen "0.0-1450"}},
           "cljs.core/reify" {:ns "cljs.core",
                              :name "reify",
                              :signature ["[& impls]"],
                              :name-encode "reify",
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :full-name-encode "cljs.core/reify",
                              :source {:code "(core/defmacro reify\n  [& impls]\n  (core/let [t        (with-meta\n                        (gensym\n                          (core/str \"t_\"\n                            (string/replace (core/str (munge ana/*cljs-ns*)) \".\" \"$\")))\n                        {:anonymous true})\n             meta-sym (gensym \"meta\")\n             this-sym (gensym \"_\")\n             locals   (keys (:locals &env))\n             ns       (core/-> &env :ns :name)\n             munge    comp/munge]\n    `(do\n       (when-not (exists? ~(symbol (core/str ns) (core/str t)))\n         (deftype ~t [~@locals ~meta-sym]\n           IWithMeta\n           (~'-with-meta [~this-sym ~meta-sym]\n             (new ~t ~@locals ~meta-sym))\n           IMeta\n           (~'-meta [~this-sym] ~meta-sym)\n           ~@impls))\n       (new ~t ~@locals ~(ana/elide-reader-meta (meta &form))))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/clojure/cljs/core.cljc",
                                       :lines [1326 1385]},
                              :full-name "cljs.core/reify",
                              :docstring "reify creates an object implementing a protocol.\n reify is a macro with the following structure:\n\n(reify options* specs*)\n\n Currently there are no options.\n\n Each spec consists of the protocol name followed by zero\n or more method bodies:\n\n protocol\n (methodName [args+] body)*\n\n Methods should be supplied for all methods of the desired\n protocol(s). You can also define overrides for Object methods. Note that\n the first parameter must be supplied to correspond to the target object\n ('this' in JavaScript parlance). Note also that recur calls\n to the method head should *not* pass the target object, it will be supplied\n automatically and can not be substituted.\n\n recur works to method heads The method bodies of reify are lexical\n closures, and can refer to the surrounding local scope:\n\n (str (let [f \"foo\"]\n      (reify Object\n        (toString [this] f))))\n == \"foo\"\n\n (seq (let [f \"foo\"]\n      (reify ISeqable\n        (-seq [this] (seq f)))))\n == (\"f\" \"o\" \"o\"))\n\n reify always implements IMeta and IWithMeta and transfers meta\n data of the form to the created object.\n\n (meta ^{:k :v} (reify Object (toString [this] \"foo\")))\n == {:k :v}"},
           "cljs.core/satisfies?" {:ns "cljs.core",
                                   :name "satisfies?",
                                   :signature ["[psym x]"],
                                   :name-encode "satisfiesQMARK",
                                   :history [["+" "0.0-927"]],
                                   :type "macro",
                                   :full-name-encode "cljs.core/satisfiesQMARK",
                                   :source {:code "(core/defmacro satisfies?\n  [psym x]\n  (core/let [p          (:name\n                          (cljs.analyzer/resolve-var\n                            (dissoc &env :locals) psym))\n             prefix     (protocol-prefix p)\n             xsym       (bool-expr (gensym))\n             [part bit] (fast-path-protocols p)\n             msym       (symbol\n                          (core/str \"-cljs$lang$protocol_mask$partition\" part \"$\"))]\n    (core/if-not (core/symbol? x)\n      `(let [~xsym ~x]\n         (if-not (nil? ~xsym)\n           (if (or ~(if bit `(unsafe-bit-and (. ~xsym ~msym) ~bit) false)\n                    (identical? cljs.core/PROTOCOL_SENTINEL\n                      (. ~xsym ~(with-meta (symbol (core/str \"-\" prefix)) {:protocol-prop true}))))\n             true\n             (if (coercive-not (. ~xsym ~msym))\n               (cljs.core/native-satisfies? ~psym ~xsym)\n               false))\n           (cljs.core/native-satisfies? ~psym ~xsym)))\n      `(if-not (nil? ~x)\n         (if (or ~(if bit `(unsafe-bit-and (. ~x ~msym) ~bit) false)\n                  (identical? cljs.core/PROTOCOL_SENTINEL\n                    (. ~x ~(with-meta (symbol (core/str \"-\" prefix)) {:protocol-prop true}))))\n           true\n           (if (coercive-not (. ~x ~msym))\n             (cljs.core/native-satisfies? ~psym ~x)\n             false))\n         (cljs.core/native-satisfies? ~psym ~x)))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/clojure/cljs/core.cljc",
                                            :lines [2210 2240]},
                                   :full-name "cljs.core/satisfies?",
                                   :docstring "Returns true if x satisfies the protocol"},
           "cljs.core/nth" {:ns "cljs.core",
                            :name "nth",
                            :signature ["[coll n]"
                                        "[coll n not-found]"],
                            :name-encode "nth",
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core/nth",
                            :source {:code "(defn nth\n  ([coll n]\n    (cond\n      (not (number? n))\n      (throw (js/Error. \"Index argument to nth must be a number\"))\n\n      (nil? coll)\n      coll\n\n      (implements? IIndexed coll)\n      (-nth coll n)\n\n      (array? coll)\n      (if (and (< -1 n (.-length coll)))\n        (aget coll (int n))\n        (throw (js/Error. \"Index out of bounds\")))\n\n      (string? coll)\n      (if (and (< -1 n (.-length coll)))\n        (.charAt coll (int n))\n        (throw (js/Error. \"Index out of bounds\")))\n\n      (or (implements? ISeq coll)\n          (implements? ISequential coll))\n      (if (neg? n)\n        (throw (js/Error. \"Index out of bounds\"))\n        (linear-traversal-nth coll n))\n\n      (native-satisfies? IIndexed coll)\n      (-nth coll n)\n\n      :else\n      (throw (js/Error. (str \"nth not supported on this type \"\n                          (type->str (type coll)))))))\n  ([coll n not-found]\n    (cond\n      (not (number? n))\n      (throw (js/Error. \"Index argument to nth must be a number.\"))\n\n      (nil? coll)\n      not-found\n\n      (implements? IIndexed coll)\n      (-nth coll n not-found)\n\n      (array? coll)\n      (if (and (< -1 n (.-length coll)))\n        (aget coll (int n))\n        not-found)\n\n      (string? coll)\n      (if (and (< -1 n (.-length coll)))\n        (.charAt coll (int n))\n        not-found)\n\n      (or (implements? ISeq coll)\n          (implements? ISequential coll))\n      (if (neg? n)\n        not-found\n        (linear-traversal-nth coll n not-found))\n\n      (native-satisfies? IIndexed coll)\n      (-nth coll n not-found)\n\n      :else\n      (throw (js/Error. (str \"nth not supported on this type \"\n                          (type->str (type coll))))))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/cljs/cljs/core.cljs",
                                     :lines [1909 1979]},
                            :full-name "cljs.core/nth",
                            :docstring "Returns the value at the index. get returns nil if index out of\nbounds, nth throws an exception unless not-found is supplied.  nth\nalso works for strings, arrays, regex Matchers and Lists, and,\nin O(n) time, for sequences."},
           "cljs.core/list" {:ns "cljs.core",
                             :name "list",
                             :signature ["[& xs]"],
                             :name-encode "list",
                             :history [["+" "0.0-927"]],
                             :type "function/macro",
                             :full-name-encode "cljs.core/list",
                             :source {:code "(defn list\n  [& xs]\n  (let [arr (if (and (instance? IndexedSeq xs) (zero? (.-i xs)))\n              (.-arr xs)\n              (let [arr (array)]\n                (loop [^not-native xs xs]\n                  (if-not (nil? xs)\n                    (do\n                      (.push arr (-first xs))\n                      (recur (-next xs)))\n                    arr))))]\n    (loop [i (alength arr) r ()]\n      (if (> i 0)\n        (recur (dec i) (-conj r (aget arr (dec i))))\n        r))))",
                                      :title "Function code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [3296 3311]},
                             :extra-sources [{:code "(core/defmacro list\n  ([]\n   '(.-EMPTY cljs.core/List))\n  ([x]\n   `(cljs.core/List. nil ~x nil 1 nil))\n  ([x & xs]\n   (core/let [cnt (core/inc (count xs))]\n     `(cljs.core/List. nil ~x (list ~@xs) ~cnt nil))))",
                                              :title "Macro code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/clojure/cljs/core.cljc",
                                              :lines [2619 2626]}],
                             :full-name "cljs.core/list",
                             :docstring "Creates a new list containing the items."},
           "cljs.core/defn" {:ns "cljs.core",
                             :name "defn",
                             :name-encode "defn",
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :full-name-encode "cljs.core/defn",
                             :source {:code "(def\n  ^{:arglists '([name doc-string? attr-map? [params*] prepost-map? body]\n                 [name doc-string? attr-map? ([params*] prepost-map? body)+ attr-map?])\n    :macro true}\n  defn (core/fn defn [&form &env name & fdecl]\n         ;; Note: Cannot delegate this check to def because of the call to (with-meta name ..)\n         (if (core/instance? #?(:clj clojure.lang.Symbol :cljs Symbol) name)\n           nil\n           (throw\n             #?(:clj (IllegalArgumentException. \"First argument to defn must be a symbol\")\n                :cljs (js/Error. \"First argument to defn must be a symbol\"))))\n         (core/let [m (if (core/string? (first fdecl))\n                        {:doc (first fdecl)}\n                        {})\n                    fdecl (if (core/string? (first fdecl))\n                            (next fdecl)\n                            fdecl)\n                    m (if (map? (first fdecl))\n                        (conj m (first fdecl))\n                        m)\n                    fdecl (if (map? (first fdecl))\n                            (next fdecl)\n                            fdecl)\n                    fdecl (if (vector? (first fdecl))\n                            (core/list fdecl)\n                            fdecl)\n                    m (if (map? (last fdecl))\n                        (conj m (last fdecl))\n                        m)\n                    fdecl (if (map? (last fdecl))\n                            (butlast fdecl)\n                            fdecl)\n                    m (conj {:arglists (core/list 'quote (sigs fdecl))} m)\n                    ;; no support for :inline\n                    ;m (core/let [inline (:inline m)\n                    ;             ifn (first inline)\n                    ;             iname (second inline)]\n                    ;    ;; same as: (if (and (= 'fn ifn) (not (symbol? iname))) ...)\n                    ;    (if (if #?(:clj (clojure.lang.Util/equiv 'fn ifn)\n                    ;               :cljs (= 'fn ifn))\n                    ;          (if #?(:clj (core/instance? clojure.lang.Symbol iname)\n                    ;                 :cljs (core/instance? Symbol iname)) false true))\n                    ;      ;; inserts the same fn name to the inline fn if it does not have one\n                    ;      (assoc m\n                    ;        :inline (cons ifn\n                    ;                  (cons (clojure.lang.Symbol/intern\n                    ;                          (.concat (.getName ^clojure.lang.Symbol name) \"__inliner\"))\n                    ;                    (next inline))))\n                    ;      m))\n                    m (conj (if (meta name) (meta name) {}) m)]\n           (core/cond\n             (multi-arity-fn? fdecl)\n             (multi-arity-fn name\n               (if (comp/checking-types?)\n                 (update-in m [:jsdoc] conj \"@param {...*} var_args\")\n                 m) fdecl (:def-emits-var &env))\n\n             (variadic-fn? fdecl)\n             (variadic-fn name\n               (if (comp/checking-types?)\n                 (update-in m [:jsdoc] conj \"@param {...*} var_args\")\n                 m) fdecl (:def-emits-var &env))\n\n             :else\n             (core/list 'def (with-meta name m)\n               ;;todo - restore propagation of fn name\n               ;;must figure out how to convey primitive hints to self calls first\n               (cons `fn fdecl))))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/clojure/cljs/core.cljc",
                                      :lines [3307 3378]},
                             :full-name "cljs.core/defn",
                             :docstring "Same as (def name (core/fn [params* ] exprs*)) or (def\n name (core/fn ([params* ] exprs*)+)) with any doc-string or attrs added\n to the var metadata. prepost-map defines a map with optional keys\n :pre and :post that contain collections of pre or post conditions."},
           "cljs.spec.gen.alpha/large-integer" {:ns "cljs.spec.gen.alpha",
                                                :name "large-integer",
                                                :signature ["[& args]"],
                                                :name-encode "large-integer",
                                                :history [["+"
                                                           "1.9.542"]],
                                                :type "function",
                                                :full-name-encode "cljs.spec.gen.alpha/large-integer",
                                                :source {:code "(lazy-prims any any-printable boolean char char-alpha char-alphanumeric char-ascii double\n  int keyword keyword-ns large-integer ratio simple-type simple-type-printable\n  string string-ascii string-alphanumeric symbol symbol-ns uuid)",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1.12.38",
                                                         :filename "src/main/cljs/cljs/spec/gen/alpha.cljs",
                                                         :lines [74
                                                                 76]},
                                                :full-name "cljs.spec.gen.alpha/large-integer",
                                                :docstring "Fn returning clojure.test.check.generators/large-integer"},
           "cljs.core/rand-nth" {:ns "cljs.core",
                                 :name "rand-nth",
                                 :signature ["[coll]"],
                                 :name-encode "rand-nth",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/rand-nth",
                                 :source {:code "(defn rand-nth\n  [coll]\n  (nth coll (rand-int (count coll))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [11281 11286]},
                                 :full-name "cljs.core/rand-nth",
                                 :docstring "Return a random element of the (sequential) collection. Will have\nthe same performance characteristics as nth for the given\ncollection."},
           "cljs.core/ex-cause" {:ns "cljs.core",
                                 :name "ex-cause",
                                 :signature ["[ex]"],
                                 :name-encode "ex-cause",
                                 :history [["+" "0.0-1576"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/ex-cause",
                                 :source {:code "(defn ex-cause\n  [ex]\n  (when (instance? ExceptionInfo ex)\n    (.-cause ex)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [11829 11835]},
                                 :full-name "cljs.core/ex-cause",
                                 :docstring "Returns exception cause (an Error / ExceptionInfo) if ex is an\nExceptionInfo.\nOtherwise returns nil."},
           "cljs.spec.gen.alpha/shuffle" {:ns "cljs.spec.gen.alpha",
                                          :name "shuffle",
                                          :signature ["[& args]"],
                                          :name-encode "shuffle",
                                          :history [["+" "1.10.439"]],
                                          :type "function",
                                          :full-name-encode "cljs.spec.gen.alpha/shuffle",
                                          :source {:code "(lazy-combinators hash-map list map not-empty set vector vector-distinct fmap elements\n  bind choose one-of such-that tuple sample return\n  large-integer* double* frequency shuffle)",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/cljs/cljs/spec/gen/alpha.cljs",
                                                   :lines [70 72]},
                                          :full-name "cljs.spec.gen.alpha/shuffle",
                                          :docstring "Lazy loaded version of clojure.test.check.generators/shuffle"},
           "cljs.core/def" {:ns "cljs.core",
                            :name "def",
                            :signature ["[symbol doc-string? init?]"],
                            :name-encode "def",
                            :history [["+" "0.0-927"]],
                            :type "special form",
                            :full-name-encode "cljs.core/def",
                            :source {:code "(defmethod parse 'def\n  [op env form _ _]\n  (when (> (count form) 4)\n    (throw (error env \"Too many arguments to def\")))\n  (let [pfn (fn\n              ([_ sym] {:sym sym})\n              ([_ sym init] {:sym sym :init init})\n              ([_ sym doc init] {:sym sym :doc doc :init init}))\n        args (apply pfn form)\n        sym (:sym args)\n        const? (-> sym meta :const)\n        sym-meta (meta sym)\n        tag (-> sym meta :tag)\n        protocol (-> sym meta :protocol valid-proto)\n        dynamic (-> sym meta :dynamic)\n        ns-name (-> env :ns :name)\n        locals (:locals env)\n        clash-ns (symbol (str ns-name \".\" sym))\n        sym-ns   (namespace sym)\n        sym      (cond\n                   (and sym-ns (not #?(:clj  (= (symbol sym-ns) ns-name)\n                                       :cljs (symbol-identical? (symbol sym-ns) ns-name))))\n                   (throw (error env (str \"Can't def ns-qualified name in namespace \" sym-ns)))\n\n                   (some? sym-ns)\n                   (symbol (name sym))\n\n                   :else sym)]\n    (when (some? (get-in @env/*compiler* [::namespaces clash-ns]))\n      (warning :ns-var-clash env\n        {:ns (symbol (str ns-name \".\" sym))\n         :var (symbol (str ns-name) (str sym))}))\n    (when (some? (:const (resolve-var (dissoc env :locals) sym)))\n      (throw (error env \"Can't redefine a constant\")))\n    (when-some [doc (:doc args)]\n      (when-not (string? doc)\n        (throw (error env \"Too many arguments to def\"))))\n    (when (and (not dynamic)\n               (earmuffed? sym)\n               (not (core-ns? ns-name)))\n      (warning :non-dynamic-earmuffed-var env\n        {:var (str sym)}))\n    (when-some [v (get-in @env/*compiler* [::namespaces ns-name :defs sym])]\n      (when (and (not *allow-redef*)\n                 (not (:declared v))\n                 (not (:declared sym-meta))\n                 *file-defs*\n                 (get @*file-defs* sym))\n        (warning :redef-in-file env {:sym sym :line (:line v)}))\n      (when (and (:declared v)\n                 (:arglists v)\n                 (not= (:arglists v) (:arglists sym-meta)))\n        (warning :declared-arglists-mismatch env {:ns-name  ns-name :sym sym\n                                                  :declared (second (:arglists v))\n                                                  :defined  (second (:arglists sym-meta))})))\n    (let [env (if (or (and (not= ns-name 'cljs.core)\n                           (core-name? env sym))\n                      (some? (get-in @env/*compiler* [::namespaces ns-name :uses sym])))\n                (let [ev (resolve-existing-var (dissoc env :locals)\n                           ;; ::no-resolve true is to suppress \"can't take value\n                           ;; of macro warning\" when sym resolves to a macro\n                           (with-meta sym {::no-resolve true}))\n                      conj-to-set (fnil conj #{})]\n                  (when (public-name? (:ns ev) sym)\n                    (warning :redef env {:sym sym :ns (:ns ev) :ns-name ns-name}))\n                  (swap! env/*compiler* update-in [::namespaces ns-name :excludes]\n                     conj-to-set sym)\n                  (update-in env [:ns :excludes] conj-to-set sym))\n                env)\n          var-name (:name (resolve-var (dissoc env :locals) sym))\n          init-expr (when (contains? args :init)\n                      (swap! env/*compiler* assoc-in [::namespaces ns-name :defs sym]\n                        (merge\n                          {:name var-name}\n                          sym-meta\n                          (when (true? dynamic) {:dynamic true})\n                          (source-info var-name env)))\n                      (disallowing-recur\n                        (disallowing-ns*\n                          (analyze (assoc env :context :expr) (:init args) sym))))\n          fn-var? (and (some? init-expr) (= (:op init-expr) :fn))\n          tag (cond\n                fn-var? (or (:ret-tag init-expr) tag (:inferred-ret-tag init-expr))\n                tag tag\n                dynamic impl/ANY_SYM\n                :else (:tag init-expr))\n          export-as (when-let [export-val (-> sym meta :export)]\n                      (if (= true export-val) var-name export-val))\n          doc (or (:doc args) (-> sym meta :doc))]\n      (when-some [v (get-in @env/*compiler* [::namespaces ns-name :defs sym])]\n        (when (and (not (-> sym meta :declared))\n                   (and (true? (:fn-var v)) (not fn-var?)))\n          (warning :fn-var env {:ns-name ns-name :sym sym})))\n\n      ;; declare must not replace any analyzer data of an already def'd sym\n      (when (or (nil? (get-in @env/*compiler* [::namespaces ns-name :defs sym]))\n                (not (:declared sym-meta)))\n        (when *file-defs*\n          (swap! *file-defs* conj sym))\n\n        (swap! env/*compiler* assoc-in [::namespaces ns-name :defs sym]\n          (merge\n            {:name var-name}\n            ;; remove actual test metadata, as it includes non-valid EDN and\n            ;; cannot be present in analysis cached to disk - David\n            (cond-> sym-meta\n              (:test sym-meta) (assoc :test true))\n            {:meta (-> sym-meta\n                       (dissoc :test)\n                       (update-in [:file]\n                         (fn [f]\n                           (if (= (-> env :ns :name) 'cljs.core)\n                             \"cljs/core.cljs\"\n                             f))))}\n            (when doc {:doc doc})\n            (when const?\n              (let [const-expr\n                    (binding [*passes* (conj *passes* (replace-env-pass {:context :expr}))]\n                      (analyze env (:init args)))]\n                (when (constant-value? const-expr)\n                  {:const-expr const-expr})))\n            (when (true? dynamic) {:dynamic true})\n            (source-info var-name env)\n            ;; the protocol a protocol fn belongs to\n            (when protocol\n              {:protocol protocol})\n            ;; symbol for reified protocol\n            (when-let [protocol-symbol (-> sym meta :protocol-symbol)]\n              {:protocol-symbol protocol-symbol\n               :info (-> protocol-symbol meta :protocol-info)\n               :impls #{}})\n            (when fn-var?\n              (let [params (map #(vec (map :name (:params %))) (:methods init-expr))]\n                (merge\n                  {:fn-var (not (:macro sym-meta))\n                   ;; protocol implementation context\n                   :protocol-impl (:protocol-impl init-expr)\n                   ;; inline protocol implementation context\n                   :protocol-inline (:protocol-inline init-expr)}\n                  (if-some [top-fn-meta (:top-fn sym-meta)]\n                    top-fn-meta\n                    {:variadic? (:variadic? init-expr)\n                     :max-fixed-arity (:max-fixed-arity init-expr)\n                     :method-params params\n                     :arglists (:arglists sym-meta)\n                     :arglists-meta (doall (map meta (:arglists sym-meta)))}))))\n            (when (and (:declared sym-meta)\n                       (:arglists sym-meta))\n              {:declared true\n               :fn-var true\n               :method-params (second (:arglists sym-meta))})\n            (if (and fn-var? (some? tag))\n              {:ret-tag tag}\n              (when tag {:tag tag})))))\n      (merge\n        {:env env\n         :op :def\n         :form form\n         :ns ns-name\n         :name var-name\n         :var (assoc\n                (analyze\n                  (-> env (dissoc :locals)\n                    (assoc :context :expr)\n                    (assoc :def-var true))\n                  sym)\n                :op :var)\n         :doc doc\n         :jsdoc (:jsdoc sym-meta)}\n        (when-let [goog-type (:goog-define sym-meta)]\n          {:goog-define goog-type})\n        (when (true? (:def-emits-var env))\n          {:var-ast (var-ast env sym)})\n        (when-some [test (:test sym-meta)]\n          {:test (analyze (assoc env :context :expr) test)})\n        (when (some? tag)\n          (if fn-var?\n            {:ret-tag tag}\n            {:tag tag}))\n        (when (true? dynamic) {:dynamic true})\n        (when (some? export-as) {:export export-as})\n        (if (some? init-expr)\n          {:init init-expr\n           :children [:var :init]}\n          {:children [:var]})))))",
                                     :title "Parser code",
                                     :repo "clojurescript",
                                     :tag "r1.12.38",
                                     :filename "src/main/clojure/cljs/analyzer.cljc",
                                     :lines [1951 2135]},
                            :extra-sources ({:code "(defmethod emit* :def\n  [{:keys [name var init env doc goog-define jsdoc export test var-ast]}]\n  ;; We only want to emit if an init is supplied, this is to avoid dead code\n  ;; elimination issues. The REPL is the exception to this rule.\n  (when (or init (:def-emits-var env))\n    (let [mname (munge name)]\n      (emit-comment env doc (concat\n                              (when goog-define\n                                [(str \"@define {\" goog-define \"}\")])\n                              jsdoc (:jsdoc init)))\n      (when (= :return (:context env))\n        (emitln \"return (\"))\n      (when (:def-emits-var env)\n        (emitln \"(function (){\"))\n      (emits var)\n      (when init\n        (emits \" = \"\n          (if-let [define (get-define mname jsdoc)]\n            define\n            init)))\n      (when (:def-emits-var env)\n        (emitln \"; return (\")\n        (emits (merge\n                 {:op  :the-var\n                  :env (assoc env :context :expr)}\n                 var-ast))\n        (emitln \");})()\"))\n      (when (= :return (:context env))\n        (emitln \")\"))\n      ;; NOTE: JavaScriptCore does not like this under advanced compilation\n      ;; this change was primarily for REPL interactions - David\n      ;(emits \" = (typeof \" mname \" != 'undefined') ? \" mname \" : undefined\")\n      (when-not (= :expr (:context env)) (emitln \";\"))\n      (when export\n        (emitln \"goog.exportSymbol('\" (munge export) \"', \" mname \");\"))\n      (when (and ana/*load-tests* test)\n        (when (= :expr (:context env))\n          (emitln \";\"))\n        (emitln var \".cljs$lang$test = \" test \";\")))))",
                                             :title "Emitting code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/clojure/cljs/compiler.cljc",
                                             :lines [814 852]}),
                            :full-name "cljs.core/def",
                            :docstring "Creates and interns a global var with the name\nof symbol in the current namespace (*ns*) or locates such a var if\nit already exists.  If init is supplied, it is evaluated, and the\nroot binding of the var is set to the resulting value.  If init is\nnot supplied, the root binding of the var is unaffected."},
           "cljs.core/transformer-iterator" {:ns "cljs.core",
                                             :name "transformer-iterator",
                                             :signature ["[xform sourceIter multi]"],
                                             :name-encode "transformer-iterator",
                                             :history [["+" "1.9.562"]],
                                             :type "function",
                                             :full-name-encode "cljs.core/transformer-iterator",
                                             :source {:code "(defn transformer-iterator\n  [xform sourceIter multi]\n  (let [iterator (TransformerIterator. EMPTY NONE false nil sourceIter multi)]\n    (set! (.-xf iterator)\n      (xform (fn\n               ([] nil)\n               ([acc] acc)\n               ([acc o]\n                (set! (.-buffer iterator) (.add (.-buffer iterator) o))\n                acc))))\n    iterator))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.12.38",
                                                      :filename "src/main/cljs/cljs/core.cljs",
                                                      :lines [4280
                                                              4290]},
                                             :full-name "cljs.core/transformer-iterator"},
           "cljs.core/atom" {:ns "cljs.core",
                             :name "atom",
                             :signature ["[x]"
                                         "[x & {:keys [meta validator]}]"],
                             :name-encode "atom",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/atom",
                             :source {:code "(defn atom\n  ([x] (Atom. x nil nil nil))\n  ([x & {:keys [meta validator]}] (Atom. x meta validator nil)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [4548 4563]},
                             :full-name "cljs.core/atom",
                             :docstring "Creates and returns an Atom with an initial value of x and zero or\nmore options (in any order):\n\n:meta metadata-map\n\n:validator validate-fn\n\nIf metadata-map is supplied, it will become the metadata on the\natom. validate-fn must be nil or a side-effect-free fn of one\nargument, which will be passed the intended new state on any state\nchange. If the new state is unacceptable, the validate-fn should\nreturn false or throw an Error.  If either of these error conditions\noccur, then the value of the atom will not change."},
           "cljs.reader/read-keyword" {:ns "cljs.reader",
                                       :name "read-keyword",
                                       :signature ["[reader initch]"],
                                       :name-encode "read-keyword",
                                       :history [["+" "0.0-927"]
                                                 ["-" "1.9.854"]],
                                       :type "function",
                                       :full-name-encode "cljs.reader/read-keyword",
                                       :source {:code "(defn read-keyword\n  [reader initch]\n  (let [token (read-token reader (read-char reader))\n        a (re-matches* symbol-pattern token)\n        _ (when (nil? a) (reader-error reader \"Invalid keyword \" (str \":\" token)))\n        token (aget a 0)\n        ns (aget a 1)\n        name (aget a 2)]\n    (if (or (and (not (undefined? ns))\n                 (identical? (. ns (substring (- (.-length ns) 2) (.-length ns))) \":/\"))\n            (identical? (aget name (dec (.-length name))) \":\")\n            (not (== (.indexOf token \"::\" 1) -1)))\n      (reader-error reader \"Invalid token: \" token)\n      (if (and (not (nil? ns)) (> (.-length ns) 0))\n        (keyword (.substring ns 0 (.indexOf ns \"/\")) name)\n        (keyword token)))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.9.671",
                                                :filename "src/main/cljs/cljs/reader.cljs",
                                                :lines [364 379]},
                                       :full-name "cljs.reader/read-keyword",
                                       :removed {:in "1.9.854",
                                                 :last-seen "1.9.671"}},
           "cljs.core/Vector" {:protocols #{"IFn"
                                            "ISeqable"
                                            "IMeta"
                                            "IWithMeta"
                                            "IStack"
                                            "IEmptyableCollection"
                                            "ICounted"
                                            "IReduce"
                                            "ILookup"
                                            "ISequential"
                                            "ICollection"
                                            "IHash"
                                            "IPrintWithWriter"
                                            "IIndexed"
                                            "IAssociative"
                                            "IVector"
                                            "IPrintable"
                                            "IEquiv"},
                               :ns "cljs.core",
                               :name "Vector",
                               :signature ["[meta array __hash]"],
                               :name-encode "Vector",
                               :history [["+" "0.0-927"]
                                         ["-" "0.0-1798"]],
                               :type "type",
                               :full-name-encode "cljs.core/Vector",
                               :source {:code "(deftype Vector [meta array ^:mutable __hash]\n  Object\n  (toString [this]\n    (pr-str this))\n\n  IWithMeta\n  (-with-meta [coll meta] (Vector. meta array __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IStack\n  (-peek [coll]\n    (let [count (alength array)]\n      (when (> count 0)\n        (aget array (dec count)))))\n  (-pop [coll]\n    (if (> (alength array) 0)\n      (let [new-array (aclone array)]\n        (. new-array (pop))\n        (Vector. meta new-array nil))\n      (throw (js/Error. \"Can't pop empty vector\"))))\n\n  ICollection\n  (-conj [coll o]\n    (let [new-array (aclone array)]\n      (.push new-array o)\n      (Vector. meta new-array nil)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.Vector/EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (when (> (alength array) 0)\n      (let [vector-seq\n             (fn vector-seq [i]\n               (lazy-seq\n                 (when (< i (alength array))\n                   (cons (aget array i) (vector-seq (inc i))))))]\n        (vector-seq 0))))\n\n  ICounted\n  (-count [coll] (alength array))\n\n  IIndexed\n  (-nth [coll n]\n    (if (and (<= 0 n) (< n (alength array)))\n      (aget array n)\n      #_(throw (js/Error. (str \"No item \" n \" in vector of length \" (alength array))))))\n  (-nth [coll n not-found]\n    (if (and (<= 0 n) (< n (alength array)))\n      (aget array n)\n      not-found))\n\n  ILookup\n  (-lookup [coll k] (-nth coll k nil))\n  (-lookup [coll k not-found] (-nth coll k not-found))\n\n  IAssociative\n  (-assoc [coll k v]\n    (let [new-array (aclone array)]\n      (aset new-array k v)\n      (Vector. meta new-array nil)))\n\n  IVector\n  (-assoc-n [coll n val] (-assoc coll n val))\n\n  IReduce\n  (-reduce [v f]\n    (ci-reduce array f))\n  (-reduce [v f start]\n    (ci-reduce array f start))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1586",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [2772 2857]},
                               :full-name "cljs.core/Vector",
                               :removed {:in "0.0-1798",
                                         :last-seen "0.0-1586"}},
           "cljs.reader/skip-line" {:ns "cljs.reader",
                                    :name "skip-line",
                                    :signature ["[reader _]"],
                                    :name-encode "skip-line",
                                    :history [["+" "0.0-927"]
                                              ["-" "1.9.854"]],
                                    :type "function",
                                    :full-name-encode "cljs.reader/skip-line",
                                    :source {:code "(defn skip-line\n  [reader _]\n  (loop []\n    (let [ch (read-char reader)]\n      (if (or (identical? ch \\newline) (identical? ch \\return) (nil? ch))\n        reader\n        (recur)))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.9.671",
                                             :filename "src/main/cljs/cljs/reader.cljs",
                                             :lines [90 97]},
                                    :full-name "cljs.reader/skip-line",
                                    :docstring "Advances the reader to the end of a line. Returns the reader",
                                    :removed {:in "1.9.854",
                                              :last-seen "1.9.671"}},
           "cljs.core/namespace" {:ns "cljs.core",
                                  :name "namespace",
                                  :signature ["[x]"],
                                  :name-encode "namespace",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/namespace",
                                  :source {:code "(defn namespace\n  [x]\n  (if (implements? INamed x)\n    (-namespace x)\n    (throw (js/Error. (str \"Doesn't support namespace: \" x)))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [3447 3452]},
                                  :full-name "cljs.core/namespace",
                                  :docstring "Returns the namespace String of a symbol or keyword, or nil if not present."},
           "cljs.core/ns-name" {:ns "cljs.core",
                                :name "ns-name",
                                :signature ["[ns-obj]"],
                                :name-encode "ns-name",
                                :history [["+" "1.7.10"]],
                                :type "function",
                                :full-name-encode "cljs.core/ns-name",
                                :source {:code "(defn ns-name\n  [ns-obj]\n  (.-name ns-obj))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [12218 12222]},
                                :full-name "cljs.core/ns-name",
                                :docstring "Returns the name of the namespace, a Namespace object.\nBootstrap only."},
           "cljs.nodejs/require" {:ns "cljs.nodejs",
                                  :name "require",
                                  :name-encode "require",
                                  :type "var",
                                  :full-name-encode "cljs.nodejs/require",
                                  :source {:code "(def require (js* \"require\"))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/nodejs.cljs",
                                           :lines [16]},
                                  :full-name "cljs.nodejs/require",
                                  :history [["+" "0.0-927"]]},
           "cljs.spec/tuple" {:ns "cljs.spec",
                              :name "tuple",
                              :signature ["[& preds]"],
                              :name-encode "tuple",
                              :history [["+" "1.9.14"]
                                        ["-" "1.9.542"]],
                              :type "macro",
                              :full-name-encode "cljs.spec/tuple",
                              :source {:code "(defmacro tuple\n  [& preds]\n  (clojure.core/assert (not (empty? preds)))\n  `(tuple-impl '~(mapv #(res &env %) preds) ~(vec preds)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.9.521",
                                       :filename "src/main/cljs/cljs/spec.cljc",
                                       :lines [388 394]},
                              :full-name "cljs.spec/tuple",
                              :docstring "takes one or more preds and returns a spec for a tuple, a vector\nwhere each element conforms to the corresponding pred. Each element\nwill be referred to in paths using its ordinal.",
                              :removed {:in "1.9.542",
                                        :last-seen "1.9.521"}},
           "cljs.core/chunk-rest" {:ns "cljs.core",
                                   :name "chunk-rest",
                                   :signature ["[s]"],
                                   :name-encode "chunk-rest",
                                   :history [["+" "0.0-1424"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/chunk-rest",
                                   :source {:code "(defn chunk-rest [s]\n  (-chunked-rest s))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [3725 3726]},
                                   :full-name "cljs.core/chunk-rest"},
           "closure-warnings/module-load" {:ns "closure-warnings",
                                           :name "module-load",
                                           :name-encode "module-load",
                                           :type "warning",
                                           :full-name-encode "closure-warnings/module-load",
                                           :full-name "closure-warnings/module-load",
                                           :history [["+" "1.10.217"]]},
           "cljs.core/unchecked-long" {:ns "cljs.core",
                                       :name "unchecked-long",
                                       :signature ["[x]"],
                                       :name-encode "unchecked-long",
                                       :history [["+" "0.0-1798"]],
                                       :type "function",
                                       :full-name-encode "cljs.core/unchecked-long",
                                       :source {:code "(defn unchecked-long\n  [x]\n  (fix x))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/core.cljs",
                                                :lines [2901 2904]},
                                       :full-name "cljs.core/unchecked-long",
                                       :docstring "Coerce to long by stripping decimal places. Identical to `int'."},
           "cljs.repl/source-fn" {:ns "cljs.repl",
                                  :name "source-fn",
                                  :signature ["[env x]"],
                                  :name-encode "source-fn",
                                  :history [["+" "0.0-2985"]],
                                  :type "function",
                                  :full-name-encode "cljs.repl/source-fn",
                                  :source {:code "(defn source-fn\n  [env x]\n  (when-let [v (ana-api/resolve env x)]\n    (when-let [filepath (:file v)]\n      (let [f (io/file filepath)\n            f (if (.exists f)\n                f\n                (io/resource filepath))]\n        (when f\n          (with-open [pbr (PushbackReader. (io/reader f))]\n            (let [rdr (readers/source-logging-push-back-reader pbr)]\n              (dotimes [_ (dec (:line v))] (readers/read-line rdr))\n              (binding [reader/*alias-map*    identity\n                        reader/*data-readers* (merge tags/*cljs-data-readers*\n                                                (ana/load-data-readers))]\n                (-> (reader/read {:read-cond :allow :features #{:cljs}} rdr)\n                  meta :source)))))))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/clojure/cljs/repl.cljc",
                                           :lines [1495 1518]},
                                  :full-name "cljs.repl/source-fn",
                                  :docstring "Returns a string of the source code for the given symbol, if it can\nfind it.  This requires that the symbol resolve to a Var defined in\na namespace for which the .clj is in the classpath.  Returns nil if\nit can't find the source.  For most REPL usage, 'source' is more\nconvenient.\n\nExample: (source-fn 'filter)"},
           "cljs.repl.server/connection" {:ns "cljs.repl.server",
                                          :name "connection",
                                          :signature ["[]"],
                                          :name-encode "connection",
                                          :history [["+" "0.0-1503"]],
                                          :type "function",
                                          :full-name-encode "cljs.repl.server/connection",
                                          :source {:code "(defn connection\n  []\n  (locking lock\n    (let [p (promise)\n          conn (.poll connq)]\n      (if (and conn (not (.isClosed conn)))\n        (deliver p conn)\n        (.offer promiseq p))\n      p)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/clojure/cljs/repl/server.clj",
                                                   :lines [24 35]},
                                          :full-name "cljs.repl.server/connection",
                                          :docstring "Promise to return a connection when one is available. If no connection is\navailable put the promise into a FIFO queue to get the next available\nconnection."},
           "clojure.browser.event/EventType" {:ns "clojure.browser.event",
                                              :name "EventType",
                                              :name-encode "EventType",
                                              :history [["+"
                                                         "0.0-927"]
                                                        ["-"
                                                         "0.0-2301"]],
                                              :type "protocol",
                                              :full-name-encode "clojure.browser.event/EventType",
                                              :source {:code "(defprotocol EventType\n  (event-types [this]))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r2280",
                                                       :filename "src/cljs/clojure/browser/event.cljs",
                                                       :lines [17 18]},
                                              :methods [{:name "event-types",
                                                         :signature ["[this]"],
                                                         :docstring nil}],
                                              :full-name "clojure.browser.event/EventType",
                                              :removed {:in "0.0-2301",
                                                        :last-seen "0.0-2280"}},
           "cljs.pprint/IPrettyFlush" {:ns "cljs.pprint",
                                       :name "IPrettyFlush",
                                       :name-encode "IPrettyFlush",
                                       :history [["+" "0.0-3255"]],
                                       :type "protocol",
                                       :full-name-encode "cljs.pprint/IPrettyFlush",
                                       :source {:code "(defprotocol IPrettyFlush\n  (-ppflush [pp]))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/pprint.cljs",
                                                :lines [145 146]},
                                       :methods [{:name "-ppflush",
                                                  :signature ["[pp]"],
                                                  :docstring nil}],
                                       :full-name "cljs.pprint/IPrettyFlush"},
           "cljs.js/file->ns" {:ns "cljs.js",
                               :name "file->ns",
                               :signature ["[file]"],
                               :name-encode "file-GTns",
                               :history [["+" "1.7.10"]],
                               :type "function",
                               :full-name-encode "cljs.js/file-GTns",
                               :source {:code "(defn file->ns\n  [file]\n  (let [lib-name (subs (string/replace file \"/\" \".\")\n                   0 (- (count file) 5))]\n    (symbol (demunge lib-name))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/js.cljs",
                                        :lines [38 42]},
                               :full-name "cljs.js/file->ns"},
           "cljs.core/ranged-iterator" {:ns "cljs.core",
                                        :name "ranged-iterator",
                                        :signature ["[v start end]"],
                                        :name-encode "ranged-iterator",
                                        :history [["+" "0.0-2371"]],
                                        :type "function",
                                        :full-name-encode "cljs.core/ranged-iterator",
                                        :source {:code "(defn ranged-iterator [v start end]\n  (let [i start]\n    (RangedIterator. i (- i (js-mod i 32))\n      (when (< start (count v))\n        (unchecked-array-for v i))\n      v start end)))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/cljs/cljs/core.cljs",
                                                 :lines [5590 5595]},
                                        :full-name "cljs.core/ranged-iterator"},
           "cljs.spec.alpha/valid?" {:ns "cljs.spec.alpha",
                                     :name "valid?",
                                     :signature ["[spec x]"
                                                 "[spec x form]"],
                                     :name-encode "validQMARK",
                                     :history [["+" "1.9.542"]],
                                     :type "function",
                                     :full-name-encode "cljs.spec.alpha/validQMARK",
                                     :source {:code "(defn valid?\n  ([spec x]\n   (let [spec (specize spec)]\n     (not (invalid? (conform* spec x)))))\n  ([spec x form]\n   (let [spec (specize spec form)]\n     (not (invalid? (conform* spec x))))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/cljs/cljs/spec/alpha.cljs",
                                              :lines [371 378]},
                                     :full-name "cljs.spec.alpha/valid?",
                                     :docstring "Helper function that returns true when x is valid for spec."},
           "cljs.pprint/print-table" {:ns "cljs.pprint",
                                      :name "print-table",
                                      :signature ["[ks rows]"
                                                  "[rows]"],
                                      :name-encode "print-table",
                                      :history [["+" "0.0-3255"]],
                                      :type "function",
                                      :full-name-encode "cljs.pprint/print-table",
                                      :source {:code "(defn print-table\n  {:added \"1.3\"}\n  ([ks rows]\n   (when (seq rows)\n     (let [widths  (map\n                     (fn [k]\n                       (apply max (count (str k)) (map #(count (str (get % k))) rows)))\n                     ks)\n           spacers (map #(apply str (repeat % \"-\")) widths)\n           fmt-row (fn [leader divider trailer row]\n                     (str leader\n                       (apply str (interpose divider\n                                    (for [[col width] (map vector (map #(get row %) ks) widths)]\n                                      (add-padding width (str col)))))\n                       trailer))]\n       (cljs.core/println)\n       (cljs.core/println (fmt-row \"| \" \" | \" \" |\" (zipmap ks ks)))\n       (cljs.core/println (fmt-row \"|-\" \"-+-\" \"-|\" (zipmap ks spacers)))\n       (doseq [row rows]\n         (cljs.core/println (fmt-row \"| \" \" | \" \" |\" row))))))\n  ([rows] (print-table (keys (first rows)) rows)))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/pprint.cljs",
                                               :lines [3302 3325]},
                                      :full-name "cljs.pprint/print-table",
                                      :docstring "Prints a collection of maps in a textual table. Prints table headings\nks, and then a line of output for each row, corresponding to the keys\nin ks. If ks are not specified, use the keys of the first item in rows."},
           "cljs.core/create-ns" {:ns "cljs.core",
                                  :name "create-ns",
                                  :signature ["[sym]" "[sym ns-obj]"],
                                  :name-encode "create-ns",
                                  :history [["+" "1.7.10"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/create-ns",
                                  :source {:code "(defn create-ns\n  ([sym]\n   (create-ns sym (find-ns-obj sym)))\n  ([sym ns-obj]\n   (Namespace. ns-obj sym)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [12177 12182]},
                                  :full-name "cljs.core/create-ns",
                                  :docstring "Create a new namespace named by the symbol. Bootstrap only."},
           "cljs.core/PROTOCOL_SENTINEL" {:ns "cljs.core",
                                          :name "PROTOCOL_SENTINEL",
                                          :name-encode "PROTOCOL_SENTINEL",
                                          :type "var",
                                          :full-name-encode "cljs.core/PROTOCOL_SENTINEL",
                                          :source {:code "(defonce PROTOCOL_SENTINEL #js {})",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/cljs/cljs/core.cljs",
                                                   :lines [37]},
                                          :full-name "cljs.core/PROTOCOL_SENTINEL",
                                          :history [["+" "1.9.293"]]},
           "cljs.spec.gen.alpha/symbol" {:ns "cljs.spec.gen.alpha",
                                         :name "symbol",
                                         :signature ["[& args]"],
                                         :name-encode "symbol",
                                         :history [["+" "1.9.542"]],
                                         :type "function",
                                         :full-name-encode "cljs.spec.gen.alpha/symbol",
                                         :source {:code "(lazy-prims any any-printable boolean char char-alpha char-alphanumeric char-ascii double\n  int keyword keyword-ns large-integer ratio simple-type simple-type-printable\n  string string-ascii string-alphanumeric symbol symbol-ns uuid)",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/cljs/cljs/spec/gen/alpha.cljs",
                                                  :lines [74 76]},
                                         :full-name "cljs.spec.gen.alpha/symbol",
                                         :docstring "Fn returning clojure.test.check.generators/symbol"},
           "cljs.repl.rhino/rhino-setup" {:ns "cljs.repl.rhino",
                                          :name "rhino-setup",
                                          :signature ["[repl-env opts]"],
                                          :name-encode "rhino-setup",
                                          :history [["+" "0.0-927"]
                                                    ["-" "1.10.738"]],
                                          :type "function",
                                          :full-name-encode "cljs.repl.rhino/rhino-setup",
                                          :source {:code "(defn rhino-setup [repl-env opts]\n  (let [scope   (:scope repl-env)\n        env     (ana/empty-env)\n        core    (io/resource \"cljs/core.cljs\")\n        base-js (io/resource \"goog/base.js\")\n        core-js (closure/compile core\n                  (assoc opts :output-file\n                    (closure/src-file->target-file\n                      core (dissoc opts :output-dir))))\n        deps    (closure/add-dependencies opts core-js)\n        output-dir (util/output-directory opts)\n        repl-deps (io/file output-dir \"rhino_repl_deps.js\")]\n    ;; emit core and deps\n    (apply closure/output-unoptimized\n      (assoc opts :output-to (.getPath repl-deps)) deps)\n\n    ;; setup back references & output stream\n    (ScriptableObject/putProperty scope\n      \"___repl_env\" (Context/javaToJS repl-env scope))\n    (ScriptableObject/putProperty scope \"__repl_opts\"\n      (Context/javaToJS opts scope))\n    (ScriptableObject/putProperty scope\n      \"out\" (Context/javaToJS *out* scope))\n    (ScriptableObject/putProperty scope\n      \"err\" (Context/javaToJS *err* scope))\n\n    ;; define file loading, load goog.base, load repl deps\n    (rhino-eval repl-env \"bootjs\" 1 bootjs)\n    (rhino-eval repl-env \"goog/base.js\" 1 (io/reader base-js))\n    (rhino-eval repl-env \"rhino_repl_deps.js\" 1 (io/reader repl-deps))\n\n    ;; === Bootstrap ===\n    ;; load cljs.core, setup printing\n    (repl/evaluate-form repl-env env \"<cljs repl>\"\n      '(do\n         (.require js/goog \"cljs.core\")\n         (set! *print-fn* (fn [x] (.write js/out x)))\n         (set! *print-err-fn* (fn [x] (.write js/err x)))))\n\n    ;; allow namespace reloading\n    (repl/evaluate-form repl-env env \"<cljs repl>\"\n      '(set! js/goog.isProvided_ (fn [x] false)))\n\n    ;; monkey-patch goog.require\n    (repl/evaluate-form repl-env env \"<cljs repl>\"\n      '(do\n         (set! *loaded-libs* #{\"cljs.core\"})\n         (set! (.-require js/goog)\n           (fn [name reload]\n             (when (or (not (contains? *loaded-libs* name)) reload)\n               (set! *loaded-libs* (conj (or *loaded-libs* #{}) name))\n               (js/CLOSURE_IMPORT_SCRIPT\n                 (if (some? goog/debugLoader_)\n                   (.getPathFromDeps_ goog/debugLoader_ name)\n                   (goog.object/get (.. js/goog -dependencies_ -nameToPath) name))))))))\n\n    ;; set closure-defines\n    (rhino-eval repl-env \"CLOSURE_UNCOMPILED_DEFINES\" 1\n      (str \"goog.global.CLOSURE_UNCOMPILED_DEFINES = \"\n        (json/write-str (:closure-defines opts)) \";\"))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.10.597",
                                                   :filename "src/main/clojure/cljs/repl/rhino.clj",
                                                   :lines [106 165]},
                                          :full-name "cljs.repl.rhino/rhino-setup",
                                          :removed {:in "1.10.738",
                                                    :last-seen "1.10.597"}},
           "cljs.repl.browser/parse-file-line-column" {:ns "cljs.repl.browser",
                                                       :name "parse-file-line-column",
                                                       :signature ["[flc]"],
                                                       :name-encode "parse-file-line-column",
                                                       :history [["+"
                                                                  "0.0-3053"]
                                                                 ["-"
                                                                  "1.7.10"]],
                                                       :type "function",
                                                       :full-name-encode "cljs.repl.browser/parse-file-line-column",
                                                       :source {:code "(defn parse-file-line-column [flc]\n  (let [xs (string/split flc #\":\")\n        [pre [line column]]\n        (reduce\n          (fn [[pre post] [x i]]\n            (if (<= i 2)\n              [pre (conj post x)]\n              [(conj pre x) post]))\n          [[] []] (map vector xs (range (count xs) 0 -1)))\n        file (string/join \":\" pre)]\n    [(cond-> file\n       (.startsWith file \"(\") (string/replace \"(\" \"\"))\n     (Long/parseLong\n       (cond-> line\n         (.endsWith line \")\") (string/replace \")\" \"\")))\n     (Long/parseLong\n       (cond-> column\n         (.endsWith column \")\") (string/replace \")\" \"\")))]))",
                                                                :title "Source code",
                                                                :repo "clojurescript",
                                                                :tag "r3308",
                                                                :filename "src/main/clojure/cljs/repl/browser.clj",
                                                                :lines [211
                                                                        228]},
                                                       :full-name "cljs.repl.browser/parse-file-line-column",
                                                       :removed {:in "1.7.10",
                                                                 :last-seen "0.0-3308"}},
           "cljs.core/merge" {:ns "cljs.core",
                              :name "merge",
                              :signature ["[& maps]"],
                              :name-encode "merge",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/merge",
                              :source {:code "(defn merge\n  [& maps]\n  (when (some identity maps)\n    (reduce #(conj (or %1 {}) %2) maps)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/cljs/core.cljs",
                                       :lines [9335 9341]},
                              :full-name "cljs.core/merge",
                              :docstring "Returns a map that consists of the rest of the maps conj-ed onto\nthe first.  If a key occurs in more than one map, the mapping from\nthe latter (left-to-right) will be the mapping in the result."},
           "clojure.core.reducers/remove" {:ns "clojure.core.reducers",
                                           :name "remove",
                                           :signature ["[pred]"
                                                       "[pred coll]"],
                                           :name-encode "remove",
                                           :history [["+" "0.0-1236"]],
                                           :type "function",
                                           :full-name-encode "clojure.core.reducers/remove",
                                           :source {:code "(defcurried remove\n  {}\n  [pred coll]\n  (filter (complement pred) coll))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/cljs/clojure/core/reducers.cljs",
                                                    :lines [145 150]},
                                           :full-name "clojure.core.reducers/remove",
                                           :docstring "Removes values in the reduction of coll for which (pred val)\n  returns logical true. Foldable."},
           "cljs.build.api/src-file->goog-require" {:return-type String,
                                                    :ns "cljs.build.api",
                                                    :name "src-file->goog-require",
                                                    :signature ["[src]"
                                                                "[src opts]"
                                                                "[state src opts]"],
                                                    :name-encode "src-file-GTgoog-require",
                                                    :history [["+"
                                                               "0.0-2629"]],
                                                    :type "function",
                                                    :full-name-encode "cljs.build.api/src-file-GTgoog-require",
                                                    :source {:code "(defn ^String src-file->goog-require\n  ([src] (src-file->goog-require src nil))\n  ([src opts]\n   (src-file->goog-require\n     (or (ana-api/current-state) (ana-api/empty-state opts)) src opts))\n  ([state src opts]\n   (ana-api/with-state state\n     (binding [ana/*cljs-warning-handlers* (:warning-handlers opts ana/*cljs-warning-handlers*)]\n       (closure/src-file->goog-require src opts)))))",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r1.12.38",
                                                             :filename "src/main/clojure/cljs/build/api.clj",
                                                             :lines [78
                                                                     88]},
                                                    :full-name "cljs.build.api/src-file->goog-require",
                                                    :docstring "Given a ClojureScript or Google Closure style JavaScript source file return\nthe goog.require statement for it."},
           "cljs.repl.node/write" {:ns "cljs.repl.node",
                                   :name "write",
                                   :signature ["[out js]"],
                                   :name-encode "write",
                                   :history [["+" "0.0-2629"]],
                                   :type "function",
                                   :full-name-encode "cljs.repl.node/write",
                                   :source {:code "(defn write [^BufferedWriter out ^String js]\n  (.write out js)\n  (.write out (int 0)) ;; terminator\n  (.flush out))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/clojure/cljs/repl/node.clj",
                                            :lines [46 49]},
                                   :full-name "cljs.repl.node/write"},
           "cljs.repl/read-source-map" {:ns "cljs.repl",
                                        :name "read-source-map",
                                        :signature ["[f]"],
                                        :name-encode "read-source-map",
                                        :history [["+" "0.0-2814"]],
                                        :type "function",
                                        :full-name-encode "cljs.repl/read-source-map",
                                        :source {:code "(defn read-source-map\n  [f]\n  (when-let [smf (util/file-or-resource (str f \".map\"))]\n    (let [ns (if (= f \"cljs/core.aot.js\")\n               'cljs.core\n               (some-> (js-src->cljs-src f) ana/parse-ns :ns))]\n      (when ns\n        (as-> @env/*compiler* compiler-env\n          (let [t (util/last-modified smf)]\n            (if (or (and (= ns 'cljs.core)\n                         (nil? (get-in compiler-env [::source-maps ns])))\n                    (and (not= ns 'cljs.core)\n                         (> t (get-in compiler-env [::source-maps ns :last-modified] 0))))\n              (swap! env/*compiler* assoc-in [::source-maps ns]\n                {:last-modified t\n                 :source-map (sm/decode (json/read-str (slurp smf) :key-fn keyword))})\n              compiler-env))\n          (get-in compiler-env [::source-maps ns :source-map]))))))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/clojure/cljs/repl.cljc",
                                                 :lines [275 293]},
                                        :full-name "cljs.repl/read-source-map",
                                        :docstring "Return the source map for the JavaScript source file."},
           "cljs.core/set-entries-iterator" {:ns "cljs.core",
                                             :name "set-entries-iterator",
                                             :signature ["[coll]"],
                                             :name-encode "set-entries-iterator",
                                             :history [["+"
                                                        "0.0-2268"]
                                                       ["-"
                                                        "0.0-2371"]],
                                             :type "function",
                                             :full-name-encode "cljs.core/set-entries-iterator",
                                             :source {:code "(defn set-entries-iterator [coll]\n  (SetEntriesIterator. (seq coll)))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r2356",
                                                      :filename "src/cljs/cljs/core.cljs",
                                                      :lines [4896
                                                              4897]},
                                             :full-name "cljs.core/set-entries-iterator",
                                             :removed {:in "0.0-2371",
                                                       :last-seen "0.0-2356"}},
           "clojure.browser.repl/send-result" {:ns "clojure.browser.repl",
                                               :name "send-result",
                                               :signature ["[connection url data]"],
                                               :name-encode "send-result",
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "clojure.browser.repl/send-result",
                                               :source {:code "(defn send-result [connection url data]\n  (net/transmit connection url \"POST\" data nil 0))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.12.38",
                                                        :filename "src/main/cljs/clojure/browser/repl.cljs",
                                                        :lines [79 80]},
                                               :full-name "clojure.browser.repl/send-result"},
           "cljs.js/with-state" {:ns "cljs.js",
                                 :name "with-state",
                                 :signature ["[state & body]"],
                                 :name-encode "with-state",
                                 :history [["+" "1.7.10"]],
                                 :type "macro",
                                 :full-name-encode "cljs.js/with-state",
                                 :source {:code "(defmacro with-state\n  [state & body]\n  `(menv/with-compiler-env ~state\n     ~@body))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/js.clj",
                                          :lines [15 18]},
                                 :full-name "cljs.js/with-state"},
           "clojure.walk/keywordize-keys" {:ns "clojure.walk",
                                           :name "keywordize-keys",
                                           :signature ["[m]"],
                                           :name-encode "keywordize-keys",
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "clojure.walk/keywordize-keys",
                                           :source {:code "(defn keywordize-keys\n  {:added \"1.1\"}\n  [m]\n  (let [f (fn [[k v]] (if (string? k) [(keyword k) v] [k v]))]\n    ;; only apply to maps\n    (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/cljs/clojure/walk.cljs",
                                                    :lines [68 74]},
                                           :full-name "clojure.walk/keywordize-keys",
                                           :docstring "Recursively transforms all map keys from strings to keywords."},
           "cljs.pprint/*print-miser-width*" {:ns "cljs.pprint",
                                              :name "*print-miser-width*",
                                              :name-encode "STARprint-miser-widthSTAR",
                                              :history [["+"
                                                         "0.0-3255"]],
                                              :type "dynamic var",
                                              :full-name-encode "cljs.pprint/STARprint-miser-widthSTAR",
                                              :source {:code "(def ^{:added \"1.2\", :dynamic true} *print-miser-width* 40)",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.12.38",
                                                       :filename "src/main/cljs/cljs/pprint.cljs",
                                                       :lines [633
                                                               638]},
                                              :full-name "cljs.pprint/*print-miser-width*",
                                              :docstring "The column at which to enter miser style. Depending on the dispatch table,\nmiser style add newlines in more places to try to keep lines short allowing for further\nlevels of nesting."},
           "cljs.core/entries-iterator" {:ns "cljs.core",
                                         :name "entries-iterator",
                                         :signature ["[coll]"],
                                         :name-encode "entries-iterator",
                                         :history [["+" "0.0-2268"]
                                                   ["-" "0.0-2371"]],
                                         :type "function",
                                         :full-name-encode "cljs.core/entries-iterator",
                                         :source {:code "(defn entries-iterator [coll]\n  (EntriesIterator. (seq coll)))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2356",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [4883 4884]},
                                         :full-name "cljs.core/entries-iterator",
                                         :removed {:in "0.0-2371",
                                                   :last-seen "0.0-2356"}},
           "closure-warnings/unknown-defines" {:ns "closure-warnings",
                                               :name "unknown-defines",
                                               :name-encode "unknown-defines",
                                               :type "warning",
                                               :full-name-encode "closure-warnings/unknown-defines",
                                               :full-name "closure-warnings/unknown-defines",
                                               :history [["+"
                                                          "0.0-2120"]]},
           "cljs.analyzer.api/empty-env" {:ns "cljs.analyzer.api",
                                          :name "empty-env",
                                          :signature ["[]"],
                                          :name-encode "empty-env",
                                          :history [["+" "0.0-3208"]],
                                          :type "function",
                                          :full-name-encode "cljs.analyzer.api/empty-env",
                                          :source {:code "(defn empty-env\n  []\n  (ana/empty-env))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/clojure/cljs/analyzer/api.cljc",
                                                   :lines [57 60]},
                                          :full-name "cljs.analyzer.api/empty-env",
                                          :docstring "Creates an empty analysis environment."},
           "cljs.build.api/add-package-jsons" {:ns "cljs.build.api",
                                               :name "add-package-jsons",
                                               :signature ["[deps]"],
                                               :name-encode "add-package-jsons",
                                               :history [["+"
                                                          "1.9.456"]
                                                         ["-"
                                                          "1.9.473"]],
                                               :type "function",
                                               :full-name-encode "cljs.build.api/add-package-jsons",
                                               :source {:code "(defn add-package-jsons\n  [deps]\n  (let [checked (atom #{})]\n    (reduce\n      (fn [ret {:keys [file] :as dep}]\n        (let [f (.getParentFile (io/file file))\n              path (.getAbsolutePath f)]\n          (if-not (contains? @checked path)\n            (let [f' (io/file f \"package.json\")]\n              (swap! checked conj path)\n              (if (.exists f')\n                (conj ret dep\n                  {:file (.getAbsolutePath f')\n                   :module-type :commonjs})\n                (conj ret dep)))\n            (conj ret dep))))\n      [] deps)))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.9.456",
                                                        :filename "src/main/clojure/cljs/build/api.clj",
                                                        :lines [222
                                                                239]},
                                               :full-name "cljs.build.api/add-package-jsons",
                                               :docstring "EXPERIMENTAL: see node-module-deps",
                                               :removed {:in "1.9.473",
                                                         :last-seen "1.9.456"}},
           "cljs.spec.alpha/or" {:ns "cljs.spec.alpha",
                                 :name "or",
                                 :signature ["[& key-pred-forms]"],
                                 :name-encode "or",
                                 :history [["+" "1.9.542"]],
                                 :type "macro",
                                 :full-name-encode "cljs.spec.alpha/or",
                                 :source {:code "(defmacro or\n  [& key-pred-forms]\n  (let [pairs (partition 2 key-pred-forms)\n        keys (mapv first pairs)\n        pred-forms (mapv second pairs)\n        pf (mapv #(res &env %) pred-forms)]\n    (clojure.core/assert (clojure.core/and (even? (count key-pred-forms)) (every? keyword? keys)) \"spec/or expects k1 p1 k2 p2..., where ks are keywords\")\n    `(or-spec-impl ~keys '~pf ~pred-forms nil)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/spec/alpha.cljc",
                                          :lines [197 212]},
                                 :full-name "cljs.spec.alpha/or",
                                 :docstring "Takes key+pred pairs, e.g.\n\n(s/or :even even? :small #(< % 42))\n\nReturns a destructuring spec that returns a map entry containing the\nkey of the first matching pred and the corresponding value. Thus the\n'key' and 'val' functions can be used to refer generically to the\ncomponents of the tagged return."},
           "cljs.core/reduced" {:ns "cljs.core",
                                :name "reduced",
                                :signature ["[x]"],
                                :name-encode "reduced",
                                :history [["+" "0.0-1211"]],
                                :type "function",
                                :full-name-encode "cljs.core/reduced",
                                :source {:code "(defn reduced\n  [x]\n  (Reduced. x))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [1477 1480]},
                                :full-name "cljs.core/reduced",
                                :docstring "Wraps x in a way such that a reduce will terminate with the value x"},
           "cljs.reader/read-string*" {:ns "cljs.reader",
                                       :name "read-string*",
                                       :signature ["[reader _]"],
                                       :name-encode "read-stringSTAR",
                                       :history [["+" "0.0-1236"]
                                                 ["-" "1.9.854"]],
                                       :type "function",
                                       :full-name-encode "cljs.reader/read-stringSTAR",
                                       :source {:code "(defn read-string*\n  [reader _]\n  (loop [buffer (gstring/StringBuffer.)\n         ch (read-char reader)]\n    (cond\n     (nil? ch) (reader-error reader \"EOF while reading\")\n     (identical? \"\\\\\" ch) (recur (do (.append buffer (escape-char buffer reader)) buffer)\n                        (read-char reader))\n     (identical? \\\" ch) (. buffer (toString))\n     :default (recur (do (.append buffer ch) buffer) (read-char reader)))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.9.671",
                                                :filename "src/main/cljs/cljs/reader.cljs",
                                                :lines [305 314]},
                                       :full-name "cljs.reader/read-string*",
                                       :removed {:in "1.9.854",
                                                 :last-seen "1.9.671"}},
           "syntax/ns-map" {:syntax-equiv {:edn-url nil, :clj-url nil},
                            :ns "syntax",
                            :name "ns-map",
                            :name-encode "ns-map",
                            :history [["+" "1.9.183"]],
                            :type "syntax",
                            :full-name-encode "syntax/ns-map",
                            :extra-sources ({:code "(defn- read-namespaced-map\n  [rdr _ opts pending-forms]\n  (let [[start-line start-column] (starting-line-col-info rdr)\n        token (read-token rdr :namespaced-map (read-char rdr))]\n    (if-let [ns (cond\n                  (= token \":\")\n                  (ns-name *ns*)\n\n                  (= \\: (first token))\n                  (some-> token (subs 1) parse-symbol second' symbol resolve-ns ns-name)\n\n                  :else\n                  (some-> token parse-symbol second'))]\n\n      (let [ch (read-past whitespace? rdr)]\n        (if (identical? ch \\{)\n          (let [items (read-delimited :namespaced-map \\} rdr opts pending-forms)\n                [end-line end-column] (ending-line-col-info rdr)]\n            (when (odd? (count items))\n              (err/throw-odd-map rdr nil nil items))\n            (let [keys (take-nth 2 items)\n                  vals (take-nth 2 (rest items))]\n              (with-meta\n                (RT/map (to-array (mapcat list (namespace-keys (str ns) keys) vals)))\n                (when start-line\n                  (merge\n                   (when-let [file (get-file-name rdr)]\n                     {:file file})\n                   {:line start-line\n                    :column start-column\n                    :end-line end-line\n                    :end-column end-column})))))\n          (err/throw-ns-map-no-map rdr token)))\n      (err/throw-bad-ns rdr token))))",
                                             :title "Reader code",
                                             :repo "tools.reader",
                                             :tag "v1.3.6",
                                             :filename "src/main/clojure/clojure/tools/reader.clj",
                                             :lines [753 786]}
                                            {:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    \\? read-cond\n    \\: read-namespaced-map\n    \\# read-symbolic-value\n    nil))",
                                             :title "Reader table",
                                             :repo "tools.reader",
                                             :tag "v1.3.6",
                                             :filename "src/main/clojure/clojure/tools/reader.clj",
                                             :lines [809 823]}),
                            :full-name "syntax/ns-map"},
           "cljs.core/ArrayNodeIterator" {:ns "cljs.core",
                                          :name "ArrayNodeIterator",
                                          :signature ["[arr i next-iter]"],
                                          :name-encode "ArrayNodeIterator",
                                          :history [["+" "1.7.28"]],
                                          :type "type",
                                          :full-name-encode "cljs.core/ArrayNodeIterator",
                                          :source {:code "(deftype ArrayNodeIterator [arr ^:mutable i ^:mutable next-iter]\n  Object\n  (hasNext [this]\n    (let [len (alength arr)]\n      (loop []\n        (if-not (and  (some? next-iter) ^boolean (.hasNext next-iter))\n          (if (< i len)\n            (let [node (aget arr i)]\n              (set! i (inc i))\n              (when (some? node)\n                (set! next-iter (-iterator node)))\n              (recur))\n            false)\n          true))))\n  (next [this]\n    (if ^boolean (.hasNext this)\n      (.next next-iter)\n      (throw (js/Error. \"No such element\"))))\n  (remove [_] (js/Error. \"Unsupported operation\")))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/cljs/cljs/core.cljs",
                                                   :lines [7676 7694]},
                                          :full-name "cljs.core/ArrayNodeIterator"},
           "cljs.core/ChunkedCons" {:protocols #{"IChunkedNext"
                                                 "ISeqable"
                                                 "IMeta"
                                                 "IWithMeta"
                                                 "IEmptyableCollection"
                                                 "ISequential"
                                                 "ISeq"
                                                 "ICollection"
                                                 "IHash"
                                                 "ASeq"
                                                 "IPrintWithWriter"
                                                 "IChunkedSeq"
                                                 "INext"
                                                 "IEquiv"},
                                    :ns "cljs.core",
                                    :name "ChunkedCons",
                                    :signature ["[chunk more meta __hash]"],
                                    :name-encode "ChunkedCons",
                                    :history [["+" "0.0-1424"]],
                                    :type "type",
                                    :full-name-encode "cljs.core/ChunkedCons",
                                    :source {:code "(deftype ChunkedCons [chunk more meta ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (ChunkedCons. chunk more new-meta __hash)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ASeq\n  ISeq\n  (-first [coll] (-nth chunk 0))\n  (-rest [coll]\n    (if (> (-count chunk) 1)\n      (ChunkedCons. (-drop-first chunk) more nil nil)\n      (if (nil? more)\n        ()\n        more)))\n\n  INext\n  (-next [coll]\n    (if (> (-count chunk) 1)\n      (ChunkedCons. (-drop-first chunk) more nil nil)\n      (when-not (nil? more)\n        (-seq more))))\n\n  IChunkedSeq\n  (-chunked-first [coll] chunk)\n  (-chunked-rest [coll]\n    (if (nil? more)\n      ()\n      more))\n\n  IChunkedNext\n  (-chunked-next [coll]\n    (if (nil? more)\n      nil\n      more))\n\n  ICollection\n  (-conj [this o]\n    (cons o this))\n\n  IEmptyableCollection\n  (-empty [coll] (.-EMPTY List))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [3638 3707]},
                                    :full-name "cljs.core/ChunkedCons"},
           "cljs.core/parse-long" {:return-type number,
                                   :ns "cljs.core",
                                   :name "parse-long",
                                   :signature ["[s]"],
                                   :name-encode "parse-long",
                                   :history [["+" "1.11.50"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/parse-long",
                                   :source {:code "(defn ^number parse-long\n  [s]\n  (if (string? s)\n    (and (re-matches #\"[+-]?\\d+\" s)\n         (let [i (js/parseInt s)]\n           (when (and (<= i js/Number.MAX_SAFE_INTEGER)\n                      (>= i js/Number.MIN_SAFE_INTEGER))\n             i)))\n    (throw (js/Error. (parsing-err s)))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [12240 12250]},
                                   :full-name "cljs.core/parse-long",
                                   :docstring "Parse string of decimal digits with optional leading -/+ and return an\ninteger value, or nil if parse fails"},
           "cljs.core/derive" {:ns "cljs.core",
                               :name "derive",
                               :signature ["[tag parent]"
                                           "[h tag parent]"],
                               :name-encode "derive",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/derive",
                               :source {:code "(defn derive\n  ([tag parent]\n   (assert (namespace parent))\n   ;; (assert (or (class? tag) (and (instance? cljs.core.Named tag) (namespace tag))))\n   (swap-global-hierarchy! derive tag parent) nil)\n  ([h tag parent]\n   (assert (not= tag parent))\n   ;; (assert (or (class? tag) (instance? clojure.lang.Named tag)))\n   ;; (assert (instance? clojure.lang.INamed tag))\n   ;; (assert (instance? clojure.lang.INamed parent))\n   (let [tp (:parents h)\n         td (:descendants h)\n         ta (:ancestors h)\n         tf (fn [m source sources target targets]\n              (reduce (fn [ret k]\n                        (assoc ret k\n                               (reduce conj (get targets k #{}) (cons target (targets target)))))\n                      m (cons source (sources source))))]\n     (or\n      (when-not (contains? (tp tag) parent)\n        (when (contains? (ta tag) parent)\n          (throw (js/Error. (str tag \"already has\" parent \"as ancestor\"))))\n        (when (contains? (ta parent) tag)\n          (throw (js/Error. (str \"Cyclic derivation:\" parent \"has\" tag \"as ancestor\"))))\n        {:parents (assoc (:parents h) tag (conj (get tp tag #{}) parent))\n         :ancestors (tf (:ancestors h) tag td parent ta)\n         :descendants (tf (:descendants h) parent ta tag td)})\n      h))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [11362 11394]},
                               :full-name "cljs.core/derive",
                               :docstring "Establishes a parent/child relationship between parent and\ntag. Parent must be a namespace-qualified symbol or keyword and\nchild can be either a namespace-qualified symbol or keyword or a\nclass. h must be a hierarchy obtained from make-hierarchy, if not\nsupplied defaults to, and modifies, the global hierarchy."},
           "clojure.zip/zipper" {:ns "clojure.zip",
                                 :name "zipper",
                                 :signature ["[branch? children make-node root]"],
                                 :name-encode "zipper",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "clojure.zip/zipper",
                                 :source {:code "(defn zipper\n  [branch? children make-node root]\n    ^{:zip/branch? branch? :zip/children children :zip/make-node make-node}\n    [root nil])",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/clojure/zip.cljs",
                                          :lines [18 32]},
                                 :full-name "clojure.zip/zipper",
                                 :docstring "Creates a new zipper structure. \n\nbranch? is a fn that, given a node, returns true if can have\nchildren, even if it currently doesn't.\n\nchildren is a fn that, given a branch node, returns a seq of its\nchildren.\n\nmake-node is a fn that, given an existing node and a seq of\nchildren, returns a new branch node with the supplied children.\nroot is the root node."},
           "cljs.spec.alpha/explain-data*" {:ns "cljs.spec.alpha",
                                            :name "explain-data*",
                                            :signature ["[spec path via in x]"],
                                            :name-encode "explain-dataSTAR",
                                            :history [["+" "1.9.542"]],
                                            :type "function",
                                            :full-name-encode "cljs.spec.alpha/explain-dataSTAR",
                                            :source {:code "(defn explain-data* [spec path via in x]\n  (when-let [probs (explain* (specize spec) path via in x)]\n    (when-not (empty? probs)\n      {::problems probs\n       ::spec spec\n       ::value x})))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/cljs/cljs/spec/alpha.cljs",
                                                     :lines [219 224]},
                                            :full-name "cljs.spec.alpha/explain-data*"},
           "cljs.test/empty-env" {:ns "cljs.test",
                                  :name "empty-env",
                                  :signature ["[]" "[reporter]"],
                                  :name-encode "empty-env",
                                  :history [["+" "0.0-2496"]],
                                  :type "function",
                                  :full-name-encode "cljs.test/empty-env",
                                  :source {:code "(defn empty-env\n  ([] (empty-env ::default))\n  ([reporter]\n   (cond-> {:report-counters {:test 0 :pass 0 :fail 0 :error 0}\n            :testing-vars ()\n            :testing-contexts ()\n            :formatter pr-str\n            :reporter reporter}\n     (= ::pprint reporter) (assoc :reporter ::default\n                             :formatter pprint/pprint))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/test.cljs",
                                           :lines [252 267]},
                                  :full-name "cljs.test/empty-env",
                                  :docstring "Generates a testing environment with a reporter.\n(empty-env) - uses the :cljs.test/default reporter.\n(empty-env :cljs.test/pprint) - pretty prints all data structures. \n(empty-env reporter) - uses a reporter of your choosing.\n\nTo create your own reporter see cljs.test/report"},
           "clojure.core.reducers/mapcat" {:ns "clojure.core.reducers",
                                           :name "mapcat",
                                           :signature ["[f]"
                                                       "[f coll]"],
                                           :name-encode "mapcat",
                                           :history [["+" "0.0-1236"]],
                                           :type "function",
                                           :full-name-encode "clojure.core.reducers/mapcat",
                                           :source {:code "(defcurried mapcat\n  {}\n  [f coll]\n  (folder coll\n   (fn [f1]\n     (rfn [f1 k]\n          ([ret k v]\n             (reduce f1 ret (f k v)))))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/cljs/clojure/core/reducers.cljs",
                                                    :lines [106 115]},
                                           :full-name "clojure.core.reducers/mapcat",
                                           :docstring "Applies f to every value in the reduction of coll, concatenating the result\n  colls of (f val). Foldable."},
           "cljs.spec/inst-in" {:ns "cljs.spec",
                                :name "inst-in",
                                :signature ["[start end]"],
                                :name-encode "inst-in",
                                :history [["+" "1.9.75"]
                                          ["-" "1.9.542"]],
                                :type "macro",
                                :full-name-encode "cljs.spec/inst-in",
                                :source {:code "(defmacro inst-in\n  [start end]\n  `(let [st# (cljs.core/inst-ms ~start)\n         et# (cljs.core/inst-ms ~end)\n         mkdate# (fn [d#] (js/Date. d#))]\n     (spec (and cljs.core/inst? #(inst-in-range? ~start ~end %))\n       :gen (fn []\n              (gen/fmap mkdate#\n                (gen/large-integer* {:min st# :max et#}))))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.9.521",
                                         :filename "src/main/cljs/cljs/spec.cljc",
                                         :lines [462 472]},
                                :full-name "cljs.spec/inst-in",
                                :docstring "Returns a spec that validates insts in the range from start\n(inclusive) to end (exclusive).",
                                :removed {:in "1.9.542",
                                          :last-seen "1.9.521"}},
           "clojure.zip/remove" {:ns "clojure.zip",
                                 :name "remove",
                                 :signature ["[loc]"],
                                 :name-encode "remove",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "clojure.zip/remove",
                                 :source {:code "(defn remove\n  [loc]\n    (let [[node {l :l, ppath :ppath, pnodes :pnodes, rs :r, :as path}] loc]\n      (if (nil? path)\n        (throw \"Remove at top\")\n        (if (pos? (count l))\n          (loop [loc (with-meta [(peek l) (assoc path :l (pop l) :changed? true)] (meta loc))]\n            (if-let [child (and (branch? loc) (down loc))]\n              (recur (rightmost child))\n              loc))\n          (with-meta [(make-node loc (peek pnodes) rs) \n                      (and ppath (assoc ppath :changed? true))]\n                     (meta loc))))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/clojure/zip.cljs",
                                          :lines [237 251]},
                                 :full-name "clojure.zip/remove",
                                 :docstring "Removes the node at loc, returning the loc that would have preceded\nit in a depth-first walk."},
           "syntax/var" {:syntax-equiv {:edn-url nil, :clj-url nil},
                         :ns "syntax",
                         :name "var",
                         :name-encode "var",
                         :history [["+" "0.0-1853"]],
                         :type "syntax",
                         :full-name-encode "syntax/var",
                         :extra-sources ({:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    \\? read-cond\n    \\: read-namespaced-map\n    \\# read-symbolic-value\n    nil))",
                                          :title "Reader table",
                                          :repo "tools.reader",
                                          :tag "v1.3.6",
                                          :filename "src/main/clojure/clojure/tools/reader.clj",
                                          :lines [809 823]}),
                         :full-name "syntax/var"},
           "cljs.repl.browser/handle-post" {:ns "cljs.repl.browser",
                                            :name "handle-post",
                                            :signature ["[m _ _]"],
                                            :name-encode "handle-post",
                                            :history [["+" "0.0-927"]],
                                            :type "multimethod",
                                            :full-name-encode "cljs.repl.browser/handle-post",
                                            :source {:code "(defmulti handle-post (fn [m _ _ ] (:type m)))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/clojure/cljs/repl/browser.clj",
                                                     :lines [252]},
                                            :extra-sources ({:code "(defmethod handle-post :ready [_ conn _]\n  (send-via es ordering (fn [_] {:expecting nil :fns {}}))\n  ;; browser refresh, reset connq\n  (locking server/lock\n    (.clear server/connq))\n  (send-for-eval conn\n    (binding [ana/*cljs-warnings*\n              (assoc ana/*cljs-warnings*\n                :undeclared-var false)]\n      (cljsc/-compile\n       '[(set! *print-fn* clojure.browser.repl/repl-print)\n         (set! *print-err-fn* clojure.browser.repl/repl-print)\n         (set! *print-newline* true)\n         (when (pos? (count clojure.browser.repl/print-queue))\n           (clojure.browser.repl/flush-print-queue!\n             @clojure.browser.repl/xpc-connection))] {}))\n    identity))",
                                                             :title "Dispatch method",
                                                             :repo "clojurescript",
                                                             :tag "r1.12.38",
                                                             :filename "src/main/clojure/cljs/repl/browser.clj",
                                                             :lines [256
                                                                     272]}
                                                            {:code "(defmethod handle-post :print [{:keys [repl content order]} conn _]\n  (constrain-order order\n    (fn []\n      (binding [*out* (or (and repl (.get outs repl)) *out*)]\n        (print (read-string content))\n        (.flush *out*))))\n  (server/send-and-close conn 200 \"ignore__\"))",
                                                             :title "Dispatch method",
                                                             :repo "clojurescript",
                                                             :tag "r1.12.38",
                                                             :filename "src/main/clojure/cljs/repl/browser.clj",
                                                             :lines [293
                                                                     299]}
                                                            {:code "(defmethod handle-post :result [{:keys [content order]} conn _]\n  (constrain-order order\n    (fn []\n      (return-value content)\n      (server/set-connection conn))))",
                                                             :title "Dispatch method",
                                                             :repo "clojurescript",
                                                             :tag "r1.12.38",
                                                             :filename "src/main/clojure/cljs/repl/browser.clj",
                                                             :lines [301
                                                                     305]}),
                                            :full-name "cljs.repl.browser/handle-post"},
           "cljs.repl/find-doc" {:ns "cljs.repl",
                                 :name "find-doc",
                                 :signature ["[re-string-or-pattern]"],
                                 :name-encode "find-doc",
                                 :history [["+" "0.0-2985"]],
                                 :type "macro",
                                 :full-name-encode "cljs.repl/find-doc",
                                 :source {:code "(defmacro find-doc\n  [re-string-or-pattern]\n  (let [re (re-pattern re-string-or-pattern)\n        ms (concat\n             (mapcat\n               (fn [ns]\n                 (map\n                   (fn [m]\n                     (update-in (select-keys m [:ns :name :doc :forms :arglists :macro :url])\n                       [:name] #(if-not (nil? %) (clojure.core/name %) %)))\n                   (sort-by :name (vals (ana-api/ns-interns ns)))))\n               (ana-api/all-ns))\n             (map #(select-keys (ana-api/find-ns %) [:name :doc]) (ana-api/all-ns))\n             (map special-doc (keys special-doc-map)))\n        ms (for [m ms\n                 :when (and (:doc m)\n                            (or (re-find (re-matcher re (:doc m)))\n                                (re-find (re-matcher re (str (:name m))))))]\n             m)]\n    `(doseq [m# (quote ~ms)]\n       (cljs.repl/print-doc m#))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/clojure/cljs/repl.cljc",
                                          :lines [1471 1493]},
                                 :full-name "cljs.repl/find-doc",
                                 :docstring "Prints documentation for any var whose documentation or name\ncontains a match for re-string-or-pattern"},
           "repl-options/source-map-inline" {:ns "repl-options",
                                             :name "source-map-inline",
                                             :name-encode "source-map-inline",
                                             :type "option",
                                             :full-name-encode "repl-options/source-map-inline",
                                             :full-name "repl-options/source-map-inline",
                                             :history [["+"
                                                        "0.0-2911"]]},
           "cljs.spec.impl.gen/not-empty" {:ns "cljs.spec.impl.gen",
                                           :name "not-empty",
                                           :signature ["[& args]"],
                                           :name-encode "not-empty",
                                           :history [["+" "1.9.14"]
                                                     ["-" "1.9.542"]],
                                           :type "function",
                                           :full-name-encode "cljs.spec.impl.gen/not-empty",
                                           :source {:code "(lazy-combinators hash-map list map not-empty set vector vector-distinct fmap elements\n  bind choose one-of such-that tuple sample return\n  large-integer* double* frequency)",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.9.521",
                                                    :filename "src/main/cljs/cljs/spec/impl/gen.cljs",
                                                    :lines [69 71]},
                                           :full-name "cljs.spec.impl.gen/not-empty",
                                           :docstring "Lazy loaded version of clojure.test.check.generators/not-empty",
                                           :removed {:in "1.9.542",
                                                     :last-seen "1.9.521"}},
           "cljs.core/find" {:ns "cljs.core",
                             :name "find",
                             :signature ["[coll k]"],
                             :name-encode "find",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/find",
                             :source {:code "(defn find\n  [coll k]\n  (if (ifind? coll)\n    (-find coll k)\n    (when (and (not (nil? coll))\n            (associative? coll)\n            (contains? coll k))\n      (MapEntry. k (get coll k) nil))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [2430 2438]},
                             :full-name "cljs.core/find",
                             :docstring "Returns the map entry for key, or nil if key not present."},
           "cljs.repl.node/repl-env*" {:ns "cljs.repl.node",
                                       :name "repl-env*",
                                       :signature ["[options]"],
                                       :name-encode "repl-envSTAR",
                                       :history [["+" "0.0-2629"]],
                                       :type "function",
                                       :full-name-encode "cljs.repl.node/repl-envSTAR",
                                       :source {:code "(defn repl-env* [options]\n  (let [{:keys [host port path debug-port]}\n        (merge\n          {:host \"localhost\"\n           :port (+ 49000 (rand-int 10000))}\n          options)]\n    (assoc\n      (NodeEnv. host port path\n        (atom nil) (atom nil) (atom {:listeners 0}))\n      :debug-port debug-port)))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/clojure/cljs/repl/node.clj",
                                                :lines [235 244]},
                                       :full-name "cljs.repl.node/repl-env*"},
           "cljs.core/hash-set" {:ns "cljs.core",
                                 :name "hash-set",
                                 :signature ["[]" "[& keys]"],
                                 :name-encode "hash-set",
                                 :history [["+" "0.0-1443"]],
                                 :type "function/macro",
                                 :full-name-encode "cljs.core/hash-set",
                                 :source {:code "(defn hash-set\n  ([] #{})\n  ([& keys] (set keys)))",
                                          :title "Function code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [9670 9674]},
                                 :extra-sources [{:code "(core/defmacro hash-set\n  ([] `(.-EMPTY cljs.core/PersistentHashSet))\n  ([& xs]\n    (if (core/and (core/<= (count xs) 8)\n                  (every? #(= (:op (cljs.analyzer/unwrap-quote %)) :const)\n                    (map #(cljs.analyzer/no-warn (cljs.analyzer/analyze &env %)) xs))\n                  (= (count (into #{} xs)) (count xs)))\n      `(cljs.core/PersistentHashSet. nil\n         (cljs.core/PersistentArrayMap. nil ~(count xs) (array ~@(interleave xs (repeat nil))) nil)\n         nil)\n      (vary-meta\n        `(.createAsIfByAssoc cljs.core/PersistentHashSet (array ~@xs))\n        assoc :tag 'cljs.core/PersistentHashSet))))",
                                                  :title "Macro code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/clojure/cljs/core.cljc",
                                                  :lines [2662 2674]}],
                                 :full-name "cljs.core/hash-set",
                                 :docstring "Returns a new hash set with supplied keys.  Any equal keys are\nhandled as if by repeated uses of conj."},
           "cljs.core/*print-dup*" {:ns "cljs.core",
                                    :name "*print-dup*",
                                    :name-encode "STARprint-dupSTAR",
                                    :history [["+" "0.0-927"]],
                                    :type "dynamic var",
                                    :full-name-encode "cljs.core/STARprint-dupSTAR",
                                    :source {:code "(def\n  ^{:dynamic true}\n  *print-dup* false)",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.12.38",
                                             :filename "src/main/cljs/cljs/core.cljs",
                                             :lines [132 138]},
                                    :full-name "cljs.core/*print-dup*",
                                    :docstring "When set to logical true, objects will be printed in a way that preserves\ntheir type when read in later.\n\nDefaults to false."},
           "closure-warnings/underscore" {:ns "closure-warnings",
                                          :name "underscore",
                                          :name-encode "underscore",
                                          :type "warning",
                                          :full-name-encode "closure-warnings/underscore",
                                          :full-name "closure-warnings/underscore",
                                          :history [["+" "1.9.473"]]},
           "cljs.analyzer.api/analyze" {:ns "cljs.analyzer.api",
                                        :name "analyze",
                                        :signature ["[env form]"
                                                    "[env form name]"
                                                    "[env form name opts]"
                                                    "[state env form name opts]"],
                                        :name-encode "analyze",
                                        :history [["+" "0.0-3208"]],
                                        :type "function",
                                        :full-name-encode "cljs.analyzer.api/analyze",
                                        :source {:code "   (defn analyze\n     ([env form] (analyze env form nil))\n     ([env form name] (analyze env form name nil))\n     ([env form name opts]\n      (analyze (or (current-state) (empty-state opts)) env form name opts))\n     ([state env form name opts]\n      (env/with-compiler-env state\n        (binding [ana/*cljs-warning-handlers* (:warning-handlers opts ana/*cljs-warning-handlers*)]\n          (ana/analyze env form name opts)))))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/clojure/cljs/analyzer/api.cljc",
                                                 :lines [126 141]},
                                        :full-name "cljs.analyzer.api/analyze",
                                        :docstring "Given an environment, a map containing {:locals (mapping of names to bindings), :context\n  (one of :statement, :expr, :return), :ns (a symbol naming the\n  compilation ns)}, and form, returns an expression object (a map\n  containing at least :form, :op and :env keys). If expr has any (immediately)\n  nested exprs, must have :children entry. This must be a vector of keywords naming\n  the immediately nested fields mapped to an expr or vector of exprs. This will\n  facilitate code walking without knowing the details of the op set."},
           "closure-warnings/late-provide" {:ns "closure-warnings",
                                            :name "late-provide",
                                            :name-encode "late-provide",
                                            :type "warning",
                                            :full-name-encode "closure-warnings/late-provide",
                                            :full-name "closure-warnings/late-provide",
                                            :history [["+" "1.9.473"]]},
           "cljs.spec/explain-data" {:ns "cljs.spec",
                                     :name "explain-data",
                                     :signature ["[spec x]"],
                                     :name-encode "explain-data",
                                     :history [["+" "1.9.14"]
                                               ["-" "1.9.542"]],
                                     :type "function",
                                     :full-name-encode "cljs.spec/explain-data",
                                     :source {:code "(defn explain-data\n  [spec x]\n  (explain-data* spec [] (if-let [name (spec-name spec)] [name] []) [] x))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.9.521",
                                              :filename "src/main/cljs/cljs/spec.cljs",
                                              :lines [205 212]},
                                     :full-name "cljs.spec/explain-data",
                                     :docstring "Given a spec and a value x which ought to conform, returns nil if x\nconforms, else a map with at least the key ::problems whose value is\na collection of problem-maps, where problem-map has at least :path :pred and :val\nkeys describing the predicate and the value that failed at that\npath.",
                                     :removed {:in "1.9.542",
                                               :last-seen "1.9.521"}},
           "cljs.core/set-from-indexed-seq" {:ns "cljs.core",
                                             :name "set-from-indexed-seq",
                                             :signature ["[iseq]"],
                                             :name-encode "set-from-indexed-seq",
                                             :history [["+"
                                                        "0.0-1877"]],
                                             :type "function",
                                             :full-name-encode "cljs.core/set-from-indexed-seq",
                                             :source {:code "(defn set-from-indexed-seq [iseq]\n  (let [arr (.-arr iseq)\n        ret (areduce arr i ^not-native res (-as-transient #{})\n              (-conj! res (aget arr i)))]\n    (-persistent! ^not-native ret)))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.12.38",
                                                      :filename "src/main/cljs/cljs/core.cljs",
                                                      :lines [9645
                                                              9649]},
                                             :full-name "cljs.core/set-from-indexed-seq"},
           "compiler-options/closure-extra-annotations" {:ns "compiler-options",
                                                         :name "closure-extra-annotations",
                                                         :name-encode "closure-extra-annotations",
                                                         :type "option",
                                                         :full-name-encode "compiler-options/closure-extra-annotations",
                                                         :full-name "compiler-options/closure-extra-annotations",
                                                         :history [["+"
                                                                    "0.0-2814"]]},
           "cljs.core/object-array" {:ns "cljs.core",
                                     :name "object-array",
                                     :signature ["[size-or-seq]"
                                                 "[size init-val-or-seq]"],
                                     :name-encode "object-array",
                                     :history [["+" "0.0-1211"]],
                                     :type "function",
                                     :full-name-encode "cljs.core/object-array",
                                     :source {:code "(defn object-array\n  ([size-or-seq]\n     (if (number? size-or-seq)\n       (object-array size-or-seq nil)\n       (into-array size-or-seq)))\n  ([size init-val-or-seq]\n     (let [a (make-array size)]\n       (if (seq? init-val-or-seq)\n         (let [s (seq init-val-or-seq)]\n           (loop [i 0 s s]\n             (if (and s (< i size))\n               (do\n                 (aset a i (first s))\n                 (recur (inc i) (next s)))\n               a)))\n         (do\n           (dotimes [i size]\n             (aset a i init-val-or-seq))\n           a)))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/cljs/cljs/core.cljs",
                                              :lines [3822 3842]},
                                     :full-name "cljs.core/object-array",
                                     :docstring "Creates an array of objects. Does not coerce array, provided for compatibility\nwith Clojure."},
           "cljs.core/indexed?" {:ns "cljs.core",
                                 :name "indexed?",
                                 :signature ["[x]"],
                                 :name-encode "indexedQMARK",
                                 :history [["+" "0.0-1211"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/indexedQMARK",
                                 :source {:code "(defn indexed?\n  [x] (satisfies? IIndexed x))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [1568 1570]},
                                 :full-name "cljs.core/indexed?",
                                 :docstring "Returns true if coll implements nth in constant time"},
           "cljs.reader/add-data-readers" {:ns "cljs.reader",
                                           :name "add-data-readers",
                                           :signature ["[default-readers]"],
                                           :name-encode "add-data-readers",
                                           :history [["+" "1.9.456"]],
                                           :type "macro",
                                           :full-name-encode "cljs.reader/add-data-readers",
                                           :source {:code "(defmacro add-data-readers [default-readers]\n  (let [data-readers\n        (->> (get @env/*compiler* :cljs.analyzer/data-readers)\n          (map (fn [[k v]]\n                 `['~k (fn [x#] (~(vary-meta (-> v meta :sym) assoc :cljs.analyzer/no-resolve true) x#))]))\n          (into {}))]\n    `(do (merge ~default-readers ~data-readers))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/cljs/cljs/reader.clj",
                                                    :lines [12 18]},
                                           :full-name "cljs.reader/add-data-readers"},
           "cljs.core/partial" {:ns "cljs.core",
                                :name "partial",
                                :signature ["[f]"
                                            "[f arg1]"
                                            "[f arg1 arg2]"
                                            "[f arg1 arg2 arg3]"
                                            "[f arg1 arg2 arg3 & more]"],
                                :name-encode "partial",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/partial",
                                :source {:code "(defn partial\n  ([f] f)\n  ([f arg1]\n   (fn\n     ([] (f arg1))\n     ([x] (f arg1 x))\n     ([x y] (f arg1 x y))\n     ([x y z] (f arg1 x y z))\n     ([x y z & args] (apply f arg1 x y z args))))\n  ([f arg1 arg2]\n   (fn\n     ([] (f arg1 arg2))\n     ([x] (f arg1 arg2 x))\n     ([x y] (f arg1 arg2 x y))\n     ([x y z] (f arg1 arg2 x y z))\n     ([x y z & args] (apply f arg1 arg2 x y z args))))\n  ([f arg1 arg2 arg3]\n   (fn\n     ([] (f arg1 arg2 arg3))\n     ([x] (f arg1 arg2 arg3 x))\n     ([x y] (f arg1 arg2 arg3 x y))\n     ([x y z] (f arg1 arg2 arg3 x y z))\n     ([x y z & args] (apply f arg1 arg2 arg3 x y z args))))\n  ([f arg1 arg2 arg3 & more]\n   (fn [& args] (apply f arg1 arg2 arg3 (concat more args)))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [4403 4430]},
                                :full-name "cljs.core/partial",
                                :docstring "Takes a function f and fewer than the normal arguments to f, and\nreturns a fn that takes a variable number of additional args. When\ncalled, the returned function calls f with args + additional args."},
           "closure-warnings/invalid-casts" {:ns "closure-warnings",
                                             :name "invalid-casts",
                                             :name-encode "invalid-casts",
                                             :type "warning",
                                             :full-name-encode "closure-warnings/invalid-casts",
                                             :full-name "closure-warnings/invalid-casts",
                                             :history [["+"
                                                        "0.0-2120"]]},
           "cljs.repl/ex-str" {:ns "cljs.repl",
                               :name "ex-str",
                               :signature ["[{:keys [:clojure.error/phase :clojure.error/source :clojure.error/line :clojure.error/column :clojure.error/symbol :clojure.error/class :clojure.error/cause :clojure.error/spec], :as triage-data}]"],
                               :name-encode "ex-str",
                               :history [["+" "1.10.514"]],
                               :type "function",
                               :full-name-encode "cljs.repl/ex-str",
                               :source {:code "(defn ex-str\n  [{:keys [:clojure.error/phase :clojure.error/source :clojure.error/line :clojure.error/column\n           :clojure.error/symbol :clojure.error/class :clojure.error/cause :clojure.error/spec]\n    :as triage-data}]\n  (let [spec-loaded? (some? (resolve 'clojure.spec.alpha/explain-out))\n        loc (str (or source \"REPL\") \":\" (or line 1) (if column (str \":\" column) \"\"))\n        class-name (name (or class \"\"))\n        simple-class (if class (or (first (re-find #\"([^.])++$\" class-name)) class-name))\n        cause-type (if (contains? #{\"Exception\" \"RuntimeException\"} simple-class)\n                     \"\" ;; omit, not useful\n                     (str \" (\" simple-class \")\"))]\n    (case phase\n      :read-source\n      (format \"Syntax error reading source at (%s).%n%s%n\" loc cause)\n\n      :macro-syntax-check\n      (format \"Syntax error macroexpanding %sat (%s).%n%s\"\n        (if symbol (str symbol \" \") \"\")\n        loc\n        (if (and spec spec-loaded?)\n          (with-out-str\n            ((resolve 'clojure.spec.alpha/explain-out)\n             (if (= @(resolve 'clojure.spec.alpha/*explain-out*) @(resolve 'clojure.spec.alpha/explain-printer))\n                (update spec :clojure.spec.alpha/problems\n                  (fn [probs] (map #(dissoc % :in) probs)))\n                spec)))\n          (format \"%s%n\" cause)))\n\n      :macroexpansion\n      (format \"Unexpected error%s macroexpanding %sat (%s).%n%s%n\"\n        cause-type\n        (if symbol (str symbol \" \") \"\")\n        loc\n        cause)\n\n      :compile-syntax-check\n      (format \"Syntax error%s compiling %sat (%s).%n%s%n\"\n        cause-type\n        (if symbol (str symbol \" \") \"\")\n        loc\n        cause)\n\n      :compilation\n      (format \"Unexpected error%s compiling %sat (%s).%n%s%n\"\n        cause-type\n        (if symbol (str symbol \" \") \"\")\n        loc\n        cause)\n\n      :read-eval-result\n      (format \"Error reading eval result%s at %s (%s).%n%s%n\" cause-type symbol loc cause)\n\n      :print-eval-result\n      (format \"Error printing return value%s at %s (%s).%n%s%n\" cause-type symbol loc cause)\n\n      :execution\n      (if (and spec spec-loaded?)\n        (format \"Execution error - invalid arguments to %s at (%s).%n%s\"\n          symbol\n          loc\n          (with-out-str\n            ((resolve 'clojure.spec.alpha/explain-out)\n              (if (= @(resolve 'clojure.spec.alpha/*explain-out*) @(resolve 'clojure.spec.alpha/explain-printer))\n                (update spec :clojure.spec.alpha/problems\n                  (fn [probs] (map #(dissoc % :in) probs)))\n                spec))))\n        (format \"Execution error%s at %s(%s).%n%s%n\"\n          cause-type\n          (if symbol (str symbol \" \") \"\")\n          loc\n          cause)))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/clojure/cljs/repl.cljc",
                                        :lines [907 980]},
                               :full-name "cljs.repl/ex-str",
                               :docstring "Returns a string from exception data, as produced by ex-triage.\nThe first line summarizes the exception phase and location.\nThe subsequent lines describe the cause."},
           "cljs.spec/explain-out" {:ns "cljs.spec",
                                    :name "explain-out",
                                    :signature ["[ed]"],
                                    :name-encode "explain-out",
                                    :history [["+" "1.9.75"]
                                              ["-" "1.9.542"]],
                                    :type "function",
                                    :full-name-encode "cljs.spec/explain-out",
                                    :source {:code "(defn explain-out\n  [ed]\n  (*explain-out* ed))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.9.521",
                                             :filename "src/main/cljs/cljs/spec.cljs",
                                             :lines [248 252]},
                                    :full-name "cljs.spec/explain-out",
                                    :docstring "Prints explanation data (per 'explain-data') to *out* using the printer in *explain-out*,\n by default explain-printer.",
                                    :removed {:in "1.9.542",
                                              :last-seen "1.9.521"}},
           "cljs.core/keyword?" {:ns "cljs.core",
                                 :name "keyword?",
                                 :signature ["[x]"],
                                 :name-encode "keywordQMARK",
                                 :history [["+" "0.0-927"]],
                                 :type "function/macro",
                                 :full-name-encode "cljs.core/keywordQMARK",
                                 :source {:code "(defn keyword?\n  [x]\n  (instance? Keyword x))",
                                          :title "Function code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [3424 3427]},
                                 :extra-sources [{:code "(core/defmacro keyword? [x]\n  (bool-expr `(instance? Keyword ~x)))",
                                                  :title "Macro code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/clojure/cljs/core.cljc",
                                                  :lines [1016 1017]}],
                                 :full-name "cljs.core/keyword?",
                                 :docstring "Return true if x is a Keyword"},
           "cljs.repl.rhino/stacktrace" {:ns "cljs.repl.rhino",
                                         :name "stacktrace",
                                         :name-encode "stacktrace",
                                         :history [["+" "0.0-927"]
                                                   ["-" "1.10.738"]],
                                         :type "multimethod",
                                         :full-name-encode "cljs.repl.rhino/stacktrace",
                                         :source {:code "(defmulti stacktrace class)",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.10.597",
                                                  :filename "src/main/clojure/cljs/repl/rhino.clj",
                                                  :lines [53]},
                                         :extra-sources ({:code "(defmethod stacktrace :default [e]\n  (apply str\n    (interpose \"\\n\"\n      (map #(str \"        \" (.toString %))\n        (.getStackTrace e)))))",
                                                          :title "Dispatch method",
                                                          :repo "clojurescript",
                                                          :tag "r1.10.597",
                                                          :filename "src/main/clojure/cljs/repl/rhino.clj",
                                                          :lines [55
                                                                  59]}
                                                         {:code "(defmethod stacktrace RhinoException [^RhinoException e]\n  (.getScriptStackTrace e))",
                                                          :title "Dispatch method",
                                                          :repo "clojurescript",
                                                          :tag "r1.10.597",
                                                          :filename "src/main/clojure/cljs/repl/rhino.clj",
                                                          :lines [61
                                                                  62]}),
                                         :full-name "cljs.repl.rhino/stacktrace",
                                         :removed {:in "1.10.738",
                                                   :last-seen "1.10.597"}},
           "compiler-options/output-to" {:ns "compiler-options",
                                         :name "output-to",
                                         :name-encode "output-to",
                                         :type "option",
                                         :full-name-encode "compiler-options/output-to",
                                         :full-name "compiler-options/output-to",
                                         :history [["+" "0.0-971"]]},
           "cljs.math/asin" {:return-type number,
                             :ns "cljs.math",
                             :name "asin",
                             :signature ["[a]"],
                             :name-encode "asin",
                             :history [["+" "1.11.50"]],
                             :type "function",
                             :full-name-encode "cljs.math/asin",
                             :source {:code "(defn ^number asin\n  {:added \"1.11.10\"}\n  [a] (Math/asin a))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/math.cljs",
                                      :lines [103 109]},
                             :full-name "cljs.math/asin",
                             :docstring "Returns the arc sine of an angle, in the range -pi/2 to pi/2.\nIf a is ##NaN or |a|>1 => ##NaN\nIf a is zero => zero with the same sign as a\nSee: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/asin"},
           "clojure.browser.event/fire-listeners" {:ns "clojure.browser.event",
                                                   :name "fire-listeners",
                                                   :signature ["[obj type capture event]"],
                                                   :name-encode "fire-listeners",
                                                   :history [["+"
                                                              "0.0-927"]],
                                                   :type "function",
                                                   :full-name-encode "clojure.browser.event/fire-listeners",
                                                   :source {:code "(defn fire-listeners\n  [obj type capture event])",
                                                            :title "Source code",
                                                            :repo "clojurescript",
                                                            :tag "r1.12.38",
                                                            :filename "src/main/cljs/clojure/browser/event.cljs",
                                                            :lines [84
                                                                    85]},
                                                   :full-name "clojure.browser.event/fire-listeners"},
           "cljs.core/Iterator" {:ns "cljs.core",
                                 :name "Iterator",
                                 :signature ["[s]"],
                                 :name-encode "Iterator",
                                 :history [["+" "0.0-2268"]
                                           ["-" "0.0-2371"]],
                                 :type "type",
                                 :full-name-encode "cljs.core/Iterator",
                                 :source {:code "(deftype Iterator [^:mutable s]\n  Object\n  (next [_]\n    (if-not (nil? s)\n      (let [x (first s)]\n        (set! s (next s))\n        #js {:value x :done false})\n      #js {:value nil :done true})))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2356",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [4861 4868]},
                                 :full-name "cljs.core/Iterator",
                                 :removed {:in "0.0-2371",
                                           :last-seen "0.0-2356"}},
           "cljs.core/vreset!" {:ns "cljs.core",
                                :name "vreset!",
                                :signature ["[vol newval]"],
                                :name-encode "vresetBANG",
                                :history [["+" "0.0-2496"]],
                                :type "function",
                                :full-name-encode "cljs.core/vresetBANG",
                                :source {:code "(defn vreset!\n  [vol newval]  (-vreset! vol newval))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [4689 4692]},
                                :full-name "cljs.core/vreset!",
                                :docstring "Sets the value of volatile to newval without regard for the\ncurrent value. Returns newval."},
           "compiler-options/cache-analysis-format" {:ns "compiler-options",
                                                     :name "cache-analysis-format",
                                                     :name-encode "cache-analysis-format",
                                                     :type "option",
                                                     :full-name-encode "compiler-options/cache-analysis-format",
                                                     :full-name "compiler-options/cache-analysis-format",
                                                     :history [["+"
                                                                "1.9.456"]]},
           "cljs.spec/speced-vars" {:ns "cljs.spec",
                                    :name "speced-vars",
                                    :signature ["[]"],
                                    :name-encode "speced-vars",
                                    :history [["+" "1.9.14"]
                                              ["-" "1.9.542"]],
                                    :type "function",
                                    :full-name-encode "cljs.spec/speced-vars",
                                    :source {:code "(defn speced-vars []\n  @_speced_vars)",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.9.521",
                                             :filename "src/main/cljs/cljs/spec.cljc",
                                             :lines [398 399]},
                                    :full-name "cljs.spec/speced-vars",
                                    :removed {:in "1.9.542",
                                              :last-seen "1.9.521"}},
           "cljs.pprint/*print-right-margin*" {:ns "cljs.pprint",
                                               :name "*print-right-margin*",
                                               :name-encode "STARprint-right-marginSTAR",
                                               :history [["+"
                                                          "0.0-3255"]],
                                               :type "dynamic var",
                                               :full-name-encode "cljs.pprint/STARprint-right-marginSTAR",
                                               :source {:code "(def ^{:added \"1.2\", :dynamic true} *print-right-margin* 72)",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.12.38",
                                                        :filename "src/main/cljs/cljs/pprint.cljs",
                                                        :lines [626
                                                                631]},
                                               :full-name "cljs.pprint/*print-right-margin*",
                                               :docstring "Pretty printing will try to avoid anything going beyond this column.\nSet it to nil to have pprint let the line be arbitrarily long. This will ignore all\nnon-mandatory newlines."},
           "cljs.core/interleave" {:ns "cljs.core",
                                   :name "interleave",
                                   :signature ["[]"
                                               "[c1]"
                                               "[c1 c2]"
                                               "[c1 c2 & colls]"],
                                   :name-encode "interleave",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/interleave",
                                   :source {:code "(defn interleave\n  ([] ())\n  ([c1] (lazy-seq c1))\n  ([c1 c2]\n     (lazy-seq\n      (let [s1 (seq c1) s2 (seq c2)]\n        (when (and s1 s2)\n          (cons (first s1) (cons (first s2)\n                                 (interleave (rest s1) (rest s2))))))))\n  ([c1 c2 & colls]\n     (lazy-seq\n      (let [ss (map seq (conj colls c2 c1))]\n        (when (every? identity ss)\n          (concat (map first ss) (apply interleave (map rest ss))))))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [5214 5228]},
                                   :full-name "cljs.core/interleave",
                                   :docstring "Returns a lazy seq of the first item in each coll, then the second etc."},
           "cljs.spec.test/check-fn" {:ns "cljs.spec.test",
                                      :name "check-fn",
                                      :signature ["[f spec]"
                                                  "[f spec opts]"],
                                      :name-encode "check-fn",
                                      :history [["+" "1.9.14"]
                                                ["-" "1.9.542"]],
                                      :type "macro",
                                      :full-name-encode "cljs.spec.test/check-fn",
                                      :source {:code "(defmacro check-fn\n  ([f spec]\n   `(check-fn ~f ~spec nil))\n  ([f spec opts]\n   `(let [opts# ~opts]\n      (validate-check-opts opts#)\n      (check-1 nil ~f ~spec opts#))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.9.521",
                                               :filename "src/main/cljs/cljs/spec/test.cljc",
                                               :lines [175 183]},
                                      :full-name "cljs.spec.test/check-fn",
                                      :docstring "Runs generative tests for fn f using spec and opts. See\n'check' for options and return.",
                                      :removed {:in "1.9.542",
                                                :last-seen "1.9.521"}},
           "cljs.spec/gen" {:ns "cljs.spec",
                            :name "gen",
                            :signature ["[spec]" "[spec overrides]"],
                            :name-encode "gen",
                            :history [["+" "1.9.14"] ["-" "1.9.542"]],
                            :type "function",
                            :full-name-encode "cljs.spec/gen",
                            :source {:code "(defn gen\n  ([spec] (gen spec nil))\n  ([spec overrides] (gensub spec overrides [] {::recursion-limit *recursion-limit*} spec)))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1.9.521",
                                     :filename "src/main/cljs/cljs/spec.cljs",
                                     :lines [277 288]},
                            :full-name "cljs.spec/gen",
                            :docstring "Given a spec, returns the generator for it, or throws if none can\nbe constructed. Optionally an overrides map can be provided which\nshould map spec names or paths (vectors of keywords) to no-arg\ngenerator-creating fns. These will be used instead of the generators at those\nnames/paths. Note that parent generator (in the spec or overrides\nmap) will supersede those of any subtrees. A generator for a regex\nop must always return a sequential collection (i.e. a generator for\ns/? should return either an empty sequence/vector or a\nsequence/vector with one item in it)",
                            :removed {:in "1.9.542",
                                      :last-seen "1.9.521"}},
           "cljs.core/TransientHashSet" {:protocols #{"IFn"
                                                      "ITransientCollection"
                                                      "ICounted"
                                                      "ITransientSet"
                                                      "ILookup"},
                                         :ns "cljs.core",
                                         :name "TransientHashSet",
                                         :signature ["[transient-map]"],
                                         :name-encode "TransientHashSet",
                                         :history [["+" "0.0-1211"]],
                                         :type "type",
                                         :full-name-encode "cljs.core/TransientHashSet",
                                         :source {:code "(deftype TransientHashSet [^:mutable transient-map]\n  ITransientCollection\n  (-conj! [tcoll o]\n    (set! transient-map (assoc! transient-map o nil))\n    tcoll)\n\n  (-persistent! [tcoll]\n    (PersistentHashSet. nil (persistent! transient-map) nil))\n\n  ITransientSet\n  (-disjoin! [tcoll v]\n    (set! transient-map (dissoc! transient-map v))\n    tcoll)\n\n  ICounted\n  (-count [tcoll] (count transient-map))\n\n  ILookup\n  (-lookup [tcoll v]\n    (-lookup tcoll v nil))\n\n  (-lookup [tcoll v not-found]\n    (if (identical? (-lookup transient-map v lookup-sentinel) lookup-sentinel)\n      not-found\n      v))\n\n  IFn\n  (-invoke [tcoll k]\n    (if (identical? (-lookup transient-map k lookup-sentinel) lookup-sentinel)\n      nil\n      k))\n\n  (-invoke [tcoll k not-found]\n    (if (identical? (-lookup transient-map k lookup-sentinel) lookup-sentinel)\n      not-found\n      k)))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/cljs/cljs/core.cljs",
                                                  :lines [9509 9544]},
                                         :full-name "cljs.core/TransientHashSet"},
           "cljs.spec.gen.alpha/choose" {:ns "cljs.spec.gen.alpha",
                                         :name "choose",
                                         :signature ["[& args]"],
                                         :name-encode "choose",
                                         :history [["+" "1.9.542"]],
                                         :type "function",
                                         :full-name-encode "cljs.spec.gen.alpha/choose",
                                         :source {:code "(lazy-combinators hash-map list map not-empty set vector vector-distinct fmap elements\n  bind choose one-of such-that tuple sample return\n  large-integer* double* frequency shuffle)",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/cljs/cljs/spec/gen/alpha.cljs",
                                                  :lines [70 72]},
                                         :full-name "cljs.spec.gen.alpha/choose",
                                         :docstring "Lazy loaded version of clojure.test.check.generators/choose"},
           "cljs.core/*flush-on-newline*" {:ns "cljs.core",
                                           :name "*flush-on-newline*",
                                           :name-encode "STARflush-on-newlineSTAR",
                                           :history [["+" "0.0-927"]],
                                           :type "dynamic var",
                                           :full-name-encode "cljs.core/STARflush-on-newlineSTAR",
                                           :source {:code "(def\n  ^{:dynamic true}\n  *flush-on-newline* true)",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/cljs/cljs/core.cljs",
                                                    :lines [102 107]},
                                           :full-name "cljs.core/*flush-on-newline*",
                                           :docstring "When set to true, output will be flushed whenever a newline is printed.\n\nDefaults to true."},
           "cljs.core/get-in" {:ns "cljs.core",
                               :name "get-in",
                               :signature ["[m ks]"
                                           "[m ks not-found]"],
                               :name-encode "get-in",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/get-in",
                               :source {:code "(defn get-in\n  {:added \"1.2\"\n   :static true}\n  ([m ks]\n   (loop [m m\n          ks (seq ks)]\n     (if (nil? ks)\n       m\n       (recur (get m (first ks))\n         (next ks)))))\n  ([m ks not-found]\n     (loop [sentinel lookup-sentinel\n            m m\n            ks (seq ks)]\n       (if-not (nil? ks)\n         (let [m (get m (first ks) sentinel)]\n           (if (identical? sentinel m)\n             not-found\n             (recur sentinel m (next ks))))\n         m))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1.12.38",
                                        :filename "src/main/cljs/cljs/core.cljs",
                                        :lines [5403 5425]},
                               :full-name "cljs.core/get-in",
                               :docstring "Returns the value in a nested associative structure,\nwhere ks is a sequence of keys. Returns nil if the key is not present,\nor the not-found value if supplied."},
           "cljs.repl.server/connq" {:ns "cljs.repl.server",
                                     :name "connq",
                                     :name-encode "connq",
                                     :type "var",
                                     :full-name-encode "cljs.repl.server/connq",
                                     :source {:code "(def connq (LinkedList.))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/clojure/cljs/repl/server.clj",
                                              :lines [20]},
                                     :full-name "cljs.repl.server/connq",
                                     :history [["+" "1.10.145"]]},
           "clojure.browser.dom/element" {:ns "clojure.browser.dom",
                                          :name "element",
                                          :signature ["[tag-or-text]"
                                                      "[tag & children]"],
                                          :name-encode "element",
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "clojure.browser.dom/element",
                                          :source {:code "(defn element\n  ([tag-or-text]\n     (log \"(element \" tag-or-text \")\")\n     (-element tag-or-text))\n  ([tag & children]\n     (log \"(element \" tag \" \" children \")\")\n     (let [attrs (first children)]\n       (if (map? attrs)\n         (-element tag attrs (rest children))\n         (-element tag nil children)))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1.12.38",
                                                   :filename "src/main/cljs/clojure/browser/dom.cljs",
                                                   :lines [81 90]},
                                          :full-name "clojure.browser.dom/element"},
           "cljs.math/get-exponent" {:return-type number,
                                     :ns "cljs.math",
                                     :name "get-exponent",
                                     :signature ["[d]"],
                                     :name-encode "get-exponent",
                                     :history [["+" "1.11.50"]],
                                     :type "function",
                                     :full-name-encode "cljs.math/get-exponent",
                                     :source {:code "(defn ^number get-exponent\n  {:added \"1.11.10\"}\n  [d]\n  (cond\n    (or ^boolean (js/isNaN d) (not ^boolean (js/isFinite d))) (inc EXP-MAX)\n    (zero? d) (dec EXP-MIN)\n    :default (let [a (js/ArrayBuffer. 8)\n                   f (js/Float64Array. a)\n                   i (js/Uint32Array. a)\n                   hi (if little-endian? 1 0)]\n               (aset f 0 d)\n               (- (bit-shift-right (bit-and (aget i hi) EXP-BITMASK32) (dec SIGNIFICAND-WIDTH32)) EXP-BIAS))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/cljs/cljs/math.cljs",
                                              :lines [599 614]},
                                     :full-name "cljs.math/get-exponent",
                                     :docstring "Returns the exponent of d.\nIf d is ##NaN, ##Inf, ##-Inf => max_Float64_exponent + 1\nIf d is zero or subnormal => min_Float64_exponent - 1\nSee: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#getExponent-double-"},
           "cljs.core/prim-seq" {:ns "cljs.core",
                                 :name "prim-seq",
                                 :signature ["[prim]" "[prim i]"],
                                 :name-encode "prim-seq",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/prim-seq",
                                 :source {:code "(defn prim-seq\n  ([prim]\n     (prim-seq prim 0))\n  ([prim i]\n     (when (< i (alength prim))\n       (IndexedSeq. prim i nil))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/core.cljs",
                                          :lines [1713 1719]},
                                 :full-name "cljs.core/prim-seq",
                                 :docstring "Create seq from a primitive JavaScript Array-like."},
           "cljs.pprint/pprint-logical-block" {:ns "cljs.pprint",
                                               :name "pprint-logical-block",
                                               :signature ["[& args]"],
                                               :name-encode "pprint-logical-block",
                                               :history [["+"
                                                          "0.0-3255"]],
                                               :type "macro",
                                               :full-name-encode "cljs.pprint/pprint-logical-block",
                                               :source {:code "(defmacro pprint-logical-block\n  [& args]\n  (let [[options body] (parse-lb-options #{:prefix :per-line-prefix :suffix} args)]\n    `(do (if (cljs.pprint/level-exceeded)\n           (~'-write cljs.core/*out* \"#\")\n           (do\n             (cljs.core/binding [cljs.pprint/*current-level* (inc cljs.pprint/*current-level*)\n                       cljs.pprint/*current-length* 0]\n               (cljs.pprint/start-block cljs.core/*out*\n                                        ~(:prefix options)\n                                        ~(:per-line-prefix options)\n                                        ~(:suffix options))\n               ~@body\n               (cljs.pprint/end-block cljs.core/*out*))))\n         nil)))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.12.38",
                                                        :filename "src/main/cljs/cljs/pprint.cljc",
                                                        :lines [58 80]},
                                               :full-name "cljs.pprint/pprint-logical-block",
                                               :docstring "Execute the body as a pretty printing logical block with output to *out* which\nmust be a pretty printing writer. When used from pprint or cl-format, this can be\nassumed.\n\nThis function is intended for use when writing custom dispatch functions.\n\nBefore the body, the caller can optionally specify options: :prefix, :per-line-prefix\nand :suffix."},
           "cljs.spec.test/get-host-port" {:ns "cljs.spec.test",
                                           :name "get-host-port",
                                           :signature ["[]"],
                                           :name-encode "get-host-port",
                                           :history [["+" "1.9.183"]
                                                     ["-" "1.9.542"]],
                                           :type "function",
                                           :full-name-encode "cljs.spec.test/get-host-port",
                                           :source {:code "(defn get-host-port []\n  (if (not= \"browser\" *target*)\n    {}\n    {:host (.. js/window -location -host)\n     :port (.. js/window -location -port)}))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.9.521",
                                                    :filename "src/main/cljs/cljs/spec/test.cljs",
                                                    :lines [45 49]},
                                           :full-name "cljs.spec.test/get-host-port",
                                           :removed {:in "1.9.542",
                                                     :last-seen "1.9.521"}},
           "cljs.spec.test.alpha/unstrument" {:ns "cljs.spec.test.alpha",
                                              :name "unstrument",
                                              :signature ["[]"
                                                          "[sym-or-syms]"],
                                              :name-encode "unstrument",
                                              :history [["+"
                                                         "1.9.542"]],
                                              :type "macro",
                                              :full-name-encode "cljs.spec.test.alpha/unstrument",
                                              :source {:code "(defmacro unstrument\n  ([]\n   `(unstrument ^::no-eval '[~@(deref instrumented-vars)]))\n  ([sym-or-syms]\n   (let [syms (sym-or-syms->syms (form->sym-or-syms sym-or-syms))]\n     `(reduce\n        (fn [ret# f#]\n          (let [sym# (f#)]\n            (cond-> ret# sym# (conj sym#))))\n        []\n        [~@(->> syms\n             (map\n               (fn [sym]\n                 (when (symbol? sym)\n                   `(fn []\n                      (unstrument-1 '~sym)))))\n             (remove nil?))]))))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1.12.38",
                                                       :filename "src/main/cljs/cljs/spec/test/alpha.cljc",
                                                       :lines [169
                                                               188]},
                                              :full-name "cljs.spec.test.alpha/unstrument",
                                              :docstring "Undoes instrument on the vars named by sym-or-syms, specified\nas in instrument. With no args, unstruments all instrumented vars.\nReturns a collection of syms naming the vars unstrumented."},
           "cljs.core/<=" {:return-type boolean,
                           :ns "cljs.core",
                           :name "<=",
                           :signature ["[x]" "[x y]" "[x y & more]"],
                           :name-encode "LTEQ",
                           :history [["+" "0.0-927"]],
                           :type "function/macro",
                           :full-name-encode "cljs.core/LTEQ",
                           :source {:code "(defn ^boolean <=\n  ([x] true)\n  ([x y] (cljs.core/<= x y))\n  ([x y & more]\n   (if (cljs.core/<= x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (cljs.core/<= y (first more)))\n     false)))",
                                    :title "Function code",
                                    :repo "clojurescript",
                                    :tag "r1.12.38",
                                    :filename "src/main/cljs/cljs/core.cljs",
                                    :lines [2726 2736]},
                           :extra-sources [{:code "(core/defmacro ^::ana/numeric <=\n  ([x] true)\n  ([x y] (bool-expr (core/list 'js* \"(~{} <= ~{})\" x y)))\n  ([x y & more] `(and (<= ~x ~y) (<= ~y ~@more))))",
                                            :title "Macro code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/clojure/cljs/core.cljc",
                                            :lines [1145 1148]}],
                           :full-name "cljs.core/<=",
                           :docstring "Returns non-nil if nums are in monotonically non-decreasing order,\notherwise false."},
           "cljs.compiler.api/compile-root" {:ns "cljs.compiler.api",
                                             :name "compile-root",
                                             :signature ["[src-dir]"
                                                         "[src-dir target-dir]"
                                                         "[src-dir target-dir opts]"
                                                         "[state src-dir target-dir opts]"],
                                             :name-encode "compile-root",
                                             :history [["+"
                                                        "0.0-3255"]],
                                             :type "function",
                                             :full-name-encode "cljs.compiler.api/compile-root",
                                             :source {:code "(defn compile-root\n  ([src-dir] (compile-root src-dir \"out\"))\n  ([src-dir target-dir] (compile-root src-dir target-dir nil))\n  ([src-dir target-dir opts]\n   (compile-root (or (ana-api/current-state) (ana-api/empty-state opts)) src-dir target-dir opts))\n  ([state src-dir target-dir opts]\n   (ana-api/with-state state\n     (binding [ana/*cljs-warning-handlers* (:warning-handlers opts ana/*cljs-warning-handlers*)]\n       (comp/compile-root src-dir target-dir opts)))))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1.12.38",
                                                      :filename "src/main/clojure/cljs/compiler/api.clj",
                                                      :lines [88 101]},
                                             :full-name "cljs.compiler.api/compile-root",
                                             :docstring "Looks recursively in src-dir for .cljs files and compiles them to\n.js files. If target-dir is provided, output will go into this\ndirectory mirroring the source directory structure. Returns a list\nof maps containing information about each file which was compiled\nin dependency order."},
           "clojure.set/map-invert" {:ns "clojure.set",
                                     :name "map-invert",
                                     :signature ["[m]"],
                                     :name-encode "map-invert",
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "clojure.set/map-invert",
                                     :source {:code "(defn map-invert\n  [m]\n  (persistent!\n    (reduce-kv (fn [m k v] (assoc! m v k))\n      (transient {})\n      m)))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/cljs/clojure/set.cljs",
                                              :lines [97 103]},
                                     :full-name "clojure.set/map-invert",
                                     :docstring "Returns the map with the vals mapped to the keys."},
           "clojure.browser.event/listen" {:ns "clojure.browser.event",
                                           :name "listen",
                                           :signature ["[src type fn]"
                                                       "[src type fn capture?]"],
                                           :name-encode "listen",
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "clojure.browser.event/listen",
                                           :source {:code "(defn listen\n  ([src type fn]\n     (listen src type fn false))\n  ([src type fn capture?]\n     (events/listen src\n                    (get (event-types src) type type)\n                    fn\n                    capture?)))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/cljs/clojure/browser/event.cljs",
                                                    :lines [46 53]},
                                           :full-name "clojure.browser.event/listen"},
           "cljs.core/neg?" {:return-type boolean,
                             :ns "cljs.core",
                             :name "neg?",
                             :signature ["[x]"],
                             :name-encode "negQMARK",
                             :history [["+" "0.0-927"]],
                             :type "function/macro",
                             :full-name-encode "cljs.core/negQMARK",
                             :source {:code "(defn ^boolean neg?\n  [x] (cljs.core/neg? x))",
                                      :title "Function code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/core.cljs",
                                      :lines [3030 3032]},
                             :extra-sources [{:code "(core/defmacro ^::ana/numeric neg? [x]\n  `(< ~x 0))",
                                              :title "Macro code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/clojure/cljs/core.cljc",
                                              :lines [1177 1178]}],
                             :full-name "cljs.core/neg?",
                             :docstring "Returns true if num is less than zero, else false"},
           "cljs.analyzer.api/ns-interns" {:ns "cljs.analyzer.api",
                                           :name "ns-interns",
                                           :signature ["[ns]"
                                                       "[state ns]"],
                                           :name-encode "ns-interns",
                                           :history [["+" "0.0-2496"]],
                                           :type "function",
                                           :full-name-encode "cljs.analyzer.api/ns-interns",
                                           :source {:code "(defn ns-interns\n  ([ns]\n   (ns-interns env/*compiler* ns))\n  ([state ns]\n   {:pre [(symbol? ns)]}\n   (let [ns (the-ns state ns)]\n     (merge\n      (:macros ns)\n      (:defs ns)))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1.12.38",
                                                    :filename "src/main/clojure/cljs/analyzer/api.cljc",
                                                    :lines [240 250]},
                                           :full-name "cljs.analyzer.api/ns-interns",
                                           :docstring "Given a namespace return all the var analysis maps. Analagous to\nclojure.core/ns-interns but returns var analysis maps not vars."},
           "cljs.spec.impl.gen/char-alphanumeric" {:ns "cljs.spec.impl.gen",
                                                   :name "char-alphanumeric",
                                                   :signature ["[& args]"],
                                                   :name-encode "char-alphanumeric",
                                                   :history [["+"
                                                              "1.9.14"]
                                                             ["-"
                                                              "1.9.542"]],
                                                   :type "function",
                                                   :full-name-encode "cljs.spec.impl.gen/char-alphanumeric",
                                                   :source {:code "(lazy-prims any any-printable boolean char char-alpha char-alphanumeric char-ascii double\n  int keyword keyword-ns large-integer ratio simple-type simple-type-printable\n  string string-ascii string-alphanumeric symbol symbol-ns uuid)",
                                                            :title "Source code",
                                                            :repo "clojurescript",
                                                            :tag "r1.9.521",
                                                            :filename "src/main/cljs/cljs/spec/impl/gen.cljs",
                                                            :lines [73
                                                                    75]},
                                                   :full-name "cljs.spec.impl.gen/char-alphanumeric",
                                                   :docstring "Fn returning clojure.test.check.generators/char-alphanumeric",
                                                   :removed {:in "1.9.542",
                                                             :last-seen "1.9.521"}},
           "cljs.repl.browser/firefox-clean-function" {:ns "cljs.repl.browser",
                                                       :name "firefox-clean-function",
                                                       :signature ["[f]"],
                                                       :name-encode "firefox-clean-function",
                                                       :history [["+"
                                                                  "0.0-3053"]
                                                                 ["-"
                                                                  "1.7.10"]],
                                                       :type "function",
                                                       :full-name-encode "cljs.repl.browser/firefox-clean-function",
                                                       :source {:code "(defn firefox-clean-function [f]\n  (as-> f f\n    (cond\n      (string/blank? f) nil\n      (not= (.indexOf f \"</\") -1)\n      (let [idx (.indexOf f \"</\")]\n        (.substring f (+ idx 2)))\n      :else f)\n    (-> f\n      (string/replace #\"<\" \"\")\n      (string/replace #\"\\/\" \"\"))))",
                                                                :title "Source code",
                                                                :repo "clojurescript",
                                                                :tag "r3308",
                                                                :filename "src/main/clojure/cljs/repl/browser.clj",
                                                                :lines [392
                                                                        402]},
                                                       :full-name "cljs.repl.browser/firefox-clean-function",
                                                       :removed {:in "1.7.10",
                                                                 :last-seen "0.0-3308"}},
           "cljs.repl/maybe-install-npm-deps" {:ns "cljs.repl",
                                               :name "maybe-install-npm-deps",
                                               :signature ["[opts]"],
                                               :name-encode "maybe-install-npm-deps",
                                               :history [["+"
                                                          "1.10.63"]],
                                               :type "function",
                                               :full-name-encode "cljs.repl/maybe-install-npm-deps",
                                               :source {:code "(defn maybe-install-npm-deps [opts]\n  (when (:install-deps opts)\n    (cljsc/check-npm-deps opts)\n    (swap! env/*compiler* update-in [:npm-deps-installed?]\n      (fn [installed?]\n        (if-not installed?\n          (cljsc/maybe-install-node-deps! opts)\n          installed?)))))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.12.38",
                                                        :filename "src/main/clojure/cljs/repl.cljc",
                                                        :lines [1019
                                                                1026]},
                                               :full-name "cljs.repl/maybe-install-npm-deps"},
           "cljs.math/cosh" {:return-type number,
                             :ns "cljs.math",
                             :name "cosh",
                             :signature ["[x]"],
                             :name-encode "cosh",
                             :history [["+" "1.11.50"]],
                             :type "function",
                             :full-name-encode "cljs.math/cosh",
                             :source {:code "(defn ^number cosh\n  {:added \"1.11.10\"}\n  [x] (Math/cosh x))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/math.cljs",
                                      :lines [680 687]},
                             :full-name "cljs.math/cosh",
                             :docstring "Returns the hyperbolic cosine of x, (e^x + e^-x)/2.\nIf x is ##NaN => ##NaN\nIf x is ##Inf or ##-Inf => ##Inf\nIf x is zero => 1.0\nSee: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/cosh"},
           "cljs.core/mix-collection-hash" {:return-type number,
                                            :ns "cljs.core",
                                            :name "mix-collection-hash",
                                            :signature ["[hash-basis count]"],
                                            :name-encode "mix-collection-hash",
                                            :history [["+" "0.0-2261"]],
                                            :type "function",
                                            :full-name-encode "cljs.core/mix-collection-hash",
                                            :source {:code "(defn ^number mix-collection-hash\n  [hash-basis count]\n  (let [h1 m3-seed\n        k1 (m3-mix-K1 hash-basis)\n        h1 (m3-mix-H1 h1 k1)]\n    (m3-fmix h1 count)))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1.12.38",
                                                     :filename "src/main/cljs/cljs/core.cljs",
                                                     :lines [1364
                                                             1374]},
                                            :full-name "cljs.core/mix-collection-hash",
                                            :docstring "Mix final collection hash for ordered or unordered collections.\nhash-basis is the combined collection hash, count is the number\nof elements included in the basis. Note this is the hash code\nconsistent with =, different from .hashCode.\nSee http://clojure.org/data_structures#hash for full algorithms."},
           "clojure.browser.dom/replace-node" {:ns "clojure.browser.dom",
                                               :name "replace-node",
                                               :signature ["[old-node new-node]"],
                                               :name-encode "replace-node",
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "clojure.browser.dom/replace-node",
                                               :source {:code "(defn replace-node\n  [old-node new-node]\n  (let [old-node (ensure-element old-node)\n        new-node (ensure-element new-node)]\n    (gdom/replaceNode new-node old-node)\n    new-node))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1.12.38",
                                                        :filename "src/main/cljs/clojure/browser/dom.cljs",
                                                        :lines [114
                                                                122]},
                                               :full-name "clojure.browser.dom/replace-node",
                                               :docstring "Replace old-node with new-node. old-node can be an element or a\nkeyword which is the id of the node to replace.  new-node can be an\nelement or an html string."},
           "cljs.core/TaggedLiteral" {:protocols #{"ILookup"
                                                   "IHash"
                                                   "IPrintWithWriter"
                                                   "IEquiv"},
                                      :ns "cljs.core",
                                      :name "TaggedLiteral",
                                      :signature ["[tag form]"],
                                      :name-encode "TaggedLiteral",
                                      :history [["+" "0.0-3255"]],
                                      :type "type",
                                      :full-name-encode "cljs.core/TaggedLiteral",
                                      :source {:code "(deftype TaggedLiteral [tag form]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n\n  IEquiv\n  (-equiv [this other]\n    (and (instance? TaggedLiteral other)\n         (= tag (.-tag other))\n         (= form (.-form other))))\n\n  IHash\n  (-hash [this]\n    (+ (* 31 (hash tag))\n       (hash form)))\n\n  ILookup\n  (-lookup [this v]\n    (-lookup this v nil))\n  (-lookup [this v not-found]\n    (case v\n      :tag tag\n      :form form\n      not-found))\n\n  IPrintWithWriter\n  (-pr-writer [o writer opts]\n    (-write writer (str \"#\" tag \" \"))\n    (pr-writer form writer opts)))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/core.cljs",
                                               :lines [11905 11933]},
                                      :full-name "cljs.core/TaggedLiteral"},
           "cljs.core/RangeChunk" {:protocols #{"ICounted"
                                                "ISeq"
                                                "IChunk"
                                                "IIndexed"},
                                   :ns "cljs.core",
                                   :name "RangeChunk",
                                   :signature ["[start step count]"],
                                   :name-encode "RangeChunk",
                                   :history [["+" "1.10.514"]
                                             ["-" "1.10.844"]],
                                   :type "type",
                                   :full-name-encode "cljs.core/RangeChunk",
                                   :source {:code "(deftype RangeChunk [start step count]\n  ICounted\n  (-count [coll] count)\n\n  ISeq\n  (-first [coll] start)\n\n  IIndexed\n  (-nth [coll i]\n    (+ start (* i step)))\n  (-nth [coll i not-found]\n    (if (and (>= i 0) (< i count))\n      (+ start (* i step))\n      not-found))\n\n  IChunk\n  (-drop-first [coll]\n    (if (<= count 1)\n      (throw (js/Error. \"-drop-first of empty chunk\"))\n      (RangeChunk. (+ start step) step (dec count)))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.10.773",
                                            :filename "src/main/cljs/cljs/core.cljs",
                                            :lines [9653 9672]},
                                   :full-name "cljs.core/RangeChunk",
                                   :removed {:in "1.10.844",
                                             :last-seen "1.10.773"}},
           "cljs.spec/registry" {:ns "cljs.spec",
                                 :name "registry",
                                 :signature ["[]"],
                                 :name-encode "registry",
                                 :history [["+" "1.9.14"]
                                           ["-" "1.9.542"]],
                                 :type "function",
                                 :full-name-encode "cljs.spec/registry",
                                 :source {:code "(defn registry\n  []\n  @registry-ref)",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.9.521",
                                          :filename "src/main/cljs/cljs/spec.cljs",
                                          :lines [300 303]},
                                 :full-name "cljs.spec/registry",
                                 :docstring "returns the registry map, prefer 'get-spec' to lookup a spec by name",
                                 :removed {:in "1.9.542",
                                           :last-seen "1.9.521"}},
           "cljs.core/parse-double" {:return-type number,
                                     :ns "cljs.core",
                                     :name "parse-double",
                                     :signature ["[s]"],
                                     :name-encode "parse-double",
                                     :history [["+" "1.11.50"]],
                                     :type "function",
                                     :full-name-encode "cljs.core/parse-double",
                                     :source {:code "(defn ^number parse-double\n  [s]\n  (if (string? s)\n    (cond\n      ^boolean (re-matches #\"[\\x00-\\x20]*[+-]?NaN[\\x00-\\x20]*\" s) ##NaN\n      ^boolean (re-matches\n                #\"[\\x00-\\x20]*[+-]?(Infinity|((\\d+\\.?\\d*|\\.\\d+)([eE][+-]?\\d+)?)[dDfF]?)[\\x00-\\x20]*\"\n                s) (js/parseFloat s)\n      :default nil)\n    (throw (js/Error. (parsing-err s)))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/cljs/cljs/core.cljs",
                                              :lines [12252 12264]},
                                     :full-name "cljs.core/parse-double",
                                     :docstring "Parse string with floating point components and return a floating point value,\nor nil if parse fails.\nGrammar: https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html#valueOf-java.lang.String-"},
           "cljs.core/DEMUNGE_PATTERN" {:ns "cljs.core",
                                        :name "DEMUNGE_PATTERN",
                                        :name-encode "DEMUNGE_PATTERN",
                                        :type "var",
                                        :full-name-encode "cljs.core/DEMUNGE_PATTERN",
                                        :source {:code "(def DEMUNGE_PATTERN nil)",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/cljs/cljs/core.cljs",
                                                 :lines [401]},
                                        :full-name "cljs.core/DEMUNGE_PATTERN",
                                        :history [["+" "1.7.10"]]},
           "repl-options/repl-verbose" {:ns "repl-options",
                                        :name "repl-verbose",
                                        :name-encode "repl-verbose",
                                        :type "option",
                                        :full-name-encode "repl-options/repl-verbose",
                                        :full-name "repl-options/repl-verbose",
                                        :history [["+" "0.0-2719"]]},
           "cljs.core/MODULE_INFOS" {:ns "cljs.core",
                                     :name "MODULE_INFOS",
                                     :name-encode "MODULE_INFOS",
                                     :type "var",
                                     :full-name-encode "cljs.core/MODULE_INFOS",
                                     :source {:code "(def MODULE_INFOS nil)",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/cljs/cljs/core.cljs",
                                              :lines [40]},
                                     :full-name "cljs.core/MODULE_INFOS",
                                     :history [["+" "1.9.854"]]},
           "cljs.core/reverse" {:ns "cljs.core",
                                :name "reverse",
                                :signature ["[coll]"],
                                :name-encode "reverse",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/reverse",
                                :source {:code "(defn reverse\n  [coll]\n  (if (reversible? coll)\n    (or (rseq coll) ())\n    (reduce conj () coll)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/cljs/core.cljs",
                                         :lines [3289 3294]},
                                :full-name "cljs.core/reverse",
                                :docstring "Returns a seq of the items in coll in reverse order. Not lazy."},
           "cljs.repl.browser/ordering" {:ns "cljs.repl.browser",
                                         :name "ordering",
                                         :name-encode "ordering",
                                         :type "dynamic var",
                                         :full-name-encode "cljs.repl.browser/ordering",
                                         :source {:code "(def ^:dynamic ordering nil)",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1.12.38",
                                                  :filename "src/main/clojure/cljs/repl/browser.clj",
                                                  :lines [28]},
                                         :full-name "cljs.repl.browser/ordering",
                                         :history [["+" "0.0-927"]]},
           "cljs.pprint/*out*" {:ns "cljs.pprint",
                                :name "*out*",
                                :name-encode "STARoutSTAR",
                                :history [["+" "0.0-3255"]
                                          ["-" "1.7.10"]],
                                :type "dynamic var",
                                :full-name-encode "cljs.pprint/STARoutSTAR",
                                :source {:code "(def ^:dynamic *out* nil)",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r3308",
                                         :filename "src/main/cljs/cljs/pprint.cljs",
                                         :lines [21]},
                                :full-name "cljs.pprint/*out*",
                                :removed {:in "1.7.10",
                                          :last-seen "0.0-3308"}},
           "cljs.core/realized?" {:return-type boolean,
                                  :ns "cljs.core",
                                  :name "realized?",
                                  :signature ["[x]"],
                                  :name-encode "realizedQMARK",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/realizedQMARK",
                                  :source {:code "(defn ^boolean realized?\n  [x]\n  (-realized? x))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/cljs/cljs/core.cljs",
                                           :lines [10992 10995]},
                                  :full-name "cljs.core/realized?",
                                  :docstring "Returns true if a value has been produced for a delay or lazy sequence."},
           "closure-warnings/missing-sources-warnings" {:ns "closure-warnings",
                                                        :name "missing-sources-warnings",
                                                        :name-encode "missing-sources-warnings",
                                                        :type "warning",
                                                        :full-name-encode "closure-warnings/missing-sources-warnings",
                                                        :full-name "closure-warnings/missing-sources-warnings",
                                                        :history [["+"
                                                                   "1.10.217"]]},
           "cljs.core/ensure-reduced" {:ns "cljs.core",
                                       :name "ensure-reduced",
                                       :signature ["[x]"],
                                       :name-encode "ensure-reduced",
                                       :history [["+" "0.0-2411"]],
                                       :type "function",
                                       :full-name-encode "cljs.core/ensure-reduced",
                                       :source {:code "(defn ensure-reduced\n  [x]\n  (if (reduced? x) x (reduced x)))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/cljs/core.cljs",
                                                :lines [1487 1490]},
                                       :full-name "cljs.core/ensure-reduced",
                                       :docstring "If x is already reduced?, returns it, else returns (reduced x)"},
           "cljs.math/PI" {:return-type number,
                           :ns "cljs.math",
                           :name "PI",
                           :name-encode "PI",
                           :history [["+" "1.11.50"]],
                           :type "var",
                           :full-name-encode "cljs.math/PI",
                           :source {:code "(def\n  ^{:added \"1.11.10\"\n    :tag number\n    :const true} PI Math/PI)",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r1.12.38",
                                    :filename "src/main/cljs/cljs/math.cljs",
                                    :lines [12 17]},
                           :full-name "cljs.math/PI",
                           :docstring "Constant for pi, the ratio of the circumference of a circle to its diameter.\nSee: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/PI"}},
 :namespaces {"cljs.repl.server" {:ns "cljs.repl.server",
                                  :name-encode "cljs.repl.server",
                                  :type "namespace",
                                  :full-name-encode "cljs.repl.server",
                                  :source {:code "(ns cljs.repl.server\n  (:refer-clojure :exclude [loaded-libs])\n  (:require [clojure.string :as str])\n  (:import java.io.BufferedReader\n           java.io.InputStreamReader\n           java.io.ByteArrayOutputStream\n           java.util.zip.GZIPOutputStream\n           java.net.ServerSocket\n           [java.util LinkedList]))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1.12.38",
                                           :filename "src/main/clojure/cljs/repl/server.clj",
                                           :lines [9 17]},
                                  :full-name "cljs.repl.server",
                                  :history [["+" "0.0-1503"]]},
              "clojure.zip" {:ns "clojure.zip",
                             :name-encode "clojure.zip",
                             :history [["+" "0.0-927"]],
                             :type "namespace",
                             :full-name-encode "clojure.zip",
                             :source {:code "(ns ^{:author \"Rich Hickey\"}\n  clojure.zip\n  (:refer-clojure :exclude (replace remove next)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/clojure/zip.cljs",
                                      :lines [12 16]},
                             :author "Rich Hickey",
                             :full-name "clojure.zip",
                             :docstring "Functional hierarchical zipper, with navigation, editing,\n  and enumeration.  See Huet"},
              "clojure.reflect" {:ns "clojure.reflect",
                                 :name-encode "clojure.reflect",
                                 :type "namespace",
                                 :full-name-encode "clojure.reflect",
                                 :source {:code "(ns clojure.reflect\n  ^{:doc \"DEPRECATED. Do not use, superceded by REPL enhancements.\"}\n  (:refer-clojure :exclude [meta macroexpand])\n  (:require [clojure.browser.net :as net]\n            [clojure.browser.event :as event]))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/clojure/reflect.cljs",
                                          :lines [9 13]},
                                 :full-name "clojure.reflect",
                                 :history [["+" "0.0-1503"]]},
              "cljs.compiler.api" {:ns "cljs.compiler.api",
                                   :name-encode "cljs.compiler.api",
                                   :type "namespace",
                                   :full-name-encode "cljs.compiler.api",
                                   :source {:code "(ns cljs.compiler.api\n  (:refer-clojure :exclude [munge])\n  (:require [cljs.analyzer :as ana]\n            [cljs.analyzer.api :as ana-api]\n            [cljs.compiler :as comp]\n            [cljs.closure :as closure]))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/clojure/cljs/compiler/api.clj",
                                            :lines [9 16]},
                                   :full-name "cljs.compiler.api",
                                   :docstring "This is intended to be a stable api for those who need programmatic access\n  to the compiler.",
                                   :history [["+" "0.0-3255"]]},
              "cljs.test" {:ns "cljs.test",
                           :name-encode "cljs.test",
                           :type "namespace",
                           :full-name-encode "cljs.test",
                           :source {:code "(ns cljs.test\n  #?(:cljs (:require-macros [clojure.template :as temp]))\n  (:require [cljs.env :as env]\n            [cljs.analyzer :as ana]\n            [cljs.analyzer.api :as ana-api]\n            #?(:clj [clojure.template :as temp])))",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r1.12.38",
                                    :filename "src/main/cljs/cljs/test.cljc",
                                    :lines [9 14]},
                           :full-name "cljs.test",
                           :history [["+" "0.0-2496"]]},
              "cljs.repl.browser" {:ns "cljs.repl.browser",
                                   :name-encode "cljs.repl.browser",
                                   :type "namespace",
                                   :full-name-encode "cljs.repl.browser",
                                   :source {:code "(ns cljs.repl.browser\n  (:refer-clojure :exclude [loaded-libs])\n  (:require [clojure.java.io :as io]\n            [clojure.java.browse :as browse]\n            [clojure.string :as string]\n            [clojure.edn :as edn]\n            [cljs.vendor.clojure.data.json :as json]\n            [cljs.util :as util]\n            [cljs.closure :as cljsc]\n            [cljs.repl :as repl]\n            [cljs.cli :as cli]\n            [cljs.repl.server :as server]\n            [cljs.stacktrace :as st]\n            [cljs.analyzer :as ana]\n            [cljs.build.api :as build]\n            [clojure.string :as str])\n  (:import [java.util.concurrent Executors ConcurrentHashMap]))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/clojure/cljs/repl/browser.clj",
                                            :lines [9 25]},
                                   :full-name "cljs.repl.browser",
                                   :history [["+" "0.0-927"]]},
              "cljs.repl.rhino" {:ns "cljs.repl.rhino",
                                 :name-encode "cljs.repl.rhino",
                                 :type "namespace",
                                 :full-name-encode "cljs.repl.rhino",
                                 :source {:code "(ns cljs.repl.rhino\n  (:refer-clojure :exclude [load-file])\n  (:require [clojure.string :as string]\n            [clojure.java.io :as io]\n            [clojure.data.json :as json]\n            [cljs.compiler :as comp]\n            [cljs.closure :as closure]\n            [cljs.analyzer :as ana]\n            [cljs.repl :as repl]\n            [cljs.cli :as cli]\n            [cljs.util :as util]\n            [cljs.stacktrace :as st])\n  (:import [java.io File Reader]\n           [org.mozilla.javascript Context ScriptableObject\n                                   RhinoException Undefined]))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.10.597",
                                          :filename "src/main/clojure/cljs/repl/rhino.clj",
                                          :lines [9 23]},
                                 :full-name "cljs.repl.rhino",
                                 :history [["+" "0.0-927"]
                                           ["-" "1.10.738"]],
                                 :removed {:in "1.10.738",
                                           :last-seen "1.10.597"}},
              "clojure.browser.dom" {:ns "clojure.browser.dom",
                                     :name-encode "clojure.browser.dom",
                                     :type "namespace",
                                     :full-name-encode "clojure.browser.dom",
                                     :source {:code "(ns clojure.browser.dom\n  (:require [goog.dom :as gdom]\n            [goog.object :as gobject]))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/cljs/clojure/browser/dom.cljs",
                                              :lines [9 11]},
                                     :full-name "clojure.browser.dom",
                                     :history [["+" "0.0-927"]]},
              "cljs.spec.gen.alpha" {:ns "cljs.spec.gen.alpha",
                                     :name-encode "cljs.spec.gen.alpha",
                                     :type "namespace",
                                     :full-name-encode "cljs.spec.gen.alpha",
                                     :source {:code "(ns cljs.spec.gen.alpha\n  (:refer-clojure :exclude [delay])\n  (:require [cljs.core :as c]\n            [clojure.string :as string]))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/cljs/cljs/spec/gen/alpha.cljc",
                                              :lines [9 12]},
                                     :full-name "cljs.spec.gen.alpha",
                                     :history [["+" "1.9.542"]]},
              "cljs.math" {:ns "cljs.math",
                           :name-encode "cljs.math",
                           :history [["+" "1.11.50"]],
                           :type "namespace",
                           :full-name-encode "cljs.math",
                           :source {:code "(ns ^{:author \"Paula Gearon\" }\n    cljs.math)",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r1.12.38",
                                    :filename "src/main/cljs/cljs/math.cljs",
                                    :lines [1 3]},
                           :author "Paula Gearon",
                           :full-name "cljs.math",
                           :docstring "ClojureScript wrapper functions for math operations"},
              "clojure.set" {:ns "clojure.set",
                             :name-encode "clojure.set",
                             :history [["+" "0.0-927"]],
                             :type "namespace",
                             :full-name-encode "clojure.set",
                             :source {:code "(ns ^{:author \"Rich Hickey\"}\n       clojure.set)",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/clojure/set.cljs",
                                      :lines [9 11]},
                             :author "Rich Hickey",
                             :full-name "clojure.set",
                             :docstring "Set operations such as union/intersection."},
              "clojure.datafy" {:ns "clojure.datafy",
                                :name-encode "clojure.datafy",
                                :type "namespace",
                                :full-name-encode "clojure.datafy",
                                :source {:code "(ns\n  clojure.datafy\n  (:require [clojure.core.protocols :as p]))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/clojure/datafy.cljs",
                                         :lines [9 12]},
                                :full-name "clojure.datafy",
                                :docstring "Functions to turn objects into data. Alpha, subject to change",
                                :history [["+" "1.10.514"]]},
              "cljs.repl.node" {:ns "cljs.repl.node",
                                :name-encode "cljs.repl.node",
                                :type "namespace",
                                :full-name-encode "cljs.repl.node",
                                :source {:code "(ns cljs.repl.node\n  (:require [clojure.string :as string]\n            [clojure.java.io :as io]\n            [cljs.util :as util]\n            [cljs.analyzer :as ana]\n            [cljs.compiler :as comp]\n            [cljs.repl :as repl]\n            [cljs.repl.bootstrap :as bootstrap]\n            [cljs.cli :as cli]\n            [cljs.closure :as closure]\n            [cljs.vendor.clojure.data.json :as json])\n  (:import [java.net Socket]\n           [java.lang StringBuilder]\n           [java.io File BufferedReader BufferedWriter IOException]\n           [java.lang ProcessBuilder Process]\n           [java.util.concurrent ConcurrentHashMap LinkedBlockingQueue]))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/clojure/cljs/repl/node.clj",
                                         :lines [9 24]},
                                :full-name "cljs.repl.node",
                                :history [["+" "0.0-2629"]]},
              "cljs.nodejs" {:ns "cljs.nodejs",
                             :name-encode "cljs.nodejs",
                             :type "namespace",
                             :full-name-encode "cljs.nodejs",
                             :source {:code "(ns cljs.nodejs\n  (:refer-clojure :exclude [require]))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/nodejs.cljs",
                                      :lines [12 13]},
                             :full-name "cljs.nodejs",
                             :history [["+" "0.0-927"]]},
              "clojure.core.protocols" {:ns "clojure.core.protocols",
                                        :name-encode "clojure.core.protocols",
                                        :type "namespace",
                                        :full-name-encode "clojure.core.protocols",
                                        :source {:code "(ns clojure.core.protocols)",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1.12.38",
                                                 :filename "src/main/cljs/clojure/core/protocols.cljs",
                                                 :lines [9]},
                                        :full-name "clojure.core.protocols",
                                        :history [["+" "1.10.514"]]},
              "cljs.repl.reflect" {:ns "cljs.repl.reflect",
                                   :name-encode "cljs.repl.reflect",
                                   :type "namespace",
                                   :full-name-encode "cljs.repl.reflect",
                                   :source {:code "(ns cljs.repl.reflect\n  (:refer-clojure :exclude [macroexpand])\n  (:require [cljs.repl.server :as server]\n            [cljs.analyzer :as analyzer]\n            [cljs.compiler :as compiler]\n            [clojure.string :as str]\n            [clojure.pprint :as pprint]))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/clojure/cljs/repl/reflect.clj",
                                            :lines [9 15]},
                                   :full-name "cljs.repl.reflect",
                                   :history [["+" "0.0-1503"]]},
              "cljs.spec" {:ns "cljs.spec",
                           :name-encode "cljs.spec",
                           :type "namespace",
                           :full-name-encode "cljs.spec",
                           :source {:code "(ns cljs.spec\n  (:refer-clojure :exclude [+ * and or cat def keys merge resolve assert])\n  (:require [cljs.core :as c]\n            [cljs.analyzer :as ana]\n            [cljs.env :as env]\n            [cljs.analyzer.api :refer [resolve]]\n            [clojure.walk :as walk]\n            [cljs.spec.impl.gen :as gen]\n            [clojure.string :as str]))",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r1.9.521",
                                    :filename "src/main/cljs/cljs/spec.cljc",
                                    :lines [9 17]},
                           :full-name "cljs.spec",
                           :history [["+" "1.9.14"] ["-" "1.9.542"]],
                           :removed {:in "1.9.542",
                                     :last-seen "1.9.521"}},
              "clojure.walk" {:ns "clojure.walk",
                              :name-encode "clojure.walk",
                              :history [["+" "0.0-927"]],
                              :type "namespace",
                              :full-name-encode "clojure.walk",
                              :source {:code "(ns \n  ^{:author \"Stuart Sierra\"}\n  clojure.walk)",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/clojure/walk.cljs",
                                       :lines [23 35]},
                              :author "Stuart Sierra",
                              :full-name "clojure.walk",
                              :docstring "This file defines a generic tree walker for Clojure data\nstructures.  It takes any data structure (list, vector, map, set,\nseq), calls a function on every element, and uses the return value\nof the function in place of the original.  This makes it fairly\neasy to write recursive search-and-replace functions, as shown in\nthe examples.\n\nNote: \"walk\" supports all Clojure data structures EXCEPT maps\ncreated with sorted-map-by.  There is no (obvious) way to retrieve\nthe sorting function."},
              "closure-warnings" {:pseudo-ns? true,
                                  :sub-options-sym "compiler-options/closure-warnings",
                                  :ns "closure-warnings",
                                  :type "namespace",
                                  :full-name-encode "closure-warnings",
                                  :full-name "closure-warnings",
                                  :history [["+" "0.0-2120"]]},
              "clojure.edn" {:ns "clojure.edn",
                             :name-encode "clojure.edn",
                             :type "namespace",
                             :full-name-encode "clojure.edn",
                             :source {:code "(ns clojure.edn\n  (:require [cljs.reader :as reader]))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/clojure/edn.cljs",
                                      :lines [9 18]},
                             :full-name "clojure.edn",
                             :docstring "edn reading.\n\n  This namespace provides alias for cljs.reader/read and cljs.reader/read-string.\n  Thus Clojure and ClojureScript source can reference these functions in the same way.\n  In Clojure, read and read-string may cause evaluation,\n  but clojure.edn/read and clojure.edn/read-string will not.\n  In ClojureScript cljs.reader/read and cljs.reader/read-string will not cause evaluation,\n  they only read edn.",
                             :history [["+" "1.10.514"]]},
              "cljs.js" {:ns "cljs.js",
                         :name-encode "cljs.js",
                         :type "namespace",
                         :full-name-encode "cljs.js",
                         :source {:code "(ns cljs.js\n  (:refer-clojure :exclude [require eval])\n  (:require-macros [cljs.js :refer [dump-core]]\n                   [cljs.env.macros :as env])\n  (:require [clojure.string :as string]\n            [clojure.walk :as walk]\n            [cljs.env :as env]\n            [cljs.spec.alpha]\n            [cljs.analyzer :as ana]\n            [cljs.compiler :as comp]\n            [cljs.tools.reader :as r]\n            [cljs.tools.reader.reader-types :as rt]\n            [cljs.tagged-literals :as tags]\n            [goog.crypt.base64 :as base64]\n            [cljs.source-map :as sm])\n  (:import [goog.string StringBuffer]))",
                                  :title "Source code",
                                  :repo "clojurescript",
                                  :tag "r1.12.38",
                                  :filename "src/main/cljs/cljs/js.cljs",
                                  :lines [9 24]},
                         :full-name "cljs.js",
                         :history [["+" "1.7.10"]]},
              "cljs.repl.nashorn" {:ns "cljs.repl.nashorn",
                                   :name-encode "cljs.repl.nashorn",
                                   :type "namespace",
                                   :full-name-encode "cljs.repl.nashorn",
                                   :source {:code "(ns cljs.repl.nashorn\n  (:require [clojure.java.io :as io]\n            [clojure.string :as string]\n            [clojure.stacktrace]\n            [clojure.data.json :as json]\n            [cljs.analyzer :as ana]\n            [cljs.env :as env]\n            [cljs.util :as util]\n            [cljs.repl :as repl]\n            [cljs.cli :as cli]\n            [cljs.compiler :as comp]\n            [cljs.closure :as closure]\n            [cljs.stacktrace :as st])\n  (:import [javax.script ScriptEngine ScriptEngineManager ScriptException ScriptEngineFactory]))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.10.597",
                                            :filename "src/main/clojure/cljs/repl/nashorn.clj",
                                            :lines [9 22]},
                                   :full-name "cljs.repl.nashorn",
                                   :history [["+" "0.0-2814"]
                                             ["-" "1.10.738"]],
                                   :removed {:in "1.10.738",
                                             :last-seen "1.10.597"}},
              "cljs.build.api" {:ns "cljs.build.api",
                                :name-encode "cljs.build.api",
                                :type "namespace",
                                :full-name-encode "cljs.build.api",
                                :source {:code "(ns cljs.build.api\n  (:refer-clojure :exclude [compile])\n  (:require [clojure.java.io :as io]\n            [cljs.util :as util]\n            [cljs.analyzer :as ana]\n            [cljs.analyzer.api :as ana-api]\n            [cljs.closure :as closure]\n            [cljs.js-deps :as deps])\n  (:import [java.io File]))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/clojure/cljs/build/api.clj",
                                         :lines [9 22]},
                                :full-name "cljs.build.api",
                                :docstring "This is intended to be a stable api for those who need programmatic access\n  to ClojureScript's project building facilities.\n\n  For example: a build script may need to how to invalidate compiled\n  files so that they will be recompiled.",
                                :history [["+" "0.0-2496"]]},
              "clojure.browser.event" {:ns "clojure.browser.event",
                                       :name-encode "clojure.browser.event",
                                       :history [["+" "0.0-927"]],
                                       :type "namespace",
                                       :full-name-encode "clojure.browser.event",
                                       :source {:code "(ns ^{:author \"Bobby Calderwood\"}\n  clojure.browser.event\n  (:require [goog.events :as events])\n  (:import (goog.events EventTarget EventType)))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/clojure/browser/event.cljs",
                                                :lines [9 14]},
                                       :author "Bobby Calderwood",
                                       :full-name "clojure.browser.event",
                                       :docstring "This namespace contains functions to work with browser\nevents.  It is based on the Google Closure Library event system."},
              "cljs.reader" {:ns "cljs.reader",
                             :name-encode "cljs.reader",
                             :type "namespace",
                             :full-name-encode "cljs.reader",
                             :source {:code "(ns cljs.reader\n  (:require-macros [cljs.reader :refer [add-data-readers]])\n  (:require [goog.object :as gobject]\n            [cljs.tools.reader :as treader]\n            [cljs.tools.reader.edn :as edn])\n  (:import [goog.string StringBuffer]))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/reader.cljs",
                                      :lines [9 14]},
                             :full-name "cljs.reader",
                             :history [["+" "0.0-927"]]},
              "clojure.string" {:ns "clojure.string",
                                :name-encode "clojure.string",
                                :type "namespace",
                                :full-name-encode "clojure.string",
                                :source {:code "(ns clojure.string\n  (:refer-clojure :exclude [replace reverse])\n  (:require [goog.string :as gstring])\n  (:import [goog.string StringBuffer]))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.12.38",
                                         :filename "src/main/cljs/clojure/string.cljs",
                                         :lines [9 12]},
                                :full-name "clojure.string",
                                :history [["+" "0.0-927"]]},
              "cljs.repl" {:ns "cljs.repl",
                           :name-encode "cljs.repl",
                           :type "namespace",
                           :full-name-encode "cljs.repl",
                           :source {:code "(ns cljs.repl\n  (:refer-clojure :exclude [load load-file])\n  (:require [clojure.java.io :as io]\n            [clojure.string :as string]\n            [clojure.set :as set]\n            [cljs.vendor.clojure.data.json :as json]\n            [cljs.vendor.clojure.tools.reader :as reader]\n            [cljs.vendor.clojure.tools.reader.reader-types :as readers]\n            [cljs.tagged-literals :as tags]\n            [clojure.edn :as edn]\n            [cljs.util :as util]\n            [cljs.compiler :as comp]\n            [cljs.analyzer :as ana]\n            [cljs.analyzer.api :as ana-api]\n            [cljs.env :as env]\n            [cljs.js-deps :as deps]\n            [cljs.closure :as cljsc]\n            [cljs.source-map :as sm])\n  (:import [java.io File PushbackReader FileWriter PrintWriter]\n           [java.net URL]\n           [java.util Base64]\n           [java.util.concurrent.atomic AtomicLong]\n           [clojure.lang IExceptionInfo]\n           [java.util.regex Pattern]))",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r1.12.38",
                                    :filename "src/main/clojure/cljs/repl.cljc",
                                    :lines [9 32]},
                           :full-name "cljs.repl",
                           :history [["+" "0.0-927"]]},
              "clojure.browser.net" {:ns "clojure.browser.net",
                                     :name-encode "clojure.browser.net",
                                     :history [["+" "0.0-927"]],
                                     :type "namespace",
                                     :full-name-encode "clojure.browser.net",
                                     :source {:code "(ns ^{:author \"Bobby Calderwood and Alex Redington\"}\n  clojure.browser.net\n  (:require [clojure.browser.event :as event]\n            [goog.json :as gjson]\n            [goog.object :as gobj])\n  (:import [goog.net XhrIo EventType WebSocket]\n           [goog.net.xpc CfgFields CrossPageChannel]\n           [goog Uri]))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1.12.38",
                                              :filename "src/main/cljs/clojure/browser/net.cljs",
                                              :lines [9 18]},
                                     :author "Bobby Calderwood and Alex Redington",
                                     :full-name "clojure.browser.net",
                                     :docstring "Network communication library, wrapping goog.net.\nIncludes a common API over XhrIo, CrossPageChannel, and Websockets."},
              "syntax" {:pseudo-ns? true,
                        :ns "syntax",
                        :type "namespace",
                        :full-name-encode "syntax",
                        :full-name "syntax",
                        :history [["+" "0.0-927"]]},
              "cljs.spec.alpha" {:ns "cljs.spec.alpha",
                                 :name-encode "cljs.spec.alpha",
                                 :type "namespace",
                                 :full-name-encode "cljs.spec.alpha",
                                 :source {:code "(ns cljs.spec.alpha\n  (:refer-clojure :exclude [+ * and or cat def keys merge resolve assert])\n  (:require [cljs.core :as c]\n            [cljs.analyzer :as ana]\n            [cljs.env :as env]\n            [cljs.analyzer.api :refer [resolve]]\n            [clojure.walk :as walk]\n            [cljs.spec.gen.alpha :as gen]\n            [clojure.string :as str]))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1.12.38",
                                          :filename "src/main/cljs/cljs/spec/alpha.cljc",
                                          :lines [9 17]},
                                 :full-name "cljs.spec.alpha",
                                 :history [["+" "1.9.542"]]},
              "cljs.spec.test" {:ns "cljs.spec.test",
                                :name-encode "cljs.spec.test",
                                :type "namespace",
                                :full-name-encode "cljs.spec.test",
                                :source {:code "(ns cljs.spec.test\n  (:require\n    [cljs.analyzer :as ana]\n    [cljs.analyzer.api :as ana-api]\n    [clojure.string :as string]\n    [cljs.spec :as s]\n    [cljs.spec.impl.gen :as gen]))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1.9.521",
                                         :filename "src/main/cljs/cljs/spec/test.cljc",
                                         :lines [9 15]},
                                :full-name "cljs.spec.test",
                                :history [["+" "1.9.14"]
                                          ["-" "1.9.542"]],
                                :removed {:in "1.9.542",
                                          :last-seen "1.9.521"}},
              "cljs.spec.test.alpha" {:ns "cljs.spec.test.alpha",
                                      :name-encode "cljs.spec.test.alpha",
                                      :type "namespace",
                                      :full-name-encode "cljs.spec.test.alpha",
                                      :source {:code "(ns cljs.spec.test.alpha\n  (:require\n    [cljs.analyzer :as ana]\n    [cljs.analyzer.api :as ana-api]\n    [clojure.string :as string]\n    [cljs.spec.alpha :as s]\n    [cljs.spec.gen.alpha :as gen]))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/cljs/spec/test/alpha.cljc",
                                               :lines [9 15]},
                                      :full-name "cljs.spec.test.alpha",
                                      :history [["+" "1.9.542"]]},
              "cljs.spec.impl.gen" {:ns "cljs.spec.impl.gen",
                                    :name-encode "cljs.spec.impl.gen",
                                    :type "namespace",
                                    :full-name-encode "cljs.spec.impl.gen",
                                    :source {:code "(ns cljs.spec.impl.gen\n  (:refer-clojure :exclude [delay])\n  (:require [cljs.core :as c]\n            [clojure.string :as string]))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1.9.521",
                                             :filename "src/main/cljs/cljs/spec/impl/gen.cljc",
                                             :lines [9 12]},
                                    :full-name "cljs.spec.impl.gen",
                                    :history [["+" "1.9.14"]
                                              ["-" "1.9.542"]],
                                    :removed {:in "1.9.542",
                                              :last-seen "1.9.521"}},
              "repl-options" {:pseudo-ns? true,
                              :ns "repl-options",
                              :type "namespace",
                              :full-name-encode "repl-options",
                              :full-name "repl-options",
                              :history [["+" "0.0-971"]]},
              "warnings" {:pseudo-ns? true,
                          :sub-options-sym "compiler-options/warnings",
                          :ns "warnings",
                          :type "namespace",
                          :full-name-encode "warnings",
                          :full-name "warnings",
                          :history [["+" "0.0-1835"]]},
              "cljs.core" {:ns "cljs.core",
                           :name-encode "cljs.core",
                           :type "namespace",
                           :full-name-encode "cljs.core",
                           :source {:code "(ns cljs.core\n  (:require goog.math.Long\n            goog.math.Integer\n            [goog.string :as gstring]\n            [goog.object :as gobject]\n            [goog.array :as garray]\n            [goog.Uri])\n  (:import [goog.string StringBuffer]))",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r1.12.38",
                                    :filename "src/main/cljs/cljs/core.cljs",
                                    :lines [9 16]},
                           :full-name "cljs.core",
                           :history [["+" "0.0-927"]]},
              "cljs.analyzer.api" {:ns "cljs.analyzer.api",
                                   :name-encode "cljs.analyzer.api",
                                   :type "namespace",
                                   :full-name-encode "cljs.analyzer.api",
                                   :source {:code "(ns cljs.analyzer.api\n  (:refer-clojure :exclude [all-ns ns-interns ns-resolve resolve find-ns\n                            ns-publics remove-ns the-ns])\n  #?(:clj  (:require [cljs.analyzer :as ana]\n                     [cljs.env :as env]\n                     [cljs.util :as util]\n                     [clojure.edn :as edn]\n                     [clojure.java.io :as io])\n     :cljs (:require [cljs.analyzer :as ana]\n                     [cljs.env :as env])))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1.12.38",
                                            :filename "src/main/clojure/cljs/analyzer/api.cljc",
                                            :lines [9 20]},
                                   :full-name "cljs.analyzer.api",
                                   :docstring "This is intended to be a stable api for those who need programmatic access\n  to the analyzer.",
                                   :history [["+" "0.0-2496"]]},
              "cljs.pprint" {:ns "cljs.pprint",
                             :name-encode "cljs.pprint",
                             :type "namespace",
                             :full-name-encode "cljs.pprint",
                             :source {:code "(ns cljs.pprint\n  (:refer-clojure :exclude [deftype #?(:cljs macroexpand)])\n  (:require [clojure.walk :as walk]\n            #?(:cljs [cljs.analyzer :as ana])))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1.12.38",
                                      :filename "src/main/cljs/cljs/pprint.cljc",
                                      :lines [9 12]},
                             :full-name "cljs.pprint",
                             :history [["+" "0.0-2496"]]},
              "clojure.data" {:ns "clojure.data",
                              :name-encode "clojure.data",
                              :history [["+" "0.0-1503"]],
                              :type "namespace",
                              :full-name-encode "clojure.data",
                              :source {:code "(ns \n  ^{:author \"Stuart Halloway\"}\n  clojure.data\n  (:require [clojure.set :as set]))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1.12.38",
                                       :filename "src/main/cljs/clojure/data.cljs",
                                       :lines [9 13]},
                              :author "Stuart Halloway",
                              :full-name "clojure.data",
                              :docstring "Non-core data functions."},
              "clojure.core.reducers" {:ns "clojure.core.reducers",
                                       :name-encode "clojure.core.reducers",
                                       :history [["+" "0.0-1236"]],
                                       :type "namespace",
                                       :full-name-encode "clojure.core.reducers",
                                       :source {:code "(ns ^{:author \"Rich Hickey\"}\n  clojure.core.reducers\n  (:refer-clojure :exclude [reduce map mapcat filter remove take take-while drop flatten cat])\n  (:require [cljs.core :as core]))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1.12.38",
                                                :filename "src/main/cljs/clojure/core/reducers.cljs",
                                                :lines [9 17]},
                                       :author "Rich Hickey",
                                       :full-name "clojure.core.reducers",
                                       :docstring "A library for reduction and parallel folding. Alpha and subject\n      to change.  Note that fold and its derivatives require\n      jsr166y.jar for fork/join support. See Clojure's pom.xml for the\n      dependency info."},
              "compiler-options" {:pseudo-ns? true,
                                  :ns "compiler-options",
                                  :type "namespace",
                                  :full-name-encode "compiler-options",
                                  :full-name "compiler-options",
                                  :history [["+" "0.0-971"]]},
              "clojure.browser.repl" {:ns "clojure.browser.repl",
                                      :name-encode "clojure.browser.repl",
                                      :history [["+" "0.0-927"]],
                                      :type "namespace",
                                      :full-name-encode "clojure.browser.repl",
                                      :source {:code "(ns ^{:author \"Bobby Calderwood and Alex Redington\"}\n  clojure.browser.repl\n  (:require [goog.dom :as gdom]\n            [goog.object :as gobj]\n            [goog.array :as garray]\n            [goog.json :as json]\n            [goog.userAgent.product :as product]\n            [clojure.browser.net :as net]\n            [clojure.browser.event :as event]\n            ;; repl-connection callback will receive goog.require('cljs.repl')\n            ;; and monkey-patched require expects to be able to derive it\n            ;; via goog.basePath, so this namespace should be compiled together\n            ;; with clojure.browser.repl:\n            [cljs.repl]))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1.12.38",
                                               :filename "src/main/cljs/clojure/browser/repl.cljs",
                                               :lines [9 29]},
                                      :author "Bobby Calderwood and Alex Redington",
                                      :full-name "clojure.browser.repl",
                                      :docstring "Receive - Eval - Print - Loop\n\n  Receive a block of JS (presumably generated by a ClojureScript compiler)\n  Evaluate it naively\n  Print the result of evaluation to a string\n  Send the resulting string back to the server Loop!"}},
 :api {:syntax {:changes {"1.10.339" {},
                          "0.0-2030" {},
                          "0.0-2067" {},
                          "1.9.521" {},
                          "0.0-2134" {},
                          "0.0-2322" {},
                          "1.10.891" {},
                          "1.10.335" {},
                          "1.10.844" {},
                          "0.0-1803" {},
                          "0.0-2371" {},
                          "0.0-2307" {},
                          "0.0-3148" {},
                          "0.0-1886" {},
                          "0.0-2138" {},
                          "1.11.60" {},
                          "0.0-2505" {},
                          "0.0-2311" {},
                          "1.9.92" {},
                          "0.0-2740" {},
                          "1.12.38" {},
                          "0.0-2725" {},
                          "1.9.211" {},
                          "1.10.312" {},
                          "0.0-2127" {},
                          "0.0-2843" {},
                          "0.0-2280" {},
                          "1.9.518" {},
                          "1.10.191" {},
                          "1.7.166" {},
                          "0.0-2199" {},
                          "1.11.54" {},
                          "1.10.514" {},
                          "0.0-2120" {:added #{"syntax/js-literal"}},
                          "1.9.93" {},
                          "1.9.495" {},
                          "1.10.748" {},
                          "0.0-1878" {},
                          "0.0-1236" {},
                          "0.0-2060" {},
                          "1.11.51" {},
                          "1.10.439" {},
                          "0.0-3178" {},
                          "0.0-3126" {},
                          "0.0-1424" {:added #{"syntax/inst-literal"
                                               "syntax/queue-literal"
                                               "syntax/uuid-literal"}},
                          "1.10.520" {},
                          "0.0-2342" {},
                          "0.0-3169" {},
                          "1.8.34" {},
                          "0.0-1885" {},
                          "1.11.132" {},
                          "1.9.227" {},
                          "0.0-1535" {},
                          "1.9.90" {},
                          "0.0-1859" {},
                          "0.0-3308" {},
                          "1.8.51" {},
                          "0.0-3190" {:added #{"syntax/cond"
                                               "syntax/cond-splicing"}},
                          "1.10.739" {},
                          "0.0-2755" {},
                          "0.0-1853" {:added #{"syntax/symbol"
                                               "syntax/vector"
                                               "syntax/string"
                                               "syntax/comment"
                                               "syntax/quote"
                                               "syntax/keyword-qualify"
                                               "syntax/meta"
                                               "syntax/regex"
                                               "syntax/eval"
                                               "syntax/unquote-splicing"
                                               "syntax/true"
                                               "syntax/keyword"
                                               "syntax/character"
                                               "syntax/unreadable"
                                               "syntax/arg"
                                               "syntax/false"
                                               "syntax/set"
                                               "syntax/tagged-literal"
                                               "syntax/syntax-quote"
                                               "syntax/dispatch"
                                               "syntax/shebang"
                                               "syntax/function"
                                               "syntax/nil"
                                               "syntax/map"
                                               "syntax/number"
                                               "syntax/list"
                                               "syntax/deref"
                                               "syntax/unquote"
                                               "syntax/ignore"
                                               "syntax/var"}},
                          "0.0-2197" {},
                          "1.9.225" {},
                          "0.0-3291" {},
                          "1.10.238" {:added #{"syntax/js-tag"}},
                          "0.0-2075" {},
                          "1.7.28" {},
                          "0.0-2277" {},
                          "1.9.89" {},
                          "1.10.896" {},
                          "0.0-2301" {},
                          "0.0-1909" {},
                          "1.10.63" {},
                          "0.0-3115" {},
                          "0.0-3195" {},
                          "1.9.35" {},
                          "1.10.753" {},
                          "0.0-3153" {},
                          "1.9.226" {},
                          "1.10.866" {},
                          "0.0-3119" {},
                          "1.9.85" {},
                          "0.0-2723" {},
                          "1.9.75" {},
                          "1.10.741" {},
                          "1.9.229" {},
                          "0.0-2727" {},
                          "0.0-3255" {},
                          "1.10.914" {},
                          "1.9.854" {},
                          "0.0-1552" {},
                          "0.0-2080" {},
                          "0.0-2234" {},
                          "0.0-2644" {},
                          "1.10.742" {},
                          "1.10.217" {},
                          "1.8.40" {},
                          "0.0-3191" {},
                          "1.11.50" {},
                          "0.0-2268" {},
                          "0.0-3269" {},
                          "0.0-2511" {},
                          "0.0-1806" {},
                          "0.0-3030" {},
                          "0.0-2341" {},
                          "1.10.64" {},
                          "1.9.36" {},
                          "0.0-3058" {},
                          "1.9.216" {},
                          "1.7.58" {},
                          "0.0-2629" {},
                          "1.11.4" {},
                          "0.0-2719" {},
                          "1.12.35" {},
                          "0.0-2816" {},
                          "1.7.228" {},
                          "0.0-2227" {},
                          "0.0-1576" {},
                          "0.0-3297" {},
                          "1.10.516" {},
                          "0.0-1844" {},
                          "1.9.493" {},
                          "0.0-1586" {},
                          "1.9.671" {},
                          "0.0-3123" {},
                          "1.10.597" {},
                          "1.10.893" {},
                          "1.7.107" {},
                          "0.0-2498" {},
                          "1.7.48" {},
                          "1.10.738" {},
                          "0.0-3117" {},
                          "0.0-2850" {},
                          "0.0-1443" {},
                          "0.0-1006" {},
                          "1.9.494" {},
                          "1.9.660" {},
                          "1.10.773" {},
                          "0.0-1913" {},
                          "0.0-2069" {},
                          "0.0-2814" {},
                          "0.0-2655" {},
                          "1.7.145" {},
                          "0.0-1513" {},
                          "1.11.57" {},
                          "0.0-1503" {},
                          "1.9.946" {:added #{"syntax/-Inf"
                                              "syntax/Inf"
                                              "syntax/NaN"}},
                          "0.0-1933" {},
                          "1.9.14" {},
                          "0.0-1895" {},
                          "0.0-971" {},
                          "0.0-2027" {},
                          "0.0-1978" {},
                          "0.0-1843" {},
                          "0.0-2758" {},
                          "0.0-2913" {},
                          "0.0-1835" {},
                          "1.10.740" {},
                          "0.0-3264" {},
                          "1.9.655" {},
                          "0.0-3149" {},
                          "1.9.198" {},
                          "1.11.121" {},
                          "0.0-1450" {},
                          "0.0-2173" {},
                          "0.0-3208" {},
                          "1.10.764" {},
                          "0.0-3263" {},
                          "1.9.473" {},
                          "1.7.170" {},
                          "0.0-1798" {},
                          "0.0-1877" {},
                          "0.0-1211" {},
                          "1.10.145" {},
                          "0.0-1449" {},
                          "0.0-2911" {},
                          "1.9.908" {},
                          "0.0-993" {},
                          "0.0-1011" {},
                          "0.0-2356" {},
                          "1.7.122" {},
                          "1.10.329" {},
                          "0.0-3211" {},
                          "0.0-3053" {},
                          "0.0-2985" {},
                          "1.9.183" {:added #{"syntax/ns-map-alias"
                                              "syntax/ns-map"}},
                          "0.0-2156" {},
                          "0.0-1847" {},
                          "1.9.293" {},
                          "1.9.542" {},
                          "1.7.189" {},
                          "0.0-2496" {},
                          "0.0-3196" {},
                          "1.10.879" {},
                          "1.10.758" {},
                          "0.0-927" {:added #{"syntax/whitespace"
                                              "syntax/earmuffs"
                                              "syntax/Math-namespace"
                                              "syntax/comma"
                                              "syntax/js-namespace"
                                              "syntax/namespace"
                                              "syntax/dot"
                                              "syntax/unused"
                                              "syntax/rest"
                                              "syntax/auto-gensym"
                                              "syntax/destructure-map"
                                              "syntax/impure"
                                              "syntax/predicate"
                                              "syntax/destructure-vector"}},
                          "0.0-1934" {},
                          "1.10.756" {},
                          "1.9.76" {},
                          "0.0-3165" {},
                          "0.0-2202" {},
                          "1.10.126" {},
                          "0.0-1820" {},
                          "1.9.456" {},
                          "0.0-2261" {},
                          "0.0-2024" {},
                          "1.9.88" {},
                          "1.7.10" {},
                          "0.0-1889" {},
                          "0.0-2657" {},
                          "0.0-1896" {},
                          "0.0-2014" {},
                          "1.9.562" {},
                          "0.0-2411" {},
                          "0.0-2665" {},
                          "0.0-2760" {}},
                :symbol-names #{"syntax/symbol"
                                "syntax/vector"
                                "syntax/inst-literal"
                                "syntax/whitespace"
                                "syntax/-Inf"
                                "syntax/earmuffs"
                                "syntax/cond"
                                "syntax/Math-namespace"
                                "syntax/comma"
                                "syntax/string"
                                "syntax/comment"
                                "syntax/js-namespace"
                                "syntax/quote"
                                "syntax/namespace"
                                "syntax/keyword-qualify"
                                "syntax/Inf"
                                "syntax/meta"
                                "syntax/regex"
                                "syntax/eval"
                                "syntax/dot"
                                "syntax/unused"
                                "syntax/unquote-splicing"
                                "syntax/cond-splicing"
                                "syntax/true"
                                "syntax/js-tag"
                                "syntax/rest"
                                "syntax/keyword"
                                "syntax/character"
                                "syntax/unreadable"
                                "syntax/auto-gensym"
                                "syntax/arg"
                                "syntax/false"
                                "syntax/set"
                                "syntax/tagged-literal"
                                "syntax/destructure-map"
                                "syntax/syntax-quote"
                                "syntax/dispatch"
                                "syntax/queue-literal"
                                "syntax/shebang"
                                "syntax/function"
                                "syntax/nil"
                                "syntax/map"
                                "syntax/number"
                                "syntax/ns-map-alias"
                                "syntax/js-literal"
                                "syntax/list"
                                "syntax/uuid-literal"
                                "syntax/impure"
                                "syntax/deref"
                                "syntax/unquote"
                                "syntax/NaN"
                                "syntax/predicate"
                                "syntax/ignore"
                                "syntax/destructure-vector"
                                "syntax/ns-map"
                                "syntax/var"},
                :namespace-names #{"syntax"}},
       :options {:changes {"1.10.339" {},
                           "0.0-2030" {},
                           "0.0-2067" {:added #{"warnings/invalid-arithmetic"}},
                           "1.9.521" {},
                           "0.0-2134" {},
                           "0.0-2322" {},
                           "1.10.891" {:removed #{"closure-warnings/undefined-names"}},
                           "1.10.335" {},
                           "1.10.844" {:removed #{"closure-warnings/strict-missing-require"
                                                  "closure-warnings/missing-getcssname"}},
                           "0.0-1803" {},
                           "0.0-2371" {:added #{"warnings/preamble-missing"}},
                           "0.0-2307" {},
                           "0.0-3148" {:added #{"repl-options/bind-err"
                                                "repl-options/quit-prompt"
                                                "repl-options/compiler-env"}},
                           "0.0-1886" {},
                           "0.0-2138" {},
                           "1.11.60" {},
                           "0.0-2505" {:added #{"compiler-options/source-map-timestamp"}},
                           "0.0-2311" {},
                           "1.9.92" {},
                           "0.0-2740" {},
                           "1.12.38" {},
                           "0.0-2725" {},
                           "1.9.211" {},
                           "1.10.312" {:added #{"compiler-options/elide-strict"
                                                "warnings/declared-arglists-mismatch"}},
                           "0.0-2127" {:added #{"compiler-options/preamble"}},
                           "0.0-2843" {},
                           "0.0-2280" {},
                           "1.9.518" {:added #{"compiler-options/npm-deps"}},
                           "1.10.191" {:added #{"compiler-options/package-json-resolution"}},
                           "1.7.166" {:added #{"warnings/protocol-with-variadic-method"}},
                           "0.0-2199" {},
                           "1.11.54" {},
                           "1.10.514" {},
                           "0.0-2120" {:added #{"closure-warnings/externs-validation"
                                                "closure-warnings/duplicate-message"
                                                "closure-warnings/tweaks"
                                                "closure-warnings/es5-strict"
                                                "closure-warnings/check-types"
                                                "closure-warnings/undefined-variables"
                                                "closure-warnings/const"
                                                "closure-warnings/access-controls"
                                                "closure-warnings/fileoverview-jsdoc"
                                                "closure-warnings/debugger-statement-present"
                                                "closure-warnings/undefined-names"
                                                "closure-warnings/missing-properties"
                                                "closure-warnings/ambiguous-function-decl"
                                                "closure-warnings/check-regexp"
                                                "compiler-options/closure-warnings"
                                                "closure-warnings/check-useless-code"
                                                "closure-warnings/strict-module-dep-check"
                                                "closure-warnings/non-standard-jsdoc"
                                                "closure-warnings/check-variables"
                                                "compiler-options/closure-defines"
                                                "closure-warnings/visiblity"
                                                "closure-warnings/internet-explorer-checks"
                                                "closure-warnings/global-this"
                                                "closure-warnings/deprecated"
                                                "closure-warnings/constant-property"
                                                "closure-warnings/unknown-defines"
                                                "closure-warnings/invalid-casts"}},
                           "1.9.93" {},
                           "1.9.495" {},
                           "1.10.748" {},
                           "0.0-1878" {},
                           "0.0-1236" {},
                           "0.0-2060" {:added #{"warnings/invoke-ctor"
                                                "compiler-options/source-map-path"}},
                           "1.11.51" {},
                           "1.10.439" {:added #{"compiler-options/spec-skip-macros"
                                                "warnings/private-var-access"
                                                "compiler-options/fingerprint"
                                                "warnings/non-dynamic-earmuffed-var"}},
                           "0.0-3178" {},
                           "0.0-3126" {},
                           "0.0-1424" {:added #{"compiler-options/static-fns"}},
                           "1.10.520" {},
                           "0.0-2342" {},
                           "0.0-3169" {},
                           "1.8.34" {:added #{"compiler-options/closure-output-charset"}},
                           "0.0-1885" {},
                           "1.11.132" {},
                           "1.9.227" {},
                           "0.0-1535" {},
                           "1.9.90" {:added #{"compiler-options/source-map-asset-path"}},
                           "0.0-1859" {},
                           "0.0-3308" {},
                           "1.8.51" {},
                           "0.0-3190" {},
                           "1.10.739" {},
                           "0.0-2755" {},
                           "0.0-1853" {:added #{"warnings/fn-arity"}},
                           "0.0-2197" {:added #{"compiler-options/hashbang"
                                                "compiler-options/language-out"
                                                "compiler-options/language-in"}},
                           "1.9.225" {},
                           "0.0-3291" {},
                           "1.10.238" {},
                           "0.0-2075" {},
                           "1.7.28" {},
                           "0.0-2277" {},
                           "1.9.89" {},
                           "1.10.896" {},
                           "0.0-2301" {},
                           "0.0-1909" {},
                           "1.10.63" {:added #{"repl-options/host"
                                               "compiler-options/closure-property-map-out"
                                               "repl-options/inits"
                                               "repl-options/port"
                                               "compiler-options/closure-variable-map-in"
                                               "compiler-options/closure-property-map-in"
                                               "compiler-options/stable-names"
                                               "compiler-options/ignore-js-module-exts"
                                               "compiler-options/closure-variable-map-out"},
                                      :removed #{"closure-warnings/common-js-module-load"}},
                           "0.0-3115" {:added #{"warnings/munged-namespace"
                                                "warnings/ns-var-clash"
                                                "repl-options/repl-requires"
                                                "warnings/extend-type-invalid-method-shape"}},
                           "0.0-3195" {},
                           "1.9.35" {},
                           "1.10.753" {},
                           "0.0-3153" {},
                           "1.9.226" {},
                           "1.10.866" {:added #{"closure-warnings/visibility"},
                                       :removed #{"closure-warnings/visiblity"}},
                           "0.0-3119" {},
                           "1.9.85" {:added #{"compiler-options/preloads"}},
                           "0.0-2723" {},
                           "1.9.75" {},
                           "1.10.741" {},
                           "1.9.229" {},
                           "0.0-2727" {:added #{"compiler-options/asset-path"}},
                           "0.0-3255" {},
                           "1.10.914" {},
                           "1.9.854" {:added #{"warnings/invalid-array-access"
                                               "compiler-options/checked-arrays"
                                               "compiler-options/install-deps"
                                               "compiler-options/process-shim"}},
                           "0.0-1552" {:added #{"repl-options/analyze-path"}},
                           "0.0-2080" {},
                           "0.0-2234" {},
                           "0.0-2644" {},
                           "1.10.742" {},
                           "1.10.217" {:added #{"closure-warnings/msg-conventions"
                                                "closure-warnings/misplaced-msg-annotation"
                                                "closure-warnings/jsdoc-missing-type"
                                                "closure-warnings/unnecessary-escape"
                                                "closure-warnings/strict-missing-properties"
                                                "closure-warnings/too-many-type-params"
                                                "closure-warnings/module-load"
                                                "closure-warnings/missing-sources-warnings"}},
                           "1.8.40" {},
                           "0.0-3191" {},
                           "1.11.50" {:removed #{"closure-warnings/unnecessary-escape"}},
                           "0.0-2268" {},
                           "0.0-3269" {},
                           "0.0-2511" {:added #{"compiler-options/cache-analysis"}},
                           "0.0-1806" {},
                           "0.0-3030" {:added #{"compiler-options/watch-fn"}},
                           "0.0-2341" {:added #{"warnings/protocol-multiple-impls"
                                                "warnings/protocol-duped-method"
                                                "warnings/protocol-invalid-method"}},
                           "1.10.64" {},
                           "1.9.36" {},
                           "0.0-3058" {},
                           "1.9.216" {},
                           "1.7.58" {},
                           "0.0-2629" {:added #{"warnings/redef-in-file"
                                                "compiler-options/compiler-stats"}},
                           "1.11.4" {},
                           "0.0-2719" {:added #{"repl-options/repl-verbose"}},
                           "1.12.35" {:added #{"warnings/js-used-as-alias"},
                                      :removed #{"closure-warnings/unused-private-property"}},
                           "0.0-2816" {},
                           "1.7.228" {},
                           "0.0-2227" {:added #{"compiler-options/pseudo-names"}},
                           "0.0-1576" {},
                           "0.0-3297" {},
                           "1.10.516" {},
                           "0.0-1844" {},
                           "1.9.493" {},
                           "0.0-1586" {},
                           "1.9.671" {},
                           "0.0-3123" {},
                           "1.10.597" {:added #{"warnings/protocol-with-overwriting-method"}},
                           "1.10.893" {},
                           "1.7.107" {},
                           "0.0-2498" {},
                           "1.7.48" {:added #{"warnings/unsupported-preprocess-value"}},
                           "1.10.738" {:added #{"compiler-options/bundle-cmd"
                                                "compiler-options/deps-cmd"
                                                "compiler-options/nodejs-rt"
                                                "compiler-options/target-fn"},
                                       :removed #{"closure-warnings/use-of-goog-base"
                                                  "closure-warnings/es3"
                                                  "closure-warnings/fileoverview-jsdoc"
                                                  "closure-warnings/ambiguous-function-decl"
                                                  "closure-warnings/check-eventful-object-disposal"
                                                  "closure-warnings/internet-explorer-checks"}},
                           "0.0-3117" {},
                           "0.0-2850" {:added #{"repl-options/watch"}},
                           "0.0-1443" {:added #{"compiler-options/warnings"}},
                           "0.0-1006" {},
                           "1.9.494" {},
                           "1.9.660" {:added #{"compiler-options/fn-invoke-direct"
                                               "warnings/protocol-impl-with-variadic-method"}},
                           "1.10.773" {},
                           "0.0-1913" {},
                           "0.0-2069" {},
                           "0.0-2814" {:added #{"compiler-options/recompile-dependents"
                                                "warnings/single-segment-namespace"
                                                "compiler-options/closure-extra-annotations"}},
                           "0.0-2655" {},
                           "1.7.145" {},
                           "0.0-1513" {:added #{"compiler-options/output-wrapper"}},
                           "1.11.57" {},
                           "0.0-1503" {:added #{"repl-options/src"}},
                           "1.9.946" {:added #{"compiler-options/rename-prefix-namespace"
                                               "compiler-options/rename-prefix"}},
                           "0.0-1933" {},
                           "1.9.14" {},
                           "0.0-1895" {},
                           "0.0-971" {:added #{"compiler-options/verbose"
                                               "compiler-options/libs"
                                               "repl-options/warn-on-undeclared"
                                               "compiler-options/optimizations"
                                               "compiler-options/pretty-print"
                                               "compiler-options/target"
                                               "compiler-options/use-only-custom-externs"
                                               "compiler-options/main"
                                               "compiler-options/output-dir"
                                               "compiler-options/print-input-delimiter"
                                               "compiler-options/foreign-libs"
                                               "compiler-options/externs"
                                               "repl-options/working-dir"
                                               "compiler-options/output-to"}},
                           "0.0-2027" {},
                           "0.0-1978" {},
                           "0.0-1843" {},
                           "0.0-2758" {},
                           "0.0-2913" {},
                           "0.0-1835" {:added #{"warnings/redef"
                                                "warnings/protocol-deprecated"
                                                "warnings/fn-var"
                                                "warnings/dynamic"
                                                "warnings/fn-deprecated"
                                                "warnings/undeclared"}},
                           "1.10.740" {},
                           "0.0-3264" {},
                           "1.9.655" {:added #{"warnings/protocol-impl-recur-with-target"}},
                           "0.0-3149" {},
                           "1.9.198" {},
                           "1.11.121" {},
                           "0.0-1450" {},
                           "0.0-2173" {:added #{"warnings/unprovided"}},
                           "0.0-3208" {},
                           "1.10.764" {},
                           "0.0-3263" {},
                           "1.9.473" {:added #{"closure-warnings/use-of-goog-base"
                                               "closure-warnings/extra-require"
                                               "closure-warnings/missing-provide"
                                               "closure-warnings/es3"
                                               "closure-warnings/strict-missing-require"
                                               "closure-warnings/type-invalidation"
                                               "closure-warnings/strict-requires"
                                               "closure-warnings/analyzer-checks"
                                               "closure-warnings/message-descriptions"
                                               "closure-warnings/conformance-violations"
                                               "closure-warnings/unused-private-property"
                                               "closure-warnings/missing-polyfill"
                                               "closure-warnings/missing-getcssname"
                                               "closure-warnings/j2cl-checks"
                                               "closure-warnings/common-js-module-load"
                                               "closure-warnings/missing-require"
                                               "closure-warnings/violated-module-dep"
                                               "closure-warnings/inferred-const-checks"
                                               "closure-warnings/deprecated-annotations"
                                               "closure-warnings/check-eventful-object-disposal"
                                               "closure-warnings/function-params"
                                               "closure-warnings/missing-override"
                                               "closure-warnings/unused-local-variable"
                                               "closure-warnings/lint-checks"
                                               "compiler-options/closure-generate-exports"
                                               "closure-warnings/duplicate-vars"
                                               "closure-warnings/misplaced-type-annotation"
                                               "closure-warnings/suspicious-code"
                                               "closure-warnings/missing-return"
                                               "closure-warnings/report-unknown-types"
                                               "closure-warnings/closure-dep-method-usage-checks"
                                               "closure-warnings/underscore"
                                               "closure-warnings/late-provide"}},
                           "1.7.170" {},
                           "0.0-1798" {:added #{"compiler-options/source-map"}},
                           "0.0-1877" {:added #{"compiler-options/optimize-constants"}},
                           "0.0-1211" {:added #{"repl-options/static-dir"}},
                           "1.10.145" {},
                           "0.0-1449" {},
                           "0.0-2911" {:added #{"repl-options/reader"
                                                "repl-options/init"
                                                "repl-options/read"
                                                "repl-options/flush"
                                                "repl-options/eval"
                                                "compiler-options/modules"
                                                "repl-options/caught"
                                                "repl-options/need-prompt"
                                                "repl-options/print-no-newline"
                                                "repl-options/print"
                                                "repl-options/prompt"
                                                "repl-options/source-map-inline"}},
                           "1.9.908" {:removed #{"closure-warnings/inferred-const-checks"}},
                           "0.0-993" {},
                           "0.0-1011" {},
                           "0.0-2356" {},
                           "1.7.122" {},
                           "1.10.329" {},
                           "0.0-3211" {},
                           "0.0-3053" {},
                           "0.0-2985" {:added #{"repl-options/wrap"}},
                           "1.9.183" {:added #{"compiler-options/browser-repl"}},
                           "0.0-2156" {:added #{"compiler-options/elide-asserts"}},
                           "0.0-1847" {},
                           "1.9.293" {:added #{"warnings/js-shadowed-by-local"}},
                           "1.9.542" {},
                           "1.7.189" {:added #{"compiler-options/parallel-build"}},
                           "0.0-2496" {},
                           "0.0-3196" {},
                           "1.10.879" {},
                           "1.10.758" {},
                           "0.0-927" {},
                           "0.0-1934" {},
                           "1.10.756" {},
                           "1.9.76" {},
                           "0.0-3165" {},
                           "0.0-2202" {},
                           "1.10.126" {:added #{"repl-options/launch-browser"
                                                "compiler-options/opts-cache"
                                                "compiler-options/aot-cache"}},
                           "0.0-1820" {},
                           "1.9.456" {:added #{"compiler-options/infer-externs"
                                               "compiler-options/watch-error-fn"
                                               "compiler-options/closure-module-roots"
                                               "warnings/infer-warning"
                                               "compiler-options/cache-analysis-format"}},
                           "0.0-2261" {},
                           "0.0-2024" {:added #{"warnings/extending-base-js-type"}},
                           "1.9.88" {},
                           "1.7.10" {:added #{"compiler-options/dump-core"
                                              "warnings/unsupported-js-module-type"
                                              "repl-options/def-emits-var"
                                              "compiler-options/warning-handlers"}},
                           "0.0-1889" {},
                           "0.0-2657" {},
                           "0.0-1896" {},
                           "0.0-2014" {:added #{"warnings/undeclared-var"
                                                "warnings/variadic-max-arity"
                                                "warnings/invalid-protocol-symbol"
                                                "warnings/multiple-variadic-overloads"
                                                "warnings/overload-arity"
                                                "warnings/undeclared-ns-form"
                                                "warnings/undeclared-ns"
                                                "warnings/undeclared-protocol-symbol"},
                                       :removed #{"warnings/undeclared"}},
                           "1.9.562" {:added #{"compiler-options/rewrite-polyfills"}},
                           "0.0-2411" {:added #{"compiler-options/anon-fn-naming-policy"}},
                           "0.0-2665" {},
                           "0.0-2760" {}},
                 :symbol-names #{"compiler-options/preloads"
                                 "compiler-options/closure-output-charset"
                                 "repl-options/reader"
                                 "compiler-options/infer-externs"
                                 "warnings/invoke-ctor"
                                 "closure-warnings/externs-validation"
                                 "warnings/redef"
                                 "warnings/preamble-missing"
                                 "compiler-options/watch-error-fn"
                                 "repl-options/init"
                                 "closure-warnings/duplicate-message"
                                 "closure-warnings/tweaks"
                                 "closure-warnings/es5-strict"
                                 "warnings/protocol-deprecated"
                                 "closure-warnings/msg-conventions"
                                 "closure-warnings/use-of-goog-base"
                                 "closure-warnings/visibility"
                                 "closure-warnings/check-types"
                                 "closure-warnings/extra-require"
                                 "warnings/protocol-multiple-impls"
                                 "compiler-options/verbose"
                                 "closure-warnings/misplaced-msg-annotation"
                                 "closure-warnings/undefined-variables"
                                 "compiler-options/browser-repl"
                                 "compiler-options/libs"
                                 "repl-options/read"
                                 "closure-warnings/missing-provide"
                                 "closure-warnings/es3"
                                 "compiler-options/pseudo-names"
                                 "compiler-options/spec-skip-macros"
                                 "compiler-options/bundle-cmd"
                                 "closure-warnings/strict-missing-require"
                                 "closure-warnings/const"
                                 "warnings/munged-namespace"
                                 "warnings/js-shadowed-by-local"
                                 "repl-options/bind-err"
                                 "repl-options/host"
                                 "closure-warnings/type-invalidation"
                                 "repl-options/warn-on-undeclared"
                                 "compiler-options/optimizations"
                                 "warnings/redef-in-file"
                                 "closure-warnings/jsdoc-missing-type"
                                 "compiler-options/static-fns"
                                 "closure-warnings/strict-requires"
                                 "compiler-options/pretty-print"
                                 "repl-options/flush"
                                 "compiler-options/watch-fn"
                                 "compiler-options/npm-deps"
                                 "compiler-options/deps-cmd"
                                 "compiler-options/target"
                                 "closure-warnings/access-controls"
                                 "compiler-options/closure-module-roots"
                                 "warnings/invalid-array-access"
                                 "warnings/undeclared-var"
                                 "repl-options/src"
                                 "closure-warnings/fileoverview-jsdoc"
                                 "warnings/extending-base-js-type"
                                 "closure-warnings/debugger-statement-present"
                                 "repl-options/watch"
                                 "compiler-options/dump-core"
                                 "compiler-options/parallel-build"
                                 "closure-warnings/undefined-names"
                                 "closure-warnings/analyzer-checks"
                                 "closure-warnings/message-descriptions"
                                 "compiler-options/asset-path"
                                 "closure-warnings/missing-properties"
                                 "closure-warnings/unnecessary-escape"
                                 "closure-warnings/conformance-violations"
                                 "closure-warnings/ambiguous-function-decl"
                                 "compiler-options/closure-property-map-out"
                                 "repl-options/eval"
                                 "closure-warnings/unused-private-property"
                                 "warnings/variadic-max-arity"
                                 "compiler-options/preamble"
                                 "closure-warnings/check-regexp"
                                 "closure-warnings/missing-polyfill"
                                 "compiler-options/closure-warnings"
                                 "closure-warnings/missing-getcssname"
                                 "compiler-options/nodejs-rt"
                                 "repl-options/launch-browser"
                                 "compiler-options/modules"
                                 "warnings/invalid-protocol-symbol"
                                 "compiler-options/fn-invoke-direct"
                                 "warnings/fn-arity"
                                 "compiler-options/use-only-custom-externs"
                                 "repl-options/inits"
                                 "compiler-options/recompile-dependents"
                                 "closure-warnings/check-useless-code"
                                 "compiler-options/elide-strict"
                                 "repl-options/caught"
                                 "compiler-options/target-fn"
                                 "warnings/ns-var-clash"
                                 "compiler-options/rewrite-polyfills"
                                 "warnings/protocol-duped-method"
                                 "repl-options/need-prompt"
                                 "closure-warnings/j2cl-checks"
                                 "warnings/multiple-variadic-overloads"
                                 "repl-options/port"
                                 "compiler-options/hashbang"
                                 "closure-warnings/strict-module-dep-check"
                                 "compiler-options/warnings"
                                 "closure-warnings/common-js-module-load"
                                 "compiler-options/main"
                                 "closure-warnings/missing-require"
                                 "closure-warnings/violated-module-dep"
                                 "repl-options/print-no-newline"
                                 "closure-warnings/inferred-const-checks"
                                 "closure-warnings/non-standard-jsdoc"
                                 "closure-warnings/strict-missing-properties"
                                 "warnings/invalid-arithmetic"
                                 "compiler-options/package-json-resolution"
                                 "warnings/unsupported-preprocess-value"
                                 "compiler-options/output-dir"
                                 "warnings/protocol-with-variadic-method"
                                 "warnings/overload-arity"
                                 "compiler-options/closure-variable-map-in"
                                 "compiler-options/source-map"
                                 "repl-options/repl-requires"
                                 "closure-warnings/deprecated-annotations"
                                 "warnings/fn-var"
                                 "warnings/unsupported-js-module-type"
                                 "repl-options/quit-prompt"
                                 "compiler-options/opts-cache"
                                 "warnings/declared-arglists-mismatch"
                                 "compiler-options/anon-fn-naming-policy"
                                 "warnings/dynamic"
                                 "warnings/single-segment-namespace"
                                 "warnings/undeclared-ns-form"
                                 "closure-warnings/check-variables"
                                 "compiler-options/optimize-constants"
                                 "compiler-options/aot-cache"
                                 "closure-warnings/check-eventful-object-disposal"
                                 "repl-options/analyze-path"
                                 "compiler-options/source-map-path"
                                 "warnings/protocol-impl-recur-with-target"
                                 "compiler-options/checked-arrays"
                                 "compiler-options/print-input-delimiter"
                                 "repl-options/def-emits-var"
                                 "compiler-options/closure-defines"
                                 "closure-warnings/function-params"
                                 "closure-warnings/visiblity"
                                 "closure-warnings/internet-explorer-checks"
                                 "closure-warnings/missing-override"
                                 "repl-options/print"
                                 "warnings/extend-type-invalid-method-shape"
                                 "warnings/protocol-impl-with-variadic-method"
                                 "compiler-options/closure-property-map-in"
                                 "compiler-options/foreign-libs"
                                 "compiler-options/source-map-asset-path"
                                 "repl-options/compiler-env"
                                 "compiler-options/externs"
                                 "closure-warnings/global-this"
                                 "closure-warnings/unused-local-variable"
                                 "compiler-options/rename-prefix-namespace"
                                 "closure-warnings/deprecated"
                                 "compiler-options/language-out"
                                 "repl-options/prompt"
                                 "closure-warnings/lint-checks"
                                 "compiler-options/closure-generate-exports"
                                 "closure-warnings/duplicate-vars"
                                 "warnings/unprovided"
                                 "warnings/private-var-access"
                                 "compiler-options/install-deps"
                                 "warnings/fn-deprecated"
                                 "repl-options/wrap"
                                 "warnings/protocol-with-overwriting-method"
                                 "warnings/js-used-as-alias"
                                 "closure-warnings/misplaced-type-annotation"
                                 "warnings/undeclared"
                                 "warnings/undeclared-ns"
                                 "compiler-options/cache-analysis"
                                 "compiler-options/rename-prefix"
                                 "compiler-options/warning-handlers"
                                 "warnings/protocol-invalid-method"
                                 "warnings/infer-warning"
                                 "compiler-options/language-in"
                                 "compiler-options/stable-names"
                                 "compiler-options/fingerprint"
                                 "compiler-options/ignore-js-module-exts"
                                 "compiler-options/output-wrapper"
                                 "repl-options/static-dir"
                                 "closure-warnings/suspicious-code"
                                 "closure-warnings/missing-return"
                                 "compiler-options/elide-asserts"
                                 "closure-warnings/report-unknown-types"
                                 "warnings/undeclared-protocol-symbol"
                                 "repl-options/working-dir"
                                 "compiler-options/source-map-timestamp"
                                 "warnings/non-dynamic-earmuffed-var"
                                 "closure-warnings/closure-dep-method-usage-checks"
                                 "compiler-options/compiler-stats"
                                 "compiler-options/process-shim"
                                 "closure-warnings/constant-property"
                                 "compiler-options/closure-variable-map-out"
                                 "closure-warnings/too-many-type-params"
                                 "closure-warnings/module-load"
                                 "closure-warnings/unknown-defines"
                                 "repl-options/source-map-inline"
                                 "closure-warnings/underscore"
                                 "closure-warnings/late-provide"
                                 "compiler-options/closure-extra-annotations"
                                 "closure-warnings/invalid-casts"
                                 "compiler-options/output-to"
                                 "compiler-options/cache-analysis-format"
                                 "repl-options/repl-verbose"
                                 "closure-warnings/missing-sources-warnings"},
                 :namespace-names #{"closure-warnings"
                                    "repl-options"
                                    "warnings"
                                    "compiler-options"}},
       :library {:changes {"1.10.339" {},
                           "0.0-2030" {},
                           "0.0-2067" {},
                           "1.9.521" {},
                           "0.0-2134" {:added #{"cljs.core/clone"
                                                "cljs.core/ICloneable"}},
                           "0.0-2322" {},
                           "1.10.891" {:added #{"cljs.core/LongImpl"}},
                           "1.10.335" {},
                           "1.10.844" {:added #{"cljs.core/IntegerRange"
                                                "cljs.core/--destructure-map"
                                                "cljs.core/IntegerRangeChunk"
                                                "cljs.core/js-fn?"},
                                       :removed #{"cljs.core/RangeChunk"}},
                           "0.0-1803" {:added #{"cljs.core/special-symbol?"
                                                "cljs.core/lazy-cat"}},
                           "0.0-2371" {:added #{"cljs.core/RangeIterator"
                                                "cljs.core/es6-set-entries-iterator"
                                                "cljs.core/es6-entries-iterator"
                                                "cljs.core/PersistentArrayMapIterator"
                                                "cljs.core/ES6EntriesIterator"
                                                "cljs.core/IndexedSeqIterator"
                                                "cljs.core/RangedIterator"
                                                "cljs.core/es6-iterator"
                                                "cljs.core/eduction"
                                                "cljs.core/ES6Iterator"
                                                "cljs.core/Eduction"
                                                "cljs.core/ES6SetEntriesIterator"
                                                "cljs.core/ranged-iterator"},
                                       :removed #{"cljs.core/iterator"
                                                  "cljs.core/SetEntriesIterator"
                                                  "cljs.core/EntriesIterator"
                                                  "cljs.core/Iteration"
                                                  "cljs.core/iteration"
                                                  "cljs.core/set-entries-iterator"
                                                  "cljs.core/entries-iterator"
                                                  "cljs.core/Iterator"}},
                           "0.0-2307" {},
                           "0.0-3148" {:added #{"cljs.repl/err-out"}},
                           "0.0-1886" {},
                           "0.0-2138" {:added #{"cljs.core/specify"}},
                           "1.11.60" {},
                           "0.0-2505" {},
                           "0.0-2311" {},
                           "1.9.92" {},
                           "0.0-2740" {},
                           "1.12.38" {},
                           "0.0-2725" {},
                           "1.9.211" {},
                           "1.10.312" {:removed #{"cljs.repl/err-out"}},
                           "0.0-2127" {},
                           "0.0-2843" {},
                           "0.0-2280" {},
                           "1.9.518" {:added #{"cljs.core/IFind"
                                               "cljs.core/ifind?"}},
                           "1.10.191" {:added #{"cljs.core/*eval*"
                                                "cljs.core/eval"}},
                           "1.7.166" {},
                           "0.0-2199" {},
                           "1.11.54" {},
                           "1.10.514" {:added #{"cljs.spec.test.alpha/validate-check-opts"
                                                "clojure.datafy/nav"
                                                "cljs.repl/Error->map"
                                                "clojure.core.protocols/Datafiable"
                                                "clojure.core.protocols/Navigable"
                                                "clojure.datafy/datafy"
                                                "clojure.edn/read"
                                                "clojure.edn/read-string"
                                                "cljs.repl/error->str"
                                                "cljs.repl/ex-triage"
                                                "cljs.repl/ex-str"
                                                "cljs.core/RangeChunk"},
                                       :removed #{"cljs.spec.alpha/fn-sym"}},
                           "0.0-2120" {:added #{"cljs.core/print-map"
                                                "cljs.core/sorted?"
                                                "cljs.core/*print-level*"
                                                "clojure.core.reducers/CollFold"
                                                "cljs.core/sequence"
                                                "cljs.core/object?"}},
                           "1.9.93" {},
                           "1.9.495" {},
                           "1.10.748" {},
                           "0.0-1878" {},
                           "0.0-1236" {:added #{"clojure.core.reducers/drop"
                                                "clojure.core.reducers/folder"
                                                "clojure.core.reducers/Cat"
                                                "clojure.core.reducers/foldcat"
                                                "clojure.core.reducers/fold"
                                                "clojure.core.reducers/monoid"
                                                "clojure.core.reducers/map"
                                                "clojure.core.reducers/cat"
                                                "clojure.core.reducers/take"
                                                "cljs.reader/maybe-read-tagged-type"
                                                "clojure.core.reducers/reduce"
                                                "cljs.core/letfn*"
                                                "clojure.core.reducers/flatten"
                                                "cljs.reader/*tag-table*"
                                                "clojure.core.reducers/filter"
                                                "cljs.core/simple-benchmark"
                                                "clojure.core.reducers/append!"
                                                "clojure.core.reducers/reducer"
                                                "clojure.core.reducers/take-while"
                                                "cljs.reader/register-tag-parser!"
                                                "clojure.core.reducers/remove"
                                                "cljs.reader/read-string*"
                                                "clojure.core.reducers/mapcat"}},
                           "0.0-2060" {:added #{"cljs.core/enable-console-print!"
                                                "cljs.core/*print-length*"
                                                "cljs.core/*print-newline*"}},
                           "1.11.51" {},
                           "1.10.439" {:added #{"cljs.spec.test.alpha/enumerate-namespace"
                                                "cljs.spec.alpha/fn-sym"
                                                "cljs.spec.gen.alpha/shuffle"}},
                           "0.0-3178" {:added #{"cljs.core/array-index-of"}},
                           "0.0-3126" {},
                           "0.0-1424" {:added #{"cljs.core/Box"
                                                "cljs.core/array-chunk"
                                                "cljs.core/string-hash-cache"
                                                "cljs.reader/read-2-chars"
                                                "cljs.core/chunk"
                                                "cljs.core/chunk-next"
                                                "cljs.reader/make-unicode-char"
                                                "cljs.core/shuffle"
                                                "cljs.core/ArrayChunk"
                                                "cljs.core/chunk-cons"
                                                "cljs.core/chunked-seq"
                                                "cljs.reader/unicode-4-pattern"
                                                "cljs.core/IComparable"
                                                "cljs.reader/unicode-2-pattern"
                                                "cljs.core/check-string-hash-cache"
                                                "cljs.core/Keyword"
                                                "cljs.core/key-test"
                                                "cljs.core/IChunkedSeq"
                                                "cljs.core/chunk-append"
                                                "cljs.core/regexp?"
                                                "cljs.reader/read-4-chars"
                                                "cljs.core/UUID"
                                                "cljs.reader/deregister-tag-parser!"
                                                "cljs.core/INext"
                                                "cljs.core/RSeq"
                                                "cljs.core/add-to-string-hash-cache"
                                                "cljs.core/chunk-buffer"
                                                "cljs.core/IChunkedNext"
                                                "cljs.core/ChunkBuffer"
                                                "cljs.core/chunked-seq?"
                                                "cljs.reader/validate-unicode-escape"
                                                "cljs.core/string-hash-cache-count"
                                                "cljs.core/IChunk"
                                                "cljs.reader/parse-timestamp"
                                                "cljs.core/chunk-first"
                                                "cljs.core/ChunkedSeq"
                                                "cljs.core/chunk-rest"
                                                "cljs.core/ChunkedCons"},
                                       :removed #{"cljs.core/vector-seq"
                                                  "cljs.reader/read-unicode-char"}},
                           "1.10.520" {},
                           "0.0-2342" {},
                           "0.0-3169" {:added #{"cljs.core/ns-unmap"}},
                           "1.8.34" {},
                           "0.0-1885" {:removed #{"cljs.core/printf"
                                                  "cljs.core/format"}},
                           "1.11.132" {:added #{"cljs.core/hash-long"
                                                "cljs.core/hash-double"}},
                           "1.9.227" {},
                           "0.0-1535" {:added #{"cljs.core/with-out-str"}},
                           "1.9.90" {},
                           "0.0-1859" {:added #{"cljs.core/type->str"}},
                           "0.0-3308" {:added #{"cljs.core/random-uuid"}},
                           "1.8.51" {:added #{"cljs.test/assert-predicate"
                                              "cljs.test/function?"
                                              "cljs.test/assert-any"
                                              "cljs.test/assert-expr"
                                              "cljs.test/ns?"}},
                           "0.0-3190" {},
                           "1.10.739" {},
                           "0.0-2755" {},
                           "0.0-1853" {:added #{"cljs.reader/parse-and-validate-timestamp"}},
                           "0.0-2197" {},
                           "1.9.225" {},
                           "0.0-3291" {:added #{"cljs.core/uuid"}},
                           "1.10.238" {},
                           "0.0-2075" {},
                           "1.7.28" {:added #{"cljs.core/RecordIter"
                                              "cljs.core/HashMapIter"
                                              "cljs.core/HashSetIter"
                                              "cljs.core/PersistentQueueIter"
                                              "cljs.core/NodeIterator"
                                              "cljs.js/compile-str"
                                              "cljs.js/analyze-str"
                                              "cljs.core/ArrayNodeIterator"},
                                     :removed #{"cljs.js/sm-data"
                                                "cljs.js/append-source-map"
                                                "cljs.js/analyze"
                                                "cljs.js/compile*"
                                                "cljs.js/analyze*"
                                                "cljs.js/load-macros"
                                                "cljs.js/load-deps"
                                                "cljs.js/eval-str*"
                                                "cljs.js/ns-side-effects"
                                                "cljs.js/wrap-error"
                                                "cljs.js/eval*"
                                                "cljs.js/compile"
                                                "cljs.js/prefix"
                                                "cljs.js/analyze-deps"}},
                           "0.0-2277" {:removed #{"cljs.core/unchecked-substract-int"
                                                  "cljs.core/unchecked-substract"}},
                           "1.9.89" {},
                           "1.10.896" {},
                           "0.0-2301" {:added #{"cljs.core/LazyTransformer.createMulti"
                                                "cljs.core/flatmap"
                                                "cljs.core/ArrayList"
                                                "cljs.core/stepper"
                                                "cljs.core/LazyTransformer.create"
                                                "cljs.core/ArrayIter"
                                                "cljs.core/PersistentArrayMap.HASHMAP-THRESHOLD"
                                                "cljs.core/LazyTransformer"
                                                "cljs.core/dedupe"
                                                "cljs.core/string-iter"
                                                "cljs.core/run!"
                                                "cljs.core/lazy-transformer"
                                                "cljs.core/random-sample"
                                                "cljs.core/iter"
                                                "cljs.core/multi-stepper"
                                                "cljs.core/Iteration"
                                                "cljs.core/PersistentVector.EMPTY-NODE"
                                                "clojure.browser.event/IEventType"
                                                "cljs.core/SeqIter"
                                                "cljs.core/Stepper"
                                                "cljs.core/transduce"
                                                "cljs.core/iteration"
                                                "cljs.core/array-iter"
                                                "cljs.core/array-list"
                                                "cljs.core/nil-iter"
                                                "cljs.core/StringIter"
                                                "cljs.core/MultiStepper"
                                                "cljs.core/seq-iter"},
                                       :removed #{"cljs.core/PersistentVector.EMPTY_NODE"
                                                  "cljs.core/PersistentArrayMap.HASHMAP_THRESHOLD"
                                                  "clojure.browser.event/EventType"}},
                           "0.0-1909" {},
                           "1.10.63" {:added #{"cljs.core/remove-tap"
                                               "cljs.core/Repeat"
                                               "clojure.browser.repl/PORT"
                                               "cljs.core/Iterate"
                                               "cljs.core/tap>"
                                               "cljs.core/map-entry?"
                                               "cljs.core/add-tap"
                                               "clojure.browser.repl/HOST"
                                               "cljs.core/Cycle"
                                               "cljs.core/*exec-tap-fn*"}},
                           "0.0-3115" {:added #{"clojure.browser.repl/bootstrap"
                                                "clojure.browser.repl/load-queue"}},
                           "0.0-3195" {},
                           "1.9.35" {},
                           "1.10.753" {},
                           "0.0-3153" {},
                           "1.9.226" {},
                           "1.10.866" {},
                           "0.0-3119" {},
                           "1.9.85" {:added #{"cljs.spec/every"
                                              "cljs.spec/every-kv"
                                              "cljs.core/bounded-count"
                                              "cljs.spec/*coll-error-limit*"
                                              "cljs.spec.impl.gen/vector-distinct"
                                              "cljs.spec/MAX_INT"}},
                           "0.0-2723" {},
                           "1.9.75" {:added #{"cljs.spec/int-in"
                                              "cljs.spec.impl.gen/large-integer*"
                                              "cljs.core/pos-int?"
                                              "cljs.core/simple-keyword?"
                                              "cljs.spec/int-in-range?"
                                              "cljs.core/boolean?"
                                              "cljs.spec/unform"
                                              "cljs.core/uuid?"
                                              "cljs.spec/get-spec"
                                              "cljs.core/qualified-keyword?"
                                              "cljs.core/Inst"
                                              "cljs.core/ident?"
                                              "cljs.core/simple-symbol?"
                                              "cljs.core/simple-ident?"
                                              "cljs.core/inst?"
                                              "cljs.core/qualified-symbol?"
                                              "cljs.core/IUUID"
                                              "cljs.core/neg-int?"
                                              "cljs.core/int?"
                                              "cljs.core/nat-int?"
                                              "cljs.core/inst-ms"
                                              "cljs.spec/inst-in-range?"
                                              "cljs.core/qualified-ident?"
                                              "cljs.spec/inst-in"
                                              "cljs.spec/explain-out"},
                                     :removed #{"cljs.spec/fn-specs"}},
                           "1.10.741" {},
                           "1.9.229" {},
                           "0.0-2727" {},
                           "0.0-3255" {:added #{"cljs.pprint/write-out"
                                                "cljs.pprint/cl-format"
                                                "cljs.core/tagged-literal?"
                                                "cljs.pprint/get-pretty-writer"
                                                "cljs.pprint/write"
                                                "cljs.pprint/char-code"
                                                "cljs.pprint/simple-dispatch"
                                                "cljs.core/var?"
                                                "cljs.pprint/fresh-line"
                                                "cljs.pprint/pprint-set"
                                                "cljs.pprint/deftype"
                                                "cljs.pprint/with-pretty-writer"
                                                "cljs.pprint/setf"
                                                "cljs.pprint/float?"
                                                "cljs.pprint/*print-base*"
                                                "cljs.pprint/pprint-newline"
                                                "cljs.core/tagged-literal"
                                                "cljs.pprint/*print-suppress-namespaces*"
                                                "cljs.pprint/set-pprint-dispatch"
                                                "cljs.pprint/with-pprint-dispatch"
                                                "cljs.pprint/*print-radix*"
                                                "cljs.pprint/pprint"
                                                "cljs.pprint/getf"
                                                "cljs.pprint/formatter-out"
                                                "cljs.pprint/pp"
                                                "cljs.pprint/formatter"
                                                "cljs.pprint/*print-pretty*"
                                                "cljs.pprint/pprint-tab"
                                                "cljs.pprint/*print-pprint-dispatch*"
                                                "cljs.pprint/pprint-indent"
                                                "cljs.pprint/print-length-loop"
                                                "cljs.core/record?"
                                                "cljs.pprint/code-dispatch"
                                                "cljs.pprint/IPrettyFlush"
                                                "cljs.pprint/print-table"
                                                "cljs.pprint/*print-miser-width*"
                                                "cljs.pprint/*print-right-margin*"
                                                "cljs.pprint/pprint-logical-block"
                                                "cljs.core/TaggedLiteral"
                                                "cljs.pprint/*out*"},
                                       :removed #{"cljs.pprint/PrettyFlush"}},
                           "1.10.914" {},
                           "1.9.854" {:added #{"cljs.core/unchecked-set"
                                               "cljs.core/ns-publics"
                                               "cljs.core/MODULE_URIS"
                                               "cljs.core/unchecked-get"
                                               "cljs.core/*command-line-args*"
                                               "cljs.core/*print-fn-bodies*"
                                               "cljs.core/*unchecked-arrays*"
                                               "cljs.core/ns-imports"
                                               "cljs.core/MODULE_INFOS"},
                                      :removed #{"cljs.reader/dispatch-macros"
                                                 "cljs.reader/read-literal"
                                                 "cljs.reader/escape-char-map"
                                                 "cljs.reader/read-comment"
                                                 "cljs.reader/read-number"
                                                 "cljs.reader/read-past"
                                                 "cljs.reader/macro-terminating?"
                                                 "cljs.reader/read-2-chars"
                                                 "cljs.reader/make-unicode-char"
                                                 "cljs.reader/desugar-meta"
                                                 "cljs.reader/read-symbol"
                                                 "cljs.reader/push-back-reader"
                                                 "cljs.reader/read-list"
                                                 "cljs.reader/read-vector"
                                                 "cljs.reader/int-pattern"
                                                 "cljs.reader/read-token"
                                                 "cljs.reader/read-dispatch"
                                                 "cljs.reader/wrapping-reader"
                                                 "cljs.reader/macros"
                                                 "cljs.reader/unicode-4-pattern"
                                                 "cljs.reader/unicode-2-pattern"
                                                 "cljs.reader/maybe-read-tagged-type"
                                                 "cljs.reader/ratio-pattern"
                                                 "cljs.reader/read-4-chars"
                                                 "cljs.reader/escape-char"
                                                 "cljs.reader/read-raw-string*"
                                                 "cljs.reader/read-map"
                                                 "cljs.reader/read-regex"
                                                 "cljs.reader/symbol-pattern"
                                                 "cljs.reader/read-delimited-list"
                                                 "cljs.reader/read-set"
                                                 "cljs.reader/throwing-reader"
                                                 "cljs.reader/reader-error"
                                                 "cljs.reader/not-implemented"
                                                 "cljs.reader/read-discard"
                                                 "cljs.reader/float-pattern"
                                                 "cljs.reader/PushbackReader"
                                                 "cljs.reader/special-symbols"
                                                 "cljs.reader/validate-unicode-escape"
                                                 "cljs.reader/read-unmatched-delimiter"
                                                 "cljs.reader/StringPushbackReader"
                                                 "cljs.reader/read-meta"
                                                 "cljs.reader/read-keyword"
                                                 "cljs.reader/skip-line"
                                                 "cljs.reader/read-string*"}},
                           "0.0-1552" {:added #{"cljs.core/Fn"
                                                "cljs.core/IEncodeJS"
                                                "cljs.core/js-mod"
                                                "cljs.core/IEncodeClojure"
                                                "cljs.core/clj->js"}},
                           "0.0-2080" {:added #{"cljs.core/unsigned-bit-shift-right"}},
                           "0.0-2234" {:added #{"cljs.core/MetaFn"}},
                           "0.0-2644" {},
                           "1.10.742" {},
                           "1.10.217" {:added #{"clojure.browser.repl/*repl*"}},
                           "1.8.40" {},
                           "0.0-3191" {},
                           "1.11.50" {:added #{"cljs.core/NaN?"
                                               "cljs.math/E"
                                               "cljs.core/parse-uuid"
                                               "cljs.math/next-after"
                                               "cljs.math/floor-mod"
                                               "cljs.math/floor"
                                               "cljs.math/to-degrees"
                                               "cljs.math/copy-sign"
                                               "cljs.math/exp"
                                               "cljs.math/next-down"
                                               "cljs.math/rint"
                                               "cljs.math/acos"
                                               "cljs.math/decrement-exact"
                                               "cljs.math/to-radians"
                                               "cljs.math/tanh"
                                               "cljs.math/pow"
                                               "cljs.math/log"
                                               "cljs.math/IEEE-remainder"
                                               "cljs.math/random"
                                               "cljs.math/scalb"
                                               "cljs.math/expm1"
                                               "cljs.math/signum"
                                               "cljs.math/ceil"
                                               "cljs.math/log1p"
                                               "cljs.core/iteration"
                                               "cljs.math/negate-exact"
                                               "cljs.core/parse-boolean"
                                               "cljs.core/update-vals"
                                               "cljs.math/hypot"
                                               "cljs.math/atan"
                                               "cljs.core/PersistentArrayMap.createAsIfByAssocComplexPath"
                                               "cljs.core/update-keys"
                                               "cljs.math/increment-exact"
                                               "cljs.math/cbrt"
                                               "cljs.math/round"
                                               "cljs.math/subtract-exact"
                                               "cljs.math/add-exact"
                                               "cljs.math/log10"
                                               "cljs.math/sinh"
                                               "cljs.math/floor-div"
                                               "cljs.math/tan"
                                               "cljs.math/ulp"
                                               "cljs.math/next-up"
                                               "cljs.core/seq-to-map-for-destructuring"
                                               "cljs.math/sin"
                                               "cljs.math/multiply-exact"
                                               "cljs.core/abs"
                                               "cljs.math/cos"
                                               "cljs.math/atan2"
                                               "cljs.math/sqrt"
                                               "cljs.core/parse-long"
                                               "cljs.math/asin"
                                               "cljs.math/get-exponent"
                                               "cljs.math/cosh"
                                               "cljs.core/parse-double"
                                               "cljs.math/PI"}},
                           "0.0-2268" {:added #{"cljs.core/iterator"
                                                "cljs.core/SetEntriesIterator"
                                                "cljs.core/EntriesIterator"
                                                "cljs.core/set-entries-iterator"
                                                "cljs.core/entries-iterator"
                                                "cljs.core/Iterator"}},
                           "0.0-3269" {},
                           "0.0-2511" {},
                           "0.0-1806" {:added #{"cljs.core/with-redefs"
                                                "cljs.core/pr-str*"}},
                           "0.0-3030" {},
                           "0.0-2341" {:added #{"cljs.core/js-str"
                                                "cljs.core/cat"
                                                "cljs.core/completing"},
                                       :removed #{"cljs.core/flatmap"}},
                           "1.10.64" {},
                           "1.9.36" {},
                           "0.0-3058" {:added #{"clojure.browser.repl/get-ua-product"}},
                           "1.9.216" {:added #{"cljs.spec/*compile-asserts*"
                                               "cljs.spec/assert*"
                                               "cljs.spec.impl.gen/double*"
                                               "cljs.spec/check-asserts?"
                                               "cljs.spec/check-asserts"
                                               "cljs.spec/assert"}},
                           "1.7.58" {},
                           "0.0-2629" {:added #{"cljs.test/are"
                                                "cljs.core/require"}},
                           "1.11.4" {},
                           "0.0-2719" {:added #{"cljs.repl/with-read-known"
                                                "cljs.core/PersistentHashMap.fromArray"
                                                "cljs.core/load-file*"}},
                           "1.12.35" {},
                           "0.0-2816" {},
                           "1.7.228" {},
                           "0.0-2227" {:added #{"cljs.core/case*"}},
                           "0.0-1576" {:added #{"cljs.core/ex-message"
                                                "cljs.reader/deregister-default-tag-parser!"
                                                "cljs.core/ex-data"
                                                "cljs.core/ex-info"
                                                "cljs.reader/*default-data-reader-fn*"
                                                "cljs.core/ExceptionInfo"
                                                "cljs.reader/register-default-tag-parser!"
                                                "cljs.core/ex-cause"}},
                           "0.0-3297" {},
                           "1.10.516" {},
                           "0.0-1844" {},
                           "1.9.493" {:removed #{"cljs.core/js-str"
                                                 "cljs.core/js-arguments"
                                                 "cljs.core/coercive-boolean"
                                                 "cljs.core/coercive-not"
                                                 "cljs.core/mask"
                                                 "cljs.core/es6-iterable"
                                                 "cljs.core/truth_"
                                                 "cljs.core/js-in"
                                                 "cljs.core/coercive-not="
                                                 "cljs.core/unsafe-bit-and"
                                                 "cljs.core/js-debugger"
                                                 "cljs.core/js-comment"
                                                 "cljs.core/js-inline-comment"
                                                 "cljs.core/copy-arguments"
                                                 "cljs.core/bitpos"
                                                 "cljs.core/unsafe-cast"
                                                 "cljs.core/coercive-="
                                                 "cljs.core/gen-apply-to"
                                                 "cljs.core/caching-hash"
                                                 "cljs.core/load-file*"}},
                           "0.0-1586" {:added #{"cljs.core/comparator"}},
                           "1.9.671" {},
                           "0.0-3123" {},
                           "1.10.597" {},
                           "1.10.893" {},
                           "1.7.107" {:added #{"cljs.reader/read-literal"
                                               "cljs.core/js-comment"
                                               "cljs.core/js-inline-comment"
                                               "cljs.core/unsafe-cast"}},
                           "0.0-2498" {:added #{"cljs.test/use-fixtures"}},
                           "1.7.48" {:added #{"clojure.browser.repl/print-queue"
                                              "clojure.browser.repl/flush-print-queue!"
                                              "cljs.core/goog-define"},
                                     :removed #{"cljs.js/debug-prn"
                                                "cljs.js/valid-opts?"
                                                "cljs.js/atom?"
                                                "cljs.js/valid-name?"}},
                           "1.10.738" {:added #{"cljs.core/*global*"
                                                "cljs.core/js-symbol?"
                                                "cljs.core/js-iterable?"}},
                           "0.0-3117" {},
                           "0.0-2850" {},
                           "0.0-1443" {:added #{"cljs.core/printf"
                                                "cljs.core/format"
                                                "cljs.core/obj-map"
                                                "cljs.core/memfn"
                                                "cljs.core/PersistentHashSet.fromArray"
                                                "cljs.core/hash-set"}},
                           "0.0-1006" {:added #{"cljs.core/PersistentVector.EMPTY_NODE"
                                                "cljs.core/PersistentVector.fromArray"
                                                "cljs.core/PersistentVector"
                                                "cljs.core/PersistentVector.EMPTY"}},
                           "1.9.494" {:added #{"cljs.core/js-arguments"
                                               "cljs.core/coercive-boolean"
                                               "cljs.core/coercive-not"
                                               "cljs.core/mask"
                                               "cljs.core/truth_"
                                               "cljs.core/coercive-not="
                                               "cljs.core/unsafe-bit-and"
                                               "cljs.core/bitpos"
                                               "cljs.core/coercive-="
                                               "cljs.core/caching-hash"
                                               "cljs.core/load-file*"}},
                           "1.9.660" {},
                           "1.10.773" {},
                           "0.0-1913" {},
                           "0.0-2069" {},
                           "0.0-2814" {:added #{"cljs.test/test-vars-block"
                                                "cljs.test/run-block"
                                                "cljs.test/test-all-vars-block"
                                                "cljs.test/async?"
                                                "cljs.test/IAsyncTest"
                                                "cljs.test/block"
                                                "cljs.test/run-tests-block"
                                                "cljs.test/async"
                                                "cljs.test/get-and-clear-env!"
                                                "cljs.core/*e"
                                                "cljs.test/test-ns-block"
                                                "cljs.test/test-var-block"}},
                           "0.0-2655" {:added #{"cljs.core/*loaded-libs*"}},
                           "1.7.145" {:added #{"clojure.string/index-of"
                                               "clojure.string/last-index-of"
                                               "cljs.core/system-time"
                                               "clojure.string/starts-with?"
                                               "clojure.string/ends-with?"
                                               "clojure.string/includes?"}},
                           "0.0-1513" {},
                           "1.11.57" {},
                           "0.0-1503" {:added #{"clojure.data/EqualityPartition"
                                                "clojure.reflect/meta"
                                                "cljs.core/write-all"
                                                "cljs.core/pr-sequential-writer"
                                                "cljs.core/StringBufferWriter"
                                                "clojure.reflect/macroexpand"
                                                "cljs.core/pr-seq-writer"
                                                "clojure.reflect/print-doc"
                                                "clojure.reflect/doc"
                                                "cljs.core/IWriter"
                                                "clojure.data/Diff"
                                                "clojure.data/diff"
                                                "cljs.core/IPrintWithWriter"},
                                       :removed #{"cljs.core/pr-with-opts"}},
                           "1.9.946" {:added #{"cljs.core/reset-vals!"
                                               "cljs.core/uri?"
                                               "cljs.core/swap-vals!"}},
                           "0.0-1933" {:removed #{"cljs.core/try*"}},
                           "1.9.14" {:added #{"cljs.spec.impl.gen/one-of"
                                              "cljs.spec.impl.gen/char-alpha"
                                              "cljs.spec.impl.gen/large-integer"
                                              "cljs.spec/describe"
                                              "cljs.spec.impl.gen/such-that"
                                              "cljs.spec.impl.gen/list"
                                              "cljs.spec.impl.gen/int"
                                              "cljs.spec.impl.gen/boolean"
                                              "cljs.spec/*fspec-iterations*"
                                              "cljs.spec.impl.gen/tuple"
                                              "cljs.spec.impl.gen/ratio"
                                              "cljs.spec/exercise"
                                              "cljs.spec/cat"
                                              "cljs.spec/unstrument"
                                              "cljs.spec.impl.gen/elements"
                                              "cljs.spec.impl.gen/symbol"
                                              "cljs.spec/or"
                                              "cljs.spec.impl.gen/gen-for-pred"
                                              "cljs.spec.impl.gen/uuid"
                                              "cljs.spec/*coll-check-limit*"
                                              "cljs.spec/conform"
                                              "cljs.spec.impl.gen/bind"
                                              "cljs.spec/form"
                                              "cljs.spec/*"
                                              "cljs.spec.impl.gen/vector"
                                              "cljs.spec/valid?"
                                              "cljs.spec/with-gen"
                                              "cljs.spec/explain-str"
                                              "cljs.spec/coll-of"
                                              "cljs.spec/instrument-ns"
                                              "cljs.spec/def"
                                              "cljs.spec/nilable"
                                              "cljs.spec/alt"
                                              "cljs.spec.impl.gen/simple-type-printable"
                                              "cljs.spec.impl.gen/delay"
                                              "cljs.spec.impl.gen/LazyVar"
                                              "cljs.spec/conformer"
                                              "cljs.spec/spec"
                                              "cljs.spec.impl.gen/choose"
                                              "cljs.spec.impl.gen/fmap"
                                              "cljs.spec.impl.gen/any"
                                              "cljs.spec.test/run-all-tests"
                                              "cljs.spec.impl.gen/string-ascii"
                                              "cljs.spec/&"
                                              "cljs.spec/fdef"
                                              "cljs.spec.impl.gen/sample"
                                              "cljs.spec.impl.gen/hash-map"
                                              "cljs.spec/Spec"
                                              "cljs.spec.impl.gen/symbol-ns"
                                              "cljs.spec.impl.gen/any-printable"
                                              "cljs.spec/abbrev"
                                              "cljs.spec/map-of"
                                              "cljs.spec/+"
                                              "cljs.spec/explain"
                                              "cljs.spec.impl.gen/char-ascii"
                                              "cljs.spec.impl.gen/cat"
                                              "cljs.spec/speced-vars*"
                                              "cljs.spec.impl.gen/quick-check"
                                              "cljs.spec/?"
                                              "cljs.spec/instrument-all"
                                              "cljs.spec/instrument"
                                              "cljs.spec.impl.gen/set"
                                              "cljs.spec.impl.gen/return"
                                              "cljs.spec/instrument*"
                                              "cljs.spec.impl.gen/double"
                                              "cljs.spec/unstrument-ns"
                                              "cljs.spec/fspec"
                                              "cljs.spec/coll-gen"
                                              "cljs.spec/and"
                                              "cljs.spec/spec?"
                                              "cljs.spec.test/check-var"
                                              "cljs.spec/regex?"
                                              "cljs.core/locking"
                                              "cljs.spec.impl.gen/char"
                                              "cljs.spec.impl.gen/simple-type"
                                              "cljs.spec.impl.gen/map"
                                              "cljs.spec/coll-checker"
                                              "cljs.spec.impl.gen/for-all*"
                                              "cljs.spec/with-instrument-disabled"
                                              "cljs.spec/multi-spec"
                                              "cljs.spec.impl.gen/dynaload"
                                              "cljs.spec/fn-specs"
                                              "cljs.spec/unstrument*"
                                              "cljs.spec/unstrument-all"
                                              "cljs.spec.impl.gen/string-alphanumeric"
                                              "cljs.spec.impl.gen/generate"
                                              "cljs.spec.impl.gen/string"
                                              "cljs.spec.impl.gen/keyword-ns"
                                              "cljs.spec.test/run-tests"
                                              "cljs.spec.impl.gen/keyword"
                                              "cljs.spec/keys*"
                                              "cljs.spec/keys"
                                              "cljs.spec/*recursion-limit*"
                                              "cljs.spec/explain-data*"
                                              "cljs.spec/tuple"
                                              "cljs.spec.impl.gen/not-empty"
                                              "cljs.spec/explain-data"
                                              "cljs.spec/speced-vars"
                                              "cljs.spec.test/check-fn"
                                              "cljs.spec/gen"
                                              "cljs.spec.impl.gen/char-alphanumeric"
                                              "cljs.spec/registry"}},
                           "0.0-1895" {},
                           "0.0-971" {:added #{"cljs.core/type"
                                               "cljs.core/IFn"}},
                           "0.0-2027" {},
                           "0.0-1978" {},
                           "0.0-1843" {},
                           "0.0-2758" {},
                           "0.0-2913" {},
                           "0.0-1835" {},
                           "1.10.740" {},
                           "0.0-3264" {},
                           "1.9.655" {:added #{"cljs.core/gen-apply-to-simple"
                                               "cljs.core/resolve"
                                               "cljs.core/equiv-map"
                                               "cljs.core/APersistentVector"}},
                           "0.0-3149" {},
                           "1.9.198" {:added #{"cljs.core/refer-clojure"}},
                           "1.11.121" {:added #{"cljs.core/partitionv"
                                                "cljs.core/splitv-at"
                                                "cljs.core/Throwable->map"
                                                "cljs.core/IDrop"
                                                "cljs.test/run-test"
                                                "cljs.core/partitionv-all"}},
                           "0.0-1450" {},
                           "0.0-2173" {:added #{"cljs.core/IReset"
                                                "cljs.core/IAtom"
                                                "cljs.core/ISwap"}},
                           "0.0-3208" {},
                           "1.10.764" {},
                           "0.0-3263" {},
                           "1.9.473" {},
                           "1.7.170" {},
                           "0.0-1798" {:added #{"cljs.core/unchecked-negate"
                                                "cljs.core/float"
                                                "cljs.core/int-array"
                                                "cljs.core/unchecked-multiply-int"
                                                "cljs.core/cond->"
                                                "cljs.core/unchecked-add"
                                                "cljs.core/js-arguments"
                                                "cljs.core/Symbol"
                                                "cljs.core/chars"
                                                "cljs.core/coercive-boolean"
                                                "cljs.core/short"
                                                "cljs.core/longs"
                                                "cljs.core/unchecked-multiply"
                                                "cljs.core/some->"
                                                "cljs.core/unchecked-negate-int"
                                                "cljs.core/truth_"
                                                "cljs.core/unchecked-substract-int"
                                                "cljs.core/unchecked-double"
                                                "cljs.core/set-print-fn!"
                                                "cljs.core/unchecked-inc-int"
                                                "cljs.core/unchecked-subtract"
                                                "cljs.core/unchecked-add-int"
                                                "cljs.core/some->>"
                                                "cljs.core/unchecked-inc"
                                                "cljs.core/unchecked-subtract-int"
                                                "cljs.core/unchecked-substract"
                                                "cljs.core/unchecked-dec"
                                                "cljs.core/unchecked-divide-int"
                                                "cljs.core/ints"
                                                "cljs.core/PersistentArrayMap.fromArray"
                                                "cljs.core/unchecked-dec-int"
                                                "cljs.core/array?"
                                                "cljs.core/unchecked-char"
                                                "cljs.core/key->js"
                                                "cljs.core/char"
                                                "cljs.core/floats"
                                                "cljs.core/cond->>"
                                                "cljs.core/booleans"
                                                "cljs.core/not-native"
                                                "cljs.core/bytes"
                                                "cljs.core/unchecked-byte"
                                                "cljs.core/unchecked-short"
                                                "cljs.core/byte"
                                                "cljs.core/INamed"
                                                "cljs.core/shorts"
                                                "cljs.core/unchecked-int"
                                                "cljs.core/double"
                                                "cljs.core/exists?"
                                                "cljs.core/doubles"
                                                "cljs.core/unchecked-float"
                                                "cljs.core/divide"
                                                "cljs.core/as->"
                                                "cljs.core/unchecked-remainder-int"
                                                "cljs.core/unchecked-long"},
                                       :removed #{"cljs.core/PersistentArrayMap.fromArrays"
                                                  "cljs.core/HashMap"
                                                  "cljs.core/IPrintable"
                                                  "cljs.core/Vector.fromArray"
                                                  "cljs.core/pr-sequential"
                                                  "cljs.core/HashMap.EMPTY"
                                                  "cljs.core/Vector.EMPTY"
                                                  "cljs.core/HashMap.fromArrays"
                                                  "cljs.core/Vector"}},
                           "0.0-1877" {:added #{"cljs.core/keyword-identical?"
                                                "cljs.core/set-from-indexed-seq"}},
                           "0.0-1211" {:added #{"cljs.core/ITransientCollection"
                                                "cljs.core/transient"
                                                "cljs.core/dissoc!"
                                                "cljs.core/PersistentArrayMap.fromArrays"
                                                "cljs.core/ITransientSet"
                                                "cljs.core/array-map"
                                                "cljs.core/rseq"
                                                "cljs.core/ITransientMap"
                                                "cljs.core/ArrayNodeSeq"
                                                "cljs.core/list?"
                                                "cljs.core/val"
                                                "cljs.core/BitmapIndexedNode"
                                                "cljs.core/IMapEntry"
                                                "cljs.core/*unchecked-if*"
                                                "cljs.core/seqable?"
                                                "cljs.core/sorted-map"
                                                "cljs.core/ASeq"
                                                "cljs.core/reduceable?"
                                                "cljs.core/vector-seq"
                                                "cljs.core/conj!"
                                                "cljs.core/PersistentHashMap"
                                                "cljs.core/coercive-not"
                                                "cljs.core/mask"
                                                "cljs.core/IReversible"
                                                "cljs.core/IKVReduce"
                                                "cljs.core/BlackNode"
                                                "cljs.core/PersistentHashSet.EMPTY"
                                                "cljs.core/PersistentArrayMap"
                                                "cljs.core/ObjMap.HASHMAP_THRESHOLD"
                                                "cljs.core/int"
                                                "cljs.core/ISorted"
                                                "cljs.core/double-array"
                                                "cljs.core/PersistentArrayMap.HASHMAP_THRESHOLD"
                                                "cljs.core/coercive-not="
                                                "cljs.core/PersistentArrayMap.EMPTY"
                                                "cljs.core/reduced?"
                                                "cljs.core/PersistentTreeMapSeq"
                                                "cljs.core/persistent!"
                                                "cljs.core/unsafe-bit-and"
                                                "cljs.core/PersistentHashMap.fromArrays"
                                                "cljs.core/sorted-set"
                                                "cljs.core/PersistentTreeMap.EMPTY"
                                                "cljs.core/IList"
                                                "cljs.core/PersistentHashMap.EMPTY"
                                                "cljs.core/to-array-2d"
                                                "cljs.core/filterv"
                                                "cljs.core/IEditableCollection"
                                                "cljs.core/ArrayNode"
                                                "cljs.core/TransientHashMap"
                                                "cljs.core/TransientArrayMap"
                                                "cljs.core/bitpos"
                                                "cljs.core/mapv"
                                                "cljs.core/long"
                                                "cljs.core/reversible?"
                                                "cljs.core/HashCollisionNode"
                                                "cljs.core/into-array"
                                                "cljs.core/TransientVector"
                                                "cljs.core/coercive-="
                                                "cljs.core/PersistentTreeSet"
                                                "cljs.core/Reduced"
                                                "cljs.core/long-array"
                                                "cljs.core/subseq"
                                                "cljs.core/bit-count"
                                                "cljs.core/assoc!"
                                                "cljs.core/sorted-map-by"
                                                "cljs.core/NodeSeq"
                                                "cljs.core/gen-apply-to"
                                                "cljs.core/rsubseq"
                                                "cljs.core/make-array"
                                                "cljs.core/sorted-set-by"
                                                "cljs.core/caching-hash"
                                                "cljs.core/disj!"
                                                "cljs.core/ifn?"
                                                "cljs.core/case"
                                                "cljs.core/RedNode"
                                                "cljs.core/key"
                                                "cljs.core/ITransientAssociative"
                                                "cljs.core/reduce-kv"
                                                "cljs.core/PersistentTreeSet.EMPTY"
                                                "cljs.core/BitmapIndexedNode.EMPTY"
                                                "cljs.core/mk-bound-fn"
                                                "cljs.core/VectorNode"
                                                "cljs.core/PersistentHashSet"
                                                "cljs.core/ITransientVector"
                                                "cljs.core/PersistentTreeMap"
                                                "cljs.core/pop!"
                                                "cljs.core/bit-shift-right-zero-fill"
                                                "cljs.core/reduced"
                                                "cljs.core/object-array"
                                                "cljs.core/indexed?"
                                                "cljs.core/TransientHashSet"},
                                       :removed #{"cljs.core/Set"
                                                  "cljs.core/Set.EMPTY"}},
                           "1.10.145" {},
                           "0.0-1449" {},
                           "0.0-2911" {:added #{"clojure.browser.net/IWebSocket"
                                                "clojure.browser.net/websocket-connection"},
                                       :removed #{"cljs.repl/with-read-known"}},
                           "1.9.908" {},
                           "0.0-993" {},
                           "0.0-1011" {:added #{"cljs.core/println-str"
                                                "cljs.core/print-str"
                                                "cljs.core/prn-str-with-opts"
                                                "cljs.core/prn-str"}},
                           "0.0-2356" {:added #{"cljs.core/IIterable"
                                                "cljs.core/iterable?"}},
                           "1.7.122" {},
                           "1.10.329" {},
                           "0.0-3211" {},
                           "0.0-3053" {},
                           "0.0-2985" {:added #{"cljs.core/import"
                                                "cljs.repl/source"
                                                "cljs.repl/apropos"
                                                "cljs.repl/pst"
                                                "cljs.repl/dir"
                                                "cljs.core/*target*"
                                                "cljs.repl/find-doc"}},
                           "1.9.183" {:added #{"cljs.spec.test/abbrev-result"
                                               "cljs.spec.test/instrumentable-syms"
                                               "cljs.spec/registry-ref"
                                               "cljs.core/use"
                                               "cljs.spec.test/instrument-1"
                                               "cljs.spec.test/distinct-by"
                                               "cljs.spec.test/->sym"
                                               "cljs.spec.test/with-instrument-disabled"
                                               "cljs.spec/exercise-fn"
                                               "cljs.spec.test/instrument"
                                               "cljs.spec.test/checkable-syms"
                                               "cljs.spec.test/summarize-results"
                                               "cljs.spec.test/get-ua-product"
                                               "cljs.spec.test/unstrument"
                                               "cljs.spec.test/get-env"
                                               "cljs.spec/merge"
                                               "cljs.spec.test/check"
                                               "cljs.spec.test/enumerate-namespace"
                                               "cljs.core/any?"
                                               "cljs.spec.test/check-1"
                                               "cljs.spec.test/checkable-syms*"
                                               "cljs.spec.test/unstrument-1"
                                               "cljs.core/use-macros"
                                               "cljs.spec.test/get-host-port"},
                                      :removed #{"cljs.spec/unstrument"
                                                 "cljs.spec/instrument-ns"
                                                 "cljs.spec.test/run-all-tests"
                                                 "cljs.spec/speced-vars*"
                                                 "cljs.spec/instrument-all"
                                                 "cljs.spec/instrument"
                                                 "cljs.spec/instrument*"
                                                 "cljs.spec/unstrument-ns"
                                                 "cljs.spec/coll-gen"
                                                 "cljs.spec.test/check-var"
                                                 "cljs.spec/coll-checker"
                                                 "cljs.spec/with-instrument-disabled"
                                                 "cljs.spec/unstrument*"
                                                 "cljs.spec/unstrument-all"
                                                 "cljs.spec.test/run-tests"}},
                           "0.0-2156" {:added #{"cljs.nodejs/enable-util-print!"
                                                "cljs.core/cloneable?"
                                                "cljs.core/specify!"
                                                "cljs.core/defonce"}},
                           "0.0-1847" {},
                           "1.9.293" {:added #{"cljs.core/infinite?"
                                               "cljs.core/ns*"
                                               "cljs.spec/*explain-out*"
                                               "cljs.spec/explain-printer"
                                               "cljs.spec/double-in"
                                               "cljs.core/float?"
                                               "cljs.core/double?"
                                               "cljs.core/PROTOCOL_SENTINEL"}},
                           "1.9.542" {:added #{"cljs.spec.alpha/tuple"
                                               "cljs.spec.alpha/get-spec"
                                               "cljs.spec.alpha/explain"
                                               "cljs.spec.gen.alpha/fmap"
                                               "cljs.spec.alpha/spec"
                                               "cljs.spec.alpha/conformer"
                                               "cljs.spec.alpha/describe"
                                               "cljs.spec.alpha/explain-str"
                                               "cljs.spec.gen.alpha/tuple"
                                               "cljs.spec.gen.alpha/map"
                                               "cljs.spec.alpha/abbrev"
                                               "cljs.spec.alpha/fdef"
                                               "cljs.spec.alpha/cat"
                                               "cljs.spec.alpha/&"
                                               "cljs.spec.test.alpha/abbrev-result"
                                               "cljs.spec.test.alpha/->sym"
                                               "cljs.spec.gen.alpha/frequency"
                                               "cljs.spec.alpha/map-of"
                                               "cljs.spec.gen.alpha/keyword"
                                               "cljs.spec.test.alpha/summarize-results"
                                               "cljs.spec.gen.alpha/double*"
                                               "cljs.spec.alpha/*"
                                               "cljs.spec.gen.alpha/quick-check"
                                               "cljs.spec.test.alpha/get-host-port"
                                               "cljs.spec.gen.alpha/vector-distinct"
                                               "cljs.spec.gen.alpha/LazyVar"
                                               "cljs.spec.alpha/gen"
                                               "cljs.spec.alpha/spec?"
                                               "cljs.spec.gen.alpha/cat"
                                               "cljs.spec.alpha/inst-in-range?"
                                               "cljs.spec.alpha/int-in"
                                               "cljs.spec.gen.alpha/double"
                                               "cljs.spec.alpha/check-asserts?"
                                               "cljs.spec.alpha/*coll-check-limit*"
                                               "cljs.spec.alpha/invalid?"
                                               "cljs.spec.test.alpha/checkable-syms"
                                               "cljs.spec.test.alpha/instrumentable-syms"
                                               "cljs.spec.alpha/explain-printer"
                                               "cljs.spec.gen.alpha/char-alpha"
                                               "cljs.spec.alpha/nonconforming"
                                               "cljs.spec.gen.alpha/char"
                                               "cljs.spec.test.alpha/instrument"
                                               "cljs.spec.gen.alpha/ratio"
                                               "cljs.spec.gen.alpha/simple-type"
                                               "cljs.spec.alpha/explain-data"
                                               "cljs.spec.gen.alpha/keyword-ns"
                                               "cljs.spec.alpha/merge"
                                               "cljs.spec.alpha/registry-ref"
                                               "cljs.spec.alpha/registry"
                                               "cljs.spec.alpha/assert*"
                                               "cljs.spec.gen.alpha/large-integer*"
                                               "cljs.spec.gen.alpha/string"
                                               "cljs.spec.gen.alpha/boolean"
                                               "cljs.spec.test.alpha/get-ua-product"
                                               "cljs.spec.alpha/exercise"
                                               "cljs.spec.alpha/double-in"
                                               "cljs.spec.gen.alpha/simple-type-printable"
                                               "cljs.spec.alpha/keys"
                                               "cljs.spec.alpha/every"
                                               "cljs.spec.test.alpha/unstrument-1"
                                               "cljs.core/MapEntry"
                                               "cljs.spec.alpha/*explain-out*"
                                               "cljs.spec.gen.alpha/sample"
                                               "cljs.spec.gen.alpha/dynaload"
                                               "cljs.spec.alpha/and"
                                               "cljs.spec.gen.alpha/elements"
                                               "cljs.spec.alpha/explain-out"
                                               "cljs.spec.alpha/inst-in"
                                               "cljs.spec.alpha/?"
                                               "cljs.spec.gen.alpha/vector"
                                               "cljs.spec.alpha/keys*"
                                               "cljs.spec.gen.alpha/one-of"
                                               "cljs.spec.alpha/coll-of"
                                               "cljs.spec.test.alpha/check-1"
                                               "cljs.spec.test.alpha/check-fn"
                                               "cljs.spec.gen.alpha/char-ascii"
                                               "cljs.spec.alpha/+"
                                               "cljs.spec.gen.alpha/list"
                                               "cljs.spec.gen.alpha/gen-for-pred"
                                               "cljs.spec.gen.alpha/hash-map"
                                               "cljs.spec.gen.alpha/string-ascii"
                                               "cljs.spec.test.alpha/check"
                                               "cljs.spec.alpha/speced-vars"
                                               "cljs.spec.alpha/conform"
                                               "cljs.spec.alpha/form"
                                               "cljs.spec.test.alpha/get-env"
                                               "cljs.spec.gen.alpha/int"
                                               "cljs.spec.alpha/with-gen"
                                               "cljs.spec.gen.alpha/not-empty"
                                               "cljs.spec.alpha/regex?"
                                               "cljs.spec.alpha/def"
                                               "cljs.spec.alpha/nilable"
                                               "cljs.spec.gen.alpha/set"
                                               "cljs.spec.gen.alpha/return"
                                               "cljs.spec.alpha/unform"
                                               "cljs.spec.test.alpha/checkable-syms*"
                                               "cljs.spec.alpha/exercise-fn"
                                               "cljs.spec.gen.alpha/any"
                                               "cljs.spec.test.alpha/instrument-1"
                                               "cljs.spec.alpha/*compile-asserts*"
                                               "cljs.spec.alpha/assert"
                                               "cljs.spec.alpha/*fspec-iterations*"
                                               "cljs.spec.gen.alpha/for-all*"
                                               "cljs.spec.alpha/*recursion-limit*"
                                               "cljs.spec.alpha/int-in-range?"
                                               "cljs.spec.alpha/*coll-error-limit*"
                                               "cljs.spec.alpha/Spec"
                                               "cljs.spec.gen.alpha/uuid"
                                               "cljs.spec.gen.alpha/symbol-ns"
                                               "cljs.spec.gen.alpha/bind"
                                               "cljs.spec.gen.alpha/generate"
                                               "cljs.spec.alpha/fspec"
                                               "cljs.spec.gen.alpha/char-alphanumeric"
                                               "cljs.spec.alpha/every-kv"
                                               "cljs.spec.gen.alpha/delay"
                                               "cljs.spec.gen.alpha/such-that"
                                               "cljs.spec.alpha/MAX_INT"
                                               "cljs.spec.alpha/Specize"
                                               "cljs.spec.test.alpha/with-instrument-disabled"
                                               "cljs.spec.gen.alpha/any-printable"
                                               "cljs.spec.gen.alpha/string-alphanumeric"
                                               "cljs.spec.alpha/alt"
                                               "cljs.spec.test.alpha/distinct-by"
                                               "cljs.spec.alpha/check-asserts"
                                               "cljs.spec.alpha/multi-spec"
                                               "cljs.spec.gen.alpha/large-integer"
                                               "cljs.spec.alpha/valid?"
                                               "cljs.spec.gen.alpha/symbol"
                                               "cljs.spec.alpha/or"
                                               "cljs.spec.alpha/explain-data*"
                                               "cljs.spec.gen.alpha/choose"
                                               "cljs.spec.test.alpha/unstrument"},
                                      :removed #{"cljs.spec.impl.gen/one-of"
                                                 "cljs.spec.impl.gen/char-alpha"
                                                 "cljs.spec/Specize"
                                                 "cljs.spec.impl.gen/large-integer"
                                                 "cljs.spec/describe"
                                                 "cljs.spec.impl.gen/such-that"
                                                 "cljs.spec/*compile-asserts*"
                                                 "cljs.spec.impl.gen/list"
                                                 "cljs.spec.impl.gen/int"
                                                 "cljs.spec.impl.gen/boolean"
                                                 "cljs.spec/*fspec-iterations*"
                                                 "cljs.spec.impl.gen/tuple"
                                                 "cljs.spec/int-in"
                                                 "cljs.spec.impl.gen/ratio"
                                                 "cljs.spec.impl.gen/large-integer*"
                                                 "cljs.spec/exercise"
                                                 "cljs.spec/cat"
                                                 "cljs.spec.impl.gen/elements"
                                                 "cljs.spec.test/abbrev-result"
                                                 "cljs.spec.impl.gen/symbol"
                                                 "cljs.spec/or"
                                                 "cljs.spec/invalid?"
                                                 "cljs.spec.impl.gen/gen-for-pred"
                                                 "cljs.spec.impl.gen/uuid"
                                                 "cljs.spec.test/instrumentable-syms"
                                                 "cljs.spec/*coll-check-limit*"
                                                 "cljs.spec/conform"
                                                 "cljs.spec/int-in-range?"
                                                 "cljs.spec.impl.gen/bind"
                                                 "cljs.spec/form"
                                                 "cljs.spec/*"
                                                 "cljs.spec.impl.gen/vector"
                                                 "cljs.spec/registry-ref"
                                                 "cljs.spec/valid?"
                                                 "cljs.spec/with-gen"
                                                 "cljs.spec/explain-str"
                                                 "cljs.spec/coll-of"
                                                 "cljs.spec/unform"
                                                 "cljs.spec/def"
                                                 "cljs.spec/nilable"
                                                 "cljs.spec/alt"
                                                 "cljs.spec.test/instrument-1"
                                                 "cljs.spec.impl.gen/simple-type-printable"
                                                 "cljs.spec.impl.gen/delay"
                                                 "cljs.spec.test/distinct-by"
                                                 "cljs.spec.impl.gen/LazyVar"
                                                 "cljs.spec.test/->sym"
                                                 "cljs.spec/assert*"
                                                 "cljs.spec/conformer"
                                                 "cljs.spec/spec"
                                                 "cljs.spec.impl.gen/double*"
                                                 "cljs.spec.test/with-instrument-disabled"
                                                 "cljs.spec/exercise-fn"
                                                 "cljs.spec.test/instrument"
                                                 "cljs.spec.impl.gen/choose"
                                                 "cljs.spec/get-spec"
                                                 "cljs.spec.impl.gen/fmap"
                                                 "cljs.spec.impl.gen/any"
                                                 "cljs.spec.impl.gen/string-ascii"
                                                 "cljs.spec/&"
                                                 "cljs.spec.test/checkable-syms"
                                                 "cljs.spec/fdef"
                                                 "cljs.spec.impl.gen/sample"
                                                 "cljs.spec/*explain-out*"
                                                 "cljs.spec/every"
                                                 "cljs.spec/check-asserts?"
                                                 "cljs.spec.test/summarize-results"
                                                 "cljs.spec.impl.gen/hash-map"
                                                 "cljs.spec/every-kv"
                                                 "cljs.spec/Spec"
                                                 "cljs.spec.impl.gen/symbol-ns"
                                                 "cljs.spec.impl.gen/any-printable"
                                                 "cljs.spec/abbrev"
                                                 "cljs.spec/explain-printer"
                                                 "cljs.spec/nonconforming"
                                                 "cljs.spec/check-asserts"
                                                 "cljs.spec/map-of"
                                                 "cljs.spec/+"
                                                 "cljs.spec/explain"
                                                 "cljs.spec.impl.gen/char-ascii"
                                                 "cljs.spec.impl.gen/cat"
                                                 "cljs.spec/double-in"
                                                 "cljs.spec.impl.gen/quick-check"
                                                 "cljs.spec/?"
                                                 "cljs.spec/*coll-error-limit*"
                                                 "cljs.spec.impl.gen/set"
                                                 "cljs.spec.impl.gen/return"
                                                 "cljs.spec.test/get-ua-product"
                                                 "cljs.spec.test/unstrument"
                                                 "cljs.spec.impl.gen/vector-distinct"
                                                 "cljs.spec.test/get-env"
                                                 "cljs.spec.impl.gen/double"
                                                 "cljs.spec/fspec"
                                                 "cljs.spec/and"
                                                 "cljs.spec/merge"
                                                 "cljs.spec.test/check"
                                                 "cljs.spec/MAX_INT"
                                                 "cljs.spec/spec?"
                                                 "cljs.spec/regex?"
                                                 "cljs.spec.impl.gen/frequency"
                                                 "cljs.spec.impl.gen/char"
                                                 "cljs.spec.impl.gen/simple-type"
                                                 "cljs.spec.impl.gen/map"
                                                 "cljs.spec.impl.gen/for-all*"
                                                 "cljs.spec/assert"
                                                 "cljs.spec/multi-spec"
                                                 "cljs.spec.test/check-1"
                                                 "cljs.spec.test/checkable-syms*"
                                                 "cljs.spec.impl.gen/dynaload"
                                                 "cljs.spec.impl.gen/string-alphanumeric"
                                                 "cljs.spec.test/unstrument-1"
                                                 "cljs.spec.impl.gen/generate"
                                                 "cljs.spec/inst-in-range?"
                                                 "cljs.spec.impl.gen/string"
                                                 "cljs.spec.impl.gen/keyword-ns"
                                                 "cljs.spec.impl.gen/keyword"
                                                 "cljs.spec/keys*"
                                                 "cljs.spec/keys"
                                                 "cljs.spec/*recursion-limit*"
                                                 "cljs.spec/explain-data*"
                                                 "cljs.spec/tuple"
                                                 "cljs.spec/inst-in"
                                                 "cljs.spec.impl.gen/not-empty"
                                                 "cljs.spec/explain-data"
                                                 "cljs.spec/explain-out"
                                                 "cljs.spec/speced-vars"
                                                 "cljs.spec.test/check-fn"
                                                 "cljs.spec/gen"
                                                 "cljs.spec.test/get-host-port"
                                                 "cljs.spec.impl.gen/char-alphanumeric"
                                                 "cljs.spec/registry"}},
                           "1.7.189" {},
                           "0.0-2496" {:added #{"cljs.test/report"
                                                "cljs.test/get-current-env"
                                                "cljs.test/join-fixtures"
                                                "cljs.core/var"
                                                "cljs.test/testing-contexts-str"
                                                "cljs.test/do-report"
                                                "cljs.test/set-env!"
                                                "cljs.test/run-tests"
                                                "cljs.repl/print-doc"
                                                "cljs.test/js-filename"
                                                "cljs.core/vswap!"
                                                "cljs.core/IVolatile"
                                                "cljs.test/file-and-line"
                                                "cljs.test/test-all-vars"
                                                "cljs.test/testing-vars-str"
                                                "cljs.test/compose-fixtures"
                                                "cljs.test/is"
                                                "cljs.core/js-debugger"
                                                "cljs.test/clear-env!"
                                                "cljs.core/Volatile"
                                                "cljs.core/ns-interns"
                                                "cljs.test/mapped-line-and-column"
                                                "cljs.test/test-var"
                                                "cljs.test/js-line-and-column"
                                                "cljs.core/volatile!"
                                                "cljs.test/*current-env*"
                                                "cljs.test/update-current-env!"
                                                "cljs.test/successful?"
                                                "cljs.test/inc-report-counter!"
                                                "cljs.core/volatile?"
                                                "cljs.test/test-vars"
                                                "cljs.test/run-all-tests"
                                                "cljs.test/try-expr"
                                                "cljs.pprint/PrettyFlush"
                                                "cljs.core/Var"
                                                "cljs.test/test-ns"
                                                "cljs.repl/doc"
                                                "cljs.core/test"
                                                "cljs.test/deftest"
                                                "cljs.test/testing"
                                                "cljs.test/empty-env"
                                                "cljs.core/vreset!"}},
                           "0.0-3196" {},
                           "1.10.879" {},
                           "1.10.758" {},
                           "0.0-927" {:added #{"cljs.core/keys"
                                               "cljs.core/reset!"
                                               "clojure.set/select"
                                               "cljs.core/delay"
                                               "cljs.core/bit-not"
                                               "cljs.core/partition"
                                               "cljs.core/parents"
                                               "cljs.core/aclone"
                                               "cljs.core/reset-meta!"
                                               "cljs.reader/dispatch-macros"
                                               "cljs.core/ICollection"
                                               "cljs.core/every?"
                                               "clojure.zip/node"
                                               "cljs.core/IEmptyableCollection"
                                               "clojure.zip/right"
                                               "cljs.core/=="
                                               "clojure.browser.net/*timeout*"
                                               "cljs.core/let*"
                                               "cljs.core/remove-method"
                                               "cljs.core/frequencies"
                                               "cljs.core/pop"
                                               "cljs.core/not-every?"
                                               "cljs.core/some-fn"
                                               "clojure.browser.event/remove-all"
                                               "cljs.core/doto"
                                               "cljs.core/take-while"
                                               "cljs.reader/escape-char-map"
                                               "clojure.browser.event/all-listeners"
                                               "cljs.core/vals"
                                               "cljs.core/IDeref"
                                               "clojure.browser.dom/log-obj"
                                               "cljs.core/for"
                                               "cljs.core/instance?"
                                               "cljs.reader/read-comment"
                                               "cljs.reader/read-number"
                                               "cljs.core/ILookup"
                                               "cljs.core/when"
                                               "clojure.browser.dom/set-value"
                                               "cljs.reader/read-past"
                                               "cljs.core/to-array"
                                               "cljs.core/interpose"
                                               "clojure.browser.net/ICrossPageChannel"
                                               "cljs.core/Cons"
                                               "cljs.core/re-find"
                                               "cljs.core/IMeta"
                                               "cljs.core/assoc-in"
                                               "clojure.string/join"
                                               "clojure.zip/rights"
                                               "cljs.core/split-at"
                                               "clojure.zip/append-child"
                                               "cljs.core/binding"
                                               "cljs.core/Set"
                                               "cljs.reader/macro-terminating?"
                                               "cljs.core/prefers"
                                               "cljs.core/vary-meta"
                                               "cljs.core/when-let"
                                               "cljs.core/drop"
                                               "cljs.core/while"
                                               "cljs.core/import-macros"
                                               "cljs.core/string-print"
                                               "cljs.core/-"
                                               "cljs.core/loop*"
                                               "clojure.zip/vector-zip"
                                               "cljs.core/js->clj"
                                               "cljs.core/List"
                                               "cljs.core/identical?"
                                               "cljs.core/*main-cli-fn*"
                                               "clojure.browser.dom/html->dom"
                                               "cljs.core/some"
                                               "cljs.core/if"
                                               "cljs.core/doall"
                                               "cljs.core/condp"
                                               "clojure.zip/down"
                                               "cljs.core/IPending"
                                               "cljs.core/count"
                                               "cljs.core/bit-test"
                                               "cljs.core/loop"
                                               "cljs.core/subvec"
                                               "cljs.core/bit-clear"
                                               "cljs.core/gensym"
                                               "cljs.core/gensym_counter"
                                               "cljs.core/in-ns"
                                               "cljs.core/+"
                                               "cljs.core/comp"
                                               "cljs.reader/desugar-meta"
                                               "cljs.core/pr"
                                               "clojure.string/upper-case"
                                               "clojure.browser.event/expose"
                                               "clojure.browser.event/listen-once"
                                               "cljs.core/empty?"
                                               "cljs.core/newline"
                                               "cljs.core/replace"
                                               "cljs.core/rand"
                                               "cljs.core/add-watch"
                                               "clojure.string/capitalize"
                                               "cljs.core/replicate"
                                               "cljs.core/sequential?"
                                               "cljs.core/underive"
                                               "cljs.core/get-method"
                                               "cljs.core/="
                                               "cljs.core/defn-"
                                               "cljs.reader/read-symbol"
                                               "cljs.reader/push-back-reader"
                                               "cljs.core/deftype"
                                               "cljs.core/Subvec"
                                               "cljs.core/."
                                               "cljs.core/extend-protocol"
                                               "cljs.reader/read"
                                               "cljs.core/EmptyList"
                                               "clojure.walk/postwalk"
                                               "clojure.zip/edit"
                                               "cljs.core/re-seq"
                                               "cljs.reader/read-list"
                                               "cljs.core/Atom"
                                               "cljs.core/IMap"
                                               "cljs.reader/read-vector"
                                               "clojure.set/join"
                                               "cljs.core/HashMap"
                                               "cljs.reader/int-pattern"
                                               "cljs.core/swap!"
                                               "cljs.core/finally"
                                               "cljs.core/dec"
                                               "clojure.browser.dom/remove-children"
                                               "cljs.core/get-validator"
                                               "cljs.core/coll?"
                                               "cljs.core/bit-or"
                                               "cljs.core/nfirst"
                                               "cljs.core/keep"
                                               "cljs.core/take"
                                               "cljs.core/cond"
                                               "cljs.core/bit-and"
                                               "cljs.core/ObjMap.fromObject"
                                               "clojure.browser.event/unique-event-id"
                                               "clojure.set/project"
                                               "clojure.string/trim-newline"
                                               "clojure.zip/insert-left"
                                               "cljs.core/true?"
                                               "clojure.browser.net/xpc-connection"
                                               "cljs.core/not"
                                               "cljs.core/js-obj"
                                               "cljs.core/complement"
                                               "cljs.core/spread"
                                               "cljs.core/keyword"
                                               "cljs.core/sort"
                                               "clojure.string/trim"
                                               "cljs.core/meta"
                                               "cljs.core/time"
                                               "cljs.core/boolean"
                                               "cljs.reader/read-token"
                                               "cljs.core/update-in"
                                               "cljs.core/map-indexed"
                                               "cljs.core/IStack"
                                               "cljs.core/IIndexed"
                                               "clojure.browser.repl/repl-print"
                                               "clojure.browser.net/xpc-config-fields"
                                               "cljs.core/nnext"
                                               "cljs.core/*print-meta*"
                                               "cljs.reader/read-dispatch"
                                               "cljs.core/distinct"
                                               "cljs.reader/wrapping-reader"
                                               "cljs.core/prn"
                                               "clojure.zip/leftmost"
                                               "cljs.core/>="
                                               "cljs.reader/macros"
                                               "cljs.core/doseq"
                                               "cljs.core/*"
                                               "cljs.core/into"
                                               "cljs.core/defmethod"
                                               "cljs.core/rest"
                                               "cljs.core/dotimes"
                                               "clojure.zip/lefts"
                                               "clojure.browser.dom/ensure-element"
                                               "cljs.core/defmacro"
                                               "cljs.core/remove"
                                               "cljs.core/ns"
                                               "cljs.core/if-not"
                                               "clojure.zip/path"
                                               "cljs.core/mapcat"
                                               "cljs.core/IWatchable"
                                               "clojure.zip/rightmost"
                                               "cljs.core/->"
                                               "cljs.core/remove-all-methods"
                                               "clojure.string/replace-first"
                                               "clojure.browser.dom/get-value"
                                               "cljs.nodejs/process"
                                               "cljs.core/not="
                                               "cljs.core/js-keys"
                                               "clojure.zip/seq-zip"
                                               "cljs.core/IVector"
                                               "cljs.core/empty"
                                               "cljs.core/re-matches"
                                               "clojure.browser.dom/DOMBuilder"
                                               "cljs.core/extend-type"
                                               "cljs.core/ISeqable"
                                               "cljs.core/assoc"
                                               "clojure.browser.repl/xpc-connection"
                                               "cljs.core/IDerefWithTimeout"
                                               "clojure.browser.repl/start-evaluator"
                                               "clojure.browser.event/unlisten"
                                               "cljs.core/do"
                                               "cljs.core/fnil"
                                               "cljs.core/this-as"
                                               "cljs.core/PersistentQueueSeq"
                                               "cljs.core/counted?"
                                               "clojure.string/trimr"
                                               "cljs.core/force"
                                               "cljs.core/compare-and-set!"
                                               "cljs.core/set?"
                                               "cljs.core/load-file"
                                               "clojure.string/escape"
                                               "cljs.core/remove-watch"
                                               "cljs.core/IMultiFn"
                                               "clojure.zip/end?"
                                               "clojure.set/superset?"
                                               "clojure.browser.net/IConnection"
                                               "cljs.core/let"
                                               "cljs.core/dorun"
                                               "cljs.core/pr-str"
                                               "cljs.core/IPrintable"
                                               "cljs.core/defprotocol"
                                               "cljs.core/assert"
                                               "cljs.core/declare"
                                               "cljs.core/fn?"
                                               "cljs.core/associative?"
                                               "cljs.core/list*"
                                               "cljs.core/reduce"
                                               "clojure.browser.event/has-listener"
                                               "cljs.core/compare"
                                               "cljs.core/contains?"
                                               "cljs.core/prefer-method"
                                               "cljs.core/array-seq"
                                               "cljs.core/PersistentQueue"
                                               "cljs.core/drop-last"
                                               "cljs.reader/read-string"
                                               "cljs.core/vector?"
                                               "cljs.core/defmulti"
                                               "cljs.core/List.EMPTY"
                                               "clojure.browser.event/dispatch-event"
                                               "clojure.string/split-lines"
                                               "cljs.core/areduce"
                                               "cljs.core/disj"
                                               "clojure.browser.net/event-types"
                                               "clojure.string/lower-case"
                                               "cljs.core/*print-fn*"
                                               "cljs.core/str"
                                               "cljs.core/ISequential"
                                               "cljs.core/try*"
                                               "cljs.core/set"
                                               "cljs.core/print"
                                               "clojure.string/blank?"
                                               "clojure.browser.dom/append"
                                               "cljs.core/take-last"
                                               "clojure.set/intersection"
                                               "cljs.core/fnext"
                                               "cljs.core/apply"
                                               "clojure.walk/prewalk"
                                               "cljs.core/flatten"
                                               "cljs.core/get"
                                               "cljs.core/.."
                                               "cljs.core/Range"
                                               "cljs.core/zero?"
                                               "cljs.core/identity"
                                               "cljs.core/first"
                                               "cljs.reader/ratio-pattern"
                                               "cljs.core/>"
                                               "cljs.core/juxt"
                                               "cljs.core/max"
                                               "cljs.core/*3"
                                               "cljs.core/number?"
                                               "cljs.core/array"
                                               "cljs.core/nthnext"
                                               "cljs.core/re-pattern"
                                               "cljs.core/missing-protocol"
                                               "clojure.browser.dom/set-text"
                                               "clojure.zip/up"
                                               "cljs.core/IWithMeta"
                                               "cljs.core/bit-and-not"
                                               "clojure.string/triml"
                                               "clojure.string/split"
                                               "cljs.core/hash-map"
                                               "cljs.core/rem"
                                               "cljs.core/IRecord"
                                               "cljs.core/constantly"
                                               "clojure.browser.dom/get-element"
                                               "cljs.core/and"
                                               "clojure.browser.repl/wrap-message"
                                               "clojure.browser.event/unlisten-by-key"
                                               "cljs.core/new"
                                               "cljs.core/try"
                                               "cljs.core/iterate"
                                               "cljs.core/lazy-seq"
                                               "cljs.core/IndexedSeq"
                                               "cljs.core/next"
                                               "cljs.core/*print-readably*"
                                               "cljs.core/last"
                                               "cljs.core/bit-shift-left"
                                               "clojure.string/reverse"
                                               "cljs.core/min"
                                               "cljs.reader/escape-char"
                                               "cljs.reader/read-map"
                                               "cljs.core/seq"
                                               "cljs.core/defrecord*"
                                               "cljs.core/not-empty"
                                               "cljs.core/println"
                                               "clojure.browser.repl/connect"
                                               "clojure.browser.dom/insert-at"
                                               "cljs.core/quot"
                                               "clojure.browser.event/get-listener"
                                               "cljs.core/filter"
                                               "clojure.zip/branch?"
                                               "cljs.core/ObjMap"
                                               "cljs.core/zipmap"
                                               "cljs.core/hash-combine"
                                               "cljs.core/max-key"
                                               "clojure.zip/insert-child"
                                               "cljs.core/defrecord"
                                               "cljs.core/butlast"
                                               "cljs.core/hash"
                                               "cljs.core/bit-set"
                                               "cljs.core/concat"
                                               "cljs.core/conj"
                                               "clojure.set/difference"
                                               "cljs.core/when-first"
                                               "cljs.core/distinct?"
                                               "cljs.core/pos?"
                                               "cljs.core/IHash"
                                               "cljs.core/is_proto_"
                                               "cljs.core/keep-indexed"
                                               "cljs.core/bit-shift-right"
                                               "clojure.zip/insert-right"
                                               "cljs.core/make-hierarchy"
                                               "cljs.core/repeat"
                                               "cljs.core/MultiFn"
                                               "cljs.core/not-any?"
                                               "cljs.reader/read-regex"
                                               "clojure.zip/next"
                                               "cljs.core/aget"
                                               "cljs.core/if-let"
                                               "cljs.core//"
                                               "cljs.core/min-key"
                                               "clojure.zip/root"
                                               "cljs.core/drop-while"
                                               "clojure.browser.repl/evaluate-javascript"
                                               "cljs.core/set-validator!"
                                               "cljs.core/<"
                                               "cljs.core/catch"
                                               "cljs.core/deftype*"
                                               "cljs.core/fn"
                                               "cljs.core/split-with"
                                               "cljs.core/IReduce"
                                               "cljs.reader/symbol-pattern"
                                               "cljs.core/repeatedly"
                                               "cljs.reader/read-delimited-list"
                                               "cljs.core/undefined?"
                                               "clojure.zip/prev"
                                               "cljs.core/seq?"
                                               "cljs.core/odd?"
                                               "cljs.core/cons"
                                               "cljs.reader/read-set"
                                               "cljs.core/descendants"
                                               "cljs.core/take-nth"
                                               "cljs.reader/throwing-reader"
                                               "cljs.core/even?"
                                               "clojure.set/subset?"
                                               "cljs.core/flush"
                                               "cljs.reader/reader-error"
                                               "clojure.walk/prewalk-replace"
                                               "cljs.core/*1"
                                               "cljs.core/Set.EMPTY"
                                               "cljs.reader/read-unicode-char"
                                               "cljs.core/dissoc"
                                               "cljs.core/ffirst"
                                               "clojure.zip/replace"
                                               "cljs.core/vec"
                                               "cljs.core/or"
                                               "cljs.core/mod"
                                               "cljs.core/aset"
                                               "cljs.core/second"
                                               "cljs.core/set!"
                                               "clojure.set/rename"
                                               "cljs.core/delay?"
                                               "clojure.zip/left"
                                               "cljs.reader/not-implemented"
                                               "cljs.core/IAssociative"
                                               "cljs.core/ObjMap.EMPTY"
                                               "cljs.core/group-by"
                                               "cljs.core/symbol"
                                               "cljs.core/Delay"
                                               "cljs.core/methods"
                                               "cljs.core/vector"
                                               "cljs.core/rand-int"
                                               "cljs.core/throw"
                                               "cljs.core/PersistentQueue.EMPTY"
                                               "cljs.core/letfn"
                                               "cljs.core/recur"
                                               "cljs.reader/read-discard"
                                               "cljs.core/inc"
                                               "cljs.core/name"
                                               "cljs.core/cycle"
                                               "cljs.core/fn*"
                                               "cljs.core/map"
                                               "cljs.core/amap"
                                               "clojure.zip/children"
                                               "cljs.core/when-not"
                                               "clojure.set/index"
                                               "clojure.browser.dom/log"
                                               "cljs.core/Vector.fromArray"
                                               "cljs.core/partition-by"
                                               "cljs.core/sort-by"
                                               "cljs.core/with-meta"
                                               "cljs.core/NeverEquiv"
                                               "cljs.core/select-keys"
                                               "cljs.core/ISeq"
                                               "clojure.walk/postwalk-replace"
                                               "cljs.core/pr-with-opts"
                                               "cljs.core/->>"
                                               "cljs.core/nil?"
                                               "cljs.core/load-namespace"
                                               "clojure.walk/stringify-keys"
                                               "clojure.browser.repl/order"
                                               "cljs.core/memoize"
                                               "cljs.core/pr-sequential"
                                               "clojure.zip/make-node"
                                               "cljs.reader/float-pattern"
                                               "cljs.core/ancestors"
                                               "cljs.core/integer?"
                                               "cljs.core/HashMap.EMPTY"
                                               "cljs.core/Vector.EMPTY"
                                               "clojure.zip/xml-zip"
                                               "clojure.walk/walk"
                                               "cljs.core/bit-xor"
                                               "clojure.set/union"
                                               "cljs.reader/PushbackReader"
                                               "cljs.core/isa?"
                                               "clojure.browser.net/xhr-connection"
                                               "cljs.core/subs"
                                               "cljs.core/symbol?"
                                               "clojure.string/replace"
                                               "cljs.core/string?"
                                               "cljs.core/partition-all"
                                               "cljs.core/merge-with"
                                               "clojure.browser.dom/set-properties"
                                               "cljs.core/trampoline"
                                               "clojure.browser.repl/send-print"
                                               "cljs.core/ICounted"
                                               "cljs.core/quote"
                                               "cljs.core/IEquiv"
                                               "cljs.core/js-delete"
                                               "cljs.core/comment"
                                               "cljs.reader/special-symbols"
                                               "cljs.core/js*"
                                               "cljs.core/alength"
                                               "cljs.core/tree-seq"
                                               "cljs.reader/read-unmatched-delimiter"
                                               "cljs.core/every-pred"
                                               "clojure.set/rename-keys"
                                               "cljs.core/peek"
                                               "cljs.core/pr-str-with-opts"
                                               "cljs.core/map?"
                                               "cljs.reader/StringPushbackReader"
                                               "cljs.core/HashMap.fromArrays"
                                               "cljs.core/deref"
                                               "cljs.core/reductions"
                                               "cljs.core/false?"
                                               "cljs.core/bit-flip"
                                               "cljs.core/ISet"
                                               "cljs.core/LazySeq"
                                               "cljs.core/*2"
                                               "clojure.browser.event/total-listener-count"
                                               "cljs.core/alter-meta!"
                                               "clojure.browser.dom/click-element"
                                               "cljs.reader/read-meta"
                                               "cljs.core/range"
                                               "cljs.core/reify"
                                               "cljs.core/satisfies?"
                                               "cljs.core/nth"
                                               "cljs.core/list"
                                               "cljs.core/defn"
                                               "cljs.core/rand-nth"
                                               "cljs.core/def"
                                               "cljs.core/atom"
                                               "cljs.reader/read-keyword"
                                               "cljs.core/Vector"
                                               "cljs.reader/skip-line"
                                               "cljs.core/namespace"
                                               "cljs.nodejs/require"
                                               "clojure.browser.event/EventType"
                                               "cljs.core/merge"
                                               "clojure.browser.repl/send-result"
                                               "clojure.walk/keywordize-keys"
                                               "cljs.core/derive"
                                               "clojure.zip/zipper"
                                               "clojure.zip/remove"
                                               "cljs.core/find"
                                               "cljs.core/*print-dup*"
                                               "cljs.core/partial"
                                               "cljs.core/keyword?"
                                               "clojure.browser.event/fire-listeners"
                                               "cljs.core/interleave"
                                               "cljs.core/*flush-on-newline*"
                                               "cljs.core/get-in"
                                               "clojure.browser.dom/element"
                                               "cljs.core/prim-seq"
                                               "cljs.core/<="
                                               "clojure.set/map-invert"
                                               "clojure.browser.event/listen"
                                               "cljs.core/neg?"
                                               "clojure.browser.dom/replace-node"
                                               "cljs.core/reverse"
                                               "cljs.core/realized?"}},
                           "0.0-1934" {},
                           "1.10.756" {},
                           "1.9.76" {},
                           "0.0-3165" {:added #{"cljs.core/dispatch-fn"
                                                "cljs.core/macroexpand"
                                                "cljs.core/macroexpand-1"
                                                "cljs.core/default-dispatch-val"}},
                           "0.0-2202" {},
                           "1.10.126" {:added #{"clojure.browser.repl/parent-connected?"}},
                           "0.0-1820" {:added #{"cljs.core/ValSeq"
                                                "cljs.core/PersistentArrayMapSeq"
                                                "cljs.core/KeySeq"
                                                "cljs.core/persistent-array-map-seq"}},
                           "1.9.456" {:added #{"cljs.spec/Specize"
                                               "cljs.spec/invalid?"
                                               "cljs.core/PersistentArrayMap.createWithCheck"
                                               "cljs.core/*print-namespace-maps*"
                                               "cljs.core/halt-when"
                                               "cljs.core/print-prefix-map"
                                               "cljs.spec/nonconforming"
                                               "cljs.core/load"
                                               "cljs.core/PersistentHashSet.createAsIfByAssoc"
                                               "cljs.core/PersistentHashMap.createWithCheck"
                                               "cljs.core/PersistentArrayMap.createAsIfByAssoc"
                                               "cljs.spec.impl.gen/frequency"
                                               "cljs.core/PersistentHashSet.createWithCheck"
                                               "cljs.core/*warn-on-infer*"
                                               "cljs.reader/add-data-readers"},
                                      :removed #{"cljs.spec.test/enumerate-namespace"}},
                           "0.0-2261" {:added #{"cljs.core/hash-unordered-coll"
                                                "cljs.core/int-rotate-left"
                                                "cljs.core/some?"
                                                "cljs.core/hash-string*"
                                                "cljs.core/m3-C1"
                                                "cljs.core/m3-fmix"
                                                "cljs.core/if-some"
                                                "cljs.core/m3-mix-H1"
                                                "cljs.core/m3-C2"
                                                "cljs.core/hash-string"
                                                "cljs.core/m3-hash-unencoded-chars"
                                                "cljs.reader/read-raw-string*"
                                                "cljs.core/m3-mix-K1"
                                                "cljs.core/hash-keyword"
                                                "cljs.core/m3-hash-int"
                                                "cljs.core/m3-seed"
                                                "cljs.core/hash-ordered-coll"
                                                "cljs.core/when-some"
                                                "cljs.core/mix-collection-hash"},
                                       :removed #{"cljs.core/check-string-hash-cache"}},
                           "0.0-2024" {},
                           "1.9.88" {},
                           "1.7.10" {:added #{"cljs.core/js-reserved"
                                              "cljs.core/demunge"
                                              "cljs.js/*loaded*"
                                              "cljs.js/require"
                                              "cljs.js/debug-prn"
                                              "cljs.core/*out*"
                                              "cljs.js/sm-data"
                                              "cljs.core/symbol-identical?"
                                              "cljs.js/append-source-map"
                                              "cljs.core/DEMUNGE_MAP"
                                              "cljs.js/dump-core"
                                              "cljs.js/analyze"
                                              "cljs.js/compile*"
                                              "cljs.core/*print-err-fn*"
                                              "cljs.core/set-print-err-fn!"
                                              "cljs.js/analyze*"
                                              "cljs.js/load-macros"
                                              "cljs.js/load-deps"
                                              "cljs.core/ns-interns*"
                                              "cljs.js/*eval-fn*"
                                              "cljs.core/munge"
                                              "cljs.core/find-macros-ns"
                                              "cljs.core/CHAR_MAP"
                                              "cljs.js/valid-opts?"
                                              "cljs.core/*ns*"
                                              "cljs.js/*load-fn*"
                                              "cljs.js/atom?"
                                              "cljs.js/valid-name?"
                                              "cljs.js/eval-str*"
                                              "cljs.core/copy-arguments"
                                              "cljs.core/print-meta?"
                                              "cljs.js/js-eval"
                                              "cljs.core/NS_CACHE"
                                              "cljs.core/char?"
                                              "cljs.js/empty-state"
                                              "cljs.js/load-analysis-cache!"
                                              "cljs.core/find-ns"
                                              "cljs.js/eval-str"
                                              "cljs.js/ns-side-effects"
                                              "cljs.js/eval"
                                              "cljs.js/wrap-error"
                                              "cljs.js/eval*"
                                              "cljs.js/ns->relpath"
                                              "cljs.js/load-source-map!"
                                              "cljs.core/find-ns-obj"
                                              "cljs.js/compile"
                                              "cljs.core/Namespace"
                                              "cljs.js/prefix"
                                              "cljs.js/analyze-deps"
                                              "cljs.core/*assert*"
                                              "cljs.core/ns-name"
                                              "cljs.js/file->ns"
                                              "cljs.core/create-ns"
                                              "cljs.js/with-state"
                                              "cljs.core/DEMUNGE_PATTERN"},
                                     :removed #{"cljs.pprint/*out*"}},
                           "0.0-1889" {},
                           "0.0-2657" {:added #{"cljs.core/require-macros"}},
                           "0.0-1896" {},
                           "0.0-2014" {:added #{"cljs.core/*clojurescript-version*"
                                                "cljs.core/implements?"}},
                           "1.9.562" {:added #{"cljs.core/TransformerIterator.create"
                                               "cljs.core/Many"
                                               "cljs.core/Empty"
                                               "cljs.core/Single"
                                               "cljs.core/TransformerIterator.createMulti"
                                               "cljs.core/MultiIterator"
                                               "cljs.core/TransformerIterator"
                                               "cljs.core/transformer-iterator"},
                                      :removed #{"cljs.core/LazyTransformer.createMulti"
                                                 "cljs.core/stepper"
                                                 "cljs.core/LazyTransformer.create"
                                                 "cljs.core/LazyTransformer"
                                                 "cljs.core/lazy-transformer"
                                                 "cljs.core/multi-stepper"
                                                 "cljs.core/Stepper"
                                                 "cljs.core/MultiStepper"}},
                           "0.0-2411" {:added #{"cljs.core/js-invoke"
                                                "cljs.core/ES6IteratorSeq"
                                                "cljs.core/unreduced"
                                                "cljs.core/es6-iterable"
                                                "cljs.core/nthrest"
                                                "cljs.core/js-in"
                                                "cljs.core/update"
                                                "cljs.core/es6-iterator-seq"
                                                "cljs.core/ensure-reduced"}},
                           "0.0-2665" {},
                           "0.0-2760" {}},
                 :symbol-names #{"cljs.core/keys"
                                 "cljs.spec.alpha/tuple"
                                 "cljs.spec.alpha/get-spec"
                                 "cljs.spec.impl.gen/one-of"
                                 "cljs.spec.impl.gen/char-alpha"
                                 "cljs.core/unchecked-negate"
                                 "cljs.spec/Specize"
                                 "cljs.core/reset!"
                                 "cljs.spec.alpha/explain"
                                 "cljs.core/ITransientCollection"
                                 "cljs.core/transient"
                                 "cljs.core/Fn"
                                 "clojure.data/EqualityPartition"
                                 "cljs.core/ex-message"
                                 "cljs.core/js-reserved"
                                 "cljs.spec.impl.gen/large-integer"
                                 "cljs.pprint/write-out"
                                 "cljs.test/test-vars-block"
                                 "cljs.spec.gen.alpha/fmap"
                                 "clojure.set/select"
                                 "cljs.core/hash-unordered-coll"
                                 "cljs.core/delay"
                                 "cljs.core/float"
                                 "cljs.core/bit-not"
                                 "cljs.spec/describe"
                                 "cljs.core/partition"
                                 "cljs.core/IEncodeJS"
                                 "cljs.core/parents"
                                 "cljs.core/aclone"
                                 "cljs.core/reset-meta!"
                                 "cljs.core/IReset"
                                 "cljs.spec.test.alpha/enumerate-namespace"
                                 "cljs.core/NaN?"
                                 "cljs.spec.alpha/spec"
                                 "cljs.core/Box"
                                 "cljs.pprint/cl-format"
                                 "cljs.core/tagged-literal?"
                                 "cljs.reader/dispatch-macros"
                                 "cljs.core/demunge"
                                 "cljs.spec.impl.gen/such-that"
                                 "cljs.pprint/get-pretty-writer"
                                 "cljs.spec.alpha/conformer"
                                 "cljs.core/int-rotate-left"
                                 "cljs.core/ICollection"
                                 "cljs.math/E"
                                 "cljs.core/every?"
                                 "clojure.zip/node"
                                 "cljs.spec/*compile-asserts*"
                                 "cljs.core/RecordIter"
                                 "cljs.core/unchecked-set"
                                 "clojure.string/index-of"
                                 "cljs.spec.impl.gen/list"
                                 "cljs.core/IEmptyableCollection"
                                 "clojure.zip/right"
                                 "cljs.core/int-array"
                                 "cljs.core/LazyTransformer.createMulti"
                                 "cljs.core/=="
                                 "cljs.core/dissoc!"
                                 "cljs.spec.impl.gen/int"
                                 "cljs.spec.impl.gen/boolean"
                                 "clojure.reflect/meta"
                                 "cljs.spec.alpha/fn-sym"
                                 "cljs.reader/read-literal"
                                 "cljs.spec/*fspec-iterations*"
                                 "cljs.spec.impl.gen/tuple"
                                 "clojure.browser.net/*timeout*"
                                 "cljs.js/*loaded*"
                                 "cljs.core/let*"
                                 "cljs.core/remove-tap"
                                 "cljs.core/remove-method"
                                 "cljs.core/array-chunk"
                                 "cljs.spec.alpha/describe"
                                 "clojure.core.reducers/drop"
                                 "clojure.browser.net/IWebSocket"
                                 "cljs.core/PersistentArrayMap.fromArrays"
                                 "cljs.core/frequencies"
                                 "cljs.core/require-macros"
                                 "cljs.core/pop"
                                 "cljs.repl/with-read-known"
                                 "cljs.core/flatmap"
                                 "cljs.core/not-every?"
                                 "cljs.core/js-invoke"
                                 "cljs.spec.alpha/explain-str"
                                 "cljs.core/some-fn"
                                 "clojure.browser.event/remove-all"
                                 "cljs.core/doto"
                                 "cljs.core/take-while"
                                 "cljs.core/*eval*"
                                 "cljs.reader/escape-char-map"
                                 "clojure.browser.event/all-listeners"
                                 "cljs.spec/int-in"
                                 "cljs.spec.gen.alpha/tuple"
                                 "cljs.core/ITransientSet"
                                 "cljs.core/vals"
                                 "cljs.core/IDeref"
                                 "cljs.js/require"
                                 "cljs.core/string-hash-cache"
                                 "cljs.core/array-map"
                                 "cljs.test/report"
                                 "clojure.browser.dom/log-obj"
                                 "cljs.core/import"
                                 "cljs.nodejs/enable-util-print!"
                                 "cljs.spec.impl.gen/ratio"
                                 "cljs.repl/source"
                                 "cljs.core/for"
                                 "cljs.spec.gen.alpha/map"
                                 "cljs.js/debug-prn"
                                 "cljs.spec.impl.gen/large-integer*"
                                 "cljs.core/parse-uuid"
                                 "cljs.core/unchecked-multiply-int"
                                 "cljs.spec/exercise"
                                 "cljs.core/cond->"
                                 "cljs.spec.test.alpha/validate-check-opts"
                                 "cljs.math/next-after"
                                 "cljs.core/instance?"
                                 "cljs.core/ValSeq"
                                 "clojure.browser.repl/print-queue"
                                 "clojure.string/last-index-of"
                                 "cljs.spec.alpha/abbrev"
                                 "cljs.core/rseq"
                                 "cljs.core/PersistentVector.EMPTY_NODE"
                                 "cljs.spec/cat"
                                 "cljs.reader/read-comment"
                                 "cljs.spec.alpha/fdef"
                                 "cljs.core/TransformerIterator.create"
                                 "clojure.datafy/nav"
                                 "cljs.core/ITransientMap"
                                 "cljs.core/pos-int?"
                                 "cljs.core/*loaded-libs*"
                                 "cljs.reader/read-number"
                                 "cljs.core/ILookup"
                                 "cljs.core/when"
                                 "cljs.core/ArrayNodeSeq"
                                 "cljs.core/list?"
                                 "cljs.core/val"
                                 "clojure.browser.dom/set-value"
                                 "cljs.core/BitmapIndexedNode"
                                 "cljs.spec/unstrument"
                                 "cljs.spec.impl.gen/elements"
                                 "cljs.reader/read-past"
                                 "cljs.core/to-array"
                                 "cljs.core/interpose"
                                 "cljs.core/IMapEntry"
                                 "clojure.browser.net/ICrossPageChannel"
                                 "cljs.core/Cons"
                                 "cljs.spec.alpha/cat"
                                 "cljs.core/re-find"
                                 "cljs.core/IMeta"
                                 "cljs.core/js-str"
                                 "cljs.spec.test/abbrev-result"
                                 "cljs.spec.impl.gen/symbol"
                                 "cljs.test/are"
                                 "cljs.spec/or"
                                 "cljs.core/RangeIterator"
                                 "cljs.core/iterator"
                                 "cljs.core/assoc-in"
                                 "clojure.string/join"
                                 "cljs.core/*unchecked-if*"
                                 "cljs.core/some?"
                                 "cljs.core/seqable?"
                                 "clojure.browser.repl/flush-print-queue!"
                                 "clojure.zip/rights"
                                 "cljs.core/split-at"
                                 "clojure.zip/append-child"
                                 "cljs.core/binding"
                                 "cljs.spec/invalid?"
                                 "cljs.core/simple-keyword?"
                                 "cljs.test/get-current-env"
                                 "cljs.math/floor-mod"
                                 "cljs.math/floor"
                                 "cljs.core/Set"
                                 "cljs.core/sorted-map"
                                 "cljs.core/ns-publics"
                                 "cljs.reader/macro-terminating?"
                                 "cljs.pprint/write"
                                 "cljs.spec.impl.gen/gen-for-pred"
                                 "cljs.test/join-fixtures"
                                 "cljs.core/prefers"
                                 "cljs.math/to-degrees"
                                 "cljs.test/assert-predicate"
                                 "cljs.core/vary-meta"
                                 "cljs.core/unchecked-add"
                                 "cljs.core/when-let"
                                 "cljs.spec.alpha/&"
                                 "clojure.core.reducers/folder"
                                 "cljs.core/ASeq"
                                 "cljs.core/drop"
                                 "cljs.core/var"
                                 "cljs.core/ArrayList"
                                 "cljs.spec.test.alpha/abbrev-result"
                                 "cljs.core/stepper"
                                 "cljs.pprint/char-code"
                                 "cljs.core/IAtom"
                                 "cljs.core/reduceable?"
                                 "cljs.core/while"
                                 "cljs.core/dispatch-fn"
                                 "cljs.core/*out*"
                                 "cljs.spec.test.alpha/->sym"
                                 "cljs.core/import-macros"
                                 "cljs.spec.gen.alpha/frequency"
                                 "cljs.spec.impl.gen/uuid"
                                 "cljs.core/string-print"
                                 "cljs.core/ES6IteratorSeq"
                                 "cljs.js/sm-data"
                                 "cljs.repl/err-out"
                                 "cljs.spec.test/instrumentable-syms"
                                 "cljs.spec.alpha/map-of"
                                 "cljs.core/IntegerRange"
                                 "cljs.spec.gen.alpha/keyword"
                                 "cljs.core/-"
                                 "cljs.core/loop*"
                                 "cljs.core/vector-seq"
                                 "cljs.core/IIterable"
                                 "cljs.test/testing-contexts-str"
                                 "clojure.zip/vector-zip"
                                 "cljs.reader/read-2-chars"
                                 "cljs.core/chunk"
                                 "cljs.core/conj!"
                                 "cljs.spec.test.alpha/summarize-results"
                                 "cljs.test/do-report"
                                 "cljs.spec.gen.alpha/double*"
                                 "cljs.core/print-map"
                                 "cljs.core/js->clj"
                                 "cljs.core/List"
                                 "cljs.spec/*coll-check-limit*"
                                 "cljs.core/identical?"
                                 "cljs.core/*main-cli-fn*"
                                 "clojure.browser.dom/html->dom"
                                 "cljs.core/js-arguments"
                                 "cljs.core/symbol-identical?"
                                 "cljs.core/LazyTransformer.create"
                                 "cljs.core/chunk-next"
                                 "cljs.core/enable-console-print!"
                                 "cljs.core/sorted?"
                                 "cljs.core/some"
                                 "cljs.core/PersistentArrayMapSeq"
                                 "cljs.reader/make-unicode-char"
                                 "cljs.core/if"
                                 "cljs.spec.alpha/*"
                                 "clojure.core.reducers/Cat"
                                 "cljs.core/write-all"
                                 "cljs.core/doall"
                                 "cljs.core/condp"
                                 "clojure.zip/down"
                                 "cljs.pprint/simple-dispatch"
                                 "cljs.core/IPending"
                                 "cljs.core/count"
                                 "cljs.core/bit-test"
                                 "cljs.core/js-mod"
                                 "cljs.spec/conform"
                                 "cljs.core/es6-set-entries-iterator"
                                 "cljs.test/set-env!"
                                 "cljs.core/SetEntriesIterator"
                                 "cljs.spec.gen.alpha/quick-check"
                                 "cljs.spec/int-in-range?"
                                 "cljs.core/loop"
                                 "cljs.core/subvec"
                                 "cljs.core/bit-clear"
                                 "cljs.spec.impl.gen/bind"
                                 "cljs.repl/apropos"
                                 "cljs.core/gensym"
                                 "cljs.core/MODULE_URIS"
                                 "cljs.core/gensym_counter"
                                 "cljs.core/in-ns"
                                 "cljs.core/Symbol"
                                 "cljs.core/hash-string*"
                                 "cljs.core/shuffle"
                                 "cljs.core/+"
                                 "cljs.core/clone"
                                 "cljs.core/comp"
                                 "cljs.core/ArrayIter"
                                 "cljs.core/var?"
                                 "cljs.reader/desugar-meta"
                                 "cljs.spec/form"
                                 "cljs.pprint/fresh-line"
                                 "cljs.math/copy-sign"
                                 "cljs.spec.test.alpha/get-host-port"
                                 "cljs.core/pr"
                                 "cljs.test/run-tests"
                                 "clojure.string/upper-case"
                                 "cljs.core/chars"
                                 "cljs.core/coercive-boolean"
                                 "cljs.core/boolean?"
                                 "cljs.spec.gen.alpha/vector-distinct"
                                 "clojure.browser.event/expose"
                                 "cljs.core/partitionv"
                                 "clojure.browser.event/listen-once"
                                 "cljs.spec.gen.alpha/LazyVar"
                                 "cljs.core/m3-C1"
                                 "cljs.core/empty?"
                                 "cljs.core/m3-fmix"
                                 "clojure.browser.repl/*repl*"
                                 "cljs.core/newline"
                                 "cljs.core/PersistentHashMap"
                                 "cljs.spec/*"
                                 "cljs.spec.alpha/gen"
                                 "cljs.pprint/pprint-set"
                                 "cljs.pprint/deftype"
                                 "cljs.spec.alpha/spec?"
                                 "cljs.core/replace"
                                 "cljs.core/rand"
                                 "cljs.core/add-watch"
                                 "cljs.math/exp"
                                 "cljs.core/cloneable?"
                                 "clojure.string/capitalize"
                                 "cljs.core/short"
                                 "cljs.core/replicate"
                                 "cljs.core/es6-entries-iterator"
                                 "cljs.spec.impl.gen/vector"
                                 "cljs.core/Many"
                                 "cljs.core/ArrayChunk"
                                 "cljs.core/sequential?"
                                 "cljs.core/underive"
                                 "cljs.core/PersistentArrayMapIterator"
                                 "cljs.core/coercive-not"
                                 "cljs.spec/registry-ref"
                                 "cljs.core/ns-unmap"
                                 "cljs.spec.gen.alpha/cat"
                                 "cljs.core/use"
                                 "cljs.core/macroexpand"
                                 "clojure.browser.repl/get-ua-product"
                                 "cljs.math/next-down"
                                 "cljs.core/get-method"
                                 "cljs.spec/valid?"
                                 "cljs.core/="
                                 "cljs.math/rint"
                                 "cljs.core/mask"
                                 "cljs.reader/deregister-default-tag-parser!"
                                 "cljs.core/system-time"
                                 "cljs.core/defn-"
                                 "cljs.js/append-source-map"
                                 "cljs.reader/read-symbol"
                                 "cljs.reader/push-back-reader"
                                 "cljs.core/deftype"
                                 "cljs.repl/print-doc"
                                 "cljs.core/longs"
                                 "cljs.repl/Error->map"
                                 "cljs.core/Subvec"
                                 "cljs.core/macroexpand-1"
                                 "cljs.core/."
                                 "cljs.core/if-some"
                                 "cljs.test/js-filename"
                                 "cljs.core/IReversible"
                                 "cljs.core/extend-protocol"
                                 "cljs.reader/read"
                                 "cljs.core/IFind"
                                 "cljs.spec.alpha/inst-in-range?"
                                 "clojure.browser.repl/parent-connected?"
                                 "cljs.core/EmptyList"
                                 "cljs.core/specify!"
                                 "cljs.core/DEMUNGE_MAP"
                                 "cljs.core/cat"
                                 "clojure.walk/postwalk"
                                 "cljs.spec.alpha/int-in"
                                 "cljs.core/PersistentArrayMap.HASHMAP-THRESHOLD"
                                 "cljs.core/PersistentArrayMap.createWithCheck"
                                 "clojure.zip/edit"
                                 "cljs.core/unreduced"
                                 "cljs.core/re-seq"
                                 "cljs.reader/read-list"
                                 "cljs.core/IKVReduce"
                                 "cljs.core/Atom"
                                 "clojure.core.reducers/foldcat"
                                 "cljs.spec/with-gen"
                                 "cljs.core/specify"
                                 "cljs.core/IMap"
                                 "cljs.core/LongImpl"
                                 "cljs.core/pr-sequential-writer"
                                 "cljs.core/unchecked-multiply"
                                 "cljs.reader/read-vector"
                                 "clojure.set/join"
                                 "cljs.spec.gen.alpha/double"
                                 "cljs.core/HashMap"
                                 "cljs.core/es6-iterable"
                                 "cljs.reader/int-pattern"
                                 "cljs.core/swap!"
                                 "cljs.core/finally"
                                 "cljs.spec/explain-str"
                                 "cljs.spec.alpha/check-asserts?"
                                 "cljs.spec/coll-of"
                                 "cljs.core/dec"
                                 "cljs.core/EntriesIterator"
                                 "cljs.core/*clojurescript-version*"
                                 "cljs.js/dump-core"
                                 "cljs.spec.alpha/*coll-check-limit*"
                                 "clojure.core.reducers/fold"
                                 "cljs.spec/instrument-ns"
                                 "cljs.core/StringBufferWriter"
                                 "cljs.js/analyze"
                                 "cljs.core/gen-apply-to-simple"
                                 "cljs.spec.alpha/invalid?"
                                 "clojure.browser.dom/remove-children"
                                 "cljs.core/BlackNode"
                                 "cljs.spec.test.alpha/checkable-syms"
                                 "cljs.core/some->"
                                 "cljs.core/hash-long"
                                 "cljs.core/get-validator"
                                 "cljs.core/coll?"
                                 "cljs.core/unchecked-negate-int"
                                 "cljs.core/bit-or"
                                 "cljs.core/nfirst"
                                 "cljs.core/keep"
                                 "cljs.core/take"
                                 "cljs.core/unchecked-get"
                                 "cljs.core/PersistentHashSet.EMPTY"
                                 "cljs.core/cond"
                                 "cljs.spec/unform"
                                 "cljs.spec.test.alpha/instrumentable-syms"
                                 "cljs.core/bit-and"
                                 "cljs.core/MetaFn"
                                 "cljs.core/ObjMap.fromObject"
                                 "cljs.core/PersistentArrayMap"
                                 "cljs.core/HashMapIter"
                                 "clojure.browser.event/unique-event-id"
                                 "cljs.core/vswap!"
                                 "cljs.spec/def"
                                 "cljs.core/ObjMap.HASHMAP_THRESHOLD"
                                 "clojure.set/project"
                                 "cljs.core/int"
                                 "clojure.reflect/macroexpand"
                                 "cljs.core/Empty"
                                 "cljs.pprint/with-pretty-writer"
                                 "clojure.string/trim-newline"
                                 "cljs.spec/nilable"
                                 "cljs.math/acos"
                                 "cljs.spec.alpha/explain-printer"
                                 "cljs.spec.gen.alpha/char-alpha"
                                 "cljs.core/pr-seq-writer"
                                 "cljs.spec.alpha/nonconforming"
                                 "cljs.core/chunk-cons"
                                 "cljs.spec/alt"
                                 "clojure.zip/insert-left"
                                 "cljs.core/*print-level*"
                                 "cljs.spec.gen.alpha/char"
                                 "cljs.core/truth_"
                                 "cljs.core/true?"
                                 "cljs.core/unchecked-substract-int"
                                 "clojure.browser.net/xpc-connection"
                                 "cljs.core/infinite?"
                                 "cljs.spec.test/instrument-1"
                                 "cljs.core/ES6EntriesIterator"
                                 "cljs.core/not"
                                 "cljs.core/js-obj"
                                 "cljs.core/complement"
                                 "cljs.core/spread"
                                 "cljs.core/unchecked-double"
                                 "cljs.core/keyword"
                                 "cljs.spec.impl.gen/simple-type-printable"
                                 "cljs.core/sort"
                                 "cljs.spec.test.alpha/instrument"
                                 "clojure.string/trim"
                                 "cljs.core/meta"
                                 "cljs.core/*command-line-args*"
                                 "cljs.core/ifind?"
                                 "cljs.spec.impl.gen/delay"
                                 "clojure.core.reducers/monoid"
                                 "cljs.core/Repeat"
                                 "cljs.core/time"
                                 "cljs.core/boolean"
                                 "cljs.reader/read-token"
                                 "cljs.core/update-in"
                                 "cljs.spec.gen.alpha/ratio"
                                 "cljs.core/map-indexed"
                                 "cljs.core/IVolatile"
                                 "cljs.core/printf"
                                 "clojure.core.reducers/map"
                                 "cljs.spec.gen.alpha/simple-type"
                                 "cljs.core/IStack"
                                 "cljs.spec.alpha/explain-data"
                                 "cljs.spec.test/distinct-by"
                                 "cljs.repl/pst"
                                 "cljs.core/splitv-at"
                                 "cljs.reader/parse-and-validate-timestamp"
                                 "clojure.browser.repl/PORT"
                                 "cljs.core/Throwable->map"
                                 "cljs.core/ISorted"
                                 "cljs.core/*print-namespace-maps*"
                                 "cljs.test/file-and-line"
                                 "cljs.core/IIndexed"
                                 "cljs.math/decrement-exact"
                                 "clojure.browser.repl/repl-print"
                                 "cljs.spec.gen.alpha/keyword-ns"
                                 "clojure.browser.net/xpc-config-fields"
                                 "cljs.js/compile*"
                                 "cljs.core/ISwap"
                                 "cljs.core/nnext"
                                 "cljs.core/*print-meta*"
                                 "cljs.reader/read-dispatch"
                                 "cljs.test/run-block"
                                 "cljs.core/*print-err-fn*"
                                 "cljs.core/distinct"
                                 "cljs.reader/wrapping-reader"
                                 "cljs.core/LazyTransformer"
                                 "cljs.core/double-array"
                                 "cljs.spec.impl.gen/LazyVar"
                                 "cljs.core/prn"
                                 "cljs.core/chunked-seq"
                                 "clojure.zip/leftmost"
                                 "cljs.core/nthrest"
                                 "cljs.core/js-in"
                                 "cljs.test/function?"
                                 "cljs.core/>="
                                 "clojure.browser.net/websocket-connection"
                                 "cljs.core/default-dispatch-val"
                                 "cljs.reader/macros"
                                 "cljs.core/doseq"
                                 "cljs.core/*"
                                 "cljs.core/into"
                                 "cljs.spec.alpha/merge"
                                 "cljs.spec.alpha/registry-ref"
                                 "cljs.core/defmethod"
                                 "cljs.math/to-radians"
                                 "cljs.core/rest"
                                 "cljs.spec.test/->sym"
                                 "cljs.reader/unicode-4-pattern"
                                 "clojure.browser.repl/bootstrap"
                                 "cljs.spec/assert*"
                                 "cljs.spec.alpha/registry"
                                 "cljs.spec.alpha/assert*"
                                 "cljs.core/dotimes"
                                 "cljs.core/dedupe"
                                 "clojure.zip/lefts"
                                 "cljs.spec.gen.alpha/large-integer*"
                                 "cljs.math/tanh"
                                 "cljs.spec.gen.alpha/string"
                                 "cljs.spec/conformer"
                                 "cljs.spec.gen.alpha/boolean"
                                 "clojure.browser.dom/ensure-element"
                                 "cljs.spec/spec"
                                 "cljs.core/defmacro"
                                 "cljs.core/remove"
                                 "cljs.test/test-all-vars"
                                 "cljs.core/reset-vals!"
                                 "cljs.core/set-print-fn!"
                                 "cljs.core/PersistentArrayMap.HASHMAP_THRESHOLD"
                                 "cljs.math/pow"
                                 "cljs.core/ns"
                                 "cljs.core/if-not"
                                 "cljs.core/string-iter"
                                 "cljs.core/set-print-err-fn!"
                                 "cljs.core/hash-double"
                                 "cljs.js/analyze*"
                                 "cljs.spec.impl.gen/double*"
                                 "cljs.test/assert-any"
                                 "clojure.zip/path"
                                 "cljs.core/mapcat"
                                 "cljs.core/m3-mix-H1"
                                 "cljs.core/IWatchable"
                                 "cljs.core/PersistentHashMap.fromArray"
                                 "cljs.core/run!"
                                 "cljs.spec.test.alpha/get-ua-product"
                                 "cljs.core/coercive-not="
                                 "cljs.spec.alpha/exercise"
                                 "cljs.core/IndexedSeqIterator"
                                 "cljs.core/unchecked-inc-int"
                                 "cljs.spec.test/with-instrument-disabled"
                                 "cljs.spec.alpha/double-in"
                                 "cljs.test/testing-vars-str"
                                 "clojure.zip/rightmost"
                                 "cljs.core/PersistentArrayMap.EMPTY"
                                 "cljs.core/m3-C2"
                                 "cljs.core/uuid?"
                                 "cljs.test/compose-fixtures"
                                 "cljs.core/unchecked-subtract"
                                 "clojure.core.protocols/Datafiable"
                                 "cljs.js/load-macros"
                                 "cljs.core/->"
                                 "cljs.core/remove-all-methods"
                                 "cljs.spec.gen.alpha/simple-type-printable"
                                 "cljs.core/unchecked-add-int"
                                 "clojure.string/replace-first"
                                 "cljs.core/reduced?"
                                 "clojure.browser.dom/get-value"
                                 "clojure.core.reducers/CollFold"
                                 "cljs.core/Iterate"
                                 "cljs.nodejs/process"
                                 "cljs.core/some->>"
                                 "cljs.core/unchecked-inc"
                                 "cljs.core/not="
                                 "cljs.spec/exercise-fn"
                                 "cljs.core/unchecked-subtract-int"
                                 "cljs.core/ex-data"
                                 "cljs.core/PersistentTreeMapSeq"
                                 "cljs.core/js-keys"
                                 "cljs.spec.alpha/keys"
                                 "clojure.zip/seq-zip"
                                 "cljs.spec.test/instrument"
                                 "cljs.core/lazy-transformer"
                                 "cljs.core/random-sample"
                                 "cljs.spec.alpha/every"
                                 "cljs.core/IVector"
                                 "cljs.core/iter"
                                 "cljs.core/persistent!"
                                 "cljs.core/empty"
                                 "cljs.core/re-matches"
                                 "cljs.spec.test.alpha/unstrument-1"
                                 "clojure.browser.dom/DOMBuilder"
                                 "cljs.spec.impl.gen/choose"
                                 "cljs.core/extend-type"
                                 "cljs.core/ISeqable"
                                 "cljs.core/assoc"
                                 "clojure.browser.repl/xpc-connection"
                                 "cljs.core/IDerefWithTimeout"
                                 "cljs.core/multi-stepper"
                                 "clojure.core.reducers/cat"
                                 "cljs.core/unchecked-substract"
                                 "cljs.core/Iteration"
                                 "clojure.browser.repl/start-evaluator"
                                 "cljs.pprint/setf"
                                 "clojure.browser.event/unlisten"
                                 "cljs.core/unsafe-bit-and"
                                 "clojure.core.protocols/Navigable"
                                 "cljs.test/is"
                                 "cljs.core/MapEntry"
                                 "cljs.spec.alpha/*explain-out*"
                                 "cljs.core/do"
                                 "cljs.spec/get-spec"
                                 "cljs.test/use-fixtures"
                                 "cljs.pprint/float?"
                                 "cljs.core/PersistentHashMap.fromArrays"
                                 "cljs.core/special-symbol?"
                                 "cljs.spec.impl.gen/fmap"
                                 "cljs.math/log"
                                 "cljs.spec.gen.alpha/sample"
                                 "cljs.js/load-deps"
                                 "cljs.core/case*"
                                 "cljs.core/js-debugger"
                                 "cljs.core/ns-interns*"
                                 "cljs.core/qualified-keyword?"
                                 "cljs.core/format"
                                 "cljs.core/sorted-set"
                                 "cljs.core/fnil"
                                 "cljs.core/ns*"
                                 "cljs.core/update"
                                 "cljs.core/--destructure-map"
                                 "cljs.core/this-as"
                                 "cljs.core/PersistentQueueSeq"
                                 "cljs.core/counted?"
                                 "clojure.string/trimr"
                                 "clojure.core.reducers/take"
                                 "cljs.core/force"
                                 "cljs.core/compare-and-set!"
                                 "cljs.core/set?"
                                 "cljs.core/hash-string"
                                 "cljs.spec.gen.alpha/dynaload"
                                 "cljs.core/Inst"
                                 "cljs.core/load-file"
                                 "cljs.core/unchecked-dec"
                                 "cljs.core/PersistentVector.EMPTY-NODE"
                                 "clojure.string/escape"
                                 "cljs.spec.alpha/and"
                                 "cljs.core/remove-watch"
                                 "cljs.core/m3-hash-unencoded-chars"
                                 "cljs.math/IEEE-remainder"
                                 "cljs.spec.gen.alpha/elements"
                                 "cljs.core/es6-iterator-seq"
                                 "cljs.js/*eval-fn*"
                                 "cljs.core/IMultiFn"
                                 "clojure.browser.event/IEventType"
                                 "cljs.core/HashSetIter"
                                 "cljs.spec.impl.gen/any"
                                 "cljs.math/random"
                                 "clojure.zip/end?"
                                 "cljs.core/halt-when"
                                 "clojure.string/starts-with?"
                                 "cljs.test/clear-env!"
                                 "cljs.test/test-all-vars-block"
                                 "clojure.set/superset?"
                                 "clojure.browser.net/IConnection"
                                 "cljs.core/let"
                                 "cljs.core/unchecked-divide-int"
                                 "cljs.core/dorun"
                                 "cljs.core/with-redefs"
                                 "cljs.core/SeqIter"
                                 "cljs.core/munge"
                                 "cljs.core/unsigned-bit-shift-right"
                                 "cljs.core/iterable?"
                                 "cljs.core/pr-str"
                                 "cljs.core/IPrintable"
                                 "cljs.math/scalb"
                                 "cljs.math/expm1"
                                 "cljs.core/defprotocol"
                                 "cljs.core/ints"
                                 "cljs.spec.test/run-all-tests"
                                 "cljs.core/assert"
                                 "cljs.core/declare"
                                 "cljs.spec.impl.gen/string-ascii"
                                 "cljs.core/PersistentTreeMap.EMPTY"
                                 "cljs.core/fn?"
                                 "cljs.core/associative?"
                                 "cljs.core/IList"
                                 "cljs.core/list*"
                                 "cljs.core/PersistentArrayMap.fromArray"
                                 "cljs.core/js-comment"
                                 "cljs.core/reduce"
                                 "cljs.core/IDrop"
                                 "clojure.browser.event/has-listener"
                                 "cljs.core/unchecked-dec-int"
                                 "cljs.core/PersistentHashMap.EMPTY"
                                 "cljs.pprint/*print-base*"
                                 "cljs.core/compare"
                                 "cljs.spec/&"
                                 "cljs.core/contains?"
                                 "cljs.spec.test/checkable-syms"
                                 "cljs.core/Stepper"
                                 "cljs.core/prefer-method"
                                 "cljs.core/array-seq"
                                 "cljs.core/to-array-2d"
                                 "cljs.core/find-macros-ns"
                                 "cljs.core/ICloneable"
                                 "cljs.core/*print-length*"
                                 "cljs.spec/fdef"
                                 "cljs.core/PersistentQueue"
                                 "cljs.spec.impl.gen/sample"
                                 "cljs.spec.alpha/explain-out"
                                 "cljs.spec.alpha/inst-in"
                                 "cljs.spec.alpha/?"
                                 "cljs.core/drop-last"
                                 "cljs.spec.gen.alpha/vector"
                                 "cljs.core/array?"
                                 "cljs.core/PersistentVector.fromArray"
                                 "cljs.spec.alpha/keys*"
                                 "cljs.core/filterv"
                                 "cljs.core/IComparable"
                                 "cljs.reader/read-string"
                                 "cljs.spec/*explain-out*"
                                 "cljs.core/*global*"
                                 "cljs.spec.gen.alpha/one-of"
                                 "cljs.reader/unicode-2-pattern"
                                 "cljs.core/CHAR_MAP"
                                 "cljs.core/Volatile"
                                 "cljs.core/check-string-hash-cache"
                                 "cljs.spec/every"
                                 "cljs.core/vector?"
                                 "cljs.core/defmulti"
                                 "cljs.spec/check-asserts?"
                                 "cljs.spec.alpha/coll-of"
                                 "cljs.core/Keyword"
                                 "cljs.spec.test/summarize-results"
                                 "cljs.spec.impl.gen/hash-map"
                                 "cljs.core/List.EMPTY"
                                 "cljs.spec.test.alpha/check-1"
                                 "cljs.spec.test.alpha/check-fn"
                                 "clojure.browser.event/dispatch-event"
                                 "clojure.datafy/datafy"
                                 "cljs.core/print-prefix-map"
                                 "cljs.core/ns-interns"
                                 "clojure.string/split-lines"
                                 "cljs.test/mapped-line-and-column"
                                 "cljs.js/valid-opts?"
                                 "cljs.spec/every-kv"
                                 "cljs.math/signum"
                                 "cljs.spec.gen.alpha/char-ascii"
                                 "cljs.core/ident?"
                                 "cljs.spec/Spec"
                                 "cljs.core/*ns*"
                                 "cljs.core/areduce"
                                 "cljs.core/disj"
                                 "cljs.js/*load-fn*"
                                 "cljs.core/IEditableCollection"
                                 "cljs.core/unchecked-char"
                                 "cljs.core/keyword-identical?"
                                 "clojure.browser.net/event-types"
                                 "clojure.string/lower-case"
                                 "cljs.math/ceil"
                                 "cljs.core/*print-fn*"
                                 "cljs.core/str"
                                 "cljs.core/ISequential"
                                 "cljs.core/try*"
                                 "cljs.spec.impl.gen/symbol-ns"
                                 "cljs.pprint/pprint-newline"
                                 "cljs.spec.impl.gen/any-printable"
                                 "cljs.core/key-test"
                                 "cljs.core/set"
                                 "cljs.spec.alpha/+"
                                 "cljs.core/obj-map"
                                 "clojure.browser.repl/load-queue"
                                 "cljs.core/print"
                                 "cljs.core/ArrayNode"
                                 "cljs.core/type"
                                 "clojure.string/blank?"
                                 "cljs.spec/abbrev"
                                 "cljs.reader/maybe-read-tagged-type"
                                 "cljs.core/js-inline-comment"
                                 "cljs.core/IChunkedSeq"
                                 "clojure.browser.dom/append"
                                 "cljs.core/take-last"
                                 "cljs.core/js-symbol?"
                                 "cljs.spec.gen.alpha/list"
                                 "clojure.edn/read"
                                 "cljs.spec.gen.alpha/gen-for-pred"
                                 "cljs.core/key->js"
                                 "cljs.spec/explain-printer"
                                 "cljs.core/TransientHashMap"
                                 "clojure.set/intersection"
                                 "cljs.core/Single"
                                 "cljs.js/atom?"
                                 "cljs.test/async?"
                                 "cljs.core/fnext"
                                 "cljs.core/apply"
                                 "clojure.walk/prewalk"
                                 "cljs.core/flatten"
                                 "cljs.js/valid-name?"
                                 "cljs.spec.gen.alpha/hash-map"
                                 "cljs.core/eval"
                                 "cljs.core/get"
                                 "cljs.core/char"
                                 "cljs.core/tagged-literal"
                                 "cljs.core/.."
                                 "cljs.core/floats"
                                 "cljs.core/Range"
                                 "cljs.spec/nonconforming"
                                 "cljs.core/zero?"
                                 "cljs.core/identity"
                                 "cljs.math/log1p"
                                 "cljs.core/load"
                                 "cljs.core/first"
                                 "cljs.core/*print-fn-bodies*"
                                 "cljs.reader/ratio-pattern"
                                 "cljs.core/println-str"
                                 "cljs.spec/check-asserts"
                                 "cljs.core/>"
                                 "cljs.core/juxt"
                                 "cljs.pprint/*print-suppress-namespaces*"
                                 "cljs.spec/map-of"
                                 "cljs.core/max"
                                 "cljs.core/completing"
                                 "cljs.core/transduce"
                                 "cljs.pprint/set-pprint-dispatch"
                                 "cljs.test/test-var"
                                 "cljs.core/with-out-str"
                                 "cljs.core/*3"
                                 "cljs.core/IntegerRangeChunk"
                                 "cljs.core/memfn"
                                 "cljs.core/IEncodeClojure"
                                 "cljs.spec/+"
                                 "cljs.js/eval-str*"
                                 "cljs.core/TransientArrayMap"
                                 "cljs.core/cond->>"
                                 "cljs.core/number?"
                                 "cljs.spec/explain"
                                 "cljs.core/array"
                                 "cljs.core/nthnext"
                                 "cljs.core/re-pattern"
                                 "cljs.core/missing-protocol"
                                 "clojure.browser.dom/set-text"
                                 "cljs.test/js-line-and-column"
                                 "cljs.core/copy-arguments"
                                 "clojure.zip/up"
                                 "cljs.spec.impl.gen/char-ascii"
                                 "cljs.core/IWithMeta"
                                 "cljs.core/bit-and-not"
                                 "clojure.string/triml"
                                 "cljs.core/chunk-append"
                                 "cljs.core/resolve"
                                 "cljs.core/simple-symbol?"
                                 "cljs.core/equiv-map"
                                 "clojure.string/ends-with?"
                                 "cljs.core/bitpos"
                                 "cljs.spec.impl.gen/cat"
                                 "cljs.core/PersistentHashSet.createAsIfByAssoc"
                                 "cljs.spec.gen.alpha/string-ascii"
                                 "cljs.core/print-meta?"
                                 "cljs.core/regexp?"
                                 "cljs.spec.test.alpha/check"
                                 "clojure.string/split"
                                 "cljs.spec.alpha/speced-vars"
                                 "cljs.reader/read-4-chars"
                                 "cljs.pprint/with-pprint-dispatch"
                                 "cljs.core/iteration"
                                 "cljs.core/simple-ident?"
                                 "cljs.core/hash-map"
                                 "cljs.core/mapv"
                                 "cljs.core/rem"
                                 "cljs.core/IRecord"
                                 "cljs.spec.alpha/conform"
                                 "cljs.core/unsafe-cast"
                                 "clojure.edn/read-string"
                                 "cljs.core/RangedIterator"
                                 "cljs.math/negate-exact"
                                 "cljs.core/volatile!"
                                 "cljs.core/constantly"
                                 "cljs.test/*current-env*"
                                 "clojure.browser.dom/get-element"
                                 "cljs.core/PersistentQueueIter"
                                 "cljs.core/UUID"
                                 "clojure.core.reducers/reduce"
                                 "cljs.core/and"
                                 "cljs.js/js-eval"
                                 "clojure.browser.repl/wrap-message"
                                 "cljs.spec/speced-vars*"
                                 "cljs.core/parse-boolean"
                                 "cljs.reader/deregister-tag-parser!"
                                 "clojure.reflect/print-doc"
                                 "clojure.browser.event/unlisten-by-key"
                                 "cljs.core/new"
                                 "cljs.core/try"
                                 "cljs.core/iterate"
                                 "cljs.spec/double-in"
                                 "cljs.core/lazy-seq"
                                 "cljs.test/update-current-env!"
                                 "cljs.spec.impl.gen/quick-check"
                                 "cljs.spec/?"
                                 "cljs.core/bounded-count"
                                 "cljs.core/IndexedSeq"
                                 "cljs.core/KeySeq"
                                 "cljs.core/js-iterable?"
                                 "cljs.core/next"
                                 "cljs.core/*print-readably*"
                                 "cljs.core/booleans"
                                 "cljs.core/not-native"
                                 "cljs.core/last"
                                 "cljs.core/pr-str*"
                                 "cljs.core/letfn*"
                                 "cljs.core/random-uuid"
                                 "cljs.core/bit-shift-left"
                                 "cljs.core/update-vals"
                                 "clojure.string/reverse"
                                 "cljs.core/*unchecked-arrays*"
                                 "cljs.spec/*coll-error-limit*"
                                 "cljs.core/min"
                                 "cljs.reader/escape-char"
                                 "cljs.reader/read-raw-string*"
                                 "cljs.core/INext"
                                 "cljs.reader/read-map"
                                 "cljs.spec/instrument-all"
                                 "cljs.core/tap>"
                                 "cljs.core/seq"
                                 "cljs.core/defrecord*"
                                 "cljs.core/*print-newline*"
                                 "cljs.spec.alpha/form"
                                 "cljs.spec.test.alpha/get-env"
                                 "cljs.spec.gen.alpha/int"
                                 "cljs.repl/error->str"
                                 "cljs.math/hypot"
                                 "cljs.core/long"
                                 "cljs.core/es6-iterator"
                                 "cljs.core/not-empty"
                                 "cljs.core/println"
                                 "cljs.core/NS_CACHE"
                                 "clojure.browser.repl/connect"
                                 "cljs.spec.alpha/with-gen"
                                 "cljs.core/bytes"
                                 "cljs.core/unchecked-byte"
                                 "clojure.browser.dom/insert-at"
                                 "cljs.core/quot"
                                 "clojure.browser.event/get-listener"
                                 "cljs.core/filter"
                                 "cljs.math/atan"
                                 "cljs.spec.gen.alpha/not-empty"
                                 "cljs.core/RSeq"
                                 "cljs.spec.alpha/regex?"
                                 "clojure.zip/branch?"
                                 "cljs.pprint/*print-radix*"
                                 "cljs.core/ObjMap"
                                 "cljs.spec/instrument"
                                 "cljs.core/sequence"
                                 "cljs.core/zipmap"
                                 "cljs.core/char?"
                                 "cljs.core/hash-combine"
                                 "cljs.core/reversible?"
                                 "cljs.core/PersistentArrayMap.createAsIfByAssocComplexPath"
                                 "cljs.core/PersistentHashMap.createWithCheck"
                                 "clojure.core.reducers/flatten"
                                 "cljs.spec.impl.gen/set"
                                 "cljs.core/max-key"
                                 "clojure.zip/insert-child"
                                 "cljs.core/defrecord"
                                 "cljs.core/eduction"
                                 "cljs.spec.impl.gen/return"
                                 "cljs.spec.alpha/def"
                                 "cljs.core/ex-info"
                                 "cljs.js/empty-state"
                                 "cljs.core/update-keys"
                                 "cljs.core/butlast"
                                 "cljs.core/array-iter"
                                 "cljs.spec.alpha/nilable"
                                 "cljs.core/print-str"
                                 "cljs.core/hash"
                                 "cljs.core/bit-set"
                                 "cljs.core/clj->js"
                                 "cljs.js/load-analysis-cache!"
                                 "cljs.core/concat"
                                 "cljs.test/IAsyncTest"
                                 "cljs.spec.test/get-ua-product"
                                 "cljs.core/map-entry?"
                                 "cljs.core/conj"
                                 "cljs.core/unchecked-short"
                                 "clojure.set/difference"
                                 "cljs.spec.gen.alpha/set"
                                 "cljs.spec/instrument*"
                                 "cljs.core/byte"
                                 "cljs.core/when-first"
                                 "cljs.core/add-tap"
                                 "cljs.reader/*tag-table*"
                                 "cljs.core/distinct?"
                                 "cljs.pprint/pprint"
                                 "clojure.core.reducers/filter"
                                 "cljs.core/INamed"
                                 "cljs.math/increment-exact"
                                 "cljs.core/add-to-string-hash-cache"
                                 "cljs.math/cbrt"
                                 "cljs.core/HashCollisionNode"
                                 "cljs.core/m3-mix-K1"
                                 "cljs.core/object?"
                                 "cljs.core/pos?"
                                 "cljs.spec.gen.alpha/return"
                                 "cljs.spec.alpha/unform"
                                 "cljs.math/round"
                                 "cljs.core/APersistentVector"
                                 "cljs.core/refer-clojure"
                                 "cljs.test/block"
                                 "cljs.core/into-array"
                                 "cljs.core/PersistentVector"
                                 "cljs.core/IHash"
                                 "clojure.reflect/doc"
                                 "cljs.core/is_proto_"
                                 "cljs.core/shorts"
                                 "cljs.core/TransientVector"
                                 "cljs.core/keep-indexed"
                                 "cljs.core/bit-shift-right"
                                 "cljs.core/comparator"
                                 "cljs.core/TransformerIterator.createMulti"
                                 "cljs.core/ES6Iterator"
                                 "cljs.pprint/getf"
                                 "cljs.core/coercive-="
                                 "cljs.repl/dir"
                                 "cljs.core/PersistentTreeSet"
                                 "clojure.zip/insert-right"
                                 "cljs.core/make-hierarchy"
                                 "cljs.core/repeat"
                                 "cljs.spec.test/unstrument"
                                 "cljs.spec.impl.gen/vector-distinct"
                                 "cljs.core/array-list"
                                 "cljs.core/prn-str-with-opts"
                                 "cljs.core/MultiFn"
                                 "cljs.spec.test.alpha/checkable-syms*"
                                 "cljs.spec.alpha/exercise-fn"
                                 "cljs.test/successful?"
                                 "cljs.core/hash-keyword"
                                 "cljs.test/run-tests-block"
                                 "cljs.spec.gen.alpha/any"
                                 "cljs.core/inst?"
                                 "cljs.core/Reduced"
                                 "cljs.test/run-test"
                                 "cljs.core/not-any?"
                                 "cljs.reader/read-regex"
                                 "clojure.zip/next"
                                 "cljs.math/subtract-exact"
                                 "cljs.test/async"
                                 "cljs.core/find-ns"
                                 "cljs.core/IFn"
                                 "cljs.core/aget"
                                 "cljs.spec.test.alpha/instrument-1"
                                 "cljs.core/if-let"
                                 "cljs.spec.test/get-env"
                                 "cljs.core//"
                                 "cljs.core/unchecked-int"
                                 "cljs.core/min-key"
                                 "clojure.zip/root"
                                 "cljs.core/drop-while"
                                 "clojure.browser.repl/evaluate-javascript"
                                 "cljs.core/set-validator!"
                                 "cljs.spec.alpha/*compile-asserts*"
                                 "cljs.core/<"
                                 "cljs.core/catch"
                                 "cljs.spec.alpha/assert"
                                 "cljs.math/add-exact"
                                 "cljs.core/deftype*"
                                 "cljs.spec.alpha/*fspec-iterations*"
                                 "cljs.math/log10"
                                 "cljs.spec.gen.alpha/for-all*"
                                 "cljs.core/fn"
                                 "cljs.core/split-with"
                                 "cljs.pprint/formatter-out"
                                 "cljs.math/sinh"
                                 "cljs.js/eval-str"
                                 "cljs.pprint/pp"
                                 "cljs.core/IWriter"
                                 "cljs.core/IReduce"
                                 "cljs.reader/symbol-pattern"
                                 "cljs.core/PersistentHashSet.fromArray"
                                 "cljs.spec.alpha/*recursion-limit*"
                                 "cljs.core/repeatedly"
                                 "cljs.core/uri?"
                                 "cljs.js/ns-side-effects"
                                 "cljs.reader/read-delimited-list"
                                 "cljs.test/inc-report-counter!"
                                 "cljs.core/undefined?"
                                 "clojure.zip/prev"
                                 "cljs.core/seq?"
                                 "cljs.pprint/formatter"
                                 "cljs.core/prn-str"
                                 "cljs.core/chunk-buffer"
                                 "cljs.core/odd?"
                                 "cljs.spec.impl.gen/double"
                                 "cljs.core/cons"
                                 "cljs.spec/unstrument-ns"
                                 "cljs.reader/read-set"
                                 "cljs.core/PersistentArrayMap.createAsIfByAssoc"
                                 "cljs.core/descendants"
                                 "cljs.core/take-nth"
                                 "cljs.reader/throwing-reader"
                                 "cljs.math/floor-div"
                                 "cljs.spec/fspec"
                                 "cljs.core/double"
                                 "cljs.core/even?"
                                 "cljs.core/simple-benchmark"
                                 "cljs.core/persistent-array-map-seq"
                                 "clojure.set/subset?"
                                 "cljs.core/flush"
                                 "cljs.core/long-array"
                                 "cljs.reader/reader-error"
                                 "clojure.walk/prewalk-replace"
                                 "cljs.core/*1"
                                 "cljs.core/subseq"
                                 "cljs.core/Eduction"
                                 "cljs.core/Set.EMPTY"
                                 "cljs.spec/coll-gen"
                                 "cljs.reader/read-unicode-char"
                                 "cljs.core/dissoc"
                                 "cljs.spec.alpha/int-in-range?"
                                 "cljs.pprint/*print-pretty*"
                                 "cljs.core/qualified-symbol?"
                                 "cljs.core/exists?"
                                 "cljs.core/ffirst"
                                 "cljs.spec/and"
                                 "cljs.repl/ex-triage"
                                 "clojure.zip/replace"
                                 "cljs.core/vec"
                                 "cljs.spec/merge"
                                 "cljs.core/or"
                                 "cljs.core/doubles"
                                 "cljs.core/mod"
                                 "cljs.core/aset"
                                 "cljs.js/eval"
                                 "cljs.core/second"
                                 "cljs.core/IChunkedNext"
                                 "cljs.spec.test/check"
                                 "cljs.core/set!"
                                 "cljs.core/bit-count"
                                 "clojure.set/rename"
                                 "cljs.core/m3-hash-int"
                                 "cljs.core/assoc!"
                                 "cljs.spec.test/enumerate-namespace"
                                 "cljs.test/get-and-clear-env!"
                                 "cljs.core/delay?"
                                 "clojure.zip/left"
                                 "cljs.reader/not-implemented"
                                 "cljs.core/IAssociative"
                                 "cljs.pprint/pprint-tab"
                                 "cljs.core/ObjMap.EMPTY"
                                 "cljs.core/group-by"
                                 "cljs.spec/MAX_INT"
                                 "cljs.reader/*default-data-reader-fn*"
                                 "cljs.core/array-index-of"
                                 "cljs.core/*e"
                                 "cljs.core/sorted-map-by"
                                 "cljs.core/symbol"
                                 "cljs.core/volatile?"
                                 "cljs.core/MultiIterator"
                                 "cljs.core/Delay"
                                 "cljs.core/methods"
                                 "cljs.test/test-vars"
                                 "cljs.core/lazy-cat"
                                 "cljs.core/vector"
                                 "cljs.core/rand-int"
                                 "cljs.core/m3-seed"
                                 "cljs.core/throw"
                                 "cljs.core/PersistentQueue.EMPTY"
                                 "cljs.spec/spec?"
                                 "cljs.core/unchecked-float"
                                 "clojure.core.reducers/append!"
                                 "cljs.core/NodeSeq"
                                 "cljs.core/letfn"
                                 "cljs.core/recur"
                                 "cljs.reader/read-discard"
                                 "cljs.js/wrap-error"
                                 "cljs.math/tan"
                                 "cljs.core/gen-apply-to"
                                 "cljs.core/inc"
                                 "cljs.core/NodeIterator"
                                 "cljs.core/name"
                                 "cljs.test/test-ns-block"
                                 "cljs.math/ulp"
                                 "cljs.core/cycle"
                                 "cljs.spec.test/check-var"
                                 "cljs.spec/regex?"
                                 "cljs.core/rsubseq"
                                 "cljs.core/locking"
                                 "cljs.math/next-up"
                                 "cljs.core/divide"
                                 "cljs.core/hash-ordered-coll"
                                 "cljs.core/nil-iter"
                                 "cljs.core/fn*"
                                 "cljs.spec.impl.gen/frequency"
                                 "cljs.core/IUUID"
                                 "cljs.test/run-all-tests"
                                 "cljs.core/map"
                                 "cljs.spec.impl.gen/char"
                                 "cljs.core/ChunkBuffer"
                                 "cljs.js/eval*"
                                 "cljs.js/ns->relpath"
                                 "cljs.core/seq-to-map-for-destructuring"
                                 "cljs.core/amap"
                                 "clojure.zip/children"
                                 "cljs.core/when-not"
                                 "clojure.set/index"
                                 "cljs.spec.impl.gen/simple-type"
                                 "cljs.core/chunked-seq?"
                                 "cljs.spec.impl.gen/map"
                                 "clojure.browser.dom/log"
                                 "cljs.spec/coll-checker"
                                 "cljs.core/Vector.fromArray"
                                 "cljs.spec.alpha/*coll-error-limit*"
                                 "cljs.core/make-array"
                                 "cljs.core/sorted-set-by"
                                 "cljs.spec.impl.gen/for-all*"
                                 "cljs.pprint/*print-pprint-dispatch*"
                                 "cljs.core/partition-by"
                                 "cljs.core/sort-by"
                                 "cljs.test/assert-expr"
                                 "cljs.core/caching-hash"
                                 "cljs.core/ns-imports"
                                 "cljs.core/with-meta"
                                 "cljs.core/NeverEquiv"
                                 "cljs.core/select-keys"
                                 "cljs.spec.alpha/Spec"
                                 "cljs.spec/with-instrument-disabled"
                                 "cljs.core/ISeq"
                                 "cljs.core/disj!"
                                 "cljs.core/partitionv-all"
                                 "cljs.core/neg-int?"
                                 "cljs.test/try-expr"
                                 "cljs.pprint/pprint-indent"
                                 "cljs.core/type->str"
                                 "clojure.walk/postwalk-replace"
                                 "cljs.core/ES6SetEntriesIterator"
                                 "clojure.browser.repl/HOST"
                                 "cljs.core/pr-with-opts"
                                 "cljs.core/->>"
                                 "cljs.spec.gen.alpha/uuid"
                                 "cljs.core/defonce"
                                 "cljs.core/nil?"
                                 "cljs.spec.gen.alpha/symbol-ns"
                                 "cljs.spec/assert"
                                 "cljs.core/any?"
                                 "cljs.core/load-file*"
                                 "cljs.core/load-namespace"
                                 "clojure.walk/stringify-keys"
                                 "cljs.spec/multi-spec"
                                 "clojure.browser.repl/order"
                                 "cljs.core/memoize"
                                 "cljs.core/pr-sequential"
                                 "cljs.js/load-source-map!"
                                 "cljs.math/sin"
                                 "clojure.zip/make-node"
                                 "cljs.spec.test/check-1"
                                 "cljs.core/PersistentVector.EMPTY"
                                 "cljs.reader/float-pattern"
                                 "cljs.core/find-ns-obj"
                                 "cljs.spec.gen.alpha/bind"
                                 "cljs.core/ancestors"
                                 "cljs.js/compile-str"
                                 "cljs.core/integer?"
                                 "cljs.js/compile"
                                 "cljs.core/HashMap.EMPTY"
                                 "cljs.core/int?"
                                 "cljs.core/Vector.EMPTY"
                                 "clojure.zip/xml-zip"
                                 "clojure.walk/walk"
                                 "cljs.spec.gen.alpha/generate"
                                 "cljs.math/multiply-exact"
                                 "cljs.core/ifn?"
                                 "cljs.core/Cycle"
                                 "cljs.core/bit-xor"
                                 "clojure.set/union"
                                 "cljs.spec.test/checkable-syms*"
                                 "cljs.spec.alpha/fspec"
                                 "cljs.core/case"
                                 "cljs.reader/PushbackReader"
                                 "cljs.core/nat-int?"
                                 "cljs.core/isa?"
                                 "cljs.core/abs"
                                 "cljs.spec.impl.gen/dynaload"
                                 "cljs.pprint/PrettyFlush"
                                 "clojure.browser.net/xhr-connection"
                                 "cljs.spec/fn-specs"
                                 "cljs.core/js-fn?"
                                 "cljs.core/as->"
                                 "clojure.core.reducers/reducer"
                                 "cljs.core/uuid"
                                 "cljs.spec.gen.alpha/char-alphanumeric"
                                 "cljs.core/subs"
                                 "cljs.core/float?"
                                 "cljs.core/symbol?"
                                 "clojure.data/Diff"
                                 "clojure.string/replace"
                                 "cljs.spec/unstrument*"
                                 "cljs.core/string?"
                                 "cljs.core/*target*"
                                 "cljs.core/*exec-tap-fn*"
                                 "cljs.core/Namespace"
                                 "cljs.core/partition-all"
                                 "cljs.core/Var"
                                 "cljs.core/RedNode"
                                 "cljs.core/ExceptionInfo"
                                 "cljs.core/merge-with"
                                 "cljs.core/key"
                                 "clojure.browser.dom/set-properties"
                                 "clojure.data/diff"
                                 "cljs.core/ITransientAssociative"
                                 "cljs.core/trampoline"
                                 "cljs.test/test-ns"
                                 "cljs.core/double?"
                                 "cljs.core/implements?"
                                 "cljs.core/PersistentHashSet.createWithCheck"
                                 "cljs.js/prefix"
                                 "clojure.browser.repl/send-print"
                                 "cljs.core/ICounted"
                                 "cljs.core/quote"
                                 "cljs.spec.alpha/every-kv"
                                 "cljs.core/IEquiv"
                                 "cljs.pprint/print-length-loop"
                                 "cljs.core/TransformerIterator"
                                 "cljs.core/reduce-kv"
                                 "cljs.core/js-delete"
                                 "cljs.core/PersistentTreeSet.EMPTY"
                                 "cljs.core/comment"
                                 "cljs.reader/special-symbols"
                                 "cljs.js/analyze-str"
                                 "cljs.core/record?"
                                 "cljs.spec/unstrument-all"
                                 "cljs.core/js*"
                                 "cljs.core/BitmapIndexedNode.EMPTY"
                                 "cljs.reader/register-default-tag-parser!"
                                 "cljs.spec.impl.gen/string-alphanumeric"
                                 "cljs.core/alength"
                                 "cljs.core/mk-bound-fn"
                                 "cljs.spec.test/unstrument-1"
                                 "cljs.spec.impl.gen/generate"
                                 "cljs.math/cos"
                                 "cljs.reader/validate-unicode-escape"
                                 "cljs.core/inst-ms"
                                 "cljs.spec/inst-in-range?"
                                 "cljs.spec.gen.alpha/delay"
                                 "cljs.js/analyze-deps"
                                 "cljs.core/VectorNode"
                                 "cljs.core/string-hash-cache-count"
                                 "cljs.spec.impl.gen/string"
                                 "cljs.core/tree-seq"
                                 "cljs.reader/read-unmatched-delimiter"
                                 "clojure.core.reducers/take-while"
                                 "cljs.reader/register-tag-parser!"
                                 "cljs.core/every-pred"
                                 "cljs.core/swap-vals!"
                                 "cljs.spec.gen.alpha/such-that"
                                 "cljs.core/PersistentHashSet"
                                 "cljs.repl/doc"
                                 "cljs.core/use-macros"
                                 "clojure.set/rename-keys"
                                 "cljs.core/peek"
                                 "cljs.spec.alpha/MAX_INT"
                                 "cljs.core/pr-str-with-opts"
                                 "cljs.core/IChunk"
                                 "cljs.core/ITransientVector"
                                 "cljs.core/IPrintWithWriter"
                                 "cljs.spec.impl.gen/keyword-ns"
                                 "cljs.core/test"
                                 "cljs.math/atan2"
                                 "cljs.core/map?"
                                 "cljs.reader/StringPushbackReader"
                                 "cljs.pprint/code-dispatch"
                                 "cljs.spec.alpha/Specize"
                                 "cljs.spec.test/run-tests"
                                 "cljs.core/PersistentTreeMap"
                                 "cljs.core/HashMap.fromArrays"
                                 "cljs.core/deref"
                                 "cljs.core/reductions"
                                 "cljs.spec.test.alpha/with-instrument-disabled"
                                 "cljs.spec.gen.alpha/any-printable"
                                 "cljs.core/false?"
                                 "cljs.core/bit-flip"
                                 "cljs.test/deftest"
                                 "cljs.spec.impl.gen/keyword"
                                 "cljs.core/ISet"
                                 "cljs.core/require"
                                 "cljs.core/StringIter"
                                 "cljs.spec.gen.alpha/string-alphanumeric"
                                 "cljs.core/LazySeq"
                                 "cljs.core/pop!"
                                 "cljs.spec.alpha/alt"
                                 "cljs.reader/parse-timestamp"
                                 "cljs.core/*warn-on-infer*"
                                 "cljs.core/chunk-first"
                                 "cljs.core/ChunkedSeq"
                                 "cljs.test/testing"
                                 "cljs.spec/keys*"
                                 "cljs.core/*2"
                                 "cljs.test/ns?"
                                 "clojure.browser.event/total-listener-count"
                                 "cljs.spec/keys"
                                 "cljs.core/goog-define"
                                 "cljs.core/MultiStepper"
                                 "cljs.core/alter-meta!"
                                 "clojure.browser.dom/click-element"
                                 "cljs.spec/*recursion-limit*"
                                 "cljs.core/*assert*"
                                 "cljs.core/seq-iter"
                                 "clojure.string/includes?"
                                 "cljs.core/unchecked-remainder-int"
                                 "cljs.math/sqrt"
                                 "cljs.spec/explain-data*"
                                 "cljs.core/bit-shift-right-zero-fill"
                                 "cljs.core/when-some"
                                 "cljs.spec.test.alpha/distinct-by"
                                 "cljs.reader/read-meta"
                                 "cljs.spec.alpha/check-asserts"
                                 "cljs.core/qualified-ident?"
                                 "cljs.spec.alpha/multi-spec"
                                 "cljs.test/test-var-block"
                                 "cljs.core/range"
                                 "cljs.core/reify"
                                 "cljs.core/satisfies?"
                                 "cljs.core/nth"
                                 "cljs.core/list"
                                 "cljs.core/defn"
                                 "cljs.spec.gen.alpha/large-integer"
                                 "cljs.core/rand-nth"
                                 "cljs.core/ex-cause"
                                 "cljs.spec.gen.alpha/shuffle"
                                 "cljs.core/def"
                                 "cljs.core/transformer-iterator"
                                 "cljs.core/atom"
                                 "cljs.reader/read-keyword"
                                 "cljs.core/Vector"
                                 "cljs.reader/skip-line"
                                 "cljs.core/namespace"
                                 "cljs.core/ns-name"
                                 "cljs.nodejs/require"
                                 "cljs.spec/tuple"
                                 "cljs.core/chunk-rest"
                                 "cljs.core/unchecked-long"
                                 "clojure.browser.event/EventType"
                                 "cljs.pprint/IPrettyFlush"
                                 "cljs.js/file->ns"
                                 "cljs.core/ranged-iterator"
                                 "cljs.spec.alpha/valid?"
                                 "cljs.pprint/print-table"
                                 "cljs.core/create-ns"
                                 "cljs.core/PROTOCOL_SENTINEL"
                                 "cljs.spec.gen.alpha/symbol"
                                 "cljs.core/merge"
                                 "clojure.core.reducers/remove"
                                 "cljs.core/set-entries-iterator"
                                 "clojure.browser.repl/send-result"
                                 "cljs.js/with-state"
                                 "clojure.walk/keywordize-keys"
                                 "cljs.pprint/*print-miser-width*"
                                 "cljs.core/entries-iterator"
                                 "cljs.spec.alpha/or"
                                 "cljs.core/reduced"
                                 "cljs.reader/read-string*"
                                 "cljs.core/ArrayNodeIterator"
                                 "cljs.core/ChunkedCons"
                                 "cljs.core/parse-long"
                                 "cljs.core/derive"
                                 "clojure.zip/zipper"
                                 "cljs.spec.alpha/explain-data*"
                                 "cljs.test/empty-env"
                                 "clojure.core.reducers/mapcat"
                                 "cljs.spec/inst-in"
                                 "clojure.zip/remove"
                                 "cljs.repl/find-doc"
                                 "cljs.spec.impl.gen/not-empty"
                                 "cljs.core/find"
                                 "cljs.core/hash-set"
                                 "cljs.core/*print-dup*"
                                 "cljs.spec/explain-data"
                                 "cljs.core/set-from-indexed-seq"
                                 "cljs.core/object-array"
                                 "cljs.core/indexed?"
                                 "cljs.reader/add-data-readers"
                                 "cljs.core/partial"
                                 "cljs.repl/ex-str"
                                 "cljs.spec/explain-out"
                                 "cljs.core/keyword?"
                                 "cljs.math/asin"
                                 "clojure.browser.event/fire-listeners"
                                 "cljs.core/Iterator"
                                 "cljs.core/vreset!"
                                 "cljs.spec/speced-vars"
                                 "cljs.pprint/*print-right-margin*"
                                 "cljs.core/interleave"
                                 "cljs.spec.test/check-fn"
                                 "cljs.spec/gen"
                                 "cljs.core/TransientHashSet"
                                 "cljs.spec.gen.alpha/choose"
                                 "cljs.core/*flush-on-newline*"
                                 "cljs.core/get-in"
                                 "clojure.browser.dom/element"
                                 "cljs.math/get-exponent"
                                 "cljs.core/prim-seq"
                                 "cljs.pprint/pprint-logical-block"
                                 "cljs.spec.test/get-host-port"
                                 "cljs.spec.test.alpha/unstrument"
                                 "cljs.core/<="
                                 "clojure.set/map-invert"
                                 "clojure.browser.event/listen"
                                 "cljs.core/neg?"
                                 "cljs.spec.impl.gen/char-alphanumeric"
                                 "cljs.math/cosh"
                                 "cljs.core/mix-collection-hash"
                                 "clojure.browser.dom/replace-node"
                                 "cljs.core/TaggedLiteral"
                                 "cljs.core/RangeChunk"
                                 "cljs.spec/registry"
                                 "cljs.core/parse-double"
                                 "cljs.core/DEMUNGE_PATTERN"
                                 "cljs.core/MODULE_INFOS"
                                 "cljs.core/reverse"
                                 "cljs.pprint/*out*"
                                 "cljs.core/realized?"
                                 "cljs.core/ensure-reduced"
                                 "cljs.math/PI"},
                 :namespace-names #{"clojure.zip"
                                    "clojure.reflect"
                                    "cljs.test"
                                    "clojure.browser.dom"
                                    "cljs.spec.gen.alpha"
                                    "cljs.math"
                                    "clojure.set"
                                    "clojure.datafy"
                                    "cljs.nodejs"
                                    "clojure.core.protocols"
                                    "cljs.spec"
                                    "clojure.walk"
                                    "clojure.edn"
                                    "cljs.js"
                                    "clojure.browser.event"
                                    "cljs.reader"
                                    "clojure.string"
                                    "cljs.repl"
                                    "clojure.browser.net"
                                    "cljs.spec.alpha"
                                    "cljs.spec.test"
                                    "cljs.spec.test.alpha"
                                    "cljs.spec.impl.gen"
                                    "cljs.core"
                                    "cljs.pprint"
                                    "clojure.data"
                                    "clojure.core.reducers"
                                    "clojure.browser.repl"}},
       :compiler {:changes {"1.10.339" {},
                            "0.0-2030" {},
                            "0.0-2067" {},
                            "1.9.521" {},
                            "0.0-2134" {},
                            "0.0-2322" {},
                            "1.10.891" {},
                            "1.10.335" {},
                            "1.10.844" {},
                            "0.0-1803" {},
                            "0.0-2371" {},
                            "0.0-2307" {},
                            "0.0-3148" {:added #{"cljs.repl/err-out"
                                                 "cljs.repl.browser/es"
                                                 "cljs.repl/canonicalize-specs"
                                                 "cljs.repl/decorate-specs"
                                                 "cljs.repl/repl-quit-prompt"},
                                        :removed #{"cljs.repl/mapped-line-and-column"}},
                            "0.0-1886" {},
                            "0.0-2138" {},
                            "1.11.60" {},
                            "0.0-2505" {},
                            "0.0-2311" {},
                            "1.9.92" {},
                            "0.0-2740" {},
                            "1.12.38" {},
                            "0.0-2725" {},
                            "1.9.211" {},
                            "1.10.312" {:removed #{"cljs.repl/err-out"}},
                            "0.0-2127" {},
                            "0.0-2843" {:added #{"cljs.repl/IPrintStacktrace"
                                                 "cljs.repl/IParseStacktrace"
                                                 "cljs.repl/mapped-stacktrace"}},
                            "0.0-2280" {},
                            "1.9.518" {},
                            "1.10.191" {:added #{"cljs.repl/add-url"
                                                 "cljs.repl/ns->input"
                                                 "cljs.repl/compilable?"}},
                            "1.7.166" {:removed #{"cljs.build.api/cljs-ns-dependents"}},
                            "0.0-2199" {},
                            "1.11.54" {},
                            "1.10.514" {:added #{"cljs.repl/demunge"
                                                 "cljs.repl/ex-triage"
                                                 "cljs.repl/ex-str"}},
                            "0.0-2120" {},
                            "1.9.93" {},
                            "1.9.495" {},
                            "1.10.748" {},
                            "0.0-1878" {},
                            "0.0-1236" {},
                            "0.0-2060" {},
                            "1.11.51" {},
                            "1.10.439" {:added #{"cljs.repl/initial-prompt"}},
                            "0.0-3178" {},
                            "0.0-3126" {},
                            "0.0-1424" {:added #{"cljs.repl.browser/preloaded-libs"}},
                            "1.10.520" {},
                            "0.0-2342" {},
                            "0.0-3169" {},
                            "1.8.34" {:added #{"cljs.repl/known-repl-opts"}},
                            "0.0-1885" {},
                            "1.11.132" {},
                            "1.9.227" {},
                            "0.0-1535" {},
                            "1.9.90" {},
                            "0.0-1859" {},
                            "0.0-3308" {},
                            "1.8.51" {},
                            "0.0-3190" {},
                            "1.10.739" {},
                            "0.0-2755" {},
                            "0.0-1853" {},
                            "0.0-2197" {},
                            "1.9.225" {},
                            "0.0-3291" {:added #{"cljs.build.api/ns->source"
                                                 "cljs.build.api/output-unoptimized"
                                                 "cljs.build.api/add-implicit-options"
                                                 "cljs.repl.browser/ext->mime-type"
                                                 "cljs.build.api/goog-dep-string"
                                                 "cljs.analyzer.api/no-warn"
                                                 "cljs.build.api/compile"
                                                 "cljs.build.api/add-dependencies"
                                                 "cljs.build.api/source-on-disk"
                                                 "cljs.build.api/ns->location"}},
                            "1.10.238" {:added #{"cljs.repl.browser/thread-name"}},
                            "0.0-2075" {},
                            "1.7.28" {},
                            "0.0-2277" {},
                            "1.9.89" {},
                            "1.10.896" {},
                            "0.0-2301" {},
                            "0.0-1909" {},
                            "1.10.63" {:added #{"cljs.repl/eval-cljs"
                                                "cljs.repl/evaluate"
                                                "cljs.repl.browser/default-index"
                                                "cljs.repl/repl-nil?"
                                                "cljs.repl/load"
                                                "cljs.repl.nashorn/tear-down-engine"
                                                "cljs.repl/repl-options"
                                                "cljs.repl/setup"
                                                "cljs.repl/run-inits"
                                                "cljs.repl/tear-down"
                                                "cljs.repl/maybe-install-npm-deps"},
                                       :removed #{"cljs.repl.browser/compile-client-js"
                                                  "cljs.repl.browser/create-client-js-file"}},
                            "0.0-3115" {:removed #{"cljs.repl.browser/loaded-libs"
                                                   "cljs.repl.browser/preloaded-libs"}},
                            "0.0-3195" {},
                            "1.9.35" {},
                            "1.10.753" {:added #{"cljs.analyzer.api/current-file"
                                                 "cljs.analyzer.api/read-analysis-cache"
                                                 "cljs.analyzer.api/current-ns"}},
                            "0.0-3153" {},
                            "1.9.226" {},
                            "1.10.866" {},
                            "0.0-3119" {},
                            "1.9.85" {},
                            "0.0-2723" {},
                            "1.9.75" {},
                            "1.10.741" {},
                            "1.9.229" {},
                            "0.0-2727" {},
                            "0.0-3255" {:added #{"cljs.compiler.api/cljs-files-in"
                                                 "cljs.compiler.api/with-core-cljs"
                                                 "cljs.compiler.api/emit"
                                                 "cljs.compiler.api/compile-file"
                                                 "cljs.compiler.api/requires-compilation?"
                                                 "cljs.compiler.api/compile-root"}},
                            "1.10.914" {},
                            "1.9.854" {:added #{"cljs.build.api/install-node-deps!"
                                                "cljs.repl.server/parse-file-parts"
                                                "cljs.build.api/compiler-opts?"
                                                "cljs.build.api/get-node-deps"},
                                       :removed #{"cljs.build.api/node-module-deps"}},
                            "0.0-1552" {},
                            "0.0-2080" {},
                            "0.0-2234" {},
                            "0.0-2644" {},
                            "1.10.742" {},
                            "1.10.217" {:added #{"cljs.repl.node/create-socket"
                                                 "cljs.repl.node/outs"
                                                 "cljs.repl.node/lock"
                                                 "cljs.repl.node/errs"
                                                 "cljs.repl.node/results"
                                                 "cljs.repl.browser/outs"
                                                 "cljs.repl.node/thread-name"},
                                        :removed #{"cljs.repl.node/socket"}},
                            "1.8.40" {},
                            "0.0-3191" {},
                            "1.11.50" {},
                            "0.0-2268" {},
                            "0.0-3269" {},
                            "0.0-2511" {},
                            "0.0-1806" {},
                            "0.0-3030" {:added #{"cljs.repl.browser/repl-env*"
                                                 "cljs.repl/IParseError"
                                                 "cljs.repl.nashorn/repl-env*"
                                                 "cljs.repl.rhino/repl-env*"},
                                        :removed #{"cljs.repl/IParseErrorMessage"}},
                            "0.0-2341" {},
                            "1.10.64" {},
                            "1.9.36" {},
                            "0.0-3058" {:added #{"cljs.repl/repl-special-doc-map"}},
                            "1.9.216" {},
                            "1.7.58" {},
                            "0.0-2629" {:added #{"cljs.build.api/parse-js-ns"
                                                 "cljs.repl.node/socket"
                                                 "cljs.repl.node/close-socket"
                                                 "cljs.repl/repl*"
                                                 "cljs.repl.node/load-javascript"
                                                 "cljs.repl/update-require-spec"
                                                 "cljs.build.api/src-file->target-file"
                                                 "cljs.repl/merge-require"
                                                 "cljs.repl.node/read-response"
                                                 "cljs.repl/merge-spec"
                                                 "cljs.repl/spec-sort"
                                                 "cljs.build.api/cljs-ns-dependents"
                                                 "cljs.analyzer.api/ns-specs"
                                                 "cljs.repl.node/repl-env"
                                                 "cljs.analyzer.api/in-cljs-user"
                                                 "cljs.repl.node/setup"
                                                 "cljs.repl.node/node-eval"
                                                 "cljs.build.api/src-file->goog-require"
                                                 "cljs.repl.node/write"
                                                 "cljs.repl.node/repl-env*"},
                                        :removed #{"cljs.repl.rhino/current-repl-env"}},
                            "1.11.4" {},
                            "0.0-2719" {:added #{"cljs.repl/with-read-known"
                                                 "cljs.repl/IReplEnvOptions"
                                                 "cljs.repl/skip-whitespace"
                                                 "cljs.repl/repl-read"
                                                 "cljs.repl/skip-if-eol"}},
                            "1.12.35" {:added #{"cljs.analyzer.api/the-ns"}},
                            "0.0-2816" {},
                            "1.7.228" {},
                            "0.0-2227" {},
                            "0.0-1576" {:removed #{"cljs.repl.rhino/loaded-libs"}},
                            "0.0-3297" {:added #{"cljs.repl.browser/mime-type->encoding"}},
                            "1.10.516" {},
                            "0.0-1844" {},
                            "1.9.493" {},
                            "0.0-1586" {},
                            "1.9.671" {},
                            "0.0-3123" {},
                            "1.10.597" {},
                            "1.10.893" {},
                            "1.7.107" {},
                            "0.0-2498" {},
                            "1.7.48" {},
                            "1.10.738" {:added #{"cljs.analyzer.api/current-state"
                                                 "cljs.analyzer.api/warning-message"
                                                 "cljs.build.api/dependency-order"
                                                 "cljs.build.api/handle-js-modules"
                                                 "cljs.build.api/node-modules"
                                                 "cljs.analyzer.api/with-passes"
                                                 "cljs.build.api/compilable->ijs"
                                                 "cljs.analyzer.api/default-passes"
                                                 "cljs.analyzer.api/with-warning-handlers"
                                                 "cljs.analyzer.api/enabled-warnings"
                                                 "cljs.compiler.api/munge"
                                                 "cljs.build.api/add-dependency-sources"
                                                 "cljs.build.api/index-ijs"},
                                        :removed #{"cljs.repl.nashorn/repl-filename"
                                                   "cljs.repl.rhino/eval-result"
                                                   "cljs.repl.nashorn/-main"
                                                   "cljs.repl.rhino/wrap-fn"
                                                   "cljs.repl.nashorn/eval-resource"
                                                   "cljs.repl.nashorn/tear-down-engine"
                                                   "cljs.repl.nashorn/eval-str"
                                                   "cljs.repl.rhino/rhino-eval"
                                                   "cljs.repl.nashorn/create-engine"
                                                   "cljs.repl.rhino/load-javascript"
                                                   "cljs.repl.nashorn/load-ns"
                                                   "cljs.repl.nashorn/load-js-file"
                                                   "cljs.repl.nashorn/init-engine"
                                                   "cljs.repl.nashorn/bootstrap-repl"
                                                   "cljs.repl.rhino/load-file"
                                                   "cljs.repl.rhino/repl-env"
                                                   "cljs.repl.nashorn/repl-env"
                                                   "cljs.repl.rhino/bootjs"
                                                   "cljs.repl.rhino/-main"
                                                   "cljs.repl.nashorn/repl-env*"
                                                   "cljs.repl.rhino/IEval"
                                                   "cljs.repl.rhino/repl-env*"
                                                   "cljs.repl.rhino/rhino-setup"
                                                   "cljs.repl.rhino/stacktrace"}},
                            "0.0-3117" {},
                            "0.0-2850" {},
                            "0.0-1443" {},
                            "0.0-1006" {},
                            "1.9.494" {},
                            "1.9.660" {},
                            "1.10.773" {},
                            "0.0-1913" {},
                            "0.0-2069" {},
                            "0.0-2814" {:added #{"cljs.repl.nashorn/repl-filename"
                                                 "cljs.repl.nashorn/eval-resource"
                                                 "cljs.repl/js-src->cljs-src"
                                                 "cljs.repl/print-mapped-stacktrace"
                                                 "cljs.repl.node/platform-path"
                                                 "cljs.repl.nashorn/eval-str"
                                                 "cljs.repl.nashorn/create-engine"
                                                 "cljs.repl.nashorn/load-ns"
                                                 "cljs.repl.nashorn/load-js-file"
                                                 "cljs.repl.nashorn/init-engine"
                                                 "cljs.repl.nashorn/bootstrap-repl"
                                                 "cljs.repl.node/seq->js-array"
                                                 "cljs.repl.nashorn/repl-env"
                                                 "cljs.repl/mapped-line-and-column"
                                                 "cljs.repl/ns-info"
                                                 "cljs.repl/read-source-map"}},
                            "0.0-2655" {:removed #{"cljs.repl/update-require-spec"
                                                   "cljs.repl/merge-require"
                                                   "cljs.repl/merge-spec"
                                                   "cljs.repl/spec-sort"
                                                   "cljs.analyzer.api/ns-specs"}},
                            "1.7.145" {},
                            "0.0-1513" {},
                            "1.11.57" {},
                            "0.0-1503" {:added #{"cljs.repl.server/handlers"
                                                 "cljs.repl.server/dispatch-on"
                                                 "cljs.repl.server/start"
                                                 "cljs.repl.reflect/parse-param"
                                                 "cljs.repl/analyze-source"
                                                 "cljs.repl.server/state"
                                                 "cljs.repl.reflect/macroexpand"
                                                 "cljs.repl.server/read-request"
                                                 "cljs.repl.server/set-connection"
                                                 "cljs.repl.server/read-post"
                                                 "cljs.repl.server/parse-headers"
                                                 "cljs.repl.reflect/handle-reflect-query"
                                                 "cljs.repl.server/stop"
                                                 "cljs.repl.server/read-get"
                                                 "cljs.repl.reflect/read-url-string"
                                                 "cljs.repl.browser/browser-state"
                                                 "cljs.repl.server/read-headers"
                                                 "cljs.repl.server/send-and-close"
                                                 "cljs.repl.server/send-404"
                                                 "cljs.repl.server/connection"},
                                        :removed #{"cljs.repl.browser/read-get"
                                                   "cljs.repl.browser/handle-get"
                                                   "cljs.repl.browser/stop-server"
                                                   "cljs.repl.browser/read-request"
                                                   "cljs.repl.browser/server-state"
                                                   "cljs.repl.browser/read-headers"
                                                   "cljs.repl.browser/parse-headers"
                                                   "cljs.repl.browser/send-404"
                                                   "cljs.repl.browser/send-and-close"
                                                   "cljs.repl.browser/handle-connection"
                                                   "cljs.repl.browser/start-server"
                                                   "cljs.repl.browser/server-loop"
                                                   "cljs.repl.browser/read-post"}},
                            "1.9.946" {},
                            "0.0-1933" {},
                            "1.9.14" {},
                            "0.0-1895" {},
                            "0.0-971" {},
                            "0.0-2027" {},
                            "0.0-1978" {},
                            "0.0-1843" {},
                            "0.0-2758" {},
                            "0.0-2913" {},
                            "0.0-1835" {},
                            "1.10.740" {},
                            "0.0-3264" {},
                            "1.9.655" {},
                            "0.0-3149" {},
                            "1.9.198" {},
                            "1.11.121" {},
                            "0.0-1450" {},
                            "0.0-2173" {},
                            "0.0-3208" {:added #{"cljs.build.api/build"
                                                 "cljs.analyzer.api/remove-ns"
                                                 "cljs.analyzer.api/parse-ns"
                                                 "cljs.analyzer.api/forms-seq"
                                                 "cljs.analyzer.api/analyze-file"
                                                 "cljs.build.api/watch"
                                                 "cljs.build.api/inputs"
                                                 "cljs.analyzer.api/empty-env"
                                                 "cljs.analyzer.api/analyze"}},
                            "1.10.764" {},
                            "0.0-3263" {},
                            "1.9.473" {:removed #{"cljs.build.api/add-package-jsons"}},
                            "1.7.170" {},
                            "0.0-1798" {},
                            "0.0-1877" {},
                            "0.0-1211" {:added #{"cljs.repl.browser/send-static"}},
                            "1.10.145" {:added #{"cljs.repl/file-display"
                                                 "cljs.repl.server/promiseq"
                                                 "cljs.repl.browser/lock"
                                                 "cljs.repl/repl-title"
                                                 "cljs.repl.server/lock"
                                                 "cljs.repl.server/connq"}},
                            "0.0-1449" {},
                            "0.0-2911" {:added #{"cljs.repl/self-require?"
                                                 "cljs.repl/repl-prompt"
                                                 "cljs.repl/*repl-opts*"
                                                 "cljs.repl/repl-caught"},
                                        :removed #{"cljs.repl/with-read-known"}},
                            "1.9.908" {},
                            "0.0-993" {:added #{"cljs.repl/default-special-fns"}},
                            "0.0-1011" {},
                            "0.0-2356" {},
                            "1.7.122" {:added #{"cljs.analyzer.api/get-js-index"}},
                            "1.10.329" {},
                            "0.0-3211" {},
                            "0.0-3053" {:added #{"cljs.repl.browser/safari-st-el->frame"
                                                 "cljs.repl.browser/firefox-st-el->frame"
                                                 "cljs.repl.browser/chrome-st-el->frame"
                                                 "cljs.repl.browser/parse-file"
                                                 "cljs.repl.browser/parse-stacktrace"
                                                 "cljs.repl.browser/parse-file-line-column"
                                                 "cljs.repl.browser/firefox-clean-function"}},
                            "0.0-2985" {:added #{"cljs.repl/source"
                                                 "cljs.repl/apropos"
                                                 "cljs.repl.rhino/wrap-fn"
                                                 "cljs.repl/pst"
                                                 "cljs.repl/IParseErrorMessage"
                                                 "cljs.analyzer.api/ns-publics"
                                                 "cljs.repl/IGetError"
                                                 "cljs.repl.rhino/load-file"
                                                 "cljs.repl/dir"
                                                 "cljs.repl/special-doc-map"
                                                 "cljs.repl/source-fn"
                                                 "cljs.repl/find-doc"},
                                        :removed #{"cljs.repl.rhino/goog-require"}},
                            "1.9.183" {},
                            "0.0-2156" {},
                            "0.0-1847" {},
                            "1.9.293" {:removed #{"cljs.repl/self-require?"
                                                  "cljs.repl/canonicalize-specs"}},
                            "1.9.542" {},
                            "1.7.189" {},
                            "0.0-2496" {:added #{"cljs.build.api/cljs-dependents-for-macro-namespaces"
                                                 "cljs.analyzer.api/find-ns"
                                                 "cljs.build.api/target-file-for-cljs-ns"
                                                 "cljs.analyzer.api/ns-resolve"
                                                 "cljs.build.api/mark-cljs-ns-for-recompile!"
                                                 "cljs.analyzer.api/all-ns"
                                                 "cljs.repl/doc"
                                                 "cljs.analyzer.api/resolve"
                                                 "cljs.analyzer.api/ns-interns"}},
                            "0.0-3196" {},
                            "1.10.879" {},
                            "1.10.758" {},
                            "0.0-927" {:added #{"cljs.repl.rhino/current-repl-env"
                                                "cljs.repl/evaluate-form"
                                                "cljs.repl/load-stream"
                                                "cljs.repl.rhino/eval-result"
                                                "cljs.repl.browser/read-get"
                                                "cljs.repl.browser/load-javascript"
                                                "cljs.repl.browser/add-in-order"
                                                "cljs.repl/load-namespace"
                                                "cljs.repl.rhino/loaded-libs"
                                                "cljs.repl.browser/run-in-order"
                                                "cljs.repl.browser/compile-client-js"
                                                "cljs.repl.browser/handle-get"
                                                "cljs.repl.browser/stop-server"
                                                "cljs.repl.browser/read-request"
                                                "cljs.repl/load-file"
                                                "cljs.repl.browser/browser-eval"
                                                "cljs.repl.browser/server-state"
                                                "cljs.repl.browser/send-for-eval"
                                                "cljs.repl.browser/constrain-order"
                                                "cljs.repl.rhino/rhino-eval"
                                                "cljs.repl.browser/read-headers"
                                                "cljs.repl/repl"
                                                "cljs.repl.rhino/load-javascript"
                                                "cljs.repl.browser/create-client-js-file"
                                                "cljs.repl/*cljs-verbose*"
                                                "cljs.repl.browser/loaded-libs"
                                                "cljs.repl.browser/repl-client-js"
                                                "cljs.repl.browser/parse-headers"
                                                "cljs.repl.browser/send-404"
                                                "cljs.repl.browser/repl-env"
                                                "cljs.repl.rhino/repl-env"
                                                "cljs.repl.rhino/goog-require"
                                                "cljs.repl.browser/send-repl-client-page"
                                                "cljs.repl.browser/send-and-close"
                                                "cljs.repl.rhino/bootjs"
                                                "cljs.repl/IJavaScriptEnv"
                                                "cljs.repl.browser/handle-connection"
                                                "cljs.repl.rhino/IEval"
                                                "cljs.repl.browser/start-server"
                                                "cljs.repl.browser/server-loop"
                                                "cljs.repl.browser/read-post"
                                                "cljs.repl.rhino/rhino-setup"
                                                "cljs.repl.browser/handle-post"
                                                "cljs.repl.rhino/stacktrace"
                                                "cljs.repl.browser/ordering"}},
                            "0.0-1934" {},
                            "1.10.756" {},
                            "1.9.76" {},
                            "0.0-3165" {:added #{"cljs.repl.nashorn/-main"
                                                 "cljs.repl.browser/-main"
                                                 "cljs.repl.rhino/-main"
                                                 "cljs.repl.node/-main"}},
                            "0.0-2202" {},
                            "1.10.126" {:added #{"cljs.repl/*repl-env*"
                                                 "cljs.repl.browser/serve"
                                                 "cljs.repl.server/gzip"}},
                            "0.0-1820" {},
                            "1.9.456" {:added #{"cljs.build.api/node-module-deps"
                                                "cljs.build.api/node-inputs"
                                                "cljs.build.api/add-package-jsons"}},
                            "0.0-2261" {},
                            "0.0-2024" {},
                            "1.9.88" {},
                            "1.7.10" {:added #{"cljs.analyzer.api/get-options"
                                               "cljs.analyzer.api/warning-enabled?"
                                               "cljs.analyzer.api/default-warning-handler"
                                               "cljs.analyzer.api/empty-state"
                                               "cljs.analyzer.api/with-state"},
                                      :removed #{"cljs.repl.browser/safari-st-el->frame"
                                                 "cljs.repl.browser/firefox-st-el->frame"
                                                 "cljs.repl.browser/chrome-st-el->frame"
                                                 "cljs.repl.browser/parse-file"
                                                 "cljs.repl.browser/parse-stacktrace"
                                                 "cljs.repl.browser/parse-file-line-column"
                                                 "cljs.repl.browser/firefox-clean-function"}},
                            "0.0-1889" {},
                            "0.0-2657" {},
                            "0.0-1896" {},
                            "0.0-2014" {},
                            "1.9.562" {},
                            "0.0-2411" {},
                            "0.0-2665" {:added #{"cljs.repl.browser/setup"}},
                            "0.0-2760" {}},
                  :symbol-names #{"cljs.repl/eval-cljs"
                                  "cljs.repl.nashorn/repl-filename"
                                  "cljs.repl.node/create-socket"
                                  "cljs.repl/file-display"
                                  "cljs.repl.rhino/current-repl-env"
                                  "cljs.build.api/cljs-dependents-for-macro-namespaces"
                                  "cljs.repl/evaluate"
                                  "cljs.build.api/build"
                                  "cljs.repl/self-require?"
                                  "cljs.repl.server/promiseq"
                                  "cljs.build.api/ns->source"
                                  "cljs.repl/with-read-known"
                                  "cljs.repl/evaluate-form"
                                  "cljs.build.api/parse-js-ns"
                                  "cljs.repl/initial-prompt"
                                  "cljs.repl.browser/repl-env*"
                                  "cljs.repl/source"
                                  "cljs.repl/load-stream"
                                  "cljs.repl/repl-prompt"
                                  "cljs.repl.rhino/eval-result"
                                  "cljs.repl.node/socket"
                                  "cljs.repl/add-url"
                                  "cljs.analyzer.api/current-state"
                                  "cljs.repl.browser/read-get"
                                  "cljs.repl.node/close-socket"
                                  "cljs.repl.browser/load-javascript"
                                  "cljs.analyzer.api/warning-message"
                                  "cljs.repl/repl*"
                                  "cljs.build.api/output-unoptimized"
                                  "cljs.analyzer.api/current-file"
                                  "cljs.build.api/node-module-deps"
                                  "cljs.build.api/install-node-deps!"
                                  "cljs.analyzer.api/read-analysis-cache"
                                  "cljs.build.api/dependency-order"
                                  "cljs.repl.browser/add-in-order"
                                  "cljs.repl.nashorn/-main"
                                  "cljs.repl.browser/default-index"
                                  "cljs.repl/err-out"
                                  "cljs.repl/repl-nil?"
                                  "cljs.repl.server/handlers"
                                  "cljs.repl.node/load-javascript"
                                  "cljs.build.api/add-implicit-options"
                                  "cljs.repl.browser/lock"
                                  "cljs.build.api/handle-js-modules"
                                  "cljs.compiler.api/cljs-files-in"
                                  "cljs.repl.browser/safari-st-el->frame"
                                  "cljs.repl.browser/mime-type->encoding"
                                  "cljs.repl/apropos"
                                  "cljs.repl/load-namespace"
                                  "cljs.repl.rhino/wrap-fn"
                                  "cljs.repl/known-repl-opts"
                                  "cljs.analyzer.api/find-ns"
                                  "cljs.repl.rhino/loaded-libs"
                                  "cljs.repl.server/dispatch-on"
                                  "cljs.repl.browser/firefox-st-el->frame"
                                  "cljs.repl/load"
                                  "cljs.repl.browser/run-in-order"
                                  "cljs.repl.browser/compile-client-js"
                                  "cljs.repl.server/start"
                                  "cljs.repl.node/outs"
                                  "cljs.repl.browser/handle-get"
                                  "cljs.repl.nashorn/eval-resource"
                                  "cljs.repl/*repl-env*"
                                  "cljs.repl.browser/ext->mime-type"
                                  "cljs.repl.node/lock"
                                  "cljs.repl/js-src->cljs-src"
                                  "cljs.repl.reflect/parse-param"
                                  "cljs.repl/print-mapped-stacktrace"
                                  "cljs.repl/ns->input"
                                  "cljs.repl/analyze-source"
                                  "cljs.repl.browser/stop-server"
                                  "cljs.repl/*repl-opts*"
                                  "cljs.repl.browser/chrome-st-el->frame"
                                  "cljs.repl/IParseError"
                                  "cljs.repl/pst"
                                  "cljs.analyzer.api/get-options"
                                  "cljs.repl/demunge"
                                  "cljs.repl.browser/read-request"
                                  "cljs.analyzer.api/remove-ns"
                                  "cljs.build.api/target-file-for-cljs-ns"
                                  "cljs.repl.server/state"
                                  "cljs.build.api/node-modules"
                                  "cljs.repl.nashorn/tear-down-engine"
                                  "cljs.repl.reflect/macroexpand"
                                  "cljs.repl.browser/-main"
                                  "cljs.repl.node/platform-path"
                                  "cljs.repl.browser/es"
                                  "cljs.repl.server/read-request"
                                  "cljs.repl/load-file"
                                  "cljs.analyzer.api/with-passes"
                                  "cljs.repl/IParseErrorMessage"
                                  "cljs.repl.nashorn/eval-str"
                                  "cljs.repl.node/errs"
                                  "cljs.repl.browser/browser-eval"
                                  "cljs.repl.browser/server-state"
                                  "cljs.build.api/compilable->ijs"
                                  "cljs.analyzer.api/default-passes"
                                  "cljs.repl/repl-title"
                                  "cljs.repl.browser/send-for-eval"
                                  "cljs.repl.browser/constrain-order"
                                  "cljs.repl/default-special-fns"
                                  "cljs.repl.rhino/rhino-eval"
                                  "cljs.repl.browser/read-headers"
                                  "cljs.analyzer.api/warning-enabled?"
                                  "cljs.repl/IReplEnvOptions"
                                  "cljs.repl.server/set-connection"
                                  "cljs.analyzer.api/ns-resolve"
                                  "cljs.repl/update-require-spec"
                                  "cljs.repl/repl"
                                  "cljs.repl.nashorn/create-engine"
                                  "cljs.build.api/src-file->target-file"
                                  "cljs.repl.node/results"
                                  "cljs.compiler.api/with-core-cljs"
                                  "cljs.repl/canonicalize-specs"
                                  "cljs.repl.browser/serve"
                                  "cljs.repl.rhino/load-javascript"
                                  "cljs.repl.browser/thread-name"
                                  "cljs.repl/merge-require"
                                  "cljs.analyzer.api/ns-publics"
                                  "cljs.repl.nashorn/load-ns"
                                  "cljs.repl.browser/create-client-js-file"
                                  "cljs.repl/*cljs-verbose*"
                                  "cljs.repl/repl-options"
                                  "cljs.repl.server/read-post"
                                  "cljs.repl/IGetError"
                                  "cljs.repl.browser/loaded-libs"
                                  "cljs.analyzer.api/default-warning-handler"
                                  "cljs.repl.nashorn/load-js-file"
                                  "cljs.repl.browser/setup"
                                  "cljs.repl/skip-whitespace"
                                  "cljs.analyzer.api/with-warning-handlers"
                                  "cljs.repl.browser/parse-file"
                                  "cljs.repl/IPrintStacktrace"
                                  "cljs.repl.server/parse-file-parts"
                                  "cljs.analyzer.api/parse-ns"
                                  "cljs.repl.nashorn/init-engine"
                                  "cljs.build.api/goog-dep-string"
                                  "cljs.repl.server/parse-headers"
                                  "cljs.repl.node/read-response"
                                  "cljs.repl.browser/repl-client-js"
                                  "cljs.repl.browser/parse-headers"
                                  "cljs.analyzer.api/enabled-warnings"
                                  "cljs.repl.reflect/handle-reflect-query"
                                  "cljs.repl/setup"
                                  "cljs.build.api/node-inputs"
                                  "cljs.repl.browser/send-404"
                                  "cljs.repl.browser/repl-env"
                                  "cljs.repl.nashorn/bootstrap-repl"
                                  "cljs.repl.rhino/load-file"
                                  "cljs.repl/merge-spec"
                                  "cljs.repl.rhino/repl-env"
                                  "cljs.repl.node/seq->js-array"
                                  "cljs.repl.server/stop"
                                  "cljs.repl/dir"
                                  "cljs.repl.rhino/goog-require"
                                  "cljs.repl/spec-sort"
                                  "cljs.analyzer.api/no-warn"
                                  "cljs.repl.server/read-get"
                                  "cljs.repl.browser/send-repl-client-page"
                                  "cljs.repl.reflect/read-url-string"
                                  "cljs.repl/repl-special-doc-map"
                                  "cljs.repl/run-inits"
                                  "cljs.repl.browser/preloaded-libs"
                                  "cljs.build.api/mark-cljs-ns-for-recompile!"
                                  "cljs.analyzer.api/current-ns"
                                  "cljs.repl.browser/parse-stacktrace"
                                  "cljs.repl.browser/browser-state"
                                  "cljs.repl.browser/send-static"
                                  "cljs.analyzer.api/forms-seq"
                                  "cljs.analyzer.api/get-js-index"
                                  "cljs.build.api/cljs-ns-dependents"
                                  "cljs.repl.browser/outs"
                                  "cljs.analyzer.api/ns-specs"
                                  "cljs.repl.nashorn/repl-env"
                                  "cljs.compiler.api/emit"
                                  "cljs.analyzer.api/analyze-file"
                                  "cljs.compiler.api/munge"
                                  "cljs.repl/ex-triage"
                                  "cljs.compiler.api/compile-file"
                                  "cljs.repl/mapped-line-and-column"
                                  "cljs.build.api/add-dependency-sources"
                                  "cljs.build.api/watch"
                                  "cljs.repl/special-doc-map"
                                  "cljs.build.api/compiler-opts?"
                                  "cljs.repl.server/lock"
                                  "cljs.compiler.api/requires-compilation?"
                                  "cljs.repl.server/read-headers"
                                  "cljs.repl/decorate-specs"
                                  "cljs.analyzer.api/all-ns"
                                  "cljs.repl/repl-read"
                                  "cljs.repl/repl-caught"
                                  "cljs.repl.browser/send-and-close"
                                  "cljs.build.api/compile"
                                  "cljs.repl/ns-info"
                                  "cljs.repl.node/repl-env"
                                  "cljs.repl/skip-if-eol"
                                  "cljs.analyzer.api/in-cljs-user"
                                  "cljs.analyzer.api/empty-state"
                                  "cljs.repl.rhino/bootjs"
                                  "cljs.build.api/get-node-deps"
                                  "cljs.analyzer.api/the-ns"
                                  "cljs.repl/tear-down"
                                  "cljs.repl/IJavaScriptEnv"
                                  "cljs.repl.rhino/-main"
                                  "cljs.repl.nashorn/repl-env*"
                                  "cljs.repl.node/-main"
                                  "cljs.repl/compilable?"
                                  "cljs.build.api/add-dependencies"
                                  "cljs.repl.server/gzip"
                                  "cljs.repl/IParseStacktrace"
                                  "cljs.repl/repl-quit-prompt"
                                  "cljs.build.api/index-ijs"
                                  "cljs.repl.browser/handle-connection"
                                  "cljs.build.api/inputs"
                                  "cljs.repl.node/thread-name"
                                  "cljs.build.api/source-on-disk"
                                  "cljs.repl.node/setup"
                                  "cljs.repl/doc"
                                  "cljs.repl.node/node-eval"
                                  "cljs.analyzer.api/with-state"
                                  "cljs.build.api/ns->location"
                                  "cljs.repl/mapped-stacktrace"
                                  "cljs.repl.rhino/IEval"
                                  "cljs.analyzer.api/resolve"
                                  "cljs.repl.browser/start-server"
                                  "cljs.repl.server/send-and-close"
                                  "cljs.repl.rhino/repl-env*"
                                  "cljs.repl.browser/server-loop"
                                  "cljs.repl.server/send-404"
                                  "cljs.repl.browser/read-post"
                                  "cljs.repl/source-fn"
                                  "cljs.repl.server/connection"
                                  "cljs.repl.rhino/rhino-setup"
                                  "cljs.repl.browser/parse-file-line-column"
                                  "cljs.build.api/src-file->goog-require"
                                  "cljs.repl.node/write"
                                  "cljs.repl/read-source-map"
                                  "cljs.analyzer.api/empty-env"
                                  "cljs.build.api/add-package-jsons"
                                  "cljs.repl.browser/handle-post"
                                  "cljs.repl/find-doc"
                                  "cljs.repl.node/repl-env*"
                                  "cljs.analyzer.api/analyze"
                                  "cljs.repl/ex-str"
                                  "cljs.repl.rhino/stacktrace"
                                  "cljs.repl.server/connq"
                                  "cljs.compiler.api/compile-root"
                                  "cljs.analyzer.api/ns-interns"
                                  "cljs.repl.browser/firefox-clean-function"
                                  "cljs.repl/maybe-install-npm-deps"
                                  "cljs.repl.browser/ordering"},
                  :namespace-names #{"cljs.repl.server"
                                     "cljs.compiler.api"
                                     "cljs.repl.browser"
                                     "cljs.repl.rhino"
                                     "cljs.repl.node"
                                     "cljs.repl.reflect"
                                     "cljs.repl.nashorn"
                                     "cljs.build.api"
                                     "cljs.repl"
                                     "cljs.analyzer.api"}}}}
